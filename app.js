//          ____  _      _
//  ┌───┐  |  _ \| | ___| |__  ___
//  │ ▷ │  | |_) | |/ _ \ '_ \/ __|
//  └───┘  |  __/| |  __/ |_) \__ \
//         |_|   |_|\___|_.__/|___/

// ===== INTERNATIONALIZATION (i18n) SYSTEM =====
// Supported languages with native names
const SUPPORTED_LANGUAGES = {
    en: 'English',
    es: 'Español',
    fr: 'Français',
    de: 'Deutsch',
    pt: 'Português',
    ru: 'Русский',
    zh: '中文',
    ja: '日本語',
    ko: '한국어',
    ar: 'العربية',
    hi: 'हिन्दी',
    it: 'Italiano'
};

// Current language (default to English, will be updated on init)
let currentLanguage = 'en';

// Translations object - organized by language code
const translations = {
    en: {
        // Navigation & Header
        'nav.home': 'Home',
        'nav.following': 'Following',
        'nav.myVideos': 'My Videos',
        'nav.liked': 'Liked',
        'nav.history': 'History',
        'nav.topics': 'TOPICS',
        'nav.live': 'Live',
        'nav.bitcoin': 'Bitcoin',
        'nav.nostr': 'Nostr',
        'nav.technology': 'Technology',
        'nav.gaming': 'Gaming',
        'nav.tutorials': 'Tutorials',
        'nav.podcasts': 'Podcasts',
        'nav.music': 'Music',
        'nav.nsfw': 'NSFW',
        'nav.about': 'About',
        'nav.contact': 'Contact',
        'nav.terms': 'Terms',
        'nav.privacy': 'Privacy',
        'nav.faq': 'FAQ',
        'nav.dmca': 'DMCA',
        'header.search': 'Search videos...',
        'header.notifications': 'Notifications',
        'header.settings': 'Settings',
        'header.create': 'Create',
        'header.admin': 'Admin',
        'header.viewProfile': 'View Profile',
        'header.logout': 'Logout',
        // Login Modal
        'login.title': 'Login with Nostr',
        'login.extension': 'Login with Extension',
        'login.extensionDesc': 'Use Alby, nos2x, or other Nostr browser extensions',
        'login.connect': 'Nostr Connect',
        'login.connectDesc': 'Connect with remote signers like Amber, nsec.app',
        'login.privateKey': 'Private Key',
        'login.privateKeyDesc': 'Enter your nsec or hex private key (local only)',
        'login.newToNostr': 'New to Nostr?',
        'login.createAccount': 'Create Account',
        'login.createAccountDesc': 'Get started with a new Nostr identity to use on Plebs',
        // Connect Modal
        'connect.title': 'Connect with Nostr',
        'connect.option1': 'Option 1: Use this connection string',
        'connect.option1Desc': 'Copy and paste this into any NIP-46 compatible app (nsec.app, Amber, etc.)',
        'connect.copyString': 'Copy Connection String',
        'connect.showQR': 'Show QR Code',
        'connect.listening': 'Listening for connection...',
        'connect.option2': 'Option 2: Paste a bunker URL',
        'connect.option2Desc': 'If you already have a bunker:// URL from a remote signer',
        'connect.withBunker': 'Connect with Bunker',
        'connect.popularSigners': 'Popular NIP-46 signers:',
        'connect.webSigner': 'Web-based signer',
        'connect.androidApp': 'Android app',
        'connect.builtInSigner': 'Built-in signer',
        // Private Key Modal
        'privateKey.title': 'Login with Private Key',
        'privateKey.warning': 'Security Warning',
        'privateKey.warningText': 'Your private key will be stored locally in your browser. For better security, consider using a browser extension or Nostr Connect instead.',
        'privateKey.label': 'Private Key (nsec or hex)',
        'privateKey.showKey': 'Show key',
        'privateKey.login': 'Login',
        // Signup Modal
        'signup.title': 'Create Nostr Account',
        'signup.whatIsNostr': 'What is Nostr?',
        'signup.nostrExplanation': 'Nostr is a decentralized social protocol that gives you ownership of your identity and content. Unlike traditional platforms, no company can ban you, censor your content, or shut down your account.',
        'signup.whyPlebs': 'Why does Plebs use Nostr?',
        'signup.plebsExplanation': 'Plebs is built on Nostr to provide censorship-resistant video sharing. Your videos, comments, and interactions are stored across a network of relays, not on our servers. Your Nostr identity works across hundreds of other apps too!',
        'signup.howItWorks': 'How it works',
        'signup.keysIdentity': 'Your keys = Your identity.',
        'signup.keysIdentityDesc': "You'll get a private key (nsec) that proves you own your account.",
        'signup.keepSecret': 'Keep your private key secret!',
        'signup.keepSecretDesc': "It's like a password that can never be reset.",
        'signup.oneIdentity': 'One identity, many apps.',
        'signup.oneIdentityDesc': 'Use the same account on Damus, Primal, Amethyst, and more.',
        'signup.gotIt': "Got it, let's create my account",
        'signup.username': 'Username',
        'signup.usernamePlaceholder': 'Choose a display name',
        'signup.about': 'About (optional)',
        'signup.aboutPlaceholder': 'Tell others about yourself',
        'signup.profilePicture': 'Profile Picture (optional)',
        'signup.uploadPhoto': 'Upload Photo',
        'signup.remove': 'Remove',
        'signup.avatarHint': 'Square images work best. Max 5MB.',
        'signup.uploading': 'Uploading...',
        'signup.lightningAddress': 'Lightning Address (optional)',
        'signup.lightningPlaceholder': 'you@walletofsatoshi.com',
        'signup.lightningHint': 'Add a Lightning address to receive zaps (Bitcoin tips) on your videos and profile.',
        'signup.nostrAddress': 'Nostr Address',
        'signup.nostrAddressPlaceholder': 'username',
        'signup.nostrAddressHint': 'Your Nostr address makes your profile easier to find. Lowercase letters, numbers, _ and - only.',
        'signup.nostrAddressRequired': 'Please enter a Nostr address',
        'signup.profilePictureRequired': 'Please upload a profile picture',
        'signup.nostrAddressAvailable': 'Available!',
        'signup.nostrAddressUnavailable': 'Already taken',
        'signup.nostrAddressChecking': 'Checking availability...',
        'signup.nostrAddressInvalid': 'Invalid username format',
        'signup.nostrAddressRegistering': 'Registering your Nostr address...',
        'signup.nostrAddressSuccess': 'Nostr address registered!',
        'signup.nostrAddressFailed': 'Could not register Nostr address',
        'signup.yourUsername': 'Your Username',
        'signup.yourBio': 'Your bio will appear here',
        'signup.createAccountBtn': 'Create Account',
        'signup.termsAgree': 'By creating an account, you agree to our',
        'signup.and': 'and',
        'signup.success': 'Account Created Successfully!',
        'signup.yourPrivateKey': 'Your Private Key (nsec)',
        'signup.keyWarning': 'This is the ONLY way to access your account. Save it somewhere safe!',
        'signup.copyPrivateKey': 'Copy Private Key',
        'signup.howToUseKey': 'How to use your private key',
        'signup.continueToPlebs': 'Continue to Plebs',
        'signup.step1': 'Save it securely:',
        'signup.step1Desc': 'Store your nsec in a password manager, write it down, or save it in an encrypted file. Never share it publicly!',
        'signup.step2': 'To log in again:',
        'signup.step2Desc': 'Click "Private Key" on the login screen and paste your nsec. It works like a password.',
        'signup.step3': 'Use on other apps:',
        'signup.step3Desc': 'Your nsec works on all Nostr apps - Damus, Primal, Amethyst, and hundreds more!',
        'signup.step4': 'Consider a signer app:',
        'signup.step4Desc': 'For better security, use apps like Amber (Android) or a browser extension like Alby to manage your keys.',
        // Notifications
        'notifications.title': 'Notifications',
        'notifications.settings': 'Notification Settings',
        'notifications.reactions': 'Reactions (likes/dislikes)',
        'notifications.replies': 'Comments & Replies',
        'notifications.zaps': 'Zaps',
        'notifications.chatMentions': 'Live Chat Mentions',
        'notifications.newFollowers': 'New Followers',
        'notifications.syncNote': 'Settings are synced across devices via Nostr',
        // Settings Modal
        'settings.title': 'Settings',
        'settings.language': 'Language',
        'settings.languageDesc': 'Choose your preferred language',
        'settings.saveToNostr': 'Save to Nostr',
        'settings.saveToNostrDesc': 'Sync settings across all Plebs instances',
        'settings.darkMode': 'Dark Mode',
        'settings.darkModeDesc': 'Switch between light and dark theme',
        'settings.contentWarnings': 'Content Warning Preferences',
        'settings.showNSFW': 'Show NSFW warnings',
        'settings.showNSFWDesc': 'Display age verification for NSFW content',
        'settings.showCommunity': 'Show community warnings',
        'settings.showCommunityDesc': 'Display warnings for flagged or heavily downvoted content',
        'settings.showFollowsReport': 'Show warnings from followed reports',
        'settings.showFollowsReportDesc': 'Display warnings when 5+ people you follow have reported content',
        'settings.filterPacks': 'Content Filter Packs',
        'settings.filterPacksDesc': 'Enable filter packs to automatically hide content matching specific keywords.',
        'settings.customKeywords': 'Custom Keyword Filter',
        'settings.customKeywordsPlaceholder': 'Enter keywords or phrases separated by commas',
        'settings.customKeywordsDesc': 'Add your own keywords to filter out (comma-separated)',
        'settings.mutedUsers': 'Muted Users',
        'settings.mutedUsersDesc': "Users you've muted won't appear in your feed or comments.",
        'settings.blossomSettings': 'Blossom Server Settings',
        'settings.premiumBlossom': 'Premium Blossom Server (NostrMedia.com)',
        'settings.premiumBlossomDesc': 'Use NostrMedia.com if you are a subscribed user',
        'settings.customBlossom': 'Custom Blossom Servers',
        'settings.customBlossomDesc': 'Add your own Blossom servers (comma-separated)',
        'settings.relaySettings': 'Relay Settings',
        'settings.useWotRelays': 'Use Web of Trust Relays',
        'settings.useWotRelaysDesc': 'Connect to Web of Trust relays for better spam filtering',
        'settings.saveSettings': 'Save Settings',
        'settings.resetDefaults': 'Reset to Defaults',
        'settings.notificationSettings': 'Notification Settings',
        // Upload Modal
        'upload.title': 'Upload Video',
        'upload.videoFile': 'Video File',
        'upload.recordFromCamera': 'Record from Camera',
        'upload.stop': 'Stop',
        'upload.recordHint': 'Record a vertical video (up to 60 seconds)',
        'upload.or': 'or',
        'upload.clickToSelect': 'Click to select video or drag and drop',
        'upload.fileTypes': 'MP4, AVI, MOV, etc (max 2GB input, will compress to <100MB)',
        'upload.preparing': 'Preparing...',
        'upload.thumbnail': 'Thumbnail',
        'upload.thumbnailOptional': '(optional)',
        'upload.thumbnailHint': 'Click to select or auto-generate from video',
        'upload.uploading': 'Uploading...',
        'upload.titleLabel': 'Title',
        'upload.titlePlaceholder': 'Enter video title',
        'upload.description': 'Description',
        'upload.descriptionPlaceholder': 'Tell viewers about your video',
        'upload.tags': 'Tags (comma separated)',
        'upload.tagsPlaceholder': 'bitcoin, nostr, tutorial',
        'upload.markNSFW': 'Mark as NSFW (18+)',
        'upload.nsfwHint': 'Content containing adult material should be marked as NSFW',
        'upload.saveDraft': 'Save as Draft',
        'upload.publish': 'Publish',
        'upload.selectVideo': 'Select a video to upload',
        'upload.termsNote': 'By uploading, you accept our',
        // Create Modal
        'create.title': 'Create',
        'create.goLive': 'Go Live',
        'create.goLiveDesc': 'Start a live stream or schedule one',
        'create.uploadVideo': 'Upload Video',
        'create.uploadVideoDesc': 'Upload a video from your device',
        'create.createShort': 'Create Short',
        'create.createShortDesc': 'Upload a vertical video (under 60s)',
        // Go Live Modal
        'goLive.title': 'Go Live',
        'goLive.when': 'When do you want to go live?',
        'goLive.now': 'Go Live Now',
        'goLive.schedule': 'Schedule Stream',
        'goLive.scheduleDateTime': 'Schedule Date & Time',
        'goLive.streamThumbnail': 'Stream Thumbnail',
        'goLive.streamTitle': 'Stream Title',
        'goLive.streamTitlePlaceholder': 'Enter your stream title',
        'goLive.streamUrl': 'Stream URL (RTMP, HLS, or WebRTC)',
        'goLive.zapGoal': 'Zap Goal (optional)',
        'goLive.zapGoalLabel': 'Zap Goal',
        'goLive.setupGuide': 'Stream Setup Guide',
        'goLive.cancel': 'Cancel',
        'goLive.goLiveBtn': 'Go Live',
        // Edit Stream Modal
        'editStream.title': 'Edit Stream',
        'editStream.changeThumbnail': 'Change Thumbnail',
        'editStream.saveChanges': 'Save Changes',
        // NSFW Warning Modal
        'nsfw.title': 'Age Verification Required',
        'nsfw.warning': 'This content is marked as NSFW (Not Safe For Work) and may contain adult material. You must be 18 years or older to view this content.',
        'nsfw.cancel': 'Cancel',
        'nsfw.confirm': 'I am 18+ years old',
        'nsfw.remember': "Don't ask again (Remember my choice)",
        // Community Warning Modal
        'community.title': 'Community Warning',
        'community.warning': 'This video has been flagged and/or heavily downvoted by the community. This might be due to:',
        'community.inappropriate': 'Inappropriate content not properly marked as NSFW',
        'community.suspicious': 'New or suspicious user details',
        'community.misleading': 'Misleading or false information',
        'community.spam': 'Spam or low-quality content',
        'community.harmful': 'Potentially harmful or illegal content',
        'community.caution': 'Proceed with caution.',
        'community.goBack': 'Go Back',
        'community.viewAnyway': 'View Anyway',
        // Report Modal
        'report.title': 'Report Video',
        'report.titleComment': 'Report Comment',
        'report.selectReason': 'Select a reason for reporting this content:',
        'report.nudity': 'Nudity or Sexual Content',
        'report.nudityDesc': 'Contains sexual or explicit imagery not marked as NSFW',
        'report.hate': 'Hate Speech or Harassment',
        'report.hateDesc': 'Promotes violence, hate, or harassment against individuals or groups',
        'report.illegal': 'Illegal Content',
        'report.illegalDesc': 'Content that may violate laws or regulations',
        'report.spam': 'Spam or Misleading',
        'report.spamDesc': 'Deceptive content, scams, or repetitive spam',
        'report.impersonation': 'Impersonation',
        'report.impersonationDesc': 'Pretending to be someone else',
        'report.other': 'Other',
        'report.otherDesc': 'Other violation not listed above',
        'report.additionalDetails': 'Additional details (optional)',
        'report.detailsPlaceholder': "Provide more context about why you're reporting this video...",
        'report.cancel': 'Cancel',
        'report.submit': 'Submit Report',
        // Share Modal
        'share.title': 'Share Video',
        'share.link': 'Link',
        'share.embed': 'Embed',
        'share.shareWith': 'Share this video with others:',
        'share.copy': 'Copy',
        'share.copied': 'Copied to clipboard!',
        'share.embedVideo': 'Embed this video on your website:',
        'share.size': 'Size:',
        'share.responsive': 'Responsive (Default)',
        'share.size1280x720': '1280 × 720 (HD)',
        'share.embedCopied': 'Embed code copied!',
        'share.fallbackNote': 'Includes automatic fallback to mirror servers if primary source fails.',
        // Edit Video Modal
        'editVideo.title': 'Edit Video',
        'editVideo.video': 'Video',
        'editVideo.replaceVideo': 'Replace Video',
        // Edit Profile Modal
        'editProfile.title': 'Edit Profile',
        'editProfile.displayName': 'Display Name',
        'editProfile.displayNamePlaceholder': 'Your display name',
        'editProfile.about': 'About',
        'editProfile.aboutPlaceholder': 'Tell others about yourself',
        'editProfile.picture': 'Profile Picture',
        'editProfile.pictureUrl': 'Or enter image URL directly:',
        'editProfile.nip05': 'NIP-05 Identifier (optional)',
        'editProfile.nip05Hint': 'A verified Nostr address for identity verification.',
        'editProfile.website': 'Website (optional)',
        'editProfile.saveChanges': 'Save Changes',
        // Confirmation Modal
        'confirm.title': 'Confirm Action',
        'confirm.message': 'Are you sure you want to proceed?',
        'confirm.cancel': 'Cancel',
        'confirm.confirm': 'Confirm',
        // Filter Packs
        'filter.racism': 'Racism & Hate Speech',
        'filter.racismDesc': 'Filters racial slurs, ethnic hate speech, and discriminatory content',
        'filter.sexualExplicit': 'Sexually Explicit',
        'filter.sexualExplicitDesc': 'Filters pornographic terms and sexually explicit content',
        'filter.violence': 'Violence & Gore',
        'filter.violenceDesc': 'Filters graphic violence, gore, and violent threats',
        'filter.drugs': 'Drugs & Substances',
        'filter.drugsDesc': 'Filters drug-related content and substance abuse',
        'filter.spam': 'Spam & Scams',
        'filter.spamDesc': 'Filters common spam, scam, and promotional content',
        'filter.crypto': 'Cryptocurrency',
        'filter.cryptoDesc': 'Filters cryptocurrency promotion, trading signals, and token shilling',
        'filter.politics': 'Political Content',
        'filter.politicsDesc': 'Filters partisan political content and divisive rhetoric',
        'filter.profanity': 'Strong Profanity',
        'filter.profanityDesc': 'Filters strong profanity and vulgar language',
        'filter.customFilter': 'Custom Filter',
        // Toast Messages
        'toast.loggedIn': 'Logged in successfully!',
        'toast.settingsSaved': 'Settings saved successfully!',
        'toast.settingsLocal': 'Settings saved locally. Could not save to Nostr.',
        'toast.settingsLocalOnly': 'Settings saved locally!',
        'toast.settingsReset': 'Settings reset to defaults!',
        'toast.avatarUploaded': 'Avatar uploaded successfully!',
        'toast.profileUpdated': 'Profile updated successfully!',
        'toast.copied': 'Copied to clipboard!',
        'toast.copyFailed': 'Failed to copy. Please copy manually.',
        'toast.installExtension': 'Please install a Nostr browser extension like Alby or nos2x',
        'toast.loginFailed': 'Failed to login with extension. Please try again.',
        'toast.invalidKey': 'Invalid private key. Please check and try again.',
        'toast.enterKey': 'Please enter your private key',
        'toast.enterUsername': 'Please enter a username',
        'toast.accountCreated': 'Welcome to Plebs! You are now logged in.',
        'toast.keyCopied': 'Private key copied to clipboard!',
        'toast.unmuted': 'User unmuted',
        'toast.unmuteFailed': 'Failed to unmute user',
        'toast.selectImage': 'Please select an image file',
        'toast.imageTooLarge': 'Image must be less than 5MB',
        'toast.avatarFailed': 'Failed to upload avatar. Please try again.',
        'toast.mustBeLoggedIn': 'You must be logged in to edit your profile',
        'toast.enterDisplayName': 'Please enter a display name',
        'toast.profileFailed': 'Failed to save profile. Please try again.',
        'toast.invalidBunker': 'Please enter a valid bunker URL',
        'toast.connectFailed': 'Failed to connect',
        'toast.showingFiltered': 'Showing filtered content',
        'toast.reportSubmitted': 'Report submitted successfully',
        'toast.draftSaved': 'Draft saved! You can continue later from My Videos.',
        'toast.draftLoaded': 'Draft loaded. Complete your upload and publish.',
        'toast.draftDeleted': 'Draft deleted',
        'toast.languageChanged': 'Language changed',
        'toast.videoBlocked': 'Video blocked and published to Nostr',
        'toast.waitForUpload': 'Please wait for video upload to complete',
        'toast.enterTitle': 'Please enter a title',
        'toast.publishing': 'Publishing video to Nostr...',
        // Video Page
        'video.views': 'views',
        'video.view': 'view',
        'video.followers': 'followers',
        'video.follower': 'follower',
        'video.videos': 'videos',
        'video.follow': 'Follow',
        'video.unfollow': 'Unfollow',
        'video.mute': 'Mute',
        'video.unmute': 'Unmute',
        'video.share': 'Share',
        'video.report': 'Report',
        'video.edit': 'Edit',
        'video.delete': 'Delete',
        'video.comments': 'Comments',
        'video.writeComment': 'Write a comment...',
        'video.postComment': 'Post',
        'video.sortNewest': 'Newest',
        'video.sortOldest': 'Oldest',
        'video.sortTop': 'Top',
        'video.noComments': 'No comments yet. Be the first to comment!',
        'video.loadMore': 'Load more comments',
        'video.reply': 'Reply',
        'video.showReplies': 'Show replies',
        'video.hideReplies': 'Hide replies',
        'video.zap': 'Zap',
        'video.boost': 'Boost',
        'video.sats': 'sats',
        // Empty States
        'empty.noVideos': 'No videos found.',
        'empty.noLikedVideos': "You haven't liked any videos yet.",
        'empty.noHistory': 'No watch history yet. Start watching videos to build your history.',
        'empty.noFollowing': 'No videos from users you follow yet.',
        'empty.noMatching': 'No matching videos found.',
        'empty.noTrending': 'No trending videos',
        'empty.noUsers': 'No matching users found.',
        'empty.noActivity': 'No recent activity.',
        'empty.loginToView': 'Please login to view your liked videos.',
        // Time
        'time.justNow': 'just now',
        'time.secondAgo': '1 second ago',
        'time.secondsAgo': '{n} seconds ago',
        'time.minuteAgo': '1 minute ago',
        'time.minutesAgo': '{n} minutes ago',
        'time.hourAgo': '1 hour ago',
        'time.hoursAgo': '{n} hours ago',
        'time.dayAgo': '1 day ago',
        'time.daysAgo': '{n} days ago',
        'time.weekAgo': '1 week ago',
        'time.weeksAgo': '{n} weeks ago',
        'time.monthAgo': '1 month ago',
        'time.monthsAgo': '{n} months ago',
        'time.yearAgo': '1 year ago',
        'time.yearsAgo': '{n} years ago',
        // Live Stream
        'live.live': 'LIVE',
        'live.scheduled': 'Scheduled',
        'live.ended': 'Stream Ended',
        'live.viewers': 'viewers',
        'live.viewer': 'viewer',
        'live.chat': 'Live Chat',
        'live.sendMessage': 'Send a message...',
        'live.send': 'Send',
        // Misc
        'misc.loading': 'Loading...',
        'misc.error': 'Error',
        'misc.retry': 'Retry',
        'misc.close': 'Close',
        'misc.back': 'Back',
        'misc.search': 'Search',
        'misc.searchResults': 'Search Results',
        'misc.videos': 'Videos',
        'misc.users': 'Users',
        'misc.trending': 'Trending',
        'misc.remove': 'Remove',
        // Common actions
        'common.cancel': 'Cancel',
        'common.uploading': 'Uploading...',
        'common.saveChanges': 'Save Changes',
        'common.close': 'Close',
        // Aria labels for accessibility
        'aria.toggleMenu': 'Toggle menu',
        'aria.mainNavigation': 'Main navigation',
        'aria.videoContent': 'Video content',
        'aria.loadingContent': 'Loading content',
        // Additional notification keys
        'notifications.settingsTitle': 'Notification Settings',
        // Additional settings keys
        'settings.contentWarning': 'Content Warning Preferences',
        'settings.showNsfwWarnings': 'Show NSFW warnings',
        'settings.showNsfwWarningsDesc': 'Display age verification for NSFW content',
        'settings.showCommunityWarnings': 'Show community warnings',
        'settings.showCommunityWarningsDesc': 'Display warnings for flagged or heavily downvoted content',
        'settings.showFollowsReportWarnings': 'Show warnings from followed reports',
        'settings.showFollowsReportWarningsDesc': 'Display warnings when 5+ people you follow have reported content',
        'settings.customKeywordFilter': 'Custom Keyword Filter',
        'settings.customKeywordFilterPlaceholder': 'Enter keywords or phrases separated by commas\nExample: spam, unwanted content, specific phrase',
        'settings.customKeywordFilterDesc': 'Add your own keywords to filter out (comma-separated)',
        'settings.blossomServer': 'Blossom Server Settings',
        'settings.customBlossomServers': 'Custom Blossom Servers',
        'settings.customBlossomServersPlaceholder': 'Enter server URLs separated by commas\nExample: https://blossom.example.com, https://another.example.com',
        'settings.customBlossomServersDesc': 'Add your own Blossom servers (comma-separated)',
        // Additional upload keys
        'upload.backToCreate': 'Back to Create',
        'upload.fileHint': 'MP4, AVI, MOV, etc (max 2GB input, will compress to <100MB)',
        'upload.remove': 'Remove',
        'upload.optional': '(optional)',
        'upload.removeVideo': 'Remove and upload different video',
        'upload.removeThumbnail': 'Remove and upload different thumbnail',
        'upload.markNsfw': 'Mark as NSFW (18+)',
        'upload.nsfwDesc': 'Content containing adult material should be marked as NSFW',
        'upload.termsNotice': 'By uploading, you accept our <a href="#/terms" style="color: var(--accent);">Terms of Service</a> and <a href="#/privacy" style="color: var(--accent);">Privacy Policy</a>',
        'upload.qualityHigh': 'High',
        // Additional Go Live keys
        'goLive.backToCreate': 'Back to Create',
        'goLive.whenLive': 'When do you want to go live?',
        'goLive.goLiveNow': 'Go Live Now',
        'goLive.scheduleStream': 'Schedule Stream',
        'goLive.scheduleDateTimeHint': 'Users can join the stream page early to chat before it starts',
        'goLive.clickToSelectThumbnail': 'Click to select a thumbnail image',
        'goLive.thumbnailFormats': 'JPG, PNG, WebP (recommended 1280x720)',
        'goLive.removeThumbnail': 'Remove and upload different thumbnail',
        'goLive.description': 'Description',
        'goLive.descriptionPlaceholder': 'Tell viewers what your stream is about',
        'goLive.tags': 'Tags (comma separated)',
        'goLive.tagsPlaceholder': 'gaming, bitcoin, tutorial',
        'goLive.streamUrlPlaceholder': 'https://your-streaming-service.com/stream.m3u8',
        'goLive.streamUrlHint': 'Use services like zap.stream, OBS Ninja, Cloudflare Stream, or any RTMP/HLS provider',
        'goLive.zapGoalPlaceholder': 'e.g. 10000',
        'goLive.zapGoalHint': 'Set a goal for Bitcoin tips (in sats) to be displayed on your stream',
        'goLive.setupGuideTitle': 'Stream Setup Guide',
        'goLive.setupGuideDesc': 'To go live, you need a streaming URL from a service provider:',
        'goLive.zapStreamDesc': 'Cheap Nostr-native streaming',
        'goLive.obsDesc': 'any RTMP ingest server',
        'goLive.otherProviders': 'Cloudflare Stream, Mux, or other HLS providers',
        'goLive.goLiveButton': 'Go Live',
        // Video page
        'video.noDescription': 'No description has been added to this video.',
        // Live stream page
        'live.noDescription': 'No description has been added to this live stream.',
        // Additional Edit Stream keys
        'editStream.titleLabel': 'Title',
        // NSFW Modal
        'nsfw.description': 'This content is marked as NSFW (Not Safe For Work) and may contain adult material. You must be 18 years or older to view this content.',
        // Community Warning Modal
        'communityWarning.title': 'Community Warning',
        'communityWarning.description': 'This video has been flagged and/or heavily downvoted by the community. This might be due to:',
        'communityWarning.reason1': 'Inappropriate content not properly marked as NSFW',
        'communityWarning.reason2': 'New or suspicious user details',
        'communityWarning.reason3': 'Misleading or false information',
        'communityWarning.reason4': 'Spam or low-quality content',
        'communityWarning.reason5': 'Potentially harmful or illegal content',
        'communityWarning.proceed': 'Proceed with caution.',
        'communityWarning.goBack': 'Go Back',
        'communityWarning.viewAnyway': 'View Anyway',
        // Additional Report keys
        'report.description': 'Select a reason for reporting this content:',
        'report.hateSpeech': 'Hate Speech or Harassment',
        'report.hateSpeechDesc': 'Promotes violence, hate, or harassment against individuals or groups',
        'report.additionalDetailsPlaceholder': 'Provide more context about why you\'re reporting this video...',
        // Additional Share keys
        'share.shareWithOthers': 'Share this video with others:',
        'share.copiedToClipboard': 'Copied to clipboard!',
        'share.embedOnWebsite': 'Embed this video on your website:',
        'share.embedCodeCopied': 'Embed code copied!',
        'share.fallbackNote': 'Includes automatic fallback to mirror servers if primary source fails.',
        // Additional Edit Video keys
        'editVideo.replaceNote': 'Click "Replace Video" to upload a new video file.',
        // Additional Edit Profile keys
        'editProfile.profilePicture': 'Profile Picture',
        'editProfile.uploadPhoto': 'Upload Photo',
        'editProfile.avatarHint': 'Square images work best. Max 5MB.',
        'editProfile.orEnterUrl': 'Or enter image URL directly:',
        'editProfile.lightningAddress': 'Lightning Address',
        'editProfile.lightningAddressHint': 'Add a Lightning address to receive zaps (Bitcoin tips) on your videos and profile.',
        'editProfile.pictureUrlPlaceholder': 'https://example.com/avatar.jpg',
        'editProfile.lightningPlaceholder': 'you@walletofsatoshi.com',
        'editProfile.nip05Placeholder': 'you@domain.com',
        'editProfile.websitePlaceholder': 'https://yourwebsite.com',
        // Additional navigation keys
        'nav.liveStreams': 'Live Streams',
        'nav.github': 'GitHub',
        // Additional connect keys
        'connect.or': 'OR',
        'connect.bunkerPlaceholder': 'bunker://...',
        // Additional private key keys
        'privateKey.placeholder': 'nsec1...',
        // Additional upload keys
        'upload.preparing': 'Preparing...',
        // Dynamic JavaScript text - Buttons and Status
        'button.hideQR': 'Hide QR Code',
        'button.showQR': 'Show QR Code',
        'button.copied': 'Copied!',
        'button.showLess': 'Show Less',
        'button.showMore': 'Show More',
        'button.creatingAccount': 'Creating account...',
        'button.submitting': 'Submitting...',
        'button.scheduleStream': 'Schedule Stream',
        'button.goLive': 'Go Live',
        'button.creatingStream': 'Creating stream...',
        'button.continueCustomAmount': 'Continue with Custom Amount',
        'button.recordFromCamera': 'Record from Camera',
        'button.requestingCamera': 'Requesting camera...',
        'button.recording': 'Recording...',
        // Status messages
        'status.saving': 'Saving...',
        'status.saved': 'Saved!',
        'status.uploading': 'Uploading...',
        'status.uploadComplete': 'Upload complete!',
        'status.uploadingToNostrBuild': 'Uploading to nostr.build...',
        'status.publishingChanges': 'Publishing changes...',
        'status.removingOldVersion': 'Removing old version...',
        'status.validatingThumbnail': 'Validating thumbnail...',
        'status.uploadingThumbnail': 'Uploading thumbnail...',
        'status.thumbnailUploaded': 'Thumbnail uploaded!',
        'status.processingVideo': 'Processing video...',
        'status.compressingVideo': 'Compressing video...',
        'status.uploadingVideo': 'Uploading video...',
        'status.videoUploaded': 'Video uploaded successfully!',
        'status.processing': 'Processing...',
        'status.generatingThumbnail': 'Generating thumbnail...',
        'status.generatingPreview': 'Generating preview...',
        'status.uploadingPreview': 'Uploading preview...',
        'status.publishing': 'Publishing...',
        'status.publishingToNostr': 'Publishing to Nostr...',
        'status.publishingVideoToNostr': 'Publishing video to Nostr...',
        'status.generatingPoW': 'Generating proof of work...',
        'status.posting': 'Posting...',
        'status.processingVideoAndThumbnail': 'Processing video and thumbnail...',
        'status.uploadFailed': 'Upload failed - please try again',
        'status.selectVideoToUpload': 'Select a video to upload',
        'status.waitingForVideoUpload': 'Waiting for video upload...',
        'status.selectVideoAndThumbnail': 'Select video and thumbnail to publish',
        'status.ready': 'Ready ✓',
        'status.failed': 'Failed ✗',
        'status.fromDraft': 'From draft',
        'status.startingNow': 'Starting now!',
        'status.ended': 'ENDED',
        'status.thumbnailReady': 'Ready',
        'status.thumbnailFailed': 'Failed',
        'status.uploadFailedRetry': 'Upload failed. Please try again.',
        // Publish button text
        'publish.video': 'Publish Video',
        'publish.autoThumbnail': 'Publish Video (auto-thumbnail)',
        // Report modal dynamic titles
        'report.titleComment': 'Report Comment',
        'report.titleUser': 'Report User',
        'report.titleVideo': 'Report Video',
        'report.descComment': 'Select a reason for reporting this comment:',
        'report.descUser': 'Select a reason for reporting this user:',
        'report.descVideo': 'Select a reason for reporting this content:',
        // Empty states - extended
        'empty.noMutedUsers': 'No muted users.',
        'empty.noVideosToMonitor': 'No videos found to monitor.',
        'empty.noRecentActivity': 'No recent activity.',
        'empty.failedLoadNotifications': 'Failed to load notifications',
        'empty.loginToViewLiked': 'Please <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">login</a> to view your liked videos.',
        'empty.loginToViewFollowing': 'Please <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">login</a> to view who you are following.',
        'empty.loginToViewVideos': 'Please <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">login</a> to view your videos.',
        'empty.loginToViewAnalytics': 'Please <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">login</a> to view your analytics.',
        'empty.noLikedVideosYet': "You haven't liked any videos yet.",
        'empty.noLikedVideosFound': 'No liked videos found.',
        'empty.noFullLengthLikedVideos': 'No full-length liked videos found.',
        'empty.noWatchHistory': 'No watch history yet. Start watching videos to build your history.',
        'empty.noVideosInHistory': 'No videos found in history.',
        'empty.noFullLengthHistory': 'No full-length videos in history.',
        'empty.noMatchingVideos': 'No matching videos found.',
        'empty.noFullLengthVideos': 'No full-length videos found.',
        'empty.failedLoadTrending': 'Failed to load trending videos.',
        'empty.noTrendingVideos': 'No trending videos found.',
        'empty.noMatchingUsers': 'No matching users found.',
        'empty.unableLoadProfiles': 'Unable to load user profiles.',
        'empty.noFollowingVideos': 'No videos from users you follow yet.',
        'empty.noFullLengthFollowing': 'No full-length videos from users you follow yet.',
        'empty.failedLoadFollowing': 'Failed to load following. Please try again.',
        'empty.noVideosUploadFirst': 'No videos found. Upload your first video!',
        'empty.noFullLengthUploaded': 'No full-length videos found.',
        'empty.noMatchingLiveStreams': 'No matching live streams found.',
        'empty.noMatchingShorts': 'No matching shorts found.',
        'empty.noVideosForTag': 'No videos found for this tag.',
        'empty.noFullLengthForTag': 'No full-length videos found for this tag.',
        'empty.noUploadedVideos': 'No videos uploaded yet.',
        'empty.noVideosFound': 'No videos found.',
        'empty.failedLoadProfile': 'Failed to load profile. Please try again.',
        'empty.noComments': 'No comments yet. Be the first to comment!',
        'empty.failedLoadComments': 'Failed to load comments',
        'empty.noLiveNow': 'No one is live right now. Be the first!',
        // Error messages
        'error.videoNotFound': 'Video not found.',
        'error.contentNotAvailable': 'This content is not available.',
        'error.invalidVideoData': 'Invalid video data.',
        'error.videoNotAvailable': 'Video not available. The file may have been removed.',
        'error.failedLoadVideo': 'Failed to load video. Please try again.',
        'error.failedLoadVideoShort': 'Failed to load video. The file may have been removed.',
        'error.liveStreamNotFound': 'Live stream not found.',
        'error.invalidLiveStreamData': 'Invalid live stream data.',
        'error.failedLoadLiveStream': 'Failed to load live stream.',
        // Button & Action Labels
        'button.follow': 'Follow',
        'button.unfollow': 'Unfollow',
        'button.mute': 'Mute',
        'button.unmute': 'Unmute',
        'button.muteUser': 'Mute user',
        'button.unmuteUser': 'Unmute user',
        'button.confirm': 'Confirm',
        'button.cancel': 'Cancel',
        'button.close': 'Close',
        'button.boost': 'Boost',
        'button.zap': 'Zap',
        'button.viewMore': 'View More',
        'button.viewAnalytics': 'View Analytics',
        'button.backToMyVideos': 'Back to My Videos',
        'button.editDraft': 'Edit draft',
        'button.deleteDraft': 'Delete draft',
        'button.editVideo': 'Edit video',
        'button.deleteVideo': 'Delete video',
        'button.editShort': 'Edit short',
        'button.deleteShort': 'Delete short',
        'button.editStream': 'Edit stream',
        'button.endStream': 'End stream',
        'button.reset': 'Reset',
        'button.download': 'Download',
        'button.watchRecording': 'Watch Recording',
        'button.show': 'Show',
        'button.login': 'Login',
        'button.toggleChat': 'Toggle chat',
        'button.blockVideo': 'Block Video',
        'button.blockUser': 'Block User',
        'button.unblock': 'Unblock',
        'button.removeFromHistory': 'Remove from history',
        // Stats & Counts
        'stat.views': 'views',
        'stat.viewsCount': '{count} views',
        'stat.videos': 'videos',
        'stat.video': 'video',
        'stat.followers': 'followers',
        'stat.follower': 'follower',
        'stat.following': 'Following',
        'stat.subscribers': 'subscribers',
        'stat.comments': 'Comments',
        'stat.liveCount': '{count} live',
        'stat.percentOfGoal': '{percent}% of goal',
        'stat.netGrowth': 'Net Growth',
        'stat.newFollowers': 'New Followers',
        'stat.unfollowed': 'Unfollowed',
        'stat.lastUpdated': 'Last updated: {date}',
        // Content Badges
        'badge.nsfw': 'NSFW',
        'badge.live': 'LIVE',
        'badge.ended': 'ENDED',
        'badge.scheduled': 'SCHEDULED',
        'badge.warning': 'WARNING',
        'badge.communityWarning': 'COMMUNITY WARNING',
        'badge.verifiedNip05': 'Verified NIP-05',
        'badge.streamer': 'Streamer',
        'badge.clickToView': 'Click to view',
        // Actions
        'action.report': 'Report',
        'action.reportComment': 'Report comment',
        'action.reportVideo': 'Report this video',
        'action.reportStream': 'Report this stream',
        'action.like': 'Like',
        'action.dislike': 'Dislike',
        'action.reply': 'Reply',
        // Placeholders
        'placeholder.searchHistory': 'Search history...',
        'placeholder.searchUsers': 'Search users...',
        'placeholder.searchMyVideos': 'Search my videos...',
        'placeholder.eventId': 'Enter event ID (hex or nevent/note)',
        'placeholder.pubkey': 'Enter pubkey (hex or npub)',
        'placeholder.customAmount': 'Custom amount',
        'placeholder.chatEnded': 'Chat is closed - stream has ended',
        'placeholder.addComment': 'Add a comment...',
        'placeholder.setNewGoal': 'Set new goal (sats)',
        // Video & Content
        'video.untitledVideo': 'Untitled Video',
        'video.untitledShort': 'Untitled Short',
        'video.upNext': 'Up next',
        'video.noVideosYet': 'No videos yet',
        'video.noShortsYet': 'No shorts yet',
        'video.noLiveStreamsYet': 'No live streams yet',
        'video.noBlockedVideos': 'No blocked videos',
        'video.noBlockedUsers': 'No blocked users',
        // Stream Messages
        'stream.ended': 'This stream has ended. Chat is now closed.',
        'stream.welcomeChat': 'Welcome to the live chat!',
        'stream.goalReached': 'Goal Reached!',
        'stream.zapGoalReached': 'Zap goal reached! {amount} sats!',
        // Muted/Hidden Content
        'muted.messageFromMutedUser': 'Message from muted user',
        'muted.commentFromMutedUserHidden': 'Comment from muted user hidden',
        'muted.commentHidden': 'Comment hidden ({packs})',
        'muted.messageHidden': 'Message hidden ({packs})',
        'muted.commentReportedByFollows': 'Comment reported by people you follow',
        'muted.messageReportedByFollows': 'Message reported by people you follow',
        'muted.commentHeavilyDownvoted': 'Comment heavily downvoted by community',
        'muted.messageHeavilyDownvoted': 'Message heavily downvoted',
        // Admin & Lists
        'list.blockedVideos': 'Blocked Videos',
        'list.blockedUsers': 'Blocked Users',
        // Errors & Alerts (Camera)
        'alert.cameraNotSupported': 'Camera access is not supported in this browser. Please use a modern browser like Chrome, Firefox, or Safari.',
        'alert.noCameraFound': 'No camera found on this device. Please connect a camera or use the file upload option instead.',
        'alert.cameraAccessDenied': 'Camera access was denied. Please allow camera permissions in your browser settings and try again.',
        'alert.cameraInUse': 'Camera is in use by another application. Please close other apps using the camera and try again.',
        'alert.cameraUnableAccess': 'Unable to access camera with current settings. Please try using the file upload option instead.',
        'alert.cameraUnableAccessWithError': 'Unable to access camera: {error}\n\nPlease use the file upload option instead.',
        // Errors & Alerts (Forms)
        'alert.fillRequiredFields': 'Please fill in all required fields',
        'alert.uploadThumbnail': 'Please upload a thumbnail image for your stream',
        'alert.failedCreateStream': 'Failed to create live stream. Please try again.',
        'alert.failedUpdateStream': 'Failed to update stream. Please try again.',
        'alert.streamNotFound': 'Could not find stream to edit',
        'alert.canOnlyEditOwnStreams': 'You can only edit your own streams',
        'alert.invalidStreamData': 'Invalid stream data',
        'alert.enterValidGoalAmount': 'Please enter a valid goal amount',
        'alert.canOnlyResetOwnGoals': 'You can only reset goals on your own streams',
        'alert.streamEventNotFound': 'Could not find stream event',
        'alert.failedResetZapGoal': 'Failed to reset zap goal. Please try again.',
        'alert.cannotBlockAdmin': 'Cannot block the admin account',
        'alert.analyticsLoadFailed': 'Failed to load analytics. Please try again.',
        // Errors (Video)
        'alert.cannotReplaceShortWithVideo': 'Cannot replace a Short with a regular video. Please upload a vertical video (60 seconds or less).',
        'alert.cannotReplaceVideoWithShort': 'Cannot replace a regular video with a Short. Please upload a horizontal/landscape video.',
        'alert.shortsRequireVertical': 'This video appears to be horizontal (landscape). Shorts must be vertical (portrait) videos. Please use "Upload Video" for horizontal videos.',
        // Zap Messages
        'zap.cannotZapYourself': 'You cannot zap yourself',
        'zap.cannotZapOwnContent': 'You cannot zap your own content',
        'zap.cannotZapOwnComment': 'You cannot zap your own comment',
        'zap.zapAmount': 'Zap {value} sats',
        // Status Messages (Progress)
        'status.loadingVideo': 'Loading video...',
        'status.loading': 'Loading...',
        'status.compressingProgress': 'Compressing... {progress}%',
        'status.uploadingProgress': 'Uploading... {progress}%',
        'status.uploadingServers': 'Uploading... ({completed}/{total} servers)',
        'status.publishedSuccess': 'Published {type} successfully!',
        // Warnings
        'warning.webmFormat': 'Note: Your browser will output WebM format (may not play on iOS). For iOS-compatible MP4, use Chrome on Windows/Mac.',
        // Footer
        'footer.lastUpdated': 'Last updated: December 2024',
        // Analytics Page
        'analytics.title': 'Channel Analytics',
        'analytics.loading': 'Loading your analytics...',
        'analytics.loadFailed': 'Failed to load analytics. Please try again.',
        'analytics.overview': 'Overview',
        'analytics.views': 'Views',
        'analytics.followers': 'Followers',
        'analytics.topByViews': 'Top Videos by Views',
        'analytics.topByEngagement': 'Top Videos by Engagement',
        'analytics.allContent': 'All Content Performance',
        'analytics.totalViews': 'Total Views',
        'analytics.likes': 'Likes',
        'analytics.likesRatio': 'Likes ({ratio}% ratio)',
        'analytics.dislikes': 'Dislikes',
        'analytics.zapsReceived': '{count} Zaps Received',
        'analytics.boostsReceived': 'Boosts Received',
        'analytics.shares': 'Shares',
        'analytics.comments': 'Comments',
        'analytics.contentCount': '{videos} Videos, {shorts} Shorts, {streams} Streams',
        'analytics.last7days': 'Last 7 days',
        'analytics.last30days': 'Last 30 days',
        'analytics.last90days': 'Last 90 days',
        'analytics.lastYear': 'Last year',
        'analytics.allTime': 'All time',
        'analytics.lastNDays': 'Last {n} days',
        'analytics.netGrowth': 'Net Growth',
        'analytics.newFollowers': 'New Followers',
        'analytics.unfollowed': 'Unfollowed',
        'analytics.noVideosYet': 'No videos yet',
        'analytics.noShortsYet': 'No shorts yet',
        'analytics.noStreamsYet': 'No live streams yet',
        'analytics.viewsTooltip': '{count} views',
        'analytics.subscribersTooltip': '{count} subscribers',
        'analytics.videosTab': 'Videos ({count})',
        'analytics.shortsTab': 'Shorts ({count})',
        'analytics.streamsTab': 'Live Streams ({count})',
        // About Page
        'about.title': 'About Plebs',
        'about.whatIs': 'What is Plebs?',
        'about.whatIsDesc': 'Plebs is a censorship-resistant, decentralized video platform built on the <a href="https://nostr.com" target="_blank" rel="noopener">Nostr protocol</a>. Unlike traditional video platforms controlled by corporations, Plebs gives you true ownership of your content and identity.',
        'about.whyNostr': 'Why Nostr?',
        'about.whyNostrDesc': 'Nostr (Notes and Other Stuff Transmitted by Relays) is a simple, open protocol that enables a truly decentralized social network. Key benefits include:',
        'about.benefit1': 'Censorship Resistance:',
        'about.benefit1Desc': 'No single entity can ban you or remove your content',
        'about.benefit2': 'Portability:',
        'about.benefit2Desc': 'Your identity and followers work across all Nostr apps',
        'about.benefit3': 'No Central Authority:',
        'about.benefit3Desc': 'No company owns or controls the network',
        'about.benefit4': 'Cryptographic Identity:',
        'about.benefit4Desc': 'Your keys prove you are who you say you are',
        'about.howItWorks': 'How It Works',
        'about.howItWorksDesc': 'Videos on Plebs are stored using <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom</a>, a distributed file storage system, while video metadata and social interactions are broadcast to Nostr relays. This means your content isn\'t stored on our servers - it\'s distributed across the network.',
        'about.features': 'Features',
        'about.feature1': 'Upload and share videos with the Nostr community',
        'about.feature2': 'Like, comment, and share videos using Nostr reactions',
        'about.feature3': 'Zap creators with Bitcoin via the Lightning Network',
        'about.feature4': 'Follow your favorite creators across any Nostr app',
        'about.feature5': 'Browse topics and discover new content',
        'about.feature6': 'Works with any Nostr identity (use existing keys)',
        'about.openSource': 'Open Source',
        'about.openSourceDesc': 'Plebs is open source software. You can view the code, contribute, or run your own instance:',
        'about.githubRepo': 'GitHub Repository',
        'about.builtBy': 'Built By',
        'about.builtByDesc': 'Plebs is developed by <a href="https://nostrservices.com" target="_blank" rel="noopener" class="accent-link">21 Million LLC</a>, a company dedicated to building tools for the Bitcoin and Nostr ecosystem.',
        // Contact Page
        'contact.title': 'Contact Us',
        'contact.getInTouch': 'Get In Touch',
        'contact.getInTouchDesc': 'Have questions, feedback, or need support? We\'d love to hear from you!',
        'contact.email': 'Email',
        'contact.emailDesc': 'The best way to reach us is through Email:',
        'contact.github': 'GitHub',
        'contact.githubDesc': 'For bug reports, feature requests, or technical issues, please open an issue on our GitHub repository:',
        'contact.githubIssues': 'GitHub Issues',
        'contact.company': 'Company',
        'contact.companyDesc': 'Plebs is developed by 21 Million LLC',
        // Terms of Service Page
        'terms.title': 'Terms of Service',
        'terms.lastUpdated': 'Last updated: December 2024',
        'terms.section1Title': '1. Acceptance of Terms',
        'terms.section1Desc': 'By accessing and using Plebs ("the Service"), you agree to be bound by these Terms of Service. If you do not agree to these terms, please do not use the Service.',
        'terms.section2Title': '2. Description of Service',
        'terms.section2Desc': 'Plebs is a decentralized video platform built on the Nostr protocol. The Service provides an interface to browse, upload, and interact with video content stored across distributed networks. Plebs does not host or store video content on centralized servers.',
        'terms.section3Title': '3. User Responsibilities',
        'terms.section3Desc': 'You are responsible for:',
        'terms.section3Item1': 'Maintaining the security of your Nostr private keys',
        'terms.section3Item2': 'All content you upload or share through the Service',
        'terms.section3Item3': 'Ensuring your use complies with applicable laws',
        'terms.section3Item4': 'Not uploading illegal, infringing, or harmful content',
        'terms.section4Title': '4. Content Guidelines',
        'terms.section4Desc': 'You agree not to upload, share, or distribute:',
        'terms.section4Item1': 'Content that infringes on intellectual property rights',
        'terms.section4Item2': 'Illegal content including but not limited to child exploitation material',
        'terms.section4Item3': 'Content that promotes violence or harm to others',
        'terms.section4Item4': 'Spam, malware, or deceptive content',
        'terms.section4Note': 'Adult content (NSFW) must be properly labeled using the NSFW tag when uploading.',
        'terms.section5Title': '5. Decentralized Nature',
        'terms.section5Desc': 'Due to the decentralized nature of Nostr and Blossom storage:',
        'terms.section5Item1': 'Content may persist on the network even after deletion requests',
        'terms.section5Item2': 'We cannot guarantee removal of content from all relays or storage servers',
        'terms.section5Item3': 'Your content and interactions are public by default',
        'terms.section5Item4': 'You are solely responsible for your private key security',
        'terms.section6Title': '6. No Warranty',
        'terms.section6Desc': 'The Service is provided "as is" without warranties of any kind. We do not guarantee continuous, uninterrupted access to the Service.',
        'terms.section7Title': '7. Limitation of Liability',
        'terms.section7Desc': 'To the maximum extent permitted by law, Plebs and its operators shall not be liable for any indirect, incidental, special, or consequential damages arising from your use of the Service.',
        'terms.section8Title': '8. Changes to Terms',
        'terms.section8Desc': 'We reserve the right to modify these terms at any time. Continued use of the Service after changes constitutes acceptance of the new terms.',
        'terms.section9Title': '9. Contact',
        'terms.section9Desc': 'For questions about these Terms, please <a href="#/contact" class="accent-link">contact us</a>.',
        // Privacy Policy Page
        'privacy.title': 'Privacy Policy',
        'privacy.lastUpdated': 'Last updated: December 2024',
        'privacy.section1Title': '1. Overview',
        'privacy.section1Desc': 'Plebs is committed to protecting your privacy. This policy explains how we handle information when you use our decentralized video platform.',
        'privacy.section2Title': '2. Decentralized Architecture',
        'privacy.section2Desc': 'Plebs is built on Nostr, a decentralized protocol. This means:',
        'privacy.section2Item1': 'Your content is broadcast to public relays, not stored on our servers',
        'privacy.section2Item2': 'Your Nostr public key serves as your identity',
        'privacy.section2Item3': 'Videos are stored on distributed Blossom servers',
        'privacy.section2Item4': 'We do not have access to your private keys',
        'privacy.section3Title': '3. Information We Collect',
        'privacy.section3LocalTitle': 'Information stored locally in your browser:',
        'privacy.section3LocalItem1': 'Your Nostr public key (when logged in)',
        'privacy.section3LocalItem2': 'Watch history and preferences',
        'privacy.section3LocalItem3': 'Theme and settings preferences',
        'privacy.section3LocalItem4': 'Private key (only if you choose local key storage - not recommended)',
        'privacy.section3CollectTitle': 'Information we may collect:',
        'privacy.section3CollectItem1': 'Basic analytics (page views, feature usage) to improve the service',
        'privacy.section3CollectItem2': 'Error logs for debugging purposes',
        'privacy.section4Title': '4. Public Information',
        'privacy.section4Desc': 'When using Nostr, the following is public by design:',
        'privacy.section4Item1': 'Your Nostr public key and profile information',
        'privacy.section4Item2': 'Videos you upload',
        'privacy.section4Item3': 'Comments, likes, and other reactions',
        'privacy.section4Item4': 'Who you follow',
        'privacy.section4Item5': 'Zaps (Lightning payments) you send or receive',
        'privacy.section5Title': '5. Data Storage',
        'privacy.section5Desc': 'Local data is stored in your browser\'s localStorage. You can clear this data at any time through your browser settings. Content published to Nostr is distributed across relays and cannot be controlled or deleted by Plebs.',
        'privacy.section6Title': '6. Third-Party Services',
        'privacy.section6Desc': 'Plebs interacts with:',
        'privacy.section6Item1': 'Nostr relays (for social data)',
        'privacy.section6Item2': 'Blossom servers (for video storage)',
        'privacy.section6Item3': 'Lightning Network (for zaps/payments)',
        'privacy.section6Note': 'Each of these services has their own privacy practices.',
        'privacy.section7Title': '7. Your Rights',
        'privacy.section7Desc': 'You can:',
        'privacy.section7Item1': 'Clear your local browser data at any time',
        'privacy.section7Item2': 'Browse videos without creating an account',
        'privacy.section7Item3': 'Use a Nostr browser extension for enhanced privacy',
        'privacy.section7Item4': 'Choose which relays and Blossom servers to use',
        'privacy.section8Title': '8. Security',
        'privacy.section8Desc': 'We recommend:',
        'privacy.section8Item1': 'Using a Nostr browser extension or hardware signer',
        'privacy.section8Item2': 'Never sharing your private key (nsec)',
        'privacy.section8Item3': 'Using a dedicated browser profile for enhanced privacy',
        'privacy.section9Title': '9. Changes to This Policy',
        'privacy.section9Desc': 'We may update this policy from time to time. Changes will be posted on this page with an updated revision date.',
        'privacy.section10Title': '10. Contact',
        'privacy.section10Desc': 'For privacy-related questions, please <a href="#/contact" class="accent-link">contact us</a>.',
        // FAQ Page
        'faq.title': 'Frequently Asked Questions',
        'faq.aboutPlebs': 'About Plebs',
        'faq.nostrProtocol': 'Nostr Protocol',
        'faq.videoStorage': 'Video Storage & Blossom',
        'faq.featuresUsage': 'Features & Usage',
        'faq.q1': 'What is Plebs?',
        'faq.a1': 'Plebs is a censorship-resistant, decentralized video platform built on the Nostr protocol. Unlike traditional video platforms controlled by corporations, Plebs gives you true ownership of your content and identity. There are no central servers that can ban you or remove your content.',
        'faq.q2': 'Is Plebs free to use?',
        'faq.a2': 'Yes, Plebs is completely free to use for watching videos. You can browse and watch content without creating an account. To upload videos, comment, like, or interact with other users, you\'ll need a Nostr identity (which is also free).',
        'faq.q3': 'Who develops Plebs?',
        'faq.a3': 'Plebs is developed by <a href="https://nostrservices.com" target="_blank" rel="noopener">21 Million LLC</a>, a company dedicated to building tools for the Bitcoin and Nostr ecosystem. Plebs is open source, and you can view the code or contribute on <a href="https://github.com/Spl0itable/plebs-app" target="_blank" rel="noopener">GitHub</a>.',
        'faq.q4': 'What is Nostr?',
        'faq.a4': 'Nostr stands for "Notes and Other Stuff Transmitted by Relays." It\'s a simple, open protocol that enables a truly decentralized social network. Unlike traditional platforms, Nostr doesn\'t rely on any central server. Instead, it uses a network of relays to transmit messages between users, and cryptographic keys for identity.',
        'faq.q5': 'Why does Plebs use Nostr?',
        'faq.a5Title': 'Nostr provides several key benefits:',
        'faq.a5Item1': 'Censorship Resistance:',
        'faq.a5Item1Desc': 'No single entity can ban you or remove your content',
        'faq.a5Item2': 'Portability:',
        'faq.a5Item2Desc': 'Your identity and followers work across all Nostr apps',
        'faq.a5Item3': 'No Central Authority:',
        'faq.a5Item3Desc': 'No company owns or controls the network',
        'faq.a5Item4': 'Cryptographic Identity:',
        'faq.a5Item4Desc': 'Your keys prove you are who you say you are',
        'faq.q6': 'What are Nostr keys (npub/nsec)?',
        'faq.a6': 'Your Nostr identity consists of two keys: a public key (npub) and a private key (nsec). Your npub is like your username - you can share it with anyone. Your nsec is like your password - never share it! Anyone with your nsec can post as you and access your account. We recommend using a browser extension like Alby or nos2x to manage your keys securely.',
        'faq.q7': 'Can I use my existing Nostr account?',
        'faq.a7': 'Absolutely! If you already have a Nostr identity from apps like Damus, Primal, Amethyst, or any other Nostr client, you can use the same keys to log into Plebs. Your followers, profile, and reputation carry over automatically.',
        'faq.q8': 'What are Nostr relays?',
        'faq.a8': 'Relays are servers that store and transmit Nostr messages. When you post something, it gets sent to multiple relays. Other users connect to relays to read messages. Because there are many independent relays, no single one can censor you - if one relay blocks you, your content still exists on others.',
        'faq.q9': 'Where are videos stored?',
        'faq.a9': 'Videos are stored on Blossom servers, not on Plebs itself. Blossom is a distributed file storage system designed to work with Nostr. When you upload a video, it goes to one or more Blossom servers of your choice. The video metadata (title, description, etc.) is published to Nostr relays.',
        'faq.q10': 'What is Blossom?',
        'faq.a10': 'Blossom is an open protocol for storing and serving media files in a decentralized way. Files are identified by their SHA-256 hash, which means the same file will have the same address regardless of which server hosts it. This enables redundancy - your files can exist on multiple servers. Learn more at <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom GitHub</a>.',
        'faq.q11': 'Does Plebs host my videos?',
        'faq.a11': 'No. Plebs is a client/interface that helps you browse and upload content, but it doesn\'t store any video or image files. All media is stored on independent Blossom servers. Plebs simply displays content from these distributed storage providers.',
        'faq.q12': 'Can I choose which Blossom server to use?',
        'faq.a12': 'Yes! You can configure which Blossom servers you want to use for uploading in your settings. You can even run your own Blossom server if you want complete control over your media storage.',
        'faq.q13': 'How do I create an account?',
        'faq.a13Title': 'Click the "Login" button and choose your preferred method:',
        'faq.a13Item1': 'Browser Extension:',
        'faq.a13Item1Desc': 'If you have a Nostr extension like Alby or nos2x installed, you can use it to sign in securely',
        'faq.a13Item2': 'Generate New Keys:',
        'faq.a13Item2Desc': 'Create a brand new Nostr identity',
        'faq.a13Item3': 'Import Keys:',
        'faq.a13Item3Desc': 'Use your existing Nostr private key (nsec)',
        'faq.a13Note': 'We recommend using a browser extension for the best security.',
        'faq.q14': 'What are Zaps?',
        'faq.a14': 'Zaps are Bitcoin payments sent over the Lightning Network. They allow you to send real money (satoshis, or "sats") to content creators as tips or appreciation. Unlike traditional platform tips that take large fees, zaps go directly to the creator. To send zaps, you need a Lightning wallet with a Nostr connection (like Alby or Zeus).',
        'faq.q15': 'How do I upload a video?',
        'faq.a15Title': 'To upload a video:',
        'faq.a15Item1': 'Log in with your Nostr identity',
        'faq.a15Item2': 'Click the "Create" button and select "Upload Video"',
        'faq.a15Item3': 'Select your video file (supports most common formats)',
        'faq.a15Item4': 'Add a title, description, and tags',
        'faq.a15Item5': 'Click "Publish" to share with the network',
        'faq.a15Note': 'Videos are automatically compressed and uploaded to Blossom servers.',
        // FAQ Self-Moderation Section
        'faq.selfModeration': 'Self-Moderation',
        'faq.q16': 'How does moderation work on a decentralized platform?',
        'faq.a16': 'Unlike traditional platforms with centralized moderators, Plebs puts you in control of what you see. We provide powerful self-moderation tools including content filter packs, user muting, community warnings, and ratioed video indicators. You decide what content is appropriate for you - there\'s no central authority making those decisions.',
        'faq.q17': 'What are Content Filter Packs?',
        'faq.a17Intro': 'Content Filter Packs are predefined keyword filters you can enable to hide specific types of content. Available packs include:',
        'faq.a17Pack1': 'Racism & Hate Speech:',
        'faq.a17Pack1Desc': 'Filters racial slurs and discriminatory content',
        'faq.a17Pack2': 'Sexually Explicit:',
        'faq.a17Pack2Desc': 'Filters pornographic and adult content',
        'faq.a17Pack3': 'Violence & Gore:',
        'faq.a17Pack3Desc': 'Filters graphic violence and self-harm content',
        'faq.a17Pack4': 'Drugs & Substances:',
        'faq.a17Pack4Desc': 'Filters drug-related content',
        'faq.a17Pack5': 'Spam & Scams:',
        'faq.a17Pack5Desc': 'Filters common spam and scam patterns',
        'faq.a17Pack6': 'Cryptocurrency:',
        'faq.a17Pack6Desc': 'Filters crypto promotion and token shilling',
        'faq.a17Pack7': 'Political Content:',
        'faq.a17Pack7Desc': 'Filters partisan political content',
        'faq.a17Pack8': 'Strong Profanity:',
        'faq.a17Pack8Desc': 'Filters vulgar language',
        'faq.a17Note': 'Enable these in Settings > Content Filters. You can also add custom keywords. Filtered content shows a placeholder with a "Show anyway" button if you want to view it temporarily.',
        'faq.q18': 'How do I mute a user?',
        'faq.a18': 'To mute a user, visit their profile and click the mute button. Once muted, all their videos will be hidden from your feed, their comments will show as "Message from muted user," and their live chat messages will be hidden. Your mute list is stored on Nostr, so it syncs across devices. You can manage muted users in your Profile Settings under "Muted Users."',
        'faq.q19': 'What does "Ratioed" mean?',
        'faq.a19': 'A video is marked as "ratioed" when it has significantly more dislikes than likes, indicating negative community reception. Specifically, a video is ratioed when it has at least 10 reactions, dislikes are at least double the likes, and dislikes make up 70% or more of total reactions. Ratioed videos display a warning badge, and you\'ll be asked to confirm before viewing.',
        'faq.q20': 'How do community warnings work?',
        'faq.a20': 'Users can report content for various reasons (spam, illegal content, abuse, misleading, etc.). When a video or user receives 5 or more reports from people you follow, a warning indicator appears. This leverages your social graph - warnings come from your trusted network, not anonymous strangers. You can toggle "Show warnings from accounts I follow" in Settings.',
        'faq.q21': 'How do I report content?',
        'faq.a21': 'Click the flag icon on any video, comment, or user profile to report it. Select a reason (Spam, Illegal, Abuse, Misleading, Impersonation, Copyright, or Other) and optionally add details. Reports are published to Nostr as events, making them transparent and decentralized. Your reports help others in your network identify problematic content.',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': 'Privacy & Security',
        'faq.q22': 'Is my activity private?',
        'faq.a22': 'On Nostr, most activity is public by design. Your likes, comments, follows, and zaps are visible on the public network. However, Plebs stores your watch history locally in your browser - it\'s never sent to any server. You can clear your local data at any time.',
        'faq.q23': 'How do I keep my account secure?',
        'faq.a23': 'Never share your private key (nsec) with anyone. We strongly recommend using a Nostr browser extension like Alby, nos2x, or a hardware signer. These keep your private key secure and only sign events when you approve them. Avoid storing your nsec directly in websites.',
        'faq.q24': 'Can I delete my content?',
        'faq.a24': 'You can request deletion by publishing a delete event on Nostr. Most well-behaved relays and clients will respect this. However, due to the decentralized nature of the network, content may persist on some relays or Blossom servers. There\'s no central authority that can force complete deletion across the entire network.',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': 'Troubleshooting',
        'faq.q25': 'Videos aren\'t loading - what should I do?',
        'faq.a25Intro': 'If videos aren\'t loading, try these steps:',
        'faq.a25Item1': 'Refresh the page',
        'faq.a25Item2': 'Check your internet connection',
        'faq.a25Item3': 'The Blossom server hosting the video might be down - this is independent of Plebs',
        'faq.a25Item4': 'Try disabling browser extensions that might block content',
        'faq.a25Item5': 'Clear your browser cache and try again',
        'faq.q26': 'I lost my private key - can you help me recover it?',
        'faq.a26': 'Unfortunately, no. Nostr keys are cryptographic - there\'s no password reset or account recovery because there\'s no central authority. This is why we strongly recommend backing up your keys and using a secure key management solution. If you lose your nsec, you\'ll need to create a new identity.',
        'faq.q27': 'How do I report a bug or request a feature?',
        'faq.a27': 'You can report bugs or request features on our <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a> page. You can also reach out to us on Nostr - visit our <a href="#/contact">Contact</a> page for details.',
        // Page Titles
        'pageTitle.following': 'Following',
        'pageTitle.myVideos': 'My Videos',
        'pageTitle.likedVideos': 'Liked Videos',
        'pageTitle.watchHistory': 'Watch History',
        'pageTitle.liveStreams': 'Live Streams',
        'pageTitle.suffix': '- Plebs',
        'pageTitle.liveSuffix': '- Live on Plebs',
        // Home Page Sections
        'section.trending': 'Trending',
        'section.recommended': 'Recommended For You',
        'section.shorts': 'Shorts',
        'section.live': 'Live',
        'section.liveNow': 'Live Now',
        'section.latestVideos': 'Latest Videos',
        'section.videos': 'Videos',
        'section.usersYouFollow': 'Users You Follow',
        // Trending Period
        'trending.thisWeek': 'This Week',
        'trending.today': 'Today',
        // Buttons
        'button.viewMore': 'View More',
        'button.clearAll': 'Clear All',
        'button.showAnyway': 'Show anyway',
        // Confirmation Modals
        'confirm.logout': 'Logout',
        'confirm.logoutMessage': 'Are you sure you want to logout?',
        'confirm.resetSettings': 'Reset Settings',
        'confirm.resetSettingsMessage': 'Are you sure you want to reset all settings to defaults?',
        'confirm.reset': 'Reset',
        'confirm.clearHistory': 'Clear History',
        'confirm.clearHistoryMessage': 'Are you sure you want to clear your entire watch history? This cannot be undone.',
        'confirm.deleteDraft': 'Delete Draft',
        'confirm.deleteDraftMessage': 'Are you sure you want to delete this draft?',
        'confirm.delete': 'Delete',
        'confirm.deleteVideo': 'Delete Video',
        'confirm.deleteVideoMessage': 'Are you sure you want to delete this video? This action cannot be undone.',
        'confirm.endStream': 'End Live Stream',
        'confirm.endStreamMessage': 'Are you sure you want to end this live stream? This action cannot be undone.',
        'confirm.endStreamButton': 'End Stream',
        // Content Filters
        'filter.hiddenByPack': 'Hidden by {pack}',
        'filter.showAnyway': 'Show anyway',
        'filter.contentHidden': 'Content hidden by content filter',
        // Following Page
        'following.noFollowingYet': 'You\'re not following anyone yet. Find creators to follow!',
        // DMCA Page
        'dmca.title': 'DMCA & Content Policy',
        'dmca.lastUpdated': 'Last Updated: December 2024',
        'dmca.architectureTitle': 'Understanding Plebs Architecture',
        'dmca.architectureDesc': 'Plebs is a decentralized video platform interface that operates differently from traditional video hosting services. It\'s important to understand how content is distributed on our platform:',
        'dmca.architectureItem1': 'Plebs does not host any video or image content.',
        'dmca.architectureItem1Desc': 'We are a client/interface that displays content stored elsewhere.',
        'dmca.architectureItem2': 'All media files (videos, images, thumbnails) are stored on independent Blossom servers operated by third parties.',
        'dmca.architectureItem3': 'Video metadata (titles, descriptions, etc.) is published to Nostr relays, which are also independently operated.',
        'dmca.architectureItem4': 'Plebs simply aggregates and displays this distributed content through a user-friendly interface.',
        'dmca.filingTitle': 'Filing a DMCA Claim',
        'dmca.filingDesc': 'Because Plebs does not host content, we cannot directly remove infringing material. To address copyright infringement, you must contact the appropriate parties:',
        'dmca.forVideoTitle': '1. For Video/Image Content',
        'dmca.forVideoDesc': 'Media files are stored on Blossom servers. You need to:',
        'dmca.forVideoItem1': 'Identify which Blossom server is hosting the content (the URL will indicate this)',
        'dmca.forVideoItem2': 'Contact the Blossom server operator directly with your DMCA takedown request',
        'dmca.forVideoItem3': 'Each Blossom server operates independently and has its own policies',
        'dmca.forMetadataTitle': '2. For Metadata/Descriptions',
        'dmca.forMetadataDesc': 'If the infringing content is in the video title, description, or other metadata:',
        'dmca.forMetadataItem1': 'This information is stored on Nostr relays',
        'dmca.forMetadataItem2': 'Contact the specific Nostr relay operators where the content appears',
        'dmca.forMetadataItem3': 'Multiple relays may store the same data due to Nostr\'s distributed nature',
        'dmca.whatWeCanDoTitle': 'What Plebs Can Do',
        'dmca.whatWeCanDoDesc': 'While we don\'t host content, we can:',
        'dmca.whatWeCanDoItem1': 'Help you identify which Blossom servers or relays are hosting specific content',
        'dmca.whatWeCanDoItem2': 'Add content to a local blocklist so it doesn\'t appear in our interface (note: this only affects plebs.app, not other Nostr clients)',
        'dmca.whatWeCanDoItem3': 'Provide guidance on how to contact the appropriate service operators',
        'dmca.toRequestAssistance': 'To request assistance, please contact us with:',
        'dmca.assistanceItem1': 'The URL or identifier of the infringing content',
        'dmca.assistanceItem2': 'Proof of your copyright ownership',
        'dmca.assistanceItem3': 'A description of the copyrighted work',
        'dmca.blossomOperatorsTitle': 'Blossom Server Operators',
        'dmca.blossomOperatorsDesc': 'If you operate a Blossom server and receive a DMCA takedown request, you are responsible for handling it according to your jurisdiction\'s laws.',
        'dmca.blossomOperatorsLink': 'For a list of known Blossom servers, refer to the Blossom project documentation.',
        'dmca.considerationsTitle': 'Important Considerations',
        'dmca.considerationsItem1': 'Decentralization:',
        'dmca.considerationsItem1Desc': 'Due to the decentralized nature of Nostr and Blossom, complete removal of content from all sources may not be possible.',
        'dmca.considerationsItem2': 'Multiple Copies:',
        'dmca.considerationsItem2Desc': 'Content may exist on multiple Blossom servers and relays. You may need to contact multiple operators.',
        'dmca.considerationsItem3': 'Hash-Based Storage:',
        'dmca.considerationsItem3Desc': 'Blossom uses content-addressed storage. The same file will have the same hash on any server.',
        'dmca.considerationsItem4': 'No Central Control:',
        'dmca.considerationsItem4Desc': 'Neither Plebs nor any single entity has the ability to remove content from the entire network.',
        'dmca.counterNotificationTitle': 'Counter-Notification',
        'dmca.counterNotificationDesc': 'If you believe your content was wrongly removed from a Blossom server, you should contact that server operator directly to file a counter-notification.',
        'dmca.contactTitle': 'Contact',
        'dmca.contactDesc': 'For questions about this policy or assistance identifying content hosts, please',
        'dmca.contactLink': 'contact us',
    },
    es: {
        // Navigation & Header
        'nav.home': 'Inicio', 'nav.following': 'Siguiendo', 'nav.myVideos': 'Mis Videos', 'nav.liked': 'Me Gusta', 'nav.history': 'Historial', 'nav.topics': 'TEMAS', 'nav.live': 'En Vivo', 'nav.bitcoin': 'Bitcoin', 'nav.nostr': 'Nostr', 'nav.technology': 'Tecnología', 'nav.gaming': 'Juegos', 'nav.tutorials': 'Tutoriales', 'nav.podcasts': 'Podcasts', 'nav.music': 'Música', 'nav.nsfw': 'NSFW', 'nav.about': 'Acerca de', 'nav.contact': 'Contacto', 'nav.terms': 'Términos', 'nav.privacy': 'Privacidad', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.playlists': 'Listas', 'nav.downloads': 'Descargas', 'nav.subscriptions': 'Suscripciones', 'nav.trending': 'Tendencias', 'nav.explore': 'Explorar', 'nav.categories': 'Categorías', 'nav.liveStreams': 'Transmisiones en Vivo', 'nav.github': 'GitHub',
        'header.search': 'Buscar videos...', 'header.notifications': 'Notificaciones', 'header.settings': 'Configuración', 'header.create': 'Crear', 'header.admin': 'Admin', 'header.viewProfile': 'Ver Perfil', 'header.logout': 'Cerrar Sesión',
        // Login Modal
        'login.title': 'Iniciar Sesión con Nostr', 'login.extension': 'Iniciar con Extensión', 'login.extensionDesc': 'Usa Alby, nos2x u otras extensiones Nostr', 'login.connect': 'Nostr Connect', 'login.connectDesc': 'Conectar con firmantes remotos como Amber, nsec.app', 'login.privateKey': 'Clave Privada', 'login.privateKeyDesc': 'Ingresa tu nsec o clave hex (solo local)', 'login.newToNostr': '¿Nuevo en Nostr?', 'login.createAccount': 'Crear Cuenta', 'login.createAccountDesc': 'Comienza con una nueva identidad Nostr para usar en Plebs',
        // Connect Modal
        'connect.title': 'Conectar con Nostr', 'connect.option1': 'Opción 1: Usa esta cadena de conexión', 'connect.option1Desc': 'Copia y pega esto en cualquier app compatible con NIP-46 (nsec.app, Amber, etc.)', 'connect.copyString': 'Copiar Cadena de Conexión', 'connect.showQR': 'Mostrar Código QR', 'connect.listening': 'Esperando conexión...', 'connect.option2': 'Opción 2: Pegar una URL bunker', 'connect.option2Desc': 'Si ya tienes una URL bunker:// de un firmante remoto', 'connect.withBunker': 'Conectar con Bunker', 'connect.popularSigners': 'Firmantes NIP-46 populares:', 'connect.webSigner': 'Firmante web', 'connect.androidApp': 'App Android', 'connect.builtInSigner': 'Firmante integrado', 'connect.or': 'O', 'connect.bunkerPlaceholder': 'bunker://...',
        // Private Key Modal
        'privateKey.title': 'Iniciar con Clave Privada', 'privateKey.warning': 'Advertencia de Seguridad', 'privateKey.warningText': 'Tu clave privada se almacenará localmente en tu navegador. Para mayor seguridad, considera usar una extensión de navegador o Nostr Connect.', 'privateKey.label': 'Clave Privada (nsec o hex)', 'privateKey.showKey': 'Mostrar clave', 'privateKey.login': 'Iniciar Sesión', 'privateKey.placeholder': 'nsec1...',
        // Signup Modal
        'signup.title': 'Crear Cuenta Nostr', 'signup.whatIsNostr': '¿Qué es Nostr?', 'signup.nostrExplanation': 'Nostr es un protocolo social descentralizado que te da propiedad de tu identidad y contenido. A diferencia de las plataformas tradicionales, ninguna empresa puede banearte, censurar tu contenido o cerrar tu cuenta.', 'signup.whyPlebs': '¿Por qué Plebs usa Nostr?', 'signup.plebsExplanation': 'Plebs está construido sobre Nostr para proporcionar compartición de videos resistente a la censura. Tus videos, comentarios e interacciones se almacenan en una red de relays, no en nuestros servidores. ¡Tu identidad Nostr funciona en cientos de otras apps también!', 'signup.howItWorks': 'Cómo funciona', 'signup.keysIdentity': 'Tus claves = Tu identidad.', 'signup.keysIdentityDesc': 'Obtendrás una clave privada (nsec) que prueba que eres dueño de tu cuenta.', 'signup.keepSecret': '¡Mantén tu clave privada en secreto!', 'signup.keepSecretDesc': 'Es como una contraseña que nunca se puede restablecer.', 'signup.oneIdentity': 'Una identidad, muchas apps.', 'signup.oneIdentityDesc': 'Usa la misma cuenta en Damus, Primal, Amethyst y más.', 'signup.gotIt': 'Entendido, vamos a crear mi cuenta', 'signup.username': 'Nombre de Usuario', 'signup.usernamePlaceholder': 'Elige un nombre para mostrar', 'signup.about': 'Acerca de (opcional)', 'signup.aboutPlaceholder': 'Cuéntale a otros sobre ti', 'signup.profilePicture': 'Foto de Perfil (opcional)', 'signup.uploadPhoto': 'Subir Foto', 'signup.remove': 'Eliminar', 'signup.avatarHint': 'Las imágenes cuadradas funcionan mejor. Máx 5MB.', 'signup.uploading': 'Subiendo...', 'signup.lightningAddress': 'Dirección Lightning (opcional)', 'signup.lightningPlaceholder': 'tu@walletofsatoshi.com', 'signup.lightningHint': 'Agrega una dirección Lightning para recibir zaps (propinas de Bitcoin) en tus videos y perfil.', 'signup.nostrAddress': 'Dirección Nostr', 'signup.nostrAddressPlaceholder': 'usuario', 'signup.nostrAddressHint': 'Tu dirección Nostr facilita encontrar tu perfil. Solo letras minúsculas, números, _ y -.', 'signup.nostrAddressRequired': 'Por favor ingresa una dirección Nostr', 'signup.nostrAddressAvailable': '¡Disponible!', 'signup.nostrAddressUnavailable': 'Ya está en uso', 'signup.nostrAddressChecking': 'Verificando...', 'signup.nostrAddressInvalid': 'Formato de usuario inválido', 'signup.nostrAddressRegistering': 'Registrando tu dirección Nostr...', 'signup.nostrAddressSuccess': '¡Dirección Nostr registrada!', 'signup.nostrAddressFailed': 'No se pudo registrar la dirección Nostr', 'signup.yourUsername': 'Tu Nombre de Usuario', 'signup.yourBio': 'Tu biografía aparecerá aquí', 'signup.createAccountBtn': 'Crear Cuenta', 'signup.termsAgree': 'Al crear una cuenta, aceptas nuestros', 'signup.and': 'y', 'signup.success': '¡Cuenta Creada Exitosamente!', 'signup.yourPrivateKey': 'Tu Clave Privada (nsec)', 'signup.keyWarning': 'Esta es la ÚNICA forma de acceder a tu cuenta. ¡Guárdala en un lugar seguro!', 'signup.copyPrivateKey': 'Copiar Clave Privada', 'signup.howToUseKey': 'Cómo usar tu clave privada', 'signup.continueToPlebs': 'Continuar a Plebs', 'signup.step1': 'Guárdala de forma segura:', 'signup.step1Desc': 'Almacena tu nsec en un administrador de contraseñas, escríbela o guárdala en un archivo encriptado. ¡Nunca la compartas públicamente!', 'signup.step2': 'Para iniciar sesión de nuevo:', 'signup.step2Desc': 'Haz clic en "Clave Privada" en la pantalla de inicio de sesión y pega tu nsec. Funciona como una contraseña.', 'signup.step3': 'Usar en otras apps:', 'signup.step3Desc': '¡Tu nsec funciona en todas las apps Nostr - Damus, Primal, Amethyst y cientos más!', 'signup.step4': 'Considera una app de firmante:', 'signup.step4Desc': 'Para mayor seguridad, usa apps como Amber (Android) o una extensión de navegador como Alby para administrar tus claves.',
        // Notifications
        'notifications.title': 'Notificaciones', 'notifications.settings': 'Configuración de Notificaciones', 'notifications.reactions': 'Reacciones (me gusta/no me gusta)', 'notifications.replies': 'Comentarios y Respuestas', 'notifications.zaps': 'Zaps', 'notifications.chatMentions': 'Menciones en Chat en Vivo', 'notifications.newFollowers': 'Nuevos Seguidores', 'notifications.syncNote': 'La configuración se sincroniza entre dispositivos vía Nostr', 'notifications.settingsTitle': 'Configuración de Notificaciones',
        // Settings Modal
        'settings.title': 'Configuración', 'settings.language': 'Idioma', 'settings.languageDesc': 'Elige tu idioma preferido', 'settings.saveToNostr': 'Guardar en Nostr', 'settings.saveToNostrDesc': 'Sincronizar configuración en todas las instancias de Plebs', 'settings.darkMode': 'Modo Oscuro', 'settings.darkModeDesc': 'Cambiar entre tema claro y oscuro', 'settings.contentWarnings': 'Preferencias de Advertencias de Contenido', 'settings.contentWarning': 'Preferencias de Advertencias de Contenido', 'settings.showNSFW': 'Mostrar advertencias NSFW', 'settings.showNSFWDesc': 'Mostrar verificación de edad para contenido NSFW', 'settings.showNsfwWarnings': 'Mostrar advertencias NSFW', 'settings.showNsfwWarningsDesc': 'Mostrar verificación de edad para contenido NSFW', 'settings.showCommunity': 'Mostrar advertencias de la comunidad', 'settings.showCommunityDesc': 'Mostrar advertencias para contenido marcado o con muchos votos negativos', 'settings.showCommunityWarnings': 'Mostrar advertencias de la comunidad', 'settings.showCommunityWarningsDesc': 'Mostrar advertencias para contenido marcado o con muchos votos negativos', 'settings.showFollowsReport': 'Mostrar advertencias de reportes de seguidos', 'settings.showFollowsReportDesc': 'Mostrar advertencias cuando 5+ personas que sigues han reportado contenido', 'settings.showFollowsReportWarnings': 'Mostrar advertencias de reportes de seguidos', 'settings.showFollowsReportWarningsDesc': 'Mostrar advertencias cuando 5+ personas que sigues han reportado contenido', 'settings.filterPacks': 'Paquetes de Filtros de Contenido', 'settings.filterPacksDesc': 'Habilita paquetes de filtros para ocultar automáticamente contenido que coincida con palabras clave específicas.', 'settings.customKeywords': 'Filtro de Palabras Clave Personalizado', 'settings.customKeywordsPlaceholder': 'Ingresa palabras clave o frases separadas por comas', 'settings.customKeywordsDesc': 'Agrega tus propias palabras clave para filtrar (separadas por comas)', 'settings.customKeywordFilter': 'Filtro de Palabras Clave Personalizado', 'settings.customKeywordFilterPlaceholder': 'Ingresa palabras clave o frases separadas por comas\nEjemplo: spam, contenido no deseado, frase específica', 'settings.customKeywordFilterDesc': 'Agrega tus propias palabras clave para filtrar (separadas por comas)', 'settings.mutedUsers': 'Usuarios Silenciados', 'settings.mutedUsersDesc': 'Los usuarios que silencies no aparecerán en tu feed o comentarios.', 'settings.blossomSettings': 'Configuración del Servidor Blossom', 'settings.premiumBlossom': 'Servidor Blossom Premium (NostrMedia.com)', 'settings.premiumBlossomDesc': 'Usa NostrMedia.com si eres usuario suscrito', 'settings.customBlossom': 'Servidores Blossom Personalizados', 'settings.customBlossomDesc': 'Agrega tus propios servidores Blossom (separados por comas)', 'settings.relaySettings': 'Configuración de Relays', 'settings.useWotRelays': 'Usar Relays Web of Trust', 'settings.useWotRelaysDesc': 'Conectar a relays Web of Trust para mejor filtrado de spam', 'settings.saveSettings': 'Guardar Configuración', 'settings.resetDefaults': 'Restablecer Valores', 'settings.notificationSettings': 'Configuración de Notificaciones',
        // Upload Modal
        'upload.title': 'Subir Video', 'upload.videoFile': 'Archivo de Video', 'upload.recordFromCamera': 'Grabar desde Cámara', 'upload.stop': 'Detener', 'upload.recordHint': 'Graba un video vertical (hasta 60 segundos)', 'upload.or': 'o', 'upload.clickToSelect': 'Haz clic para seleccionar video o arrastra y suelta', 'upload.fileTypes': 'MP4, AVI, MOV, etc (máx 2GB entrada, se comprimirá a <100MB)', 'upload.preparing': 'Preparando...', 'upload.thumbnail': 'Miniatura', 'upload.thumbnailHint': 'Haz clic para seleccionar o auto-generar del video', 'upload.uploading': 'Subiendo...', 'upload.titleLabel': 'Título', 'upload.titlePlaceholder': 'Ingresa el título del video', 'upload.descriptionLabel': 'Descripción', 'upload.descriptionPlaceholder': 'Cuéntale a los espectadores sobre tu video', 'upload.tagsLabel': 'Etiquetas (separadas por comas)', 'upload.tagsPlaceholder': 'bitcoin, nostr, tutorial', 'upload.markNsfw': 'Marcar como NSFW (18+)', 'upload.nsfwDesc': 'El contenido que contiene material adulto debe marcarse como NSFW', 'upload.saveDraft': 'Guardar como Borrador', 'upload.publish': 'Publicar', 'upload.selectVideo': 'Selecciona un video para subir', 'upload.optional': '(opcional)', 'upload.remove': 'Eliminar', 'upload.removeThumbnail': 'Eliminar y subir diferente miniatura', 'upload.removeVideo': 'Eliminar y subir diferente video', 'upload.qualityHigh': 'Alta', 'upload.backToCreate': 'Volver a Crear',
        // Create Modal
        'create.title': 'Crear', 'create.goLive': 'En Vivo', 'create.goLiveDesc': 'Inicia una transmisión en vivo o programa una', 'create.uploadVideo': 'Subir Video', 'create.uploadVideoDesc': 'Sube un video desde tu dispositivo', 'create.createShort': 'Crear Short', 'create.createShortDesc': 'Sube un video vertical (menos de 60s)',
        // Go Live Modal
        'goLive.title': 'En Vivo', 'goLive.when': '¿Cuándo quieres transmitir en vivo?', 'goLive.now': 'Transmitir Ahora', 'goLive.schedule': 'Programar Transmisión', 'goLive.scheduleDateTime': 'Fecha y Hora Programada', 'goLive.streamThumbnail': 'Miniatura de Transmisión', 'goLive.streamTitle': 'Título de Transmisión', 'goLive.streamTitlePlaceholder': 'Ingresa el título de tu transmisión', 'goLive.description': 'Descripción', 'goLive.descriptionPlaceholder': 'Cuéntale a los espectadores de qué trata tu transmisión', 'goLive.tags': 'Etiquetas (separadas por comas)', 'goLive.tagsPlaceholder': 'gaming, bitcoin, tutorial', 'goLive.streamUrl': 'URL de Transmisión (RTMP, HLS o WebRTC)', 'goLive.streamUrlPlaceholder': 'https://tu-servicio-streaming.com/stream.m3u8', 'goLive.streamUrlHint': 'Usa servicios como zap.stream, OBS Ninja, Cloudflare Stream o cualquier proveedor RTMP/HLS', 'goLive.zapGoal': 'Meta de Zaps (opcional)', 'goLive.zapGoalLabel': 'Meta de Zaps', 'goLive.zapGoalPlaceholder': 'ej. 10000', 'goLive.zapGoalHint': 'Establece una meta de propinas de Bitcoin (en sats) para mostrar en tu transmisión', 'goLive.setupGuide': 'Guía de Configuración de Transmisión', 'goLive.setupGuideDesc': 'Para transmitir en vivo, necesitas una URL de streaming de un proveedor de servicios:', 'goLive.cancel': 'Cancelar', 'goLive.goLiveBtn': 'Transmitir',
        'video.noDescription': 'No se ha añadido descripción a este video.', 'live.noDescription': 'No se ha añadido descripción a esta transmisión en vivo.',
        // Edit Stream Modal
        'editStream.title': 'Editar Transmisión', 'editStream.changeThumbnail': 'Cambiar Miniatura', 'editStream.titleLabel': 'Título', 'editStream.saveChanges': 'Guardar Cambios',
        // NSFW Warning Modal
        'nsfw.title': 'Verificación de Edad Requerida', 'nsfw.description': 'Este contenido está marcado como NSFW (No Seguro Para el Trabajo) y puede contener material adulto. Debes tener 18 años o más para ver este contenido.', 'nsfw.confirm': 'Tengo 18+ años', 'nsfw.remember': 'No preguntar de nuevo (Recordar mi elección)',
        // Community Warning Modal
        'communityWarning.title': 'Advertencia de la Comunidad', 'communityWarning.description': 'Este video ha sido marcado y/o tiene muchos votos negativos de la comunidad. Esto puede ser debido a:', 'communityWarning.reason1': 'Contenido inapropiado no marcado correctamente como NSFW', 'communityWarning.reason2': 'Detalles de usuario nuevos o sospechosos', 'communityWarning.reason3': 'Información engañosa o falsa', 'communityWarning.reason4': 'Spam o contenido de baja calidad', 'communityWarning.reason5': 'Contenido potencialmente dañino o ilegal', 'communityWarning.proceed': 'Procede con precaución.', 'communityWarning.goBack': 'Volver', 'communityWarning.viewAnyway': 'Ver de Todos Modos',
        // Report Modal
        'report.title': 'Reportar Video', 'report.description': 'Selecciona una razón para reportar este contenido:', 'report.nudity': 'Desnudez o Contenido Sexual', 'report.nudityDesc': 'Contiene imágenes sexuales o explícitas no marcadas como NSFW', 'report.hate': 'Discurso de Odio o Acoso', 'report.hateDesc': 'Promueve violencia, odio o acoso contra individuos o grupos', 'report.illegal': 'Contenido Ilegal', 'report.illegalDesc': 'Contenido que puede violar leyes o regulaciones', 'report.spam': 'Spam o Engañoso', 'report.spamDesc': 'Contenido engañoso, estafas o spam repetitivo', 'report.impersonation': 'Suplantación de Identidad', 'report.impersonationDesc': 'Pretender ser otra persona', 'report.other': 'Otro', 'report.otherDesc': 'Otra violación no listada arriba', 'report.additionalDetails': 'Detalles adicionales (opcional)', 'report.detailsPlaceholder': 'Proporciona más contexto sobre por qué estás reportando este video...', 'report.cancel': 'Cancelar', 'report.submit': 'Enviar Reporte',
        // Share Modal
        'share.title': 'Compartir Video', 'share.link': 'Enlace', 'share.embed': 'Incrustar', 'share.shareWith': 'Comparte este video con otros:', 'share.copy': 'Copiar', 'share.copied': '¡Copiado al portapapeles!', 'share.embedOnWebsite': 'Incrusta este video en tu sitio web:', 'share.size': 'Tamaño:', 'share.responsive': 'Responsivo (Por defecto)', 'share.size1280x720': '1280 × 720 (HD)', 'share.embedCodeCopied': '¡Código de incrustación copiado!', 'share.fallbackNote': 'Incluye respaldo automático a servidores espejo si la fuente principal falla.',
        // Edit Video Modal
        'editVideo.title': 'Editar Video', 'editVideo.video': 'Video', 'editVideo.currentVideo': 'Video Actual', 'editVideo.replaceVideo': 'Reemplazar Video', 'editVideo.thumbnail': 'Miniatura', 'editVideo.currentThumbnail': 'Miniatura Actual', 'editVideo.changeThumbnail': 'Cambiar Miniatura', 'editVideo.titleLabel': 'Título', 'editVideo.descriptionLabel': 'Descripción', 'editVideo.tagsLabel': 'Etiquetas (separadas por comas)', 'editVideo.cancel': 'Cancelar', 'editVideo.saveChanges': 'Guardar Cambios',
        // Edit Profile Modal
        'editProfile.title': 'Editar Perfil', 'editProfile.displayName': 'Nombre para Mostrar', 'editProfile.displayNamePlaceholder': 'Tu nombre para mostrar', 'editProfile.about': 'Acerca de', 'editProfile.aboutPlaceholder': 'Cuéntale a otros sobre ti', 'editProfile.picture': 'Foto de Perfil', 'editProfile.pictureUrl': 'O ingresa la URL de imagen directamente:', 'editProfile.pictureUrlPlaceholder': 'https://ejemplo.com/avatar.jpg', 'editProfile.lightningPlaceholder': 'tu@walletofsatoshi.com', 'editProfile.nip05': 'Identificador NIP-05 (opcional)', 'editProfile.nip05Placeholder': 'tu@dominio.com', 'editProfile.nip05Hint': 'Una dirección Nostr verificada para verificación de identidad.', 'editProfile.website': 'Sitio Web (opcional)', 'editProfile.websitePlaceholder': 'https://tusitio.com', 'editProfile.lightning': 'Dirección Lightning (opcional)', 'editProfile.saveChanges': 'Guardar Cambios',
        // Confirmation Modal
        'confirm.title': 'Confirmar Acción', 'confirm.message': '¿Estás seguro de que quieres continuar?', 'confirm.cancel': 'Cancelar', 'confirm.confirm': 'Confirmar',
        // Video Page
        'video.views': 'vistas', 'video.view': 'vista', 'video.followers': 'seguidores', 'video.follower': 'seguidor', 'video.follow': 'Seguir', 'video.unfollow': 'Dejar de Seguir', 'video.share': 'Compartir', 'video.comments': 'Comentarios', 'video.writeComment': 'Escribe un comentario...', 'video.noComments': 'Sin comentarios aún. ¡Sé el primero!', 'video.reply': 'Responder', 'video.report': 'Reportar', 'video.mute': 'Silenciar Usuario',
        // Toast Messages
        'toast.loggedIn': '¡Sesión iniciada!', 'toast.settingsSaved': '¡Configuración guardada!', 'toast.settingsLocal': 'Configuración guardada localmente. No se pudo guardar en Nostr.', 'toast.settingsLocalOnly': '¡Configuración guardada localmente!', 'toast.settingsReset': '¡Configuración restablecida!', 'toast.avatarUploaded': '¡Avatar subido exitosamente!', 'toast.profileUpdated': '¡Perfil actualizado exitosamente!', 'toast.copied': '¡Copiado al portapapeles!', 'toast.copyFailed': 'Error al copiar. Por favor copia manualmente.', 'toast.installExtension': 'Por favor instala una extensión de navegador Nostr como Alby o nos2x', 'toast.loginFailed': 'Error al iniciar sesión con la extensión. Intenta de nuevo.', 'toast.invalidKey': 'Clave privada inválida. Por favor verifica e intenta de nuevo.', 'toast.enterKey': 'Por favor ingresa tu clave privada', 'toast.enterUsername': 'Por favor ingresa un nombre de usuario', 'toast.accountCreated': '¡Bienvenido a Plebs! Has iniciado sesión.', 'toast.keyCopied': '¡Clave privada copiada al portapapeles!', 'toast.unmuted': 'Usuario desilenciado', 'toast.unmuteFailed': 'Error al desilenciar usuario', 'toast.selectImage': 'Por favor selecciona un archivo de imagen', 'toast.imageTooLarge': 'La imagen debe ser menor a 5MB', 'toast.avatarFailed': 'Error al subir avatar. Por favor intenta de nuevo.', 'toast.mustBeLoggedIn': 'Debes iniciar sesión para editar tu perfil', 'toast.enterDisplayName': 'Por favor ingresa un nombre para mostrar', 'toast.profileFailed': 'Error al guardar perfil. Por favor intenta de nuevo.', 'toast.invalidBunker': 'Por favor ingresa una URL bunker válida', 'toast.connectFailed': 'Error al conectar', 'toast.showingFiltered': 'Mostrando contenido filtrado', 'toast.reportSubmitted': 'Reporte enviado exitosamente', 'toast.draftSaved': '¡Borrador guardado! Puedes continuar después desde Mis Videos.', 'toast.draftLoaded': 'Borrador cargado. Completa tu subida y publica.', 'toast.draftDeleted': 'Borrador eliminado', 'toast.languageChanged': 'Idioma cambiado', 'toast.videoBlocked': 'Video bloqueado y publicado en Nostr', 'toast.waitForUpload': 'Por favor espera a que se complete la subida del video', 'toast.enterTitle': 'Por favor ingresa un título', 'toast.publishing': 'Publicando video en Nostr...',
        // Time
        'time.justNow': 'ahora mismo', 'time.secondAgo': 'hace 1 segundo', 'time.secondsAgo': 'hace {n} segundos', 'time.minuteAgo': 'hace 1 minuto', 'time.minutesAgo': 'hace {n} minutos', 'time.hourAgo': 'hace 1 hora', 'time.hoursAgo': 'hace {n} horas', 'time.dayAgo': 'hace 1 día', 'time.daysAgo': 'hace {n} días', 'time.weekAgo': 'hace 1 semana', 'time.weeksAgo': 'hace {n} semanas', 'time.monthAgo': 'hace 1 mes', 'time.monthsAgo': 'hace {n} meses', 'time.yearAgo': 'hace 1 año', 'time.yearsAgo': 'hace {n} años',
        // Empty States
        'empty.noVideos': 'No se encontraron videos.', 'empty.noLikedVideos': 'Aún no has dado me gusta a ningún video.', 'empty.noHistory': 'Sin historial de reproducción.', 'empty.noFollowing': 'No estás siguiendo a nadie todavía.', 'empty.noNotifications': 'No hay notificaciones.',
        // Misc
        'misc.loading': 'Cargando...', 'misc.close': 'Cerrar', 'misc.back': 'Volver', 'misc.search': 'Buscar', 'misc.searchResults': 'Resultados de Búsqueda', 'misc.videos': 'Videos', 'misc.users': 'Usuarios', 'misc.trending': 'Tendencias', 'misc.remove': 'Eliminar',
        // Common
        'common.cancel': 'Cancelar', 'common.uploading': 'Subiendo...', 'common.saveChanges': 'Guardar Cambios', 'common.close': 'Cerrar',
        // Aria Labels
        'aria.toggleMenu': 'Alternar menú', 'aria.mainNavigation': 'Navegación principal', 'aria.videoContent': 'Contenido de video', 'aria.loadingContent': 'Cargando contenido',
        // Dynamic JavaScript text
        'button.hideQR': 'Ocultar Código QR', 'button.showQR': 'Mostrar Código QR', 'button.copied': '¡Copiado!', 'button.showLess': 'Ver Menos', 'button.showMore': 'Ver Más', 'button.creatingAccount': 'Creando cuenta...', 'button.submitting': 'Enviando...', 'button.scheduleStream': 'Programar Transmisión', 'button.goLive': 'Transmitir', 'button.creatingStream': 'Creando transmisión...', 'button.continueCustomAmount': 'Continuar con Cantidad Personalizada', 'button.recordFromCamera': 'Grabar desde Cámara', 'button.requestingCamera': 'Solicitando cámara...', 'button.recording': 'Grabando...',
        'status.saving': 'Guardando...', 'status.saved': '¡Guardado!', 'status.uploading': 'Subiendo...', 'status.uploadComplete': '¡Subida completa!', 'status.uploadingToNostrBuild': 'Subiendo a nostr.build...', 'status.publishingChanges': 'Publicando cambios...', 'status.removingOldVersion': 'Eliminando versión anterior...', 'status.validatingThumbnail': 'Validando miniatura...', 'status.uploadingThumbnail': 'Subiendo miniatura...', 'status.thumbnailUploaded': '¡Miniatura subida!', 'status.processingVideo': 'Procesando video...', 'status.compressingVideo': 'Comprimiendo video...', 'status.uploadingVideo': 'Subiendo video...', 'status.videoUploaded': '¡Video subido exitosamente!', 'status.processing': 'Procesando...', 'status.generatingThumbnail': 'Generando miniatura...', 'status.generatingPreview': 'Generando vista previa...', 'status.uploadingPreview': 'Subiendo vista previa...', 'status.publishing': 'Publicando...', 'status.publishingToNostr': 'Publicando en Nostr...', 'status.publishingVideoToNostr': 'Publicando video en Nostr...', 'status.generatingPoW': 'Generando prueba de trabajo...', 'status.posting': 'Publicando...', 'status.processingVideoAndThumbnail': 'Procesando video y miniatura...', 'status.uploadFailed': 'Subida fallida - intenta de nuevo', 'status.selectVideoToUpload': 'Selecciona un video para subir', 'status.waitingForVideoUpload': 'Esperando subida de video...', 'status.selectVideoAndThumbnail': 'Selecciona video y miniatura para publicar', 'status.ready': 'Listo ✓', 'status.failed': 'Fallido ✗', 'status.fromDraft': 'Desde borrador', 'status.startingNow': '¡Comenzando ahora!', 'status.ended': 'TERMINADO', 'status.thumbnailReady': 'Listo', 'status.thumbnailFailed': 'Fallido', 'status.uploadFailedRetry': 'Subida fallida. Intenta de nuevo.',
        'publish.video': 'Publicar Video', 'publish.autoThumbnail': 'Publicar Video (miniatura automática)',
        'report.titleComment': 'Reportar Comentario', 'report.titleUser': 'Reportar Usuario', 'report.titleVideo': 'Reportar Video', 'report.descComment': 'Selecciona una razón para reportar este comentario:', 'report.descUser': 'Selecciona una razón para reportar este usuario:', 'report.descVideo': 'Selecciona una razón para reportar este contenido:',
        'empty.noMutedUsers': 'Sin usuarios silenciados.', 'empty.noVideosToMonitor': 'No se encontraron videos para monitorear.', 'empty.noRecentActivity': 'Sin actividad reciente.', 'empty.failedLoadNotifications': 'Error al cargar notificaciones', 'empty.loginToViewLiked': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">inicia sesión</a> para ver tus videos favoritos.', 'empty.loginToViewFollowing': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">inicia sesión</a> para ver a quién sigues.', 'empty.loginToViewVideos': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">inicia sesión</a> para ver tus videos.', 'empty.loginToViewAnalytics': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">inicia sesión</a> para ver tus estadísticas.', 'empty.noLikedVideosYet': 'Aún no has dado me gusta a ningún video.', 'empty.noLikedVideosFound': 'No se encontraron videos favoritos.', 'empty.noFullLengthLikedVideos': 'No se encontraron videos largos favoritos.', 'empty.noWatchHistory': 'Sin historial de reproducción. Comienza a ver videos para crear tu historial.', 'empty.noVideosInHistory': 'No se encontraron videos en el historial.', 'empty.noFullLengthHistory': 'No se encontraron videos largos en el historial.', 'empty.noMatchingVideos': 'No se encontraron videos coincidentes.', 'empty.noFullLengthVideos': 'No se encontraron videos largos.', 'empty.failedLoadTrending': 'Error al cargar videos en tendencia.', 'empty.noTrendingVideos': 'No se encontraron videos en tendencia.', 'empty.noMatchingUsers': 'No se encontraron usuarios coincidentes.', 'empty.unableLoadProfiles': 'No se pudieron cargar los perfiles.', 'empty.noFollowingVideos': 'Aún no hay videos de usuarios que sigues.', 'empty.noFullLengthFollowing': 'No hay videos largos de usuarios que sigues.', 'empty.failedLoadFollowing': 'Error al cargar seguidos. Intenta de nuevo.', 'empty.noVideosUploadFirst': 'No se encontraron videos. ¡Sube tu primer video!', 'empty.noFullLengthUploaded': 'No se encontraron videos largos.', 'empty.noMatchingLiveStreams': 'No se encontraron transmisiones coincidentes.', 'empty.noMatchingShorts': 'No se encontraron shorts coincidentes.', 'empty.noVideosForTag': 'No se encontraron videos para esta etiqueta.', 'empty.noFullLengthForTag': 'No se encontraron videos largos para esta etiqueta.', 'empty.noUploadedVideos': 'Aún no hay videos subidos.', 'empty.noVideosFound': 'No se encontraron videos.', 'empty.failedLoadProfile': 'Error al cargar perfil. Intenta de nuevo.', 'empty.noComments': '¡Sin comentarios aún. Sé el primero en comentar!', 'empty.failedLoadComments': 'Error al cargar comentarios', 'empty.noLiveNow': '¡Nadie está en vivo ahora. Sé el primero!',
        'error.videoNotFound': 'Video no encontrado.', 'error.contentNotAvailable': 'Este contenido no está disponible.', 'error.invalidVideoData': 'Datos de video inválidos.', 'error.videoNotAvailable': 'Video no disponible. El archivo puede haber sido eliminado.', 'error.failedLoadVideo': 'Error al cargar video. Intenta de nuevo.', 'error.failedLoadVideoShort': 'Error al cargar video. El archivo puede haber sido eliminado.', 'error.liveStreamNotFound': 'Transmisión en vivo no encontrada.', 'error.invalidLiveStreamData': 'Datos de transmisión inválidos.', 'error.failedLoadLiveStream': 'Error al cargar transmisión en vivo.',
        // New Button & Action Labels
        'button.follow': 'Seguir', 'button.unfollow': 'Dejar de seguir', 'button.mute': 'Silenciar', 'button.unmute': 'Quitar silencio', 'button.muteUser': 'Silenciar usuario', 'button.unmuteUser': 'Quitar silencio al usuario', 'button.confirm': 'Confirmar', 'button.cancel': 'Cancelar', 'button.close': 'Cerrar', 'button.boost': 'Impulsar', 'button.zap': 'Zap', 'button.viewMore': 'Ver más', 'button.viewAnalytics': 'Ver estadísticas', 'button.backToMyVideos': 'Volver a Mis Videos', 'button.editDraft': 'Editar borrador', 'button.deleteDraft': 'Eliminar borrador', 'button.editVideo': 'Editar video', 'button.deleteVideo': 'Eliminar video', 'button.editShort': 'Editar short', 'button.deleteShort': 'Eliminar short', 'button.editStream': 'Editar transmisión', 'button.endStream': 'Finalizar transmisión', 'button.reset': 'Restablecer', 'button.download': 'Descargar', 'button.watchRecording': 'Ver grabación', 'button.show': 'Mostrar', 'button.login': 'Iniciar sesión', 'button.toggleChat': 'Alternar chat', 'button.blockVideo': 'Bloquear video', 'button.blockUser': 'Bloquear usuario', 'button.unblock': 'Desbloquear', 'button.removeFromHistory': 'Eliminar del historial',
        // New Stats & Counts
        'stat.views': 'vistas', 'stat.viewsCount': '{count} vistas', 'stat.videos': 'videos', 'stat.video': 'video', 'stat.followers': 'seguidores', 'stat.follower': 'seguidor', 'stat.following': 'Siguiendo', 'stat.subscribers': 'suscriptores', 'stat.comments': 'Comentarios', 'stat.liveCount': '{count} en vivo', 'stat.percentOfGoal': '{percent}% del objetivo', 'stat.netGrowth': 'Crecimiento neto', 'stat.newFollowers': 'Nuevos seguidores', 'stat.unfollowed': 'Dejaron de seguir', 'stat.lastUpdated': 'Última actualización: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'EN VIVO', 'badge.ended': 'TERMINADO', 'badge.scheduled': 'PROGRAMADO', 'badge.warning': 'ADVERTENCIA', 'badge.communityWarning': 'ADVERTENCIA DE LA COMUNIDAD', 'badge.verifiedNip05': 'NIP-05 verificado', 'badge.streamer': 'Streamer', 'badge.clickToView': 'Clic para ver',
        // New Actions
        'action.report': 'Reportar', 'action.reportComment': 'Reportar comentario', 'action.reportVideo': 'Reportar este video', 'action.reportStream': 'Reportar esta transmisión', 'action.like': 'Me gusta', 'action.dislike': 'No me gusta', 'action.reply': 'Responder',
        // New Placeholders
        'placeholder.searchHistory': 'Buscar historial...', 'placeholder.searchUsers': 'Buscar usuarios...', 'placeholder.searchMyVideos': 'Buscar mis videos...', 'placeholder.eventId': 'Ingresa ID del evento (hex o nevent/note)', 'placeholder.pubkey': 'Ingresa pubkey (hex o npub)', 'placeholder.customAmount': 'Cantidad personalizada', 'placeholder.chatEnded': 'Chat cerrado - la transmisión ha terminado', 'placeholder.addComment': 'Agrega un comentario...', 'placeholder.setNewGoal': 'Establecer nuevo objetivo (sats)',
        // New Video & Content
        'video.untitledVideo': 'Video sin título', 'video.untitledShort': 'Short sin título', 'video.upNext': 'A continuación', 'video.noVideosYet': 'Aún no hay videos', 'video.noShortsYet': 'Aún no hay shorts', 'video.noLiveStreamsYet': 'Aún no hay transmisiones en vivo', 'video.noBlockedVideos': 'No hay videos bloqueados', 'video.noBlockedUsers': 'No hay usuarios bloqueados',
        // New Stream Messages
        'stream.ended': 'Esta transmisión ha terminado. El chat está cerrado.', 'stream.welcomeChat': '¡Bienvenido al chat en vivo!', 'stream.goalReached': '¡Objetivo alcanzado!', 'stream.zapGoalReached': '¡Objetivo de zap alcanzado! ¡{amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Mensaje de usuario silenciado', 'muted.commentFromMutedUserHidden': 'Comentario de usuario silenciado oculto', 'muted.commentHidden': 'Comentario oculto ({packs})', 'muted.messageHidden': 'Mensaje oculto ({packs})', 'muted.commentReportedByFollows': 'Comentario reportado por personas que sigues', 'muted.messageReportedByFollows': 'Mensaje reportado por personas que sigues', 'muted.commentHeavilyDownvoted': 'Comentario muy negativo por la comunidad', 'muted.messageHeavilyDownvoted': 'Mensaje muy negativo',
        // New Admin & Lists
        'list.blockedVideos': 'Videos bloqueados', 'list.blockedUsers': 'Usuarios bloqueados',
        // New Errors & Alerts
        'alert.cameraNotSupported': 'El acceso a la cámara no es compatible con este navegador. Por favor usa un navegador moderno como Chrome, Firefox o Safari.', 'alert.noCameraFound': 'No se encontró cámara en este dispositivo. Por favor conecta una cámara o usa la opción de subir archivo.', 'alert.cameraAccessDenied': 'Acceso a la cámara denegado. Por favor permite los permisos de cámara en tu navegador e intenta de nuevo.', 'alert.cameraInUse': 'La cámara está siendo usada por otra aplicación. Por favor cierra otras apps que usen la cámara e intenta de nuevo.', 'alert.cameraUnableAccess': 'No se puede acceder a la cámara con la configuración actual. Por favor intenta usar la opción de subir archivo.', 'alert.cameraUnableAccessWithError': 'No se puede acceder a la cámara: {error}\n\nPor favor usa la opción de subir archivo.', 'alert.fillRequiredFields': 'Por favor completa todos los campos requeridos', 'alert.uploadThumbnail': 'Por favor sube una imagen de miniatura para tu transmisión', 'alert.failedCreateStream': 'Error al crear la transmisión en vivo. Por favor intenta de nuevo.', 'alert.failedUpdateStream': 'Error al actualizar la transmisión. Por favor intenta de nuevo.', 'alert.streamNotFound': 'No se encontró la transmisión para editar', 'alert.canOnlyEditOwnStreams': 'Solo puedes editar tus propias transmisiones', 'alert.invalidStreamData': 'Datos de transmisión inválidos', 'alert.enterValidGoalAmount': 'Por favor ingresa una cantidad de objetivo válida', 'alert.canOnlyResetOwnGoals': 'Solo puedes restablecer objetivos en tus propias transmisiones', 'alert.streamEventNotFound': 'No se encontró el evento de transmisión', 'alert.failedResetZapGoal': 'Error al restablecer el objetivo de zap. Por favor intenta de nuevo.', 'alert.cannotBlockAdmin': 'No se puede bloquear la cuenta de administrador', 'alert.analyticsLoadFailed': 'Error al cargar estadísticas. Por favor intenta de nuevo.', 'alert.cannotReplaceShortWithVideo': 'No se puede reemplazar un Short con un video regular. Por favor sube un video vertical (60 segundos o menos).', 'alert.cannotReplaceVideoWithShort': 'No se puede reemplazar un video regular con un Short. Por favor sube un video horizontal/paisaje.', 'alert.shortsRequireVertical': 'Este video parece ser horizontal (paisaje). Los Shorts deben ser videos verticales (retrato). Por favor usa "Subir Video" para videos horizontales.',
        // New Zap Messages
        'zap.cannotZapYourself': 'No puedes enviarte zap a ti mismo', 'zap.cannotZapOwnContent': 'No puedes enviar zap a tu propio contenido', 'zap.cannotZapOwnComment': 'No puedes enviar zap a tu propio comentario', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'Cargando video...', 'status.loading': 'Cargando...', 'status.compressingProgress': 'Comprimiendo... {progress}%', 'status.uploadingProgress': 'Subiendo... {progress}%', 'status.uploadingServers': 'Subiendo... ({completed}/{total} servidores)', 'status.publishedSuccess': '¡{type} publicado exitosamente!',
        // New Warnings
        'warning.webmFormat': 'Nota: Tu navegador producirá formato WebM (puede no reproducirse en iOS). Para MP4 compatible con iOS, usa Chrome en Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Última actualización: Diciembre 2024',
        // DMCA Page
        'dmca.title': 'DMCA y Política de Contenido',
        'dmca.lastUpdated': 'Última actualización: Diciembre 2024',
        'dmca.architectureTitle': 'Entendiendo la Arquitectura de Plebs',
        'dmca.architectureDesc': 'Plebs es una interfaz de plataforma de video descentralizada que opera diferente a los servicios tradicionales de alojamiento de video. Es importante entender cómo se distribuye el contenido en nuestra plataforma:',
        'dmca.architectureItem1': 'Plebs no aloja ningún contenido de video o imagen.',
        'dmca.architectureItem1Desc': 'Somos un cliente/interfaz que muestra contenido almacenado en otro lugar.',
        'dmca.architectureItem2': 'Todos los archivos multimedia (videos, imágenes, miniaturas) se almacenan en servidores Blossom independientes operados por terceros.',
        'dmca.architectureItem3': 'Los metadatos de video (títulos, descripciones, etc.) se publican en relays Nostr, que también son operados independientemente.',
        'dmca.architectureItem4': 'Plebs simplemente agrega y muestra este contenido distribuido a través de una interfaz fácil de usar.',
        'dmca.filingTitle': 'Presentar una Reclamación DMCA',
        'dmca.filingDesc': 'Debido a que Plebs no aloja contenido, no podemos eliminar directamente material infractor. Para abordar la infracción de derechos de autor, debe contactar a las partes apropiadas:',
        'dmca.forVideoTitle': '1. Para Contenido de Video/Imagen',
        'dmca.forVideoDesc': 'Los archivos multimedia se almacenan en servidores Blossom. Necesita:',
        'dmca.forVideoItem1': 'Identificar qué servidor Blossom está alojando el contenido (la URL lo indicará)',
        'dmca.forVideoItem2': 'Contactar directamente al operador del servidor Blossom con su solicitud de eliminación DMCA',
        'dmca.forVideoItem3': 'Cada servidor Blossom opera independientemente y tiene sus propias políticas',
        'dmca.forMetadataTitle': '2. Para Metadatos/Descripciones',
        'dmca.forMetadataDesc': 'Si el contenido infractor está en el título del video, descripción u otros metadatos:',
        'dmca.forMetadataItem1': 'Esta información se almacena en relays Nostr',
        'dmca.forMetadataItem2': 'Contacte a los operadores específicos del relay Nostr donde aparece el contenido',
        'dmca.forMetadataItem3': 'Múltiples relays pueden almacenar los mismos datos debido a la naturaleza distribuida de Nostr',
        'dmca.whatWeCanDoTitle': 'Lo que Plebs Puede Hacer',
        'dmca.whatWeCanDoDesc': 'Aunque no alojamos contenido, podemos:',
        'dmca.whatWeCanDoItem1': 'Ayudarle a identificar qué servidores Blossom o relays están alojando contenido específico',
        'dmca.whatWeCanDoItem2': 'Agregar contenido a una lista de bloqueo local para que no aparezca en nuestra interfaz (nota: esto solo afecta a plebs.app, no a otros clientes Nostr)',
        'dmca.whatWeCanDoItem3': 'Proporcionar orientación sobre cómo contactar a los operadores de servicio apropiados',
        'dmca.toRequestAssistance': 'Para solicitar asistencia, por favor contáctenos con:',
        'dmca.assistanceItem1': 'La URL o identificador del contenido infractor',
        'dmca.assistanceItem2': 'Prueba de su propiedad de derechos de autor',
        'dmca.assistanceItem3': 'Una descripción del trabajo protegido',
        'dmca.blossomOperatorsTitle': 'Operadores de Servidores Blossom',
        'dmca.blossomOperatorsDesc': 'Si opera un servidor Blossom y recibe una solicitud de eliminación DMCA, usted es responsable de manejarla según las leyes de su jurisdicción.',
        'dmca.blossomOperatorsLink': 'Para una lista de servidores Blossom conocidos, consulte la documentación del proyecto Blossom.',
        'dmca.considerationsTitle': 'Consideraciones Importantes',
        'dmca.considerationsItem1': 'Descentralización:',
        'dmca.considerationsItem1Desc': 'Debido a la naturaleza descentralizada de Nostr y Blossom, la eliminación completa del contenido de todas las fuentes puede no ser posible.',
        'dmca.considerationsItem2': 'Múltiples Copias:',
        'dmca.considerationsItem2Desc': 'El contenido puede estar replicado en múltiples servidores Blossom, requiriendo solicitudes de eliminación separadas para cada uno.',
        'dmca.considerationsItem3': 'Persistencia de Metadatos:',
        'dmca.considerationsItem3Desc': 'Incluso si los archivos multimedia se eliminan, los metadatos en los relays Nostr pueden persistir.',
        'dmca.considerationsItem4': 'Sin Control Central:',
        'dmca.considerationsItem4Desc': 'No hay una sola entidad que pueda eliminar contenido de toda la red.',
        'dmca.counterNotificationTitle': 'Contra-Notificación',
        'dmca.counterNotificationDesc': 'Si cree que su contenido fue eliminado erróneamente de un servidor Blossom, debe contactar directamente al operador de ese servidor para presentar una contra-notificación.',
        'dmca.contactTitle': 'Contacto',
        'dmca.contactDesc': 'Para preguntas sobre esta política o asistencia identificando hosts de contenido, por favor',
        'dmca.contactLink': 'contáctenos',
        // Admin Dashboard
        'admin.title': 'Panel de Administración',
        'admin.loading': 'Cargando análisis de plataforma...',
        'admin.platformOverview': 'Resumen de la Plataforma',
        'admin.totalVideos': 'Total de Videos',
        'admin.videos7Days': 'Videos (7 días)',
        'admin.videos30Days': 'Videos (30 días)',
        'admin.uniqueCreators': 'Creadores Únicos',
        'admin.likes30Days': 'Me gusta (30 días)',
        'admin.dislikes30Days': 'No me gusta (30 días)',
        'admin.monthlyActiveUsers': 'Usuarios Activos Mensuales',
        'admin.mauDesc': 'Usuarios únicos que subieron videos, reaccionaron o comentaron cada mes (últimos 6 meses)',
        'admin.boostRevenue': 'Ingresos de Boost (Últimos 30 Días)',
        'admin.totalBoostRevenue': 'Ingresos Totales de Boost',
        'admin.totalBoosts': 'Total de Boosts',
        'admin.blocklistManagement': 'Gestión de Lista de Bloqueo',
        'admin.blocklistDesc': 'Bloquee videos o usuarios específicos para que no aparezcan en la plataforma.',
        'admin.blockedVideos': 'Videos Bloqueados',
        'admin.blockedUsers': 'Usuarios Bloqueados',
        'admin.blockByEventId': 'Bloquear Video por ID de Evento',
        'admin.blockByPubkey': 'Bloquear Usuario por Pubkey',
        'admin.blockVideo': 'Bloquear Video',
        'admin.blockUser': 'Bloquear Usuario',
        'admin.noBlockedVideos': 'Sin videos bloqueados',
        'admin.noBlockedUsers': 'Sin usuarios bloqueados',
        'admin.unblock': 'Desbloquear',
        'admin.accessDenied': 'Acceso denegado. Solo administrador.',
        // Search/Trending/Channel/Buttons/Common
        'search.noVideosFound': 'No se encontraron videos que coincidan con "{query}".',
        'search.noFullLengthVideos': 'No se encontraron videos de larga duración que coincidan con "{query}".',
        'trending.noVideosToday': 'No hay videos en tendencia hoy.',
        'trending.noVideosThisWeek': 'No hay videos en tendencia esta semana.',
        'channel.video': 'video',
        'channel.videos': 'videos',
        'channel.follower': 'seguidor',
        'channel.followers': 'seguidores',
        'button.follow': 'Seguir',
        'button.following': 'Siguiendo',
        'button.unfollow': 'Dejar de seguir',
        'button.mute': 'Silenciar',
        'button.unmute': 'Desilenciar',
        'button.report': 'Reportar',
        'button.muteUser': 'Silenciar usuario',
        'button.unmuteUser': 'Desilenciar usuario',
        'button.reportComment': 'Reportar comentario',
        'button.reportUser': 'Reportar este usuario',
        'live.goalReached': '¡Meta Alcanzada!',
        'live.goalProgress': '{percent}% de la meta',
        'common.loading': 'Cargando...',
        'common.sats': 'sats',
        // Analytics Page
        'analytics.title': 'Análisis del Canal',
        'analytics.loading': 'Cargando tus análisis...',
        'analytics.loadFailed': 'Error al cargar análisis. Por favor intenta de nuevo.',
        'analytics.overview': 'Resumen',
        'analytics.views': 'Vistas',
        'analytics.followers': 'Seguidores',
        'analytics.topByViews': 'Videos Más Vistos',
        'analytics.topByEngagement': 'Videos con Mayor Interacción',
        'analytics.allContent': 'Rendimiento de Todo el Contenido',
        'analytics.totalViews': 'Vistas Totales',
        'analytics.likes': 'Me Gusta',
        'analytics.likesRatio': 'Me Gusta ({ratio}% proporción)',
        'analytics.dislikes': 'No Me Gusta',
        'analytics.zapsReceived': '{count} Zaps Recibidos',
        'analytics.boostsReceived': 'Boosts Recibidos',
        'analytics.shares': 'Compartidos',
        'analytics.comments': 'Comentarios',
        'analytics.contentCount': '{videos} Videos, {shorts} Shorts, {streams} Streams',
        'analytics.last7days': 'Últimos 7 días',
        'analytics.last30days': 'Últimos 30 días',
        'analytics.last90days': 'Últimos 90 días',
        'analytics.lastYear': 'Último año',
        'analytics.allTime': 'Todo el tiempo',
        'analytics.lastNDays': 'Últimos {n} días',
        'analytics.netGrowth': 'Crecimiento Neto',
        'analytics.newFollowers': 'Nuevos Seguidores',
        'analytics.unfollowed': 'Dejaron de Seguir',
        'analytics.noVideosYet': 'Sin videos aún',
        'analytics.noShortsYet': 'Sin shorts aún',
        'analytics.noStreamsYet': 'Sin transmisiones aún',
        'analytics.viewsTooltip': '{count} vistas',
        'analytics.subscribersTooltip': '{count} suscriptores',
        'analytics.videosTab': 'Videos ({count})',
        'analytics.shortsTab': 'Shorts ({count})',
        'analytics.streamsTab': 'Transmisiones ({count})',
        // About Page
        'about.title': 'Acerca de Plebs',
        'about.whatIs': '¿Qué es Plebs?',
        'about.whatIsDesc': 'Plebs es una plataforma de videos descentralizada y resistente a la censura construida sobre el <a href="https://nostr.com" target="_blank" rel="noopener">protocolo Nostr</a>. A diferencia de las plataformas tradicionales controladas por corporaciones, Plebs te da verdadera propiedad de tu contenido e identidad.',
        'about.whyNostr': '¿Por qué Nostr?',
        'about.whyNostrDesc': 'Nostr (Notes and Other Stuff Transmitted by Relays) es un protocolo simple y abierto que permite una red social verdaderamente descentralizada. Los beneficios clave incluyen:',
        'about.benefit1': 'Resistencia a la Censura:',
        'about.benefit1Desc': 'Ninguna entidad puede banearte o eliminar tu contenido',
        'about.benefit2': 'Portabilidad:',
        'about.benefit2Desc': 'Tu identidad y seguidores funcionan en todas las apps Nostr',
        'about.benefit3': 'Sin Autoridad Central:',
        'about.benefit3Desc': 'Ninguna empresa posee o controla la red',
        'about.benefit4': 'Identidad Criptográfica:',
        'about.benefit4Desc': 'Tus claves prueban que eres quien dices ser',
        'about.howItWorks': 'Cómo Funciona',
        'about.howItWorksDesc': 'Los videos en Plebs se almacenan usando <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom</a>, un sistema de almacenamiento distribuido, mientras que los metadatos e interacciones sociales se transmiten a relays Nostr. Esto significa que tu contenido no se almacena en nuestros servidores - está distribuido en la red.',
        'about.features': 'Características',
        'about.feature1': 'Sube y comparte videos con la comunidad Nostr',
        'about.feature2': 'Da me gusta, comenta y comparte videos usando reacciones Nostr',
        'about.feature3': 'Envía Zaps a creadores con Bitcoin vía Lightning Network',
        'about.feature4': 'Sigue a tus creadores favoritos en cualquier app Nostr',
        'about.feature5': 'Explora temas y descubre nuevo contenido',
        'about.feature6': 'Funciona con cualquier identidad Nostr (usa claves existentes)',
        'about.openSource': 'Código Abierto',
        'about.openSourceDesc': 'Plebs es software de código abierto. Puedes ver el código, contribuir o ejecutar tu propia instancia:',
        'about.githubRepo': 'Repositorio GitHub',
        'about.builtBy': 'Desarrollado Por',
        'about.builtByDesc': 'Plebs es desarrollado por <a href="https://nostrservices.com" target="_blank" rel="noopener" class="accent-link">21 Million LLC</a>, una empresa dedicada a construir herramientas para el ecosistema Bitcoin y Nostr.',
        // Contact Page
        'contact.title': 'Contáctanos',
        'contact.getInTouch': 'Ponte en Contacto',
        'contact.getInTouchDesc': '¿Tienes preguntas, comentarios o necesitas soporte? ¡Nos encantaría saber de ti!',
        'contact.email': 'Correo Electrónico',
        'contact.emailDesc': 'La mejor forma de contactarnos es por correo:',
        'contact.github': 'GitHub',
        'contact.githubDesc': 'Para reportar errores, solicitar funciones o problemas técnicos, abre un issue en nuestro repositorio:',
        'contact.githubIssues': 'Issues de GitHub',
        'contact.company': 'Empresa',
        'contact.companyDesc': 'Plebs es desarrollado por 21 Million LLC',
        // Terms of Service
        'terms.title': 'Términos de Servicio',
        'terms.lastUpdated': 'Última actualización: Diciembre 2024',
        'terms.section1Title': '1. Aceptación de Términos',
        'terms.section1Desc': 'Al acceder y usar Plebs ("el Servicio"), aceptas estar sujeto a estos Términos de Servicio. Si no estás de acuerdo con estos términos, por favor no uses el Servicio.',
        'terms.section2Title': '2. Descripción del Servicio',
        'terms.section2Desc': 'Plebs es una plataforma de videos descentralizada construida sobre el protocolo Nostr. El Servicio proporciona una interfaz para navegar, subir e interactuar con contenido de video almacenado en redes distribuidas. Plebs no aloja ni almacena contenido de video en servidores centralizados.',
        'terms.section3Title': '3. Responsabilidades del Usuario',
        'terms.section3Desc': 'Eres responsable de:',
        'terms.section3Item1': 'Mantener la seguridad de tus claves privadas Nostr',
        'terms.section3Item2': 'Todo el contenido que subas o compartas a través del Servicio',
        'terms.section3Item3': 'Asegurar que tu uso cumpla con las leyes aplicables',
        'terms.section3Item4': 'No subir contenido ilegal, infractor o dañino',
        'terms.section4Title': '4. Directrices de Contenido',
        'terms.section4Desc': 'Aceptas no subir, compartir o distribuir:',
        'terms.section4Item1': 'Contenido que infrinja derechos de propiedad intelectual',
        'terms.section4Item2': 'Contenido ilegal incluyendo pero no limitado a material de explotación infantil',
        'terms.section4Item3': 'Contenido que promueva violencia o daño a otros',
        'terms.section4Item4': 'Spam, malware o contenido engañoso',
        'terms.section4Note': 'El contenido adulto (NSFW) debe ser etiquetado apropiadamente usando la etiqueta NSFW al subir.',
        'terms.section5Title': '5. Naturaleza Descentralizada',
        'terms.section5Desc': 'Debido a la naturaleza descentralizada de Nostr y almacenamiento Blossom:',
        'terms.section5Item1': 'El contenido puede persistir en la red incluso después de solicitudes de eliminación',
        'terms.section5Item2': 'No podemos garantizar la eliminación de contenido de todos los relays o servidores',
        'terms.section5Item3': 'Tu contenido e interacciones son públicos por defecto',
        'terms.section5Item4': 'Eres el único responsable de la seguridad de tu clave privada',
        'terms.section6Title': '6. Sin Garantía',
        'terms.section6Desc': 'El Servicio se proporciona "tal cual" sin garantías de ningún tipo. No garantizamos acceso continuo e ininterrumpido al Servicio.',
        'terms.section7Title': '7. Limitación de Responsabilidad',
        'terms.section7Desc': 'En la máxima medida permitida por la ley, Plebs y sus operadores no serán responsables de ningún daño indirecto, incidental, especial o consecuente derivado de tu uso del Servicio.',
        'terms.section8Title': '8. Cambios a los Términos',
        'terms.section8Desc': 'Nos reservamos el derecho de modificar estos términos en cualquier momento. El uso continuado del Servicio después de los cambios constituye aceptación de los nuevos términos.',
        'terms.section9Title': '9. Contacto',
        'terms.section9Desc': 'Para preguntas sobre estos Términos, por favor <a href="#/contact" class="accent-link">contáctanos</a>.',
        // Privacy Policy
        'privacy.title': 'Política de Privacidad',
        'privacy.lastUpdated': 'Última actualización: Diciembre 2024',
        'privacy.section1Title': '1. Resumen',
        'privacy.section1Desc': 'Plebs está comprometido con proteger tu privacidad. Esta política explica cómo manejamos la información cuando usas nuestra plataforma de videos descentralizada.',
        'privacy.section2Title': '2. Arquitectura Descentralizada',
        'privacy.section2Desc': 'Plebs está construido sobre Nostr, un protocolo descentralizado. Esto significa:',
        'privacy.section2Item1': 'Tu contenido se transmite a relays públicos, no se almacena en nuestros servidores',
        'privacy.section2Item2': 'Tu clave pública Nostr sirve como tu identidad',
        'privacy.section2Item3': 'Los videos se almacenan en servidores Blossom distribuidos',
        'privacy.section2Item4': 'No tenemos acceso a tus claves privadas',
        'privacy.section3Title': '3. Información que Recopilamos',
        'privacy.section3LocalTitle': 'Información almacenada localmente en tu navegador:',
        'privacy.section3LocalItem1': 'Tu clave pública Nostr (cuando inicias sesión)',
        'privacy.section3LocalItem2': 'Historial de visualización y preferencias',
        'privacy.section3LocalItem3': 'Preferencias de tema y configuración',
        'privacy.section3LocalItem4': 'Clave privada (solo si eliges almacenamiento local - no recomendado)',
        'privacy.section3CollectTitle': 'Información que podemos recopilar:',
        'privacy.section3CollectItem1': 'Análisis básicos (vistas de página, uso de funciones) para mejorar el servicio',
        'privacy.section3CollectItem2': 'Registros de errores para depuración',
        'privacy.section4Title': '4. Información Pública',
        'privacy.section4Desc': 'Al usar Nostr, lo siguiente es público por diseño:',
        'privacy.section4Item1': 'Tu clave pública Nostr e información de perfil',
        'privacy.section4Item2': 'Videos que subes',
        'privacy.section4Item3': 'Comentarios, me gusta y otras reacciones',
        'privacy.section4Item4': 'A quién sigues',
        'privacy.section4Item5': 'Zaps (pagos Lightning) que envías o recibes',
        'privacy.section5Title': '5. Almacenamiento de Datos',
        'privacy.section5Desc': 'Los datos locales se almacenan en el localStorage de tu navegador. Puedes borrar estos datos en cualquier momento a través de la configuración de tu navegador. El contenido publicado en Nostr se distribuye a través de relays y no puede ser controlado o eliminado por Plebs.',
        'privacy.section6Title': '6. Servicios de Terceros',
        'privacy.section6Desc': 'Plebs interactúa con:',
        'privacy.section6Item1': 'Relays Nostr (para datos sociales)',
        'privacy.section6Item2': 'Servidores Blossom (para almacenamiento de video)',
        'privacy.section6Item3': 'Lightning Network (para zaps/pagos)',
        'privacy.section6Note': 'Cada uno de estos servicios tiene sus propias prácticas de privacidad.',
        'privacy.section7Title': '7. Tus Derechos',
        'privacy.section7Desc': 'Puedes:',
        'privacy.section7Item1': 'Borrar tus datos locales del navegador en cualquier momento',
        'privacy.section7Item2': 'Navegar videos sin crear una cuenta',
        'privacy.section7Item3': 'Usar una extensión de navegador Nostr para mayor privacidad',
        'privacy.section7Item4': 'Elegir qué relays y servidores Blossom usar',
        'privacy.section8Title': '8. Seguridad',
        'privacy.section8Desc': 'Recomendamos:',
        'privacy.section8Item1': 'Usar una extensión de navegador Nostr o firmante de hardware',
        'privacy.section8Item2': 'Nunca compartir tu clave privada (nsec)',
        'privacy.section8Item3': 'Usar un perfil de navegador dedicado para mayor privacidad',
        'privacy.section9Title': '9. Cambios a Esta Política',
        'privacy.section9Desc': 'Podemos actualizar esta política de vez en cuando. Los cambios se publicarán en esta página con una fecha de revisión actualizada.',
        'privacy.section10Title': '10. Contacto',
        'privacy.section10Desc': 'Para preguntas relacionadas con privacidad, por favor <a href="#/contact" class="accent-link">contáctanos</a>.',
        // FAQ Page
        'faq.title': 'Preguntas Frecuentes',
        'faq.aboutPlebs': 'Acerca de Plebs',
        'faq.nostrProtocol': 'Protocolo Nostr',
        'faq.videoStorage': 'Almacenamiento de Video y Blossom',
        'faq.featuresUsage': 'Características y Uso',
        'faq.q1': '¿Qué es Plebs?',
        'faq.a1': 'Plebs es una plataforma de videos descentralizada y resistente a la censura construida sobre el protocolo Nostr. A diferencia de las plataformas tradicionales controladas por corporaciones, Plebs te da verdadera propiedad de tu contenido e identidad. No hay servidores centrales que puedan banearte o eliminar tu contenido.',
        'faq.q2': '¿Es Plebs gratis?',
        'faq.a2': 'Sí, Plebs es completamente gratis para ver videos. Puedes navegar y ver contenido sin crear una cuenta. Para subir videos, comentar, dar me gusta o interactuar con otros usuarios, necesitarás una identidad Nostr (que también es gratis).',
        'faq.q3': '¿Quién desarrolla Plebs?',
        'faq.a3': 'Plebs es desarrollado por <a href="https://nostrservices.com" target="_blank" rel="noopener">21 Million LLC</a>, una empresa dedicada a construir herramientas para el ecosistema Bitcoin y Nostr. Plebs es de código abierto, y puedes ver el código o contribuir en <a href="https://github.com/Spl0itable/plebs-app" target="_blank" rel="noopener">GitHub</a>.',
        'faq.q4': '¿Qué es Nostr?',
        'faq.a4': 'Nostr significa "Notes and Other Stuff Transmitted by Relays." Es un protocolo simple y abierto que permite una red social verdaderamente descentralizada. A diferencia de las plataformas tradicionales, Nostr no depende de ningún servidor central. En su lugar, usa una red de relays para transmitir mensajes entre usuarios, y claves criptográficas para identidad.',
        'faq.q5': '¿Por qué Plebs usa Nostr?',
        'faq.a5Title': 'Nostr proporciona varios beneficios clave:',
        'faq.a5Item1': 'Resistencia a la Censura:',
        'faq.a5Item1Desc': 'Ninguna entidad puede banearte o eliminar tu contenido',
        'faq.a5Item2': 'Portabilidad:',
        'faq.a5Item2Desc': 'Tu identidad y seguidores funcionan en todas las apps Nostr',
        'faq.a5Item3': 'Sin Autoridad Central:',
        'faq.a5Item3Desc': 'Ninguna empresa posee o controla la red',
        'faq.a5Item4': 'Identidad Criptográfica:',
        'faq.a5Item4Desc': 'Tus claves prueban que eres quien dices ser',
        'faq.q6': '¿Qué son las claves Nostr (npub/nsec)?',
        'faq.a6': 'Tu identidad Nostr consiste en dos claves: una clave pública (npub) y una clave privada (nsec). Tu npub es como tu nombre de usuario - puedes compartirla con cualquiera. Tu nsec es como tu contraseña - ¡nunca la compartas! Cualquiera con tu nsec puede publicar como tú y acceder a tu cuenta. Recomendamos usar una extensión de navegador como Alby o nos2x para gestionar tus claves de forma segura.',
        'faq.q7': '¿Puedo usar mi cuenta Nostr existente?',
        'faq.a7': '¡Absolutamente! Si ya tienes una identidad Nostr de apps como Damus, Primal, Amethyst u otro cliente Nostr, puedes usar las mismas claves para iniciar sesión en Plebs. Tus seguidores, perfil y reputación se transfieren automáticamente.',
        'faq.q8': '¿Qué son los relays Nostr?',
        'faq.a8': 'Los relays son servidores que almacenan y transmiten mensajes Nostr. Cuando publicas algo, se envía a múltiples relays. Otros usuarios se conectan a relays para leer mensajes. Como hay muchos relays independientes, ninguno puede censurarte - si un relay te bloquea, tu contenido sigue existiendo en otros.',
        'faq.q9': '¿Dónde se almacenan los videos?',
        'faq.a9': 'Los videos se almacenan en servidores Blossom, no en Plebs. Blossom es un sistema de almacenamiento distribuido diseñado para funcionar con Nostr. Cuando subes un video, va a uno o más servidores Blossom de tu elección. Los metadatos del video (título, descripción, etc.) se publican en relays Nostr.',
        'faq.q10': '¿Qué es Blossom?',
        'faq.a10': 'Blossom es un protocolo abierto para almacenar y servir archivos multimedia de forma descentralizada. Los archivos se identifican por su hash SHA-256, lo que significa que el mismo archivo tendrá la misma dirección independientemente de qué servidor lo aloje. Esto permite redundancia - tus archivos pueden existir en múltiples servidores. Aprende más en <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom GitHub</a>.',
        'faq.q11': '¿Plebs aloja mis videos?',
        'faq.a11': 'No. Plebs es un cliente/interfaz que te ayuda a navegar y subir contenido, pero no almacena ningún archivo de video o imagen. Todos los medios se almacenan en servidores Blossom independientes. Plebs simplemente muestra contenido de estos proveedores de almacenamiento distribuido.',
        'faq.q12': '¿Puedo elegir qué servidor Blossom usar?',
        'faq.a12': '¡Sí! Puedes configurar qué servidores Blossom quieres usar para subir en tu configuración. Incluso puedes ejecutar tu propio servidor Blossom si quieres control completo sobre tu almacenamiento de medios.',
        'faq.q13': '¿Cómo creo una cuenta?',
        'faq.a13Title': 'Haz clic en el botón "Iniciar Sesión" y elige tu método preferido:',
        'faq.a13Item1': 'Extensión de Navegador:',
        'faq.a13Item1Desc': 'Si tienes una extensión Nostr como Alby o nos2x instalada, puedes usarla para iniciar sesión de forma segura',
        'faq.a13Item2': 'Generar Nuevas Claves:',
        'faq.a13Item2Desc': 'Crea una nueva identidad Nostr',
        'faq.a13Item3': 'Importar Claves:',
        'faq.a13Item3Desc': 'Usa tu clave privada Nostr existente (nsec)',
        'faq.a13Note': 'Recomendamos usar una extensión de navegador para la mejor seguridad.',
        'faq.q14': '¿Qué son los Zaps?',
        'faq.a14': 'Los Zaps son pagos de Bitcoin enviados a través de Lightning Network. Te permiten enviar dinero real (satoshis, o "sats") a creadores de contenido como propinas o apreciación. A diferencia de las propinas tradicionales de plataformas que cobran grandes comisiones, los zaps van directamente al creador. Para enviar zaps, necesitas una billetera Lightning con conexión Nostr (como Alby o Zeus).',
        'faq.q15': '¿Cómo subo un video?',
        'faq.a15Title': 'Para subir un video:',
        'faq.a15Item1': 'Inicia sesión con tu identidad Nostr',
        'faq.a15Item2': 'Haz clic en el botón "Crear" y selecciona "Subir Video"',
        'faq.a15Item3': 'Selecciona tu archivo de video (soporta la mayoría de formatos comunes)',
        'faq.a15Item4': 'Añade un título, descripción y etiquetas',
        'faq.a15Item5': 'Haz clic en "Publicar" para compartir con la red',
        'faq.a15Note': 'Los videos se comprimen automáticamente y se suben a servidores Blossom.',
        // FAQ Self-Moderation Section
        'faq.selfModeration': 'Auto-Moderación',
        'faq.q16': '¿Cómo funciona la moderación en una plataforma descentralizada?',
        'faq.a16': 'A diferencia de las plataformas tradicionales con moderadores centralizados, Plebs te da el control de lo que ves. Proporcionamos poderosas herramientas de auto-moderación que incluyen paquetes de filtros de contenido, silenciamiento de usuarios, advertencias de la comunidad e indicadores de videos con muchos votos negativos. Tú decides qué contenido es apropiado para ti - no hay una autoridad central tomando esas decisiones.',
        'faq.q17': '¿Qué son los Paquetes de Filtros de Contenido?',
        'faq.a17Intro': 'Los Paquetes de Filtros de Contenido son filtros de palabras clave predefinidos que puedes habilitar para ocultar tipos específicos de contenido. Los paquetes disponibles incluyen:',
        'faq.a17Pack1': 'Racismo y Discurso de Odio:',
        'faq.a17Pack1Desc': 'Filtra insultos raciales y contenido discriminatorio',
        'faq.a17Pack2': 'Sexualmente Explícito:',
        'faq.a17Pack2Desc': 'Filtra contenido pornográfico y para adultos',
        'faq.a17Pack3': 'Violencia y Gore:',
        'faq.a17Pack3Desc': 'Filtra violencia gráfica y contenido de autolesión',
        'faq.a17Pack4': 'Drogas y Sustancias:',
        'faq.a17Pack4Desc': 'Filtra contenido relacionado con drogas',
        'faq.a17Pack5': 'Spam y Estafas:',
        'faq.a17Pack5Desc': 'Filtra patrones comunes de spam y estafas',
        'faq.a17Pack6': 'Criptomonedas:',
        'faq.a17Pack6Desc': 'Filtra promoción de criptomonedas y tokens',
        'faq.a17Pack7': 'Contenido Político:',
        'faq.a17Pack7Desc': 'Filtra contenido político partidista',
        'faq.a17Pack8': 'Lenguaje Fuerte:',
        'faq.a17Pack8Desc': 'Filtra lenguaje vulgar',
        'faq.a17Note': 'Activa estos en Configuración > Filtros de Contenido. También puedes agregar palabras clave personalizadas. El contenido filtrado muestra un marcador de posición con un botón "Mostrar de todos modos" si quieres verlo temporalmente.',
        'faq.q18': '¿Cómo silencio a un usuario?',
        'faq.a18': 'Para silenciar a un usuario, visita su perfil y haz clic en el botón de silenciar. Una vez silenciado, todos sus videos se ocultarán de tu feed, sus comentarios se mostrarán como "Mensaje de usuario silenciado" y sus mensajes de chat en vivo se ocultarán. Tu lista de silenciados se almacena en Nostr, por lo que se sincroniza entre dispositivos. Puedes gestionar usuarios silenciados en la Configuración de tu Perfil bajo "Usuarios Silenciados".',
        'faq.q19': '¿Qué significa "Ratioed"?',
        'faq.a19': 'Un video se marca como "ratioed" cuando tiene significativamente más no me gusta que me gusta, indicando una recepción negativa de la comunidad. Específicamente, un video es ratioed cuando tiene al menos 10 reacciones, los no me gusta son al menos el doble de los me gusta, y los no me gusta representan el 70% o más de las reacciones totales. Los videos ratioed muestran una insignia de advertencia, y se te pedirá que confirmes antes de verlo.',
        'faq.q20': '¿Cómo funcionan las advertencias de la comunidad?',
        'faq.a20': 'Los usuarios pueden reportar contenido por varias razones (spam, contenido ilegal, abuso, engañoso, etc.). Cuando un video o usuario recibe 5 o más reportes de personas que sigues, aparece un indicador de advertencia. Esto aprovecha tu grafo social - las advertencias provienen de tu red de confianza, no de extraños anónimos. Puedes activar "Mostrar advertencias de cuentas que sigo" en Configuración.',
        'faq.q21': '¿Cómo reporto contenido?',
        'faq.a21': 'Haz clic en el ícono de bandera en cualquier video, comentario o perfil de usuario para reportarlo. Selecciona una razón (Spam, Ilegal, Abuso, Engañoso, Suplantación, Derechos de Autor u Otro) y opcionalmente agrega detalles. Los reportes se publican en Nostr como eventos, haciéndolos transparentes y descentralizados. Tus reportes ayudan a otros en tu red a identificar contenido problemático.',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': 'Privacidad y Seguridad',
        'faq.q22': '¿Es mi actividad privada?',
        'faq.a22': 'En Nostr, la mayoría de la actividad es pública por diseño. Tus me gusta, comentarios, seguidos y zaps son visibles en la red pública. Sin embargo, Plebs almacena tu historial de visualización localmente en tu navegador - nunca se envía a ningún servidor. Puedes borrar tus datos locales en cualquier momento.',
        'faq.q23': '¿Cómo mantengo mi cuenta segura?',
        'faq.a23': 'Nunca compartas tu clave privada (nsec) con nadie. Recomendamos encarecidamente usar una extensión de navegador Nostr como Alby, nos2x o un firmante de hardware. Estos mantienen tu clave privada segura y solo firman eventos cuando los apruebas. Evita almacenar tu nsec directamente en sitios web.',
        'faq.q24': '¿Puedo eliminar mi contenido?',
        'faq.a24': 'Puedes solicitar la eliminación publicando un evento de eliminación en Nostr. La mayoría de los relays y clientes bien comportados respetarán esto. Sin embargo, debido a la naturaleza descentralizada de la red, el contenido puede persistir en algunos relays o servidores Blossom. No hay una autoridad central que pueda forzar la eliminación completa en toda la red.',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': 'Solución de Problemas',
        'faq.q25': 'Los videos no se cargan - ¿qué debo hacer?',
        'faq.a25Intro': 'Si los videos no se cargan, prueba estos pasos:',
        'faq.a25Item1': 'Actualiza la página',
        'faq.a25Item2': 'Verifica tu conexión a internet',
        'faq.a25Item3': 'El servidor Blossom que aloja el video podría estar caído - esto es independiente de Plebs',
        'faq.a25Item4': 'Intenta deshabilitar extensiones del navegador que puedan bloquear contenido',
        'faq.a25Item5': 'Borra la caché de tu navegador e intenta de nuevo',
        'faq.q26': 'Perdí mi clave privada - ¿pueden ayudarme a recuperarla?',
        'faq.a26': 'Desafortunadamente, no. Las claves Nostr son criptográficas - no hay restablecimiento de contraseña ni recuperación de cuenta porque no hay una autoridad central. Por esto recomendamos encarecidamente hacer copias de seguridad de tus claves y usar una solución segura de gestión de claves. Si pierdes tu nsec, necesitarás crear una nueva identidad.',
        'faq.q27': '¿Cómo reporto un error o solicito una función?',
        'faq.a27': 'Puedes reportar errores o solicitar funciones en nuestra página de <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a>. También puedes contactarnos en Nostr - visita nuestra página de <a href="#/contact">Contacto</a> para más detalles.',
        // Page Titles
        'pageTitle.following': 'Siguiendo', 'pageTitle.myVideos': 'Mis Videos', 'pageTitle.likedVideos': 'Videos que Me Gustan', 'pageTitle.watchHistory': 'Historial de Reproducción', 'pageTitle.liveStreams': 'Transmisiones en Vivo', 'pageTitle.suffix': '- Plebs', 'pageTitle.liveSuffix': '- En Vivo en Plebs',
        // Home Page Sections
        'section.trending': 'Tendencias', 'section.recommended': 'Recomendado Para Ti', 'section.shorts': 'Shorts', 'section.live': 'En Vivo', 'section.liveNow': 'En Vivo Ahora', 'section.latestVideos': 'Últimos Videos', 'section.videos': 'Videos', 'section.usersYouFollow': 'Usuarios que Sigues',
        // Trending Period
        'trending.thisWeek': 'Esta Semana', 'trending.today': 'Hoy',
        // Buttons
        'button.viewMore': 'Ver Más', 'button.clearAll': 'Borrar Todo', 'button.showAnyway': 'Mostrar de todos modos',
        // Confirmation Modals
        'confirm.logout': 'Cerrar Sesión', 'confirm.logoutMessage': '¿Estás seguro de que quieres cerrar sesión?', 'confirm.resetSettings': 'Restablecer Configuración', 'confirm.resetSettingsMessage': '¿Estás seguro de que quieres restablecer toda la configuración a los valores predeterminados?', 'confirm.reset': 'Restablecer', 'confirm.clearHistory': 'Borrar Historial', 'confirm.clearHistoryMessage': '¿Estás seguro de que quieres borrar todo tu historial de reproducción? Esto no se puede deshacer.', 'confirm.deleteDraft': 'Eliminar Borrador', 'confirm.deleteDraftMessage': '¿Estás seguro de que quieres eliminar este borrador?', 'confirm.delete': 'Eliminar', 'confirm.deleteVideo': 'Eliminar Video', 'confirm.deleteVideoMessage': '¿Estás seguro de que quieres eliminar este video? Esta acción no se puede deshacer.', 'confirm.endStream': 'Finalizar Transmisión en Vivo', 'confirm.endStreamMessage': '¿Estás seguro de que quieres finalizar esta transmisión en vivo? Esta acción no se puede deshacer.', 'confirm.endStreamButton': 'Finalizar Transmisión',
        // Content Filters
        'filter.hiddenByPack': 'Oculto por {pack}', 'filter.showAnyway': 'Mostrar de todos modos', 'filter.contentHidden': 'Contenido oculto por filtro de contenido',
        // Filter Packs
        'filter.racism': 'Racismo y Discurso de Odio', 'filter.racismDesc': 'Filtra insultos raciales, discurso de odio étnico y contenido discriminatorio', 'filter.sexualExplicit': 'Sexualmente Explícito', 'filter.sexualExplicitDesc': 'Filtra términos pornográficos y contenido sexualmente explícito', 'filter.violence': 'Violencia y Gore', 'filter.violenceDesc': 'Filtra violencia gráfica, gore y amenazas violentas', 'filter.drugs': 'Drogas y Sustancias', 'filter.drugsDesc': 'Filtra contenido relacionado con drogas y abuso de sustancias', 'filter.spam': 'Spam y Estafas', 'filter.spamDesc': 'Filtra spam común, estafas y contenido promocional', 'filter.crypto': 'Criptomonedas', 'filter.cryptoDesc': 'Filtra promoción de criptomonedas, señales de trading y promoción de tokens', 'filter.politics': 'Contenido Político', 'filter.politicsDesc': 'Filtra contenido político partidista y retórica divisiva', 'filter.profanity': 'Lenguaje Fuerte', 'filter.profanityDesc': 'Filtra blasfemias fuertes y lenguaje vulgar', 'filter.customFilter': 'Filtro Personalizado',
        // Following Page
        'following.noFollowingYet': 'Aún no sigues a nadie. ¡Encuentra creadores para seguir!',
    },
    fr: {
        // Navigation & Header
        'nav.home': 'Accueil', 'nav.following': 'Abonnements', 'nav.myVideos': 'Mes Vidéos', 'nav.liked': 'Aimés', 'nav.history': 'Historique', 'nav.topics': 'SUJETS', 'nav.live': 'En Direct', 'nav.bitcoin': 'Bitcoin', 'nav.nostr': 'Nostr', 'nav.technology': 'Technologie', 'nav.gaming': 'Jeux', 'nav.tutorials': 'Tutoriels', 'nav.podcasts': 'Podcasts', 'nav.music': 'Musique', 'nav.nsfw': 'NSFW', 'nav.about': 'À Propos', 'nav.contact': 'Contact', 'nav.terms': 'Conditions', 'nav.privacy': 'Confidentialité', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.playlists': 'Playlists', 'nav.downloads': 'Téléchargements', 'nav.subscriptions': 'Abonnements', 'nav.trending': 'Tendances', 'nav.explore': 'Explorer', 'nav.categories': 'Catégories', 'nav.liveStreams': 'Diffusions en Direct', 'nav.github': 'GitHub',
        'header.search': 'Rechercher des vidéos...', 'header.notifications': 'Notifications', 'header.settings': 'Paramètres', 'header.create': 'Créer', 'header.admin': 'Admin', 'header.viewProfile': 'Voir le Profil', 'header.logout': 'Déconnexion',
        // Login Modal
        'login.title': 'Connexion avec Nostr', 'login.extension': 'Connexion avec Extension', 'login.extensionDesc': 'Utilisez Alby, nos2x ou d\'autres extensions Nostr', 'login.connect': 'Nostr Connect', 'login.connectDesc': 'Connectez-vous avec des signataires distants comme Amber, nsec.app', 'login.privateKey': 'Clé Privée', 'login.privateKeyDesc': 'Entrez votre nsec ou clé hex (local uniquement)', 'login.newToNostr': 'Nouveau sur Nostr?', 'login.createAccount': 'Créer un Compte', 'login.createAccountDesc': 'Commencez avec une nouvelle identité Nostr pour utiliser sur Plebs',
        // Connect Modal
        'connect.title': 'Connexion avec Nostr', 'connect.option1': 'Option 1: Utilisez cette chaîne de connexion', 'connect.option1Desc': 'Copiez et collez ceci dans n\'importe quelle app compatible NIP-46 (nsec.app, Amber, etc.)', 'connect.copyString': 'Copier la Chaîne de Connexion', 'connect.showQR': 'Afficher le Code QR', 'connect.listening': 'En attente de connexion...', 'connect.option2': 'Option 2: Coller une URL bunker', 'connect.option2Desc': 'Si vous avez déjà une URL bunker:// d\'un signataire distant', 'connect.withBunker': 'Connecter avec Bunker', 'connect.popularSigners': 'Signataires NIP-46 populaires:', 'connect.webSigner': 'Signataire web', 'connect.androidApp': 'App Android', 'connect.builtInSigner': 'Signataire intégré', 'connect.or': 'OU', 'connect.bunkerPlaceholder': 'bunker://...',
        // Private Key Modal
        'privateKey.title': 'Connexion avec Clé Privée', 'privateKey.warning': 'Avertissement de Sécurité', 'privateKey.warningText': 'Votre clé privée sera stockée localement dans votre navigateur. Pour plus de sécurité, envisagez d\'utiliser une extension de navigateur ou Nostr Connect.', 'privateKey.label': 'Clé Privée (nsec ou hex)', 'privateKey.showKey': 'Afficher la clé', 'privateKey.login': 'Connexion', 'privateKey.placeholder': 'nsec1...',
        // Signup Modal
        'signup.title': 'Créer un Compte Nostr', 'signup.whatIsNostr': 'Qu\'est-ce que Nostr?', 'signup.nostrExplanation': 'Nostr est un protocole social décentralisé qui vous donne la propriété de votre identité et de votre contenu. Contrairement aux plateformes traditionnelles, aucune entreprise ne peut vous bannir, censurer votre contenu ou fermer votre compte.', 'signup.whyPlebs': 'Pourquoi Plebs utilise Nostr?', 'signup.plebsExplanation': 'Plebs est construit sur Nostr pour fournir un partage de vidéos résistant à la censure. Vos vidéos, commentaires et interactions sont stockés sur un réseau de relais, pas sur nos serveurs. Votre identité Nostr fonctionne sur des centaines d\'autres apps aussi!', 'signup.howItWorks': 'Comment ça marche', 'signup.keysIdentity': 'Vos clés = Votre identité.', 'signup.keysIdentityDesc': 'Vous obtiendrez une clé privée (nsec) qui prouve que vous êtes propriétaire de votre compte.', 'signup.keepSecret': 'Gardez votre clé privée secrète!', 'signup.keepSecretDesc': 'C\'est comme un mot de passe qui ne peut jamais être réinitialisé.', 'signup.oneIdentity': 'Une identité, plusieurs apps.', 'signup.oneIdentityDesc': 'Utilisez le même compte sur Damus, Primal, Amethyst et plus.', 'signup.gotIt': 'Compris, créons mon compte', 'signup.username': 'Nom d\'utilisateur', 'signup.usernamePlaceholder': 'Choisissez un nom d\'affichage', 'signup.about': 'À propos (optionnel)', 'signup.aboutPlaceholder': 'Parlez de vous aux autres', 'signup.profilePicture': 'Photo de Profil (optionnel)', 'signup.uploadPhoto': 'Télécharger une Photo', 'signup.remove': 'Supprimer', 'signup.avatarHint': 'Les images carrées fonctionnent mieux. Max 5Mo.', 'signup.uploading': 'Téléchargement...', 'signup.lightningAddress': 'Adresse Lightning (optionnel)', 'signup.lightningPlaceholder': 'vous@walletofsatoshi.com', 'signup.lightningHint': 'Ajoutez une adresse Lightning pour recevoir des zaps (pourboires Bitcoin) sur vos vidéos et profil.', 'signup.nostrAddress': 'Adresse Nostr', 'signup.nostrAddressPlaceholder': 'utilisateur', 'signup.nostrAddressHint': 'Votre adresse Nostr facilite la recherche de votre profil. Lettres minuscules, chiffres, _ et - uniquement.', 'signup.nostrAddressRequired': 'Veuillez entrer une adresse Nostr', 'signup.nostrAddressAvailable': 'Disponible!', 'signup.nostrAddressUnavailable': 'Déjà pris', 'signup.nostrAddressChecking': 'Vérification...', 'signup.nostrAddressInvalid': 'Format de nom d\'utilisateur invalide', 'signup.nostrAddressRegistering': 'Enregistrement de votre adresse Nostr...', 'signup.nostrAddressSuccess': 'Adresse Nostr enregistrée!', 'signup.nostrAddressFailed': 'Impossible d\'enregistrer l\'adresse Nostr', 'signup.yourUsername': 'Votre Nom d\'utilisateur', 'signup.yourBio': 'Votre bio apparaîtra ici', 'signup.createAccountBtn': 'Créer le Compte', 'signup.termsAgree': 'En créant un compte, vous acceptez nos', 'signup.and': 'et', 'signup.success': 'Compte Créé avec Succès!', 'signup.yourPrivateKey': 'Votre Clé Privée (nsec)', 'signup.keyWarning': 'C\'est la SEULE façon d\'accéder à votre compte. Gardez-la en sécurité!', 'signup.copyPrivateKey': 'Copier la Clé Privée', 'signup.howToUseKey': 'Comment utiliser votre clé privée', 'signup.continueToPlebs': 'Continuer vers Plebs',
        // Notifications
        'notifications.title': 'Notifications', 'notifications.settings': 'Paramètres de Notifications', 'notifications.reactions': 'Réactions (j\'aime/je n\'aime pas)', 'notifications.replies': 'Commentaires & Réponses', 'notifications.zaps': 'Zaps', 'notifications.chatMentions': 'Mentions en Chat en Direct', 'notifications.newFollowers': 'Nouveaux Abonnés', 'notifications.syncNote': 'Les paramètres sont synchronisés entre appareils via Nostr',
        // Settings Modal
        'settings.title': 'Paramètres', 'settings.language': 'Langue', 'settings.languageDesc': 'Choisissez votre langue préférée', 'settings.saveToNostr': 'Enregistrer sur Nostr', 'settings.saveToNostrDesc': 'Synchroniser les paramètres sur toutes les instances Plebs', 'settings.darkMode': 'Mode Sombre', 'settings.darkModeDesc': 'Basculer entre thème clair et sombre', 'settings.contentWarning': 'Préférences d\'avertissement de contenu', 'settings.showNsfwWarnings': 'Afficher les avertissements NSFW', 'settings.showNsfwWarningsDesc': 'Afficher la vérification d\'âge pour le contenu NSFW', 'settings.showCommunityWarnings': 'Afficher les avertissements de la communauté', 'settings.showCommunityWarningsDesc': 'Afficher les avertissements pour le contenu signalé ou fortement négatif', 'settings.showFollowsReportWarnings': 'Afficher les avertissements des rapports suivis', 'settings.showFollowsReportWarningsDesc': 'Afficher les avertissements lorsque 5+ personnes que vous suivez ont signalé du contenu', 'settings.filterPacks': 'Packs de filtres de contenu', 'settings.filterPacksDesc': 'Activez les packs de filtres pour masquer automatiquement le contenu correspondant à des mots-clés spécifiques.', 'settings.customKeywordFilter': 'Filtre de mots-clés personnalisé', 'settings.customKeywordFilterPlaceholder': 'Entrez des mots-clés ou phrases séparés par des virgules\nExemple: spam, contenu indésirable, phrase spécifique', 'settings.customKeywordFilterDesc': 'Ajoutez vos propres mots-clés à filtrer (séparés par des virgules)', 'settings.saveSettings': 'Enregistrer les Paramètres', 'settings.resetDefaults': 'Réinitialiser', 'settings.notificationSettings': 'Paramètres de Notification',
        // Upload Modal
        'upload.title': 'Télécharger une Vidéo', 'upload.videoFile': 'Fichier Vidéo', 'upload.clickToSelect': 'Cliquez pour sélectionner une vidéo ou glissez-déposez', 'upload.fileTypes': 'MP4, AVI, MOV, etc (max 2Go entrée, sera compressé à <100Mo)', 'upload.preparing': 'Préparation...', 'upload.thumbnail': 'Miniature', 'upload.thumbnailHint': 'Cliquez pour sélectionner ou auto-générer depuis la vidéo', 'upload.uploading': 'Téléchargement...', 'upload.titleLabel': 'Titre', 'upload.titlePlaceholder': 'Entrez le titre de la vidéo', 'upload.descriptionLabel': 'Description', 'upload.descriptionPlaceholder': 'Parlez de votre vidéo aux spectateurs', 'upload.tagsLabel': 'Tags (séparés par des virgules)', 'upload.tagsPlaceholder': 'bitcoin, nostr, tutoriel', 'upload.markNsfw': 'Marquer comme NSFW (18+)', 'upload.nsfwDesc': 'Le contenu pour adultes doit être marqué comme NSFW', 'upload.saveDraft': 'Enregistrer comme Brouillon', 'upload.publish': 'Publier', 'upload.selectVideo': 'Sélectionnez une vidéo à télécharger', 'upload.optional': '(optionnel)', 'upload.remove': 'Supprimer', 'upload.qualityHigh': 'Haute',
        // Create Modal
        'create.title': 'Créer', 'create.goLive': 'En Direct', 'create.goLiveDesc': 'Démarrer une diffusion en direct ou en programmer une', 'create.uploadVideo': 'Télécharger une Vidéo', 'create.uploadVideoDesc': 'Télécharger une vidéo depuis votre appareil', 'create.createShort': 'Créer un Short', 'create.createShortDesc': 'Télécharger une vidéo verticale (moins de 60s)',
        // Go Live Modal
        'goLive.title': 'En Direct', 'goLive.when': 'Quand voulez-vous diffuser en direct?', 'goLive.now': 'Diffuser Maintenant', 'goLive.schedule': 'Programmer une Diffusion', 'goLive.streamTitle': 'Titre de la Diffusion', 'goLive.streamTitlePlaceholder': 'Entrez le titre de votre diffusion', 'goLive.description': 'Description', 'goLive.descriptionPlaceholder': 'Dites aux spectateurs de quoi parle votre diffusion', 'goLive.tags': 'Tags (séparés par des virgules)', 'goLive.tagsPlaceholder': 'gaming, bitcoin, tutoriel', 'goLive.streamUrl': 'URL de Diffusion (RTMP, HLS ou WebRTC)', 'goLive.streamUrlPlaceholder': 'https://votre-service-streaming.com/stream.m3u8', 'goLive.zapGoal': 'Objectif de Zaps (optionnel)', 'goLive.zapGoalLabel': 'Objectif de Zaps', 'goLive.zapGoalPlaceholder': 'ex. 10000', 'goLive.cancel': 'Annuler', 'goLive.goLiveBtn': 'Diffuser',
        'video.noDescription': 'Aucune description n\'a été ajoutée à cette vidéo.', 'live.noDescription': 'Aucune description n\'a été ajoutée à cette diffusion en direct.',
        // Edit Stream Modal
        'editStream.title': 'Modifier la Diffusion', 'editStream.changeThumbnail': 'Changer la Miniature', 'editStream.titleLabel': 'Titre', 'editStream.saveChanges': 'Enregistrer les Modifications',
        // NSFW Warning Modal
        'nsfw.title': 'Vérification d\'Âge Requise', 'nsfw.description': 'Ce contenu est marqué comme NSFW et peut contenir du matériel pour adultes. Vous devez avoir 18 ans ou plus pour voir ce contenu.', 'nsfw.confirm': 'J\'ai 18 ans ou plus', 'nsfw.remember': 'Ne plus demander (Mémoriser mon choix)',
        // Community Warning Modal
        'communityWarning.title': 'Avertissement de la Communauté', 'communityWarning.description': 'Cette vidéo a été signalée et/ou fortement désapprouvée par la communauté. Cela peut être dû à:', 'communityWarning.reason1': 'Contenu inapproprié non correctement marqué comme NSFW', 'communityWarning.reason2': 'Détails d\'utilisateur nouveau ou suspect', 'communityWarning.reason3': 'Informations trompeuses ou fausses', 'communityWarning.reason4': 'Spam ou contenu de faible qualité', 'communityWarning.reason5': 'Contenu potentiellement nuisible ou illégal', 'communityWarning.proceed': 'Procédez avec prudence.', 'communityWarning.goBack': 'Retour', 'communityWarning.viewAnyway': 'Voir Quand Même',
        // Report Modal
        'report.title': 'Signaler la Vidéo', 'report.description': 'Sélectionnez une raison pour signaler ce contenu:', 'report.nudity': 'Nudité ou Contenu Sexuel', 'report.nudityDesc': 'Contient des images sexuelles ou explicites non marquées comme NSFW', 'report.hate': 'Discours de Haine ou Harcèlement', 'report.hateDesc': 'Promeut la violence, la haine ou le harcèlement', 'report.illegal': 'Contenu Illégal', 'report.illegalDesc': 'Contenu pouvant violer les lois', 'report.spam': 'Spam ou Trompeur', 'report.spamDesc': 'Contenu trompeur, arnaques ou spam répétitif', 'report.impersonation': 'Usurpation d\'Identité', 'report.impersonationDesc': 'Se faire passer pour quelqu\'un d\'autre', 'report.other': 'Autre', 'report.otherDesc': 'Autre violation non listée', 'report.cancel': 'Annuler', 'report.submit': 'Soumettre le Signalement',
        // Share Modal
        'share.title': 'Partager la Vidéo', 'share.link': 'Lien', 'share.embed': 'Intégrer', 'share.shareWith': 'Partagez cette vidéo avec d\'autres:', 'share.copy': 'Copier', 'share.copied': 'Copié dans le presse-papiers!', 'share.embedOnWebsite': 'Intégrez cette vidéo sur votre site web:', 'share.size': 'Taille:', 'share.responsive': 'Responsive (Par défaut)', 'share.size1280x720': '1280 × 720 (HD)', 'share.embedCodeCopied': 'Code d\'intégration copié!',
        // Edit Video Modal
        'editVideo.title': 'Modifier la Vidéo', 'editVideo.video': 'Vidéo', 'editVideo.replaceVideo': 'Remplacer la Vidéo', 'editVideo.thumbnail': 'Miniature', 'editVideo.changeThumbnail': 'Changer la Miniature', 'editVideo.titleLabel': 'Titre', 'editVideo.descriptionLabel': 'Description', 'editVideo.tagsLabel': 'Tags (séparés par des virgules)', 'editVideo.cancel': 'Annuler', 'editVideo.saveChanges': 'Enregistrer les Modifications',
        // Edit Profile Modal
        'editProfile.title': 'Modifier le Profil', 'editProfile.displayName': 'Nom d\'Affichage', 'editProfile.displayNamePlaceholder': 'Votre nom d\'affichage', 'editProfile.about': 'À propos', 'editProfile.aboutPlaceholder': 'Parlez de vous aux autres', 'editProfile.picture': 'Photo de Profil', 'editProfile.pictureUrl': 'Ou entrez l\'URL de l\'image directement:', 'editProfile.nip05': 'Identifiant NIP-05 (optionnel)', 'editProfile.nip05Hint': 'Une adresse Nostr vérifiée pour la vérification d\'identité.', 'editProfile.website': 'Site Web (optionnel)', 'editProfile.saveChanges': 'Enregistrer les Modifications',
        // Confirmation Modal
        'confirm.title': 'Confirmer l\'Action', 'confirm.message': 'Êtes-vous sûr de vouloir continuer?', 'confirm.cancel': 'Annuler', 'confirm.confirm': 'Confirmer',
        // Video Page
        'video.views': 'vues', 'video.view': 'vue', 'video.followers': 'abonnés', 'video.follower': 'abonné', 'video.follow': 'S\'abonner', 'video.unfollow': 'Se désabonner', 'video.share': 'Partager', 'video.comments': 'Commentaires', 'video.writeComment': 'Écrire un commentaire...', 'video.noComments': 'Pas encore de commentaires. Soyez le premier!',
        // Toast Messages
        'toast.loggedIn': 'Connexion réussie!', 'toast.settingsSaved': 'Paramètres enregistrés!', 'toast.settingsLocal': 'Paramètres enregistrés localement. Impossible de sauvegarder sur Nostr.', 'toast.settingsLocalOnly': 'Paramètres enregistrés localement!', 'toast.settingsReset': 'Paramètres réinitialisés!', 'toast.avatarUploaded': 'Avatar téléchargé avec succès!', 'toast.profileUpdated': 'Profil mis à jour avec succès!', 'toast.copied': 'Copié dans le presse-papiers!', 'toast.copyFailed': 'Échec de la copie. Veuillez copier manuellement.', 'toast.installExtension': 'Veuillez installer une extension Nostr comme Alby ou nos2x', 'toast.loginFailed': 'Échec de connexion avec l\'extension. Veuillez réessayer.', 'toast.invalidKey': 'Clé privée invalide. Veuillez vérifier et réessayer.', 'toast.enterKey': 'Veuillez entrer votre clé privée', 'toast.enterUsername': 'Veuillez entrer un nom d\'utilisateur', 'toast.accountCreated': 'Bienvenue sur Plebs! Vous êtes connecté.', 'toast.keyCopied': 'Clé privée copiée dans le presse-papiers!', 'toast.unmuted': 'Utilisateur réactivé', 'toast.unmuteFailed': 'Échec de la réactivation de l\'utilisateur', 'toast.selectImage': 'Veuillez sélectionner un fichier image', 'toast.imageTooLarge': 'L\'image doit faire moins de 5 Mo', 'toast.avatarFailed': 'Échec du téléchargement de l\'avatar. Veuillez réessayer.', 'toast.mustBeLoggedIn': 'Vous devez être connecté pour modifier votre profil', 'toast.enterDisplayName': 'Veuillez entrer un nom d\'affichage', 'toast.profileFailed': 'Échec de la sauvegarde du profil. Veuillez réessayer.', 'toast.invalidBunker': 'Veuillez entrer une URL bunker valide', 'toast.connectFailed': 'Échec de la connexion', 'toast.showingFiltered': 'Affichage du contenu filtré', 'toast.reportSubmitted': 'Signalement envoyé avec succès', 'toast.draftSaved': 'Brouillon enregistré! Vous pouvez continuer plus tard depuis Mes Vidéos.', 'toast.draftLoaded': 'Brouillon chargé. Complétez votre téléchargement et publiez.', 'toast.draftDeleted': 'Brouillon supprimé', 'toast.languageChanged': 'Langue modifiée', 'toast.videoBlocked': 'Vidéo bloquée et publiée sur Nostr', 'toast.waitForUpload': 'Veuillez attendre la fin du téléchargement de la vidéo', 'toast.enterTitle': 'Veuillez entrer un titre', 'toast.publishing': 'Publication de la vidéo sur Nostr...',
        // Time
        'time.justNow': 'à l\'instant', 'time.secondAgo': 'il y a 1 seconde', 'time.secondsAgo': 'il y a {n} secondes', 'time.minuteAgo': 'il y a 1 minute', 'time.minutesAgo': 'il y a {n} minutes', 'time.hourAgo': 'il y a 1 heure', 'time.hoursAgo': 'il y a {n} heures', 'time.dayAgo': 'il y a 1 jour', 'time.daysAgo': 'il y a {n} jours', 'time.weekAgo': 'il y a 1 semaine', 'time.weeksAgo': 'il y a {n} semaines', 'time.monthAgo': 'il y a 1 mois', 'time.monthsAgo': 'il y a {n} mois', 'time.yearAgo': 'il y a 1 an', 'time.yearsAgo': 'il y a {n} ans',
        // Empty States
        'empty.noVideos': 'Aucune vidéo trouvée.', 'empty.noLikedVideos': 'Vous n\'avez encore aimé aucune vidéo.', 'empty.noHistory': 'Pas d\'historique.',
        // Misc
        'misc.loading': 'Chargement...', 'misc.close': 'Fermer', 'misc.back': 'Retour', 'misc.search': 'Rechercher',
        // Common
        'common.cancel': 'Annuler', 'common.uploading': 'Téléchargement...', 'common.saveChanges': 'Enregistrer les Modifications', 'common.close': 'Fermer',
        // Aria Labels
        'aria.toggleMenu': 'Basculer le menu', 'aria.mainNavigation': 'Navigation principale', 'aria.videoContent': 'Contenu vidéo', 'aria.loadingContent': 'Chargement du contenu',
        // Dynamic JavaScript text
        'button.hideQR': 'Masquer le Code QR', 'button.showQR': 'Afficher le Code QR', 'button.copied': 'Copié!', 'button.showLess': 'Voir Moins', 'button.showMore': 'Voir Plus', 'button.creatingAccount': 'Création du compte...', 'button.submitting': 'Envoi en cours...', 'button.scheduleStream': 'Programmer la Diffusion', 'button.goLive': 'Diffuser', 'button.creatingStream': 'Création de la diffusion...', 'button.continueCustomAmount': 'Continuer avec Montant Personnalisé', 'button.recordFromCamera': 'Enregistrer depuis la Caméra', 'button.requestingCamera': 'Demande de caméra...', 'button.recording': 'Enregistrement...',
        'status.saving': 'Enregistrement...', 'status.saved': 'Enregistré!', 'status.uploading': 'Téléchargement...', 'status.uploadComplete': 'Téléchargement terminé!', 'status.uploadingToNostrBuild': 'Téléchargement vers nostr.build...', 'status.publishingChanges': 'Publication des modifications...', 'status.removingOldVersion': 'Suppression de l\'ancienne version...', 'status.validatingThumbnail': 'Validation de la miniature...', 'status.uploadingThumbnail': 'Téléchargement de la miniature...', 'status.thumbnailUploaded': 'Miniature téléchargée!', 'status.processingVideo': 'Traitement de la vidéo...', 'status.compressingVideo': 'Compression de la vidéo...', 'status.uploadingVideo': 'Téléchargement de la vidéo...', 'status.videoUploaded': 'Vidéo téléchargée avec succès!', 'status.processing': 'Traitement...', 'status.generatingThumbnail': 'Génération de la miniature...', 'status.generatingPreview': 'Génération de l\'aperçu...', 'status.uploadingPreview': 'Téléchargement de l\'aperçu...', 'status.publishing': 'Publication...', 'status.publishingToNostr': 'Publication sur Nostr...', 'status.publishingVideoToNostr': 'Publication de la vidéo sur Nostr...', 'status.generatingPoW': 'Génération de la preuve de travail...', 'status.posting': 'Publication...', 'status.processingVideoAndThumbnail': 'Traitement de la vidéo et de la miniature...', 'status.uploadFailed': 'Échec du téléchargement - réessayez', 'status.selectVideoToUpload': 'Sélectionnez une vidéo à télécharger', 'status.waitingForVideoUpload': 'En attente du téléchargement de la vidéo...', 'status.selectVideoAndThumbnail': 'Sélectionnez vidéo et miniature pour publier', 'status.ready': 'Prêt ✓', 'status.failed': 'Échoué ✗', 'status.fromDraft': 'Depuis le brouillon', 'status.startingNow': 'Démarrage maintenant!', 'status.ended': 'TERMINÉ', 'status.thumbnailReady': 'Prêt', 'status.thumbnailFailed': 'Échoué', 'status.uploadFailedRetry': 'Échec du téléchargement. Veuillez réessayer.',
        'publish.video': 'Publier la Vidéo', 'publish.autoThumbnail': 'Publier la Vidéo (miniature auto)',
        'report.titleComment': 'Signaler le Commentaire', 'report.titleUser': 'Signaler l\'Utilisateur', 'report.titleVideo': 'Signaler la Vidéo', 'report.descComment': 'Sélectionnez une raison pour signaler ce commentaire:', 'report.descUser': 'Sélectionnez une raison pour signaler cet utilisateur:', 'report.descVideo': 'Sélectionnez une raison pour signaler ce contenu:',
        'empty.noMutedUsers': 'Aucun utilisateur en sourdine.', 'empty.noVideosToMonitor': 'Aucune vidéo à surveiller.', 'empty.noRecentActivity': 'Aucune activité récente.', 'empty.failedLoadNotifications': 'Échec du chargement des notifications', 'empty.loginToViewLiked': 'Veuillez <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">vous connecter</a> pour voir vos vidéos aimées.', 'empty.loginToViewFollowing': 'Veuillez <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">vous connecter</a> pour voir qui vous suivez.', 'empty.loginToViewVideos': 'Veuillez <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">vous connecter</a> pour voir vos vidéos.', 'empty.loginToViewAnalytics': 'Veuillez <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">vous connecter</a> pour voir vos statistiques.', 'empty.noLikedVideosYet': 'Vous n\'avez encore aimé aucune vidéo.', 'empty.noLikedVideosFound': 'Aucune vidéo aimée trouvée.', 'empty.noFullLengthLikedVideos': 'Aucune vidéo longue aimée trouvée.', 'empty.noWatchHistory': 'Pas d\'historique. Commencez à regarder des vidéos.', 'empty.noVideosInHistory': 'Aucune vidéo dans l\'historique.', 'empty.noFullLengthHistory': 'Aucune vidéo longue dans l\'historique.', 'empty.noMatchingVideos': 'Aucune vidéo correspondante trouvée.', 'empty.noFullLengthVideos': 'Aucune vidéo longue trouvée.', 'empty.failedLoadTrending': 'Échec du chargement des tendances.', 'empty.noTrendingVideos': 'Aucune vidéo tendance trouvée.', 'empty.noMatchingUsers': 'Aucun utilisateur correspondant trouvé.', 'empty.unableLoadProfiles': 'Impossible de charger les profils.', 'empty.noFollowingVideos': 'Pas encore de vidéos des utilisateurs que vous suivez.', 'empty.noFullLengthFollowing': 'Pas de vidéos longues des utilisateurs que vous suivez.', 'empty.failedLoadFollowing': 'Échec du chargement. Veuillez réessayer.', 'empty.noVideosUploadFirst': 'Aucune vidéo. Téléchargez votre première vidéo!', 'empty.noFullLengthUploaded': 'Aucune vidéo longue trouvée.', 'empty.noMatchingLiveStreams': 'Aucune diffusion correspondante trouvée.', 'empty.noMatchingShorts': 'Aucun short correspondant trouvé.', 'empty.noVideosForTag': 'Aucune vidéo pour ce tag.', 'empty.noFullLengthForTag': 'Aucune vidéo longue pour ce tag.', 'empty.noUploadedVideos': 'Pas encore de vidéos téléchargées.', 'empty.noVideosFound': 'Aucune vidéo trouvée.', 'empty.failedLoadProfile': 'Échec du chargement du profil. Réessayez.', 'empty.noComments': 'Pas encore de commentaires. Soyez le premier!', 'empty.failedLoadComments': 'Échec du chargement des commentaires', 'empty.noLiveNow': 'Personne n\'est en direct. Soyez le premier!',
        'error.videoNotFound': 'Vidéo non trouvée.', 'error.contentNotAvailable': 'Ce contenu n\'est pas disponible.', 'error.invalidVideoData': 'Données vidéo invalides.', 'error.videoNotAvailable': 'Vidéo non disponible. Le fichier a peut-être été supprimé.', 'error.failedLoadVideo': 'Échec du chargement. Veuillez réessayer.', 'error.failedLoadVideoShort': 'Échec du chargement. Fichier peut-être supprimé.', 'error.liveStreamNotFound': 'Diffusion en direct non trouvée.', 'error.invalidLiveStreamData': 'Données de diffusion invalides.', 'error.failedLoadLiveStream': 'Échec du chargement de la diffusion.',
        // New Button & Action Labels
        'button.follow': 'Suivre', 'button.unfollow': 'Ne plus suivre', 'button.mute': 'Mettre en sourdine', 'button.unmute': 'Réactiver le son', 'button.muteUser': 'Mettre l\'utilisateur en sourdine', 'button.unmuteUser': 'Réactiver l\'utilisateur', 'button.confirm': 'Confirmer', 'button.cancel': 'Annuler', 'button.close': 'Fermer', 'button.boost': 'Booster', 'button.zap': 'Zap', 'button.viewMore': 'Voir plus', 'button.viewAnalytics': 'Voir les statistiques', 'button.backToMyVideos': 'Retour à Mes Vidéos', 'button.editDraft': 'Modifier le brouillon', 'button.deleteDraft': 'Supprimer le brouillon', 'button.editVideo': 'Modifier la vidéo', 'button.deleteVideo': 'Supprimer la vidéo', 'button.editShort': 'Modifier le short', 'button.deleteShort': 'Supprimer le short', 'button.editStream': 'Modifier la diffusion', 'button.endStream': 'Terminer la diffusion', 'button.reset': 'Réinitialiser', 'button.download': 'Télécharger', 'button.watchRecording': 'Regarder l\'enregistrement', 'button.show': 'Afficher', 'button.login': 'Connexion', 'button.toggleChat': 'Basculer le chat', 'button.blockVideo': 'Bloquer la vidéo', 'button.blockUser': 'Bloquer l\'utilisateur', 'button.unblock': 'Débloquer', 'button.removeFromHistory': 'Supprimer de l\'historique',
        // New Stats & Counts
        'stat.views': 'vues', 'stat.viewsCount': '{count} vues', 'stat.videos': 'vidéos', 'stat.video': 'vidéo', 'stat.followers': 'abonnés', 'stat.follower': 'abonné', 'stat.following': 'Abonnements', 'stat.subscribers': 'abonnés', 'stat.comments': 'Commentaires', 'stat.liveCount': '{count} en direct', 'stat.percentOfGoal': '{percent}% de l\'objectif', 'stat.netGrowth': 'Croissance nette', 'stat.newFollowers': 'Nouveaux abonnés', 'stat.unfollowed': 'Désabonnements', 'stat.lastUpdated': 'Dernière mise à jour: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'EN DIRECT', 'badge.ended': 'TERMINÉ', 'badge.scheduled': 'PROGRAMMÉ', 'badge.warning': 'AVERTISSEMENT', 'badge.communityWarning': 'AVERTISSEMENT COMMUNAUTAIRE', 'badge.verifiedNip05': 'NIP-05 vérifié', 'badge.streamer': 'Streamer', 'badge.clickToView': 'Cliquer pour voir',
        // New Actions
        'action.report': 'Signaler', 'action.reportComment': 'Signaler le commentaire', 'action.reportVideo': 'Signaler cette vidéo', 'action.reportStream': 'Signaler cette diffusion', 'action.like': 'J\'aime', 'action.dislike': 'Je n\'aime pas', 'action.reply': 'Répondre',
        // New Placeholders
        'placeholder.searchHistory': 'Rechercher dans l\'historique...', 'placeholder.searchUsers': 'Rechercher des utilisateurs...', 'placeholder.searchMyVideos': 'Rechercher mes vidéos...', 'placeholder.eventId': 'Entrer l\'ID d\'événement (hex ou nevent/note)', 'placeholder.pubkey': 'Entrer pubkey (hex ou npub)', 'placeholder.customAmount': 'Montant personnalisé', 'placeholder.chatEnded': 'Chat fermé - la diffusion est terminée', 'placeholder.addComment': 'Ajouter un commentaire...', 'placeholder.setNewGoal': 'Définir un nouvel objectif (sats)',
        // New Video & Content
        'video.untitledVideo': 'Vidéo sans titre', 'video.untitledShort': 'Short sans titre', 'video.upNext': 'À suivre', 'video.noVideosYet': 'Pas encore de vidéos', 'video.noShortsYet': 'Pas encore de shorts', 'video.noLiveStreamsYet': 'Pas encore de diffusions en direct', 'video.noBlockedVideos': 'Aucune vidéo bloquée', 'video.noBlockedUsers': 'Aucun utilisateur bloqué',
        // New Stream Messages
        'stream.ended': 'Cette diffusion est terminée. Le chat est maintenant fermé.', 'stream.welcomeChat': 'Bienvenue dans le chat en direct!', 'stream.goalReached': 'Objectif atteint!', 'stream.zapGoalReached': 'Objectif de zap atteint! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Message d\'un utilisateur en sourdine', 'muted.commentFromMutedUserHidden': 'Commentaire d\'un utilisateur en sourdine masqué', 'muted.commentHidden': 'Commentaire masqué ({packs})', 'muted.messageHidden': 'Message masqué ({packs})', 'muted.commentReportedByFollows': 'Commentaire signalé par des personnes que vous suivez', 'muted.messageReportedByFollows': 'Message signalé par des personnes que vous suivez', 'muted.commentHeavilyDownvoted': 'Commentaire fortement négativé par la communauté', 'muted.messageHeavilyDownvoted': 'Message fortement négativé',
        // New Admin & Lists
        'list.blockedVideos': 'Vidéos bloquées', 'list.blockedUsers': 'Utilisateurs bloqués',
        // New Alerts
        'alert.cameraNotSupported': 'L\'accès à la caméra n\'est pas pris en charge dans ce navigateur. Veuillez utiliser un navigateur moderne comme Chrome, Firefox ou Safari.', 'alert.noCameraFound': 'Aucune caméra trouvée sur cet appareil. Veuillez connecter une caméra ou utiliser l\'option de téléchargement de fichier.', 'alert.cameraAccessDenied': 'L\'accès à la caméra a été refusé. Veuillez autoriser les permissions de caméra dans les paramètres de votre navigateur.', 'alert.cameraInUse': 'La caméra est utilisée par une autre application. Veuillez fermer les autres apps utilisant la caméra.', 'alert.cameraUnableAccess': 'Impossible d\'accéder à la caméra avec les paramètres actuels. Veuillez essayer l\'option de téléchargement.', 'alert.cameraUnableAccessWithError': 'Impossible d\'accéder à la caméra: {error}\n\nVeuillez utiliser l\'option de téléchargement.', 'alert.fillRequiredFields': 'Veuillez remplir tous les champs requis', 'alert.uploadThumbnail': 'Veuillez télécharger une miniature pour votre diffusion', 'alert.failedCreateStream': 'Échec de la création de la diffusion. Veuillez réessayer.', 'alert.failedUpdateStream': 'Échec de la mise à jour. Veuillez réessayer.', 'alert.streamNotFound': 'Diffusion introuvable', 'alert.canOnlyEditOwnStreams': 'Vous ne pouvez modifier que vos propres diffusions', 'alert.invalidStreamData': 'Données de diffusion invalides', 'alert.enterValidGoalAmount': 'Veuillez entrer un montant d\'objectif valide', 'alert.canOnlyResetOwnGoals': 'Vous ne pouvez réinitialiser que vos propres objectifs', 'alert.streamEventNotFound': 'Événement de diffusion introuvable', 'alert.failedResetZapGoal': 'Échec de la réinitialisation de l\'objectif zap. Veuillez réessayer.', 'alert.cannotBlockAdmin': 'Impossible de bloquer le compte admin', 'alert.analyticsLoadFailed': 'Échec du chargement des statistiques. Veuillez réessayer.', 'alert.cannotReplaceShortWithVideo': 'Impossible de remplacer un Short par une vidéo normale. Veuillez télécharger une vidéo verticale (60 secondes ou moins).', 'alert.cannotReplaceVideoWithShort': 'Impossible de remplacer une vidéo par un Short. Veuillez télécharger une vidéo horizontale.', 'alert.shortsRequireVertical': 'Cette vidéo semble être horizontale. Les Shorts doivent être des vidéos verticales. Veuillez utiliser "Télécharger une Vidéo" pour les vidéos horizontales.',
        // New Zap Messages
        'zap.cannotZapYourself': 'Vous ne pouvez pas vous zapper vous-même', 'zap.cannotZapOwnContent': 'Vous ne pouvez pas zapper votre propre contenu', 'zap.cannotZapOwnComment': 'Vous ne pouvez pas zapper votre propre commentaire', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'Chargement de la vidéo...', 'status.loading': 'Chargement...', 'status.compressingProgress': 'Compression... {progress}%', 'status.uploadingProgress': 'Téléchargement... {progress}%', 'status.uploadingServers': 'Téléchargement... ({completed}/{total} serveurs)', 'status.publishedSuccess': '{type} publié avec succès!',
        // New Warnings
        'warning.webmFormat': 'Note: Votre navigateur produira le format WebM (peut ne pas fonctionner sur iOS). Pour MP4 compatible iOS, utilisez Chrome sur Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Dernière mise à jour: Décembre 2024',
        // DMCA Page
        'dmca.title': 'DMCA et Politique de Contenu',
        'dmca.lastUpdated': 'Dernière mise à jour : Décembre 2024',
        'dmca.architectureTitle': 'Comprendre l\'Architecture de Plebs',
        'dmca.architectureDesc': 'Plebs est une interface de plateforme vidéo décentralisée qui fonctionne différemment des services d\'hébergement vidéo traditionnels.',
        'dmca.architectureItem1': 'Plebs n\'héberge aucun contenu vidéo ou image.',
        'dmca.architectureItem1Desc': 'Nous sommes un client/interface qui affiche du contenu stocké ailleurs.',
        'dmca.architectureItem2': 'Tous les fichiers multimédias sont stockés sur des serveurs Blossom indépendants.',
        'dmca.architectureItem3': 'Les métadonnées vidéo sont publiées sur des relais Nostr.',
        'dmca.architectureItem4': 'Plebs agrège et affiche simplement ce contenu distribué.',
        'dmca.filingTitle': 'Déposer une Réclamation DMCA',
        'dmca.filingDesc': 'Puisque Plebs n\'héberge pas de contenu, nous ne pouvons pas supprimer directement le matériel contrefaisant.',
        'dmca.forVideoTitle': '1. Pour le Contenu Vidéo/Image',
        'dmca.forVideoDesc': 'Les fichiers multimédias sont stockés sur des serveurs Blossom.',
        'dmca.forVideoItem1': 'Identifier quel serveur Blossom héberge le contenu',
        'dmca.forVideoItem2': 'Contacter directement l\'opérateur du serveur Blossom',
        'dmca.forVideoItem3': 'Chaque serveur Blossom fonctionne indépendamment',
        'dmca.forMetadataTitle': '2. Pour les Métadonnées/Descriptions',
        'dmca.forMetadataDesc': 'Si le contenu contrefaisant est dans le titre, la description ou autres métadonnées:',
        'dmca.forMetadataItem1': 'Ces informations sont stockées sur les relais Nostr',
        'dmca.forMetadataItem2': 'Contactez les opérateurs de relais Nostr spécifiques',
        'dmca.forMetadataItem3': 'Plusieurs relais peuvent stocker les mêmes données',
        'dmca.whatWeCanDoTitle': 'Ce que Plebs Peut Faire',
        'dmca.whatWeCanDoDesc': 'Bien que nous n\'hébergeons pas de contenu, nous pouvons:',
        'dmca.whatWeCanDoItem1': 'Vous aider à identifier quels serveurs hébergent du contenu spécifique',
        'dmca.whatWeCanDoItem2': 'Ajouter du contenu à une liste de blocage locale',
        'dmca.whatWeCanDoItem3': 'Fournir des conseils pour contacter les opérateurs appropriés',
        'dmca.toRequestAssistance': 'Pour demander de l\'aide, veuillez nous contacter avec:',
        'dmca.assistanceItem1': 'L\'URL ou identifiant du contenu contrefaisant',
        'dmca.assistanceItem2': 'Preuve de votre propriété du droit d\'auteur',
        'dmca.assistanceItem3': 'Une description de l\'œuvre protégée',
        'dmca.blossomOperatorsTitle': 'Opérateurs de Serveurs Blossom',
        'dmca.blossomOperatorsDesc': 'Si vous exploitez un serveur Blossom, vous êtes responsable du traitement des demandes DMCA.',
        'dmca.blossomOperatorsLink': 'Pour une liste des serveurs Blossom connus, consultez la documentation.',
        'dmca.considerationsTitle': 'Considérations Importantes',
        'dmca.considerationsItem1': 'Décentralisation:',
        'dmca.considerationsItem1Desc': 'La suppression complète du contenu peut ne pas être possible.',
        'dmca.considerationsItem2': 'Copies Multiples:',
        'dmca.considerationsItem2Desc': 'Le contenu peut être répliqué sur plusieurs serveurs.',
        'dmca.considerationsItem3': 'Persistance des Métadonnées:',
        'dmca.considerationsItem3Desc': 'Les métadonnées peuvent persister même après suppression.',
        'dmca.considerationsItem4': 'Pas de Contrôle Central:',
        'dmca.considerationsItem4Desc': 'Aucune entité unique ne peut supprimer du contenu de tout le réseau.',
        'dmca.counterNotificationTitle': 'Contre-Notification',
        'dmca.counterNotificationDesc': 'Si vous pensez que votre contenu a été supprimé par erreur, contactez l\'opérateur du serveur.',
        'dmca.contactTitle': 'Contact',
        'dmca.contactDesc': 'Pour des questions, veuillez',
        'dmca.contactLink': 'nous contacter',
        // Admin Dashboard
        'admin.title': 'Tableau de Bord Admin',
        'admin.loading': 'Chargement des analyses...',
        'admin.platformOverview': 'Aperçu de la Plateforme',
        'admin.totalVideos': 'Total des Vidéos',
        'admin.videos7Days': 'Vidéos (7 jours)',
        'admin.videos30Days': 'Vidéos (30 jours)',
        'admin.uniqueCreators': 'Créateurs Uniques',
        'admin.likes30Days': 'J\'aime (30 jours)',
        'admin.dislikes30Days': 'Je n\'aime pas (30 jours)',
        'admin.monthlyActiveUsers': 'Utilisateurs Actifs Mensuels',
        'admin.mauDesc': 'Utilisateurs uniques ayant téléchargé, réagi ou commenté (6 derniers mois)',
        'admin.boostRevenue': 'Revenus Boost (30 Derniers Jours)',
        'admin.totalBoostRevenue': 'Revenus Boost Totaux',
        'admin.totalBoosts': 'Total des Boosts',
        'admin.blocklistManagement': 'Gestion de la Liste de Blocage',
        'admin.blocklistDesc': 'Bloquer des vidéos ou utilisateurs spécifiques.',
        'admin.blockedVideos': 'Vidéos Bloquées',
        'admin.blockedUsers': 'Utilisateurs Bloqués',
        'admin.blockByEventId': 'Bloquer Vidéo par ID',
        'admin.blockByPubkey': 'Bloquer Utilisateur par Pubkey',
        'admin.blockVideo': 'Bloquer Vidéo',
        'admin.blockUser': 'Bloquer Utilisateur',
        'admin.noBlockedVideos': 'Aucune vidéo bloquée',
        'admin.noBlockedUsers': 'Aucun utilisateur bloqué',
        'admin.unblock': 'Débloquer',
        'admin.accessDenied': 'Accès refusé. Admin uniquement.',
        // Search/Trending/Channel/Buttons/Common
        'search.noVideosFound': 'Aucune vidéo trouvée pour "{query}".',
        'search.noFullLengthVideos': 'Aucune vidéo longue trouvée pour "{query}".',
        'trending.noVideosToday': 'Pas de vidéos tendance aujourd\'hui.',
        'trending.noVideosThisWeek': 'Pas de vidéos tendance cette semaine.',
        'channel.video': 'vidéo',
        'channel.videos': 'vidéos',
        'channel.follower': 'abonné',
        'channel.followers': 'abonnés',
        'button.follow': 'Suivre',
        'button.following': 'Abonné',
        'button.unfollow': 'Se désabonner',
        'button.mute': 'Masquer',
        'button.unmute': 'Afficher',
        'button.report': 'Signaler',
        'button.muteUser': 'Masquer l\'utilisateur',
        'button.unmuteUser': 'Afficher l\'utilisateur',
        'button.reportComment': 'Signaler le commentaire',
        'button.reportUser': 'Signaler cet utilisateur',
        'live.goalReached': 'Objectif Atteint!',
        'live.goalProgress': '{percent}% de l\'objectif',
        'common.loading': 'Chargement...',
        'common.sats': 'sats',
        // Analytics Page
        'analytics.title': 'Analytiques de la Chaîne',
        'analytics.loading': 'Chargement de vos analytiques...',
        'analytics.loadFailed': 'Échec du chargement des analytiques. Veuillez réessayer.',
        'analytics.overview': 'Aperçu',
        'analytics.views': 'Vues',
        'analytics.followers': 'Abonnés',
        'analytics.topByViews': 'Meilleures Vidéos par Vues',
        'analytics.topByEngagement': 'Meilleures Vidéos par Engagement',
        'analytics.allContent': 'Performance de Tout le Contenu',
        'analytics.totalViews': 'Vues Totales',
        'analytics.likes': 'J\'aime',
        'analytics.likesRatio': 'J\'aime ({ratio}% ratio)',
        'analytics.dislikes': 'Je n\'aime pas',
        'analytics.zapsReceived': '{count} Zaps Reçus',
        'analytics.boostsReceived': 'Boosts Reçus',
        'analytics.shares': 'Partages',
        'analytics.comments': 'Commentaires',
        'analytics.contentCount': '{videos} Vidéos, {shorts} Shorts, {streams} Streams',
        'analytics.last7days': '7 derniers jours',
        'analytics.last30days': '30 derniers jours',
        'analytics.last90days': '90 derniers jours',
        'analytics.lastYear': 'Dernière année',
        'analytics.allTime': 'Tout le temps',
        'analytics.lastNDays': '{n} derniers jours',
        'analytics.netGrowth': 'Croissance Nette',
        'analytics.newFollowers': 'Nouveaux Abonnés',
        'analytics.unfollowed': 'Désabonnements',
        'analytics.noVideosYet': 'Pas encore de vidéos',
        'analytics.noShortsYet': 'Pas encore de shorts',
        'analytics.noStreamsYet': 'Pas encore de streams',
        'analytics.viewsTooltip': '{count} vues',
        'analytics.subscribersTooltip': '{count} abonnés',
        'analytics.videosTab': 'Vidéos ({count})',
        'analytics.shortsTab': 'Shorts ({count})',
        'analytics.streamsTab': 'Streams ({count})',
        // About Page
        'about.title': 'À Propos de Plebs',
        'about.whatIs': 'Qu\'est-ce que Plebs?',
        'about.whatIsDesc': 'Plebs est une plateforme vidéo décentralisée et résistante à la censure construite sur le <a href="https://nostr.com" target="_blank" rel="noopener">protocole Nostr</a>. Contrairement aux plateformes traditionnelles contrôlées par des entreprises, Plebs vous donne la vraie propriété de votre contenu et identité.',
        'about.whyNostr': 'Pourquoi Nostr?',
        'about.whyNostrDesc': 'Nostr (Notes and Other Stuff Transmitted by Relays) est un protocole simple et ouvert qui permet un réseau social vraiment décentralisé. Les avantages clés incluent:',
        'about.benefit1': 'Résistance à la Censure:',
        'about.benefit1Desc': 'Aucune entité ne peut vous bannir ou supprimer votre contenu',
        'about.benefit2': 'Portabilité:',
        'about.benefit2Desc': 'Votre identité et abonnés fonctionnent sur toutes les apps Nostr',
        'about.benefit3': 'Pas d\'Autorité Centrale:',
        'about.benefit3Desc': 'Aucune entreprise ne possède ou contrôle le réseau',
        'about.benefit4': 'Identité Cryptographique:',
        'about.benefit4Desc': 'Vos clés prouvent que vous êtes qui vous dites être',
        'about.howItWorks': 'Comment Ça Marche',
        'about.howItWorksDesc': 'Les vidéos sur Plebs sont stockées en utilisant <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom</a>, un système de stockage distribué, tandis que les métadonnées et interactions sociales sont diffusées aux relais Nostr. Cela signifie que votre contenu n\'est pas stocké sur nos serveurs - il est distribué sur le réseau.',
        'about.features': 'Fonctionnalités',
        'about.feature1': 'Téléchargez et partagez des vidéos avec la communauté Nostr',
        'about.feature2': 'Aimez, commentez et partagez des vidéos avec les réactions Nostr',
        'about.feature3': 'Envoyez des Zaps aux créateurs avec Bitcoin via Lightning Network',
        'about.feature4': 'Suivez vos créateurs préférés sur n\'importe quelle app Nostr',
        'about.feature5': 'Parcourez les sujets et découvrez du nouveau contenu',
        'about.feature6': 'Fonctionne avec n\'importe quelle identité Nostr (utilisez vos clés existantes)',
        'about.openSource': 'Open Source',
        'about.openSourceDesc': 'Plebs est un logiciel open source. Vous pouvez voir le code, contribuer ou exécuter votre propre instance:',
        'about.githubRepo': 'Dépôt GitHub',
        'about.builtBy': 'Développé Par',
        'about.builtByDesc': 'Plebs est développé par <a href="https://nostrservices.com" target="_blank" rel="noopener" class="accent-link">21 Million LLC</a>, une entreprise dédiée à la création d\'outils pour l\'écosystème Bitcoin et Nostr.',
        // Contact Page
        'contact.title': 'Contactez-nous',
        'contact.getInTouch': 'Entrer en Contact',
        'contact.getInTouchDesc': 'Vous avez des questions, des commentaires ou besoin d\'aide? Nous serions ravis de vous entendre!',
        'contact.email': 'Email',
        'contact.emailDesc': 'La meilleure façon de nous contacter est par email:',
        'contact.github': 'GitHub',
        'contact.githubDesc': 'Pour signaler des bugs, demander des fonctionnalités ou des problèmes techniques, ouvrez un issue sur notre dépôt:',
        'contact.githubIssues': 'Issues GitHub',
        'contact.company': 'Entreprise',
        'contact.companyDesc': 'Plebs est développé par 21 Million LLC',
        // Terms of Service
        'terms.title': 'Conditions d\'Utilisation',
        'terms.lastUpdated': 'Dernière mise à jour: Décembre 2024',
        'terms.section1Title': '1. Acceptation des Conditions',
        'terms.section1Desc': 'En accédant et en utilisant Plebs ("le Service"), vous acceptez d\'être lié par ces Conditions d\'Utilisation. Si vous n\'acceptez pas ces conditions, veuillez ne pas utiliser le Service.',
        'terms.section2Title': '2. Description du Service',
        'terms.section2Desc': 'Plebs est une plateforme vidéo décentralisée construite sur le protocole Nostr. Le Service fournit une interface pour parcourir, télécharger et interagir avec du contenu vidéo stocké sur des réseaux distribués. Plebs n\'héberge pas et ne stocke pas de contenu vidéo sur des serveurs centralisés.',
        'terms.section3Title': '3. Responsabilités de l\'Utilisateur',
        'terms.section3Desc': 'Vous êtes responsable de:',
        'terms.section3Item1': 'Maintenir la sécurité de vos clés privées Nostr',
        'terms.section3Item2': 'Tout le contenu que vous téléchargez ou partagez via le Service',
        'terms.section3Item3': 'Assurer que votre utilisation respecte les lois applicables',
        'terms.section3Item4': 'Ne pas télécharger de contenu illégal, contrefait ou nuisible',
        'terms.section4Title': '4. Directives de Contenu',
        'terms.section4Desc': 'Vous acceptez de ne pas télécharger, partager ou distribuer:',
        'terms.section4Item1': 'Contenu qui viole les droits de propriété intellectuelle',
        'terms.section4Item2': 'Contenu illégal y compris mais non limité au matériel d\'exploitation d\'enfants',
        'terms.section4Item3': 'Contenu qui promeut la violence ou le mal envers autrui',
        'terms.section4Item4': 'Spam, malware ou contenu trompeur',
        'terms.section4Note': 'Le contenu adulte (NSFW) doit être correctement étiqueté en utilisant le tag NSFW lors du téléchargement.',
        'terms.section5Title': '5. Nature Décentralisée',
        'terms.section5Desc': 'En raison de la nature décentralisée de Nostr et du stockage Blossom:',
        'terms.section5Item1': 'Le contenu peut persister sur le réseau même après les demandes de suppression',
        'terms.section5Item2': 'Nous ne pouvons pas garantir la suppression du contenu de tous les relais ou serveurs de stockage',
        'terms.section5Item3': 'Votre contenu et interactions sont publics par défaut',
        'terms.section5Item4': 'Vous êtes seul responsable de la sécurité de votre clé privée',
        'terms.section6Title': '6. Aucune Garantie',
        'terms.section6Desc': 'Le Service est fourni "tel quel" sans garanties d\'aucune sorte. Nous ne garantissons pas un accès continu et ininterrompu au Service.',
        'terms.section7Title': '7. Limitation de Responsabilité',
        'terms.section7Desc': 'Dans la mesure maximale permise par la loi, Plebs et ses opérateurs ne seront pas responsables de tout dommage indirect, accessoire, spécial ou consécutif découlant de votre utilisation du Service.',
        'terms.section8Title': '8. Modifications des Conditions',
        'terms.section8Desc': 'Nous nous réservons le droit de modifier ces conditions à tout moment. L\'utilisation continue du Service après les modifications constitue l\'acceptation des nouvelles conditions.',
        'terms.section9Title': '9. Contact',
        'terms.section9Desc': 'Pour des questions sur ces Conditions, veuillez <a href="#/contact" class="accent-link">nous contacter</a>.',
        // Privacy Policy
        'privacy.title': 'Politique de Confidentialité',
        'privacy.lastUpdated': 'Dernière mise à jour: Décembre 2024',
        'privacy.section1Title': '1. Aperçu',
        'privacy.section1Desc': 'Plebs s\'engage à protéger votre vie privée. Cette politique explique comment nous traitons les informations lorsque vous utilisez notre plateforme vidéo décentralisée.',
        'privacy.section2Title': '2. Architecture Décentralisée',
        'privacy.section2Desc': 'Plebs est construit sur Nostr, un protocole décentralisé. Cela signifie:',
        'privacy.section2Item1': 'Votre contenu est diffusé aux relais publics, pas stocké sur nos serveurs',
        'privacy.section2Item2': 'Votre clé publique Nostr sert d\'identité',
        'privacy.section2Item3': 'Les vidéos sont stockées sur des serveurs Blossom distribués',
        'privacy.section2Item4': 'Nous n\'avons pas accès à vos clés privées',
        'privacy.section3Title': '3. Informations que Nous Collectons',
        'privacy.section3LocalTitle': 'Informations stockées localement dans votre navigateur:',
        'privacy.section3LocalItem1': 'Votre clé publique Nostr (une fois connecté)',
        'privacy.section3LocalItem2': 'Historique de visionnage et préférences',
        'privacy.section3LocalItem3': 'Préférences de thème et paramètres',
        'privacy.section3LocalItem4': 'Clé privée (uniquement si vous choisissez le stockage local - non recommandé)',
        'privacy.section3CollectTitle': 'Informations que nous pouvons collecter:',
        'privacy.section3CollectItem1': 'Analytiques de base (pages vues, utilisation des fonctionnalités) pour améliorer le service',
        'privacy.section3CollectItem2': 'Journaux d\'erreurs pour le débogage',
        'privacy.section4Title': '4. Informations Publiques',
        'privacy.section4Desc': 'Lors de l\'utilisation de Nostr, les éléments suivants sont publics par conception:',
        'privacy.section4Item1': 'Votre clé publique Nostr et informations de profil',
        'privacy.section4Item2': 'Vidéos que vous téléchargez',
        'privacy.section4Item3': 'Commentaires, likes et autres réactions',
        'privacy.section4Item4': 'Qui vous suivez',
        'privacy.section4Item5': 'Zaps (paiements Lightning) que vous envoyez ou recevez',
        'privacy.section5Title': '5. Stockage des Données',
        'privacy.section5Desc': 'Les données locales sont stockées dans le localStorage de votre navigateur. Vous pouvez effacer ces données à tout moment via les paramètres de votre navigateur. Le contenu publié sur Nostr est distribué sur les relais et ne peut pas être contrôlé ou supprimé par Plebs.',
        'privacy.section6Title': '6. Services Tiers',
        'privacy.section6Desc': 'Plebs interagit avec:',
        'privacy.section6Item1': 'Relais Nostr (pour les données sociales)',
        'privacy.section6Item2': 'Serveurs Blossom (pour le stockage vidéo)',
        'privacy.section6Item3': 'Lightning Network (pour les zaps/paiements)',
        'privacy.section6Note': 'Chacun de ces services a ses propres pratiques de confidentialité.',
        'privacy.section7Title': '7. Vos Droits',
        'privacy.section7Desc': 'Vous pouvez:',
        'privacy.section7Item1': 'Effacer vos données locales du navigateur à tout moment',
        'privacy.section7Item2': 'Parcourir les vidéos sans créer de compte',
        'privacy.section7Item3': 'Utiliser une extension de navigateur Nostr pour une confidentialité améliorée',
        'privacy.section7Item4': 'Choisir quels relais et serveurs Blossom utiliser',
        'privacy.section8Title': '8. Sécurité',
        'privacy.section8Desc': 'Nous recommandons:',
        'privacy.section8Item1': 'Utiliser une extension de navigateur Nostr ou un signataire matériel',
        'privacy.section8Item2': 'Ne jamais partager votre clé privée (nsec)',
        'privacy.section8Item3': 'Utiliser un profil de navigateur dédié pour une confidentialité améliorée',
        'privacy.section9Title': '9. Modifications de Cette Politique',
        'privacy.section9Desc': 'Nous pouvons mettre à jour cette politique de temps en temps. Les modifications seront publiées sur cette page avec une date de révision mise à jour.',
        'privacy.section10Title': '10. Contact',
        'privacy.section10Desc': 'Pour des questions relatives à la confidentialité, veuillez <a href="#/contact" class="accent-link">nous contacter</a>.',
        // FAQ Page
        'faq.title': 'Questions Fréquemment Posées',
        'faq.aboutPlebs': 'À Propos de Plebs',
        'faq.nostrProtocol': 'Protocole Nostr',
        'faq.videoStorage': 'Stockage Vidéo et Blossom',
        'faq.featuresUsage': 'Fonctionnalités et Utilisation',
        'faq.q1': 'Qu\'est-ce que Plebs?',
        'faq.a1': 'Plebs est une plateforme vidéo décentralisée et résistante à la censure construite sur le protocole Nostr. Contrairement aux plateformes traditionnelles contrôlées par des entreprises, Plebs vous donne la vraie propriété de votre contenu et identité. Il n\'y a pas de serveurs centraux qui peuvent vous bannir ou supprimer votre contenu.',
        'faq.q2': 'Plebs est-il gratuit?',
        'faq.a2': 'Oui, Plebs est entièrement gratuit pour regarder des vidéos. Vous pouvez parcourir et regarder du contenu sans créer de compte. Pour télécharger des vidéos, commenter, aimer ou interagir avec d\'autres utilisateurs, vous aurez besoin d\'une identité Nostr (qui est également gratuite).',
        'faq.q3': 'Qui développe Plebs?',
        'faq.a3': 'Plebs est développé par <a href="https://nostrservices.com" target="_blank" rel="noopener">21 Million LLC</a>, une entreprise dédiée à la création d\'outils pour l\'écosystème Bitcoin et Nostr. Plebs est open source, et vous pouvez voir le code ou contribuer sur <a href="https://github.com/Spl0itable/plebs-app" target="_blank" rel="noopener">GitHub</a>.',
        'faq.q4': 'Qu\'est-ce que Nostr?',
        'faq.a4': 'Nostr signifie "Notes and Other Stuff Transmitted by Relays." C\'est un protocole simple et ouvert qui permet un réseau social vraiment décentralisé. Contrairement aux plateformes traditionnelles, Nostr ne dépend d\'aucun serveur central. Au lieu de cela, il utilise un réseau de relais pour transmettre des messages entre utilisateurs, et des clés cryptographiques pour l\'identité.',
        'faq.q5': 'Pourquoi Plebs utilise-t-il Nostr?',
        'faq.a5Title': 'Nostr offre plusieurs avantages clés:',
        'faq.a5Item1': 'Résistance à la Censure:',
        'faq.a5Item1Desc': 'Aucune entité ne peut vous bannir ou supprimer votre contenu',
        'faq.a5Item2': 'Portabilité:',
        'faq.a5Item2Desc': 'Votre identité et abonnés fonctionnent sur toutes les apps Nostr',
        'faq.a5Item3': 'Pas d\'Autorité Centrale:',
        'faq.a5Item3Desc': 'Aucune entreprise ne possède ou contrôle le réseau',
        'faq.a5Item4': 'Identité Cryptographique:',
        'faq.a5Item4Desc': 'Vos clés prouvent que vous êtes qui vous dites être',
        'faq.q6': 'Que sont les clés Nostr (npub/nsec)?',
        'faq.a6': 'Votre identité Nostr se compose de deux clés: une clé publique (npub) et une clé privée (nsec). Votre npub est comme votre nom d\'utilisateur - vous pouvez la partager avec n\'importe qui. Votre nsec est comme votre mot de passe - ne la partagez jamais! Quiconque ayant votre nsec peut publier en votre nom et accéder à votre compte. Nous recommandons d\'utiliser une extension de navigateur comme Alby ou nos2x pour gérer vos clés en toute sécurité.',
        'faq.q7': 'Puis-je utiliser mon compte Nostr existant?',
        'faq.a7': 'Absolument! Si vous avez déjà une identité Nostr d\'apps comme Damus, Primal, Amethyst ou tout autre client Nostr, vous pouvez utiliser les mêmes clés pour vous connecter à Plebs. Vos abonnés, profil et réputation se transfèrent automatiquement.',
        'faq.q8': 'Que sont les relais Nostr?',
        'faq.a8': 'Les relais sont des serveurs qui stockent et transmettent les messages Nostr. Lorsque vous publiez quelque chose, il est envoyé à plusieurs relais. D\'autres utilisateurs se connectent aux relais pour lire les messages. Parce qu\'il y a de nombreux relais indépendants, aucun ne peut vous censurer - si un relais vous bloque, votre contenu existe toujours sur d\'autres.',
        'faq.q9': 'Où sont stockées les vidéos?',
        'faq.a9': 'Les vidéos sont stockées sur des serveurs Blossom, pas sur Plebs lui-même. Blossom est un système de stockage distribué conçu pour fonctionner avec Nostr. Lorsque vous téléchargez une vidéo, elle va sur un ou plusieurs serveurs Blossom de votre choix. Les métadonnées vidéo (titre, description, etc.) sont publiées sur les relais Nostr.',
        'faq.q10': 'Qu\'est-ce que Blossom?',
        'faq.a10': 'Blossom est un protocole ouvert pour stocker et servir des fichiers multimédias de manière décentralisée. Les fichiers sont identifiés par leur hash SHA-256, ce qui signifie que le même fichier aura la même adresse quel que soit le serveur qui l\'héberge. Cela permet la redondance - vos fichiers peuvent exister sur plusieurs serveurs. En savoir plus sur <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom GitHub</a>.',
        'faq.q11': 'Plebs héberge-t-il mes vidéos?',
        'faq.a11': 'Non. Plebs est un client/interface qui vous aide à parcourir et télécharger du contenu, mais il ne stocke aucun fichier vidéo ou image. Tous les médias sont stockés sur des serveurs Blossom indépendants. Plebs affiche simplement le contenu de ces fournisseurs de stockage distribués.',
        'faq.q12': 'Puis-je choisir quel serveur Blossom utiliser?',
        'faq.a12': 'Oui! Vous pouvez configurer quels serveurs Blossom vous voulez utiliser pour le téléchargement dans vos paramètres. Vous pouvez même exécuter votre propre serveur Blossom si vous voulez un contrôle complet sur votre stockage multimédia.',
        'faq.q13': 'Comment créer un compte?',
        'faq.a13Title': 'Cliquez sur le bouton "Connexion" et choisissez votre méthode préférée:',
        'faq.a13Item1': 'Extension de Navigateur:',
        'faq.a13Item1Desc': 'Si vous avez une extension Nostr comme Alby ou nos2x installée, vous pouvez l\'utiliser pour vous connecter en toute sécurité',
        'faq.a13Item2': 'Générer de Nouvelles Clés:',
        'faq.a13Item2Desc': 'Créer une toute nouvelle identité Nostr',
        'faq.a13Item3': 'Importer des Clés:',
        'faq.a13Item3Desc': 'Utiliser votre clé privée Nostr existante (nsec)',
        'faq.a13Note': 'Nous recommandons d\'utiliser une extension de navigateur pour la meilleure sécurité.',
        'faq.q14': 'Que sont les Zaps?',
        'faq.a14': 'Les Zaps sont des paiements Bitcoin envoyés via le Lightning Network. Ils vous permettent d\'envoyer de l\'argent réel (satoshis, ou "sats") aux créateurs de contenu comme pourboires ou appréciation. Contrairement aux pourboires traditionnels des plateformes qui prennent de gros frais, les zaps vont directement au créateur. Pour envoyer des zaps, vous avez besoin d\'un portefeuille Lightning avec une connexion Nostr (comme Alby ou Zeus).',
        'faq.q15': 'Comment télécharger une vidéo?',
        'faq.a15Title': 'Pour télécharger une vidéo:',
        'faq.a15Item1': 'Connectez-vous avec votre identité Nostr',
        'faq.a15Item2': 'Cliquez sur le bouton "Créer" et sélectionnez "Télécharger Vidéo"',
        'faq.a15Item3': 'Sélectionnez votre fichier vidéo (supporte la plupart des formats courants)',
        'faq.a15Item4': 'Ajoutez un titre, une description et des tags',
        'faq.a15Item5': 'Cliquez sur "Publier" pour partager avec le réseau',
        'faq.a15Note': 'Les vidéos sont automatiquement compressées et téléchargées vers les serveurs Blossom.',
        // FAQ Self-Moderation Section
        'faq.selfModeration': 'Auto-Modération',
        'faq.q16': 'Comment fonctionne la modération sur une plateforme décentralisée?',
        'faq.a16': 'Contrairement aux plateformes traditionnelles avec des modérateurs centralisés, Plebs vous met en contrôle de ce que vous voyez. Nous fournissons des outils d\'auto-modération puissants incluant des packs de filtres de contenu, la mise en sourdine d\'utilisateurs, des avertissements de la communauté et des indicateurs de vidéos fortement négativées. Vous décidez quel contenu est approprié pour vous - il n\'y a pas d\'autorité centrale prenant ces décisions.',
        'faq.q17': 'Que sont les Packs de Filtres de Contenu?',
        'faq.a17Intro': 'Les Packs de Filtres de Contenu sont des filtres de mots-clés prédéfinis que vous pouvez activer pour masquer des types spécifiques de contenu. Les packs disponibles incluent:',
        'faq.a17Pack1': 'Racisme et Discours de Haine:',
        'faq.a17Pack1Desc': 'Filtre les insultes raciales et le contenu discriminatoire',
        'faq.a17Pack2': 'Sexuellement Explicite:',
        'faq.a17Pack2Desc': 'Filtre le contenu pornographique et pour adultes',
        'faq.a17Pack3': 'Violence et Gore:',
        'faq.a17Pack3Desc': 'Filtre la violence graphique et le contenu d\'automutilation',
        'faq.a17Pack4': 'Drogues et Substances:',
        'faq.a17Pack4Desc': 'Filtre le contenu lié aux drogues',
        'faq.a17Pack5': 'Spam et Arnaques:',
        'faq.a17Pack5Desc': 'Filtre les modèles courants de spam et d\'arnaques',
        'faq.a17Pack6': 'Cryptomonnaie:',
        'faq.a17Pack6Desc': 'Filtre la promotion de crypto et le shilling de tokens',
        'faq.a17Pack7': 'Contenu Politique:',
        'faq.a17Pack7Desc': 'Filtre le contenu politique partisan',
        'faq.a17Pack8': 'Langage Grossier:',
        'faq.a17Pack8Desc': 'Filtre le langage vulgaire',
        'faq.a17Note': 'Activez-les dans Paramètres > Filtres de Contenu. Vous pouvez également ajouter des mots-clés personnalisés. Le contenu filtré affiche un espace réservé avec un bouton "Afficher quand même" si vous souhaitez le voir temporairement.',
        'faq.q18': 'Comment mettre un utilisateur en sourdine?',
        'faq.a18': 'Pour mettre un utilisateur en sourdine, visitez son profil et cliquez sur le bouton de mise en sourdine. Une fois en sourdine, toutes leurs vidéos seront cachées de votre flux, leurs commentaires s\'afficheront comme "Message d\'un utilisateur en sourdine" et leurs messages de chat en direct seront masqués. Votre liste de mise en sourdine est stockée sur Nostr, elle se synchronise donc entre les appareils. Vous pouvez gérer les utilisateurs en sourdine dans les Paramètres de votre Profil sous "Utilisateurs en Sourdine".',
        'faq.q19': 'Que signifie "Ratioed"?',
        'faq.a19': 'Une vidéo est marquée comme "ratioed" lorsqu\'elle a significativement plus de je n\'aime pas que de j\'aime, indiquant une réception négative de la communauté. Spécifiquement, une vidéo est ratioed lorsqu\'elle a au moins 10 réactions, les je n\'aime pas sont au moins le double des j\'aime, et les je n\'aime pas représentent 70% ou plus des réactions totales. Les vidéos ratioed affichent un badge d\'avertissement, et vous serez invité à confirmer avant de voir.',
        'faq.q20': 'Comment fonctionnent les avertissements de la communauté?',
        'faq.a20': 'Les utilisateurs peuvent signaler du contenu pour diverses raisons (spam, contenu illégal, abus, trompeur, etc.). Lorsqu\'une vidéo ou un utilisateur reçoit 5 signalements ou plus de personnes que vous suivez, un indicateur d\'avertissement apparaît. Cela exploite votre graphe social - les avertissements proviennent de votre réseau de confiance, pas d\'inconnus anonymes. Vous pouvez activer "Afficher les avertissements des comptes que je suis" dans les Paramètres.',
        'faq.q21': 'Comment signaler du contenu?',
        'faq.a21': 'Cliquez sur l\'icône de drapeau sur n\'importe quelle vidéo, commentaire ou profil d\'utilisateur pour le signaler. Sélectionnez une raison (Spam, Illégal, Abus, Trompeur, Usurpation d\'identité, Droits d\'auteur ou Autre) et ajoutez éventuellement des détails. Les signalements sont publiés sur Nostr en tant qu\'événements, les rendant transparents et décentralisés. Vos signalements aident les autres dans votre réseau à identifier le contenu problématique.',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': 'Confidentialité et Sécurité',
        'faq.q22': 'Mon activité est-elle privée?',
        'faq.a22': 'Sur Nostr, la plupart des activités sont publiques par conception. Vos j\'aime, commentaires, abonnements et zaps sont visibles sur le réseau public. Cependant, Plebs stocke votre historique de visionnage localement dans votre navigateur - il n\'est jamais envoyé à un serveur. Vous pouvez effacer vos données locales à tout moment.',
        'faq.q23': 'Comment garder mon compte sécurisé?',
        'faq.a23': 'Ne partagez jamais votre clé privée (nsec) avec quiconque. Nous recommandons fortement d\'utiliser une extension de navigateur Nostr comme Alby, nos2x ou un signataire matériel. Ceux-ci gardent votre clé privée sécurisée et ne signent les événements que lorsque vous les approuvez. Évitez de stocker votre nsec directement dans les sites web.',
        'faq.q24': 'Puis-je supprimer mon contenu?',
        'faq.a24': 'Vous pouvez demander la suppression en publiant un événement de suppression sur Nostr. La plupart des relais et clients bien comportés respecteront cela. Cependant, en raison de la nature décentralisée du réseau, le contenu peut persister sur certains relais ou serveurs Blossom. Il n\'y a pas d\'autorité centrale qui peut forcer la suppression complète sur l\'ensemble du réseau.',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': 'Dépannage',
        'faq.q25': 'Les vidéos ne se chargent pas - que dois-je faire?',
        'faq.a25Intro': 'Si les vidéos ne se chargent pas, essayez ces étapes:',
        'faq.a25Item1': 'Actualisez la page',
        'faq.a25Item2': 'Vérifiez votre connexion Internet',
        'faq.a25Item3': 'Le serveur Blossom hébergeant la vidéo pourrait être hors ligne - ceci est indépendant de Plebs',
        'faq.a25Item4': 'Essayez de désactiver les extensions de navigateur qui pourraient bloquer le contenu',
        'faq.a25Item5': 'Effacez le cache de votre navigateur et réessayez',
        'faq.q26': 'J\'ai perdu ma clé privée - pouvez-vous m\'aider à la récupérer?',
        'faq.a26': 'Malheureusement, non. Les clés Nostr sont cryptographiques - il n\'y a pas de réinitialisation de mot de passe ni de récupération de compte car il n\'y a pas d\'autorité centrale. C\'est pourquoi nous recommandons fortement de sauvegarder vos clés et d\'utiliser une solution de gestion de clés sécurisée. Si vous perdez votre nsec, vous devrez créer une nouvelle identité.',
        'faq.q27': 'Comment signaler un bug ou demander une fonctionnalité?',
        'faq.a27': 'Vous pouvez signaler des bugs ou demander des fonctionnalités sur notre page <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a>. Vous pouvez également nous contacter sur Nostr - visitez notre page <a href="#/contact">Contact</a> pour plus de détails.',
        // Page Titles
        'pageTitle.following': 'Abonnements', 'pageTitle.myVideos': 'Mes Vidéos', 'pageTitle.likedVideos': 'Vidéos Aimées', 'pageTitle.watchHistory': 'Historique de Visionnage', 'pageTitle.liveStreams': 'Diffusions en Direct', 'pageTitle.suffix': '- Plebs', 'pageTitle.liveSuffix': '- En Direct sur Plebs',
        // Home Page Sections
        'section.trending': 'Tendances', 'section.recommended': 'Recommandé Pour Vous', 'section.shorts': 'Shorts', 'section.live': 'En Direct', 'section.liveNow': 'En Direct Maintenant', 'section.latestVideos': 'Dernières Vidéos', 'section.videos': 'Vidéos', 'section.usersYouFollow': 'Utilisateurs Que Vous Suivez',
        // Trending Period
        'trending.thisWeek': 'Cette Semaine', 'trending.today': 'Aujourd\'hui',
        // Buttons
        'button.viewMore': 'Voir Plus', 'button.clearAll': 'Tout Effacer', 'button.showAnyway': 'Afficher quand même',
        // Confirmation Modals
        'confirm.logout': 'Déconnexion', 'confirm.logoutMessage': 'Êtes-vous sûr de vouloir vous déconnecter?', 'confirm.resetSettings': 'Réinitialiser les Paramètres', 'confirm.resetSettingsMessage': 'Êtes-vous sûr de vouloir réinitialiser tous les paramètres aux valeurs par défaut?', 'confirm.reset': 'Réinitialiser', 'confirm.clearHistory': 'Effacer l\'Historique', 'confirm.clearHistoryMessage': 'Êtes-vous sûr de vouloir effacer tout votre historique de visionnage? Cette action ne peut pas être annulée.', 'confirm.deleteDraft': 'Supprimer le Brouillon', 'confirm.deleteDraftMessage': 'Êtes-vous sûr de vouloir supprimer ce brouillon?', 'confirm.delete': 'Supprimer', 'confirm.deleteVideo': 'Supprimer la Vidéo', 'confirm.deleteVideoMessage': 'Êtes-vous sûr de vouloir supprimer cette vidéo? Cette action ne peut pas être annulée.', 'confirm.endStream': 'Terminer la Diffusion en Direct', 'confirm.endStreamMessage': 'Êtes-vous sûr de vouloir terminer cette diffusion en direct? Cette action ne peut pas être annulée.', 'confirm.endStreamButton': 'Terminer la Diffusion',
        // Content Filters
        'filter.hiddenByPack': 'Masqué par {pack}', 'filter.showAnyway': 'Afficher quand même', 'filter.contentHidden': 'Contenu masqué par filtre de contenu',
        // Filter Packs
        'filter.racism': 'Racisme et Discours de Haine', 'filter.racismDesc': 'Filtre les insultes raciales, le discours de haine ethnique et le contenu discriminatoire', 'filter.sexualExplicit': 'Sexuellement Explicite', 'filter.sexualExplicitDesc': 'Filtre les termes pornographiques et le contenu sexuellement explicite', 'filter.violence': 'Violence et Gore', 'filter.violenceDesc': 'Filtre la violence graphique, le gore et les menaces violentes', 'filter.drugs': 'Drogues et Substances', 'filter.drugsDesc': 'Filtre le contenu lié aux drogues et l\'abus de substances', 'filter.spam': 'Spam et Arnaques', 'filter.spamDesc': 'Filtre le spam courant, les arnaques et le contenu promotionnel', 'filter.crypto': 'Cryptomonnaie', 'filter.cryptoDesc': 'Filtre la promotion de cryptomonnaies, les signaux de trading et la promotion de tokens', 'filter.politics': 'Contenu Politique', 'filter.politicsDesc': 'Filtre le contenu politique partisan et la rhétorique divisive', 'filter.profanity': 'Langage Grossier', 'filter.profanityDesc': 'Filtre les gros mots et le langage vulgaire', 'filter.customFilter': 'Filtre Personnalisé',
        // Following Page
        'following.noFollowingYet': 'Vous ne suivez personne encore. Trouvez des créateurs à suivre!',
    },
    de: {
        // Navigation & Header
        'nav.home': 'Startseite', 'nav.following': 'Abonniert', 'nav.myVideos': 'Meine Videos', 'nav.liked': 'Gefällt mir', 'nav.history': 'Verlauf', 'nav.topics': 'THEMEN', 'nav.live': 'Live', 'nav.bitcoin': 'Bitcoin', 'nav.nostr': 'Nostr', 'nav.technology': 'Technologie', 'nav.gaming': 'Gaming', 'nav.tutorials': 'Tutorials', 'nav.podcasts': 'Podcasts', 'nav.music': 'Musik', 'nav.nsfw': 'NSFW', 'nav.about': 'Über', 'nav.contact': 'Kontakt', 'nav.terms': 'AGB', 'nav.privacy': 'Datenschutz', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.playlists': 'Playlists', 'nav.downloads': 'Downloads', 'nav.subscriptions': 'Abonnements', 'nav.trending': 'Trends', 'nav.explore': 'Entdecken', 'nav.categories': 'Kategorien', 'nav.liveStreams': 'Live-Streams', 'nav.github': 'GitHub',
        'header.search': 'Videos suchen...', 'header.notifications': 'Benachrichtigungen', 'header.settings': 'Einstellungen', 'header.create': 'Erstellen', 'header.admin': 'Admin', 'header.viewProfile': 'Profil anzeigen', 'header.logout': 'Abmelden',
        // Login Modal
        'login.title': 'Mit Nostr anmelden', 'login.extension': 'Mit Erweiterung anmelden', 'login.extensionDesc': 'Verwenden Sie Alby, nos2x oder andere Nostr-Erweiterungen', 'login.connect': 'Nostr Connect', 'login.connectDesc': 'Mit Remote-Signern wie Amber, nsec.app verbinden', 'login.privateKey': 'Privater Schlüssel', 'login.privateKeyDesc': 'Geben Sie Ihren nsec oder hex-Schlüssel ein (nur lokal)', 'login.newToNostr': 'Neu bei Nostr?', 'login.createAccount': 'Konto erstellen', 'login.createAccountDesc': 'Starten Sie mit einer neuen Nostr-Identität für Plebs',
        // Connect Modal
        'connect.title': 'Mit Nostr verbinden', 'connect.option1': 'Option 1: Verwenden Sie diese Verbindungszeichenfolge', 'connect.option1Desc': 'Kopieren Sie dies in eine NIP-46 kompatible App (nsec.app, Amber, etc.)', 'connect.copyString': 'Verbindungsstring kopieren', 'connect.showQR': 'QR-Code anzeigen', 'connect.listening': 'Warte auf Verbindung...', 'connect.option2': 'Option 2: Bunker-URL einfügen', 'connect.option2Desc': 'Falls Sie bereits eine bunker:// URL von einem Remote-Signer haben', 'connect.withBunker': 'Mit Bunker verbinden', 'connect.or': 'ODER', 'connect.bunkerPlaceholder': 'bunker://...',
        // Private Key Modal
        'privateKey.title': 'Mit privatem Schlüssel anmelden', 'privateKey.warning': 'Sicherheitswarnung', 'privateKey.warningText': 'Ihr privater Schlüssel wird lokal in Ihrem Browser gespeichert. Für mehr Sicherheit verwenden Sie eine Browsererweiterung oder Nostr Connect.', 'privateKey.label': 'Privater Schlüssel (nsec oder hex)', 'privateKey.showKey': 'Schlüssel anzeigen', 'privateKey.login': 'Anmelden', 'privateKey.placeholder': 'nsec1...',
        // Signup Modal
        'signup.title': 'Nostr-Konto erstellen', 'signup.whatIsNostr': 'Was ist Nostr?', 'signup.nostrExplanation': 'Nostr ist ein dezentrales soziales Protokoll, das Ihnen die Kontrolle über Ihre Identität und Inhalte gibt. Anders als bei herkömmlichen Plattformen kann Sie kein Unternehmen sperren, zensieren oder Ihr Konto schließen.', 'signup.whyPlebs': 'Warum verwendet Plebs Nostr?', 'signup.plebsExplanation': 'Plebs basiert auf Nostr, um zensurresistentes Video-Sharing zu ermöglichen. Ihre Videos, Kommentare und Interaktionen werden in einem Netzwerk von Relays gespeichert, nicht auf unseren Servern.', 'signup.howItWorks': 'So funktioniert es', 'signup.keysIdentity': 'Ihre Schlüssel = Ihre Identität.', 'signup.keysIdentityDesc': 'Sie erhalten einen privaten Schlüssel (nsec), der beweist, dass Sie der Besitzer Ihres Kontos sind.', 'signup.keepSecret': 'Halten Sie Ihren privaten Schlüssel geheim!', 'signup.keepSecretDesc': 'Er ist wie ein Passwort, das niemals zurückgesetzt werden kann.', 'signup.oneIdentity': 'Eine Identität, viele Apps.', 'signup.oneIdentityDesc': 'Verwenden Sie dasselbe Konto auf Damus, Primal, Amethyst und mehr.', 'signup.gotIt': 'Verstanden, Konto erstellen', 'signup.username': 'Benutzername', 'signup.usernamePlaceholder': 'Wählen Sie einen Anzeigenamen', 'signup.about': 'Über mich (optional)', 'signup.aboutPlaceholder': 'Erzählen Sie anderen von sich', 'signup.profilePicture': 'Profilbild (optional)', 'signup.uploadPhoto': 'Foto hochladen', 'signup.remove': 'Entfernen', 'signup.avatarHint': 'Quadratische Bilder funktionieren am besten. Max 5MB.', 'signup.uploading': 'Wird hochgeladen...', 'signup.lightningAddress': 'Lightning-Adresse (optional)', 'signup.lightningPlaceholder': 'du@walletofsatoshi.com', 'signup.lightningHint': 'Fügen Sie eine Lightning-Adresse hinzu, um Zaps (Bitcoin-Trinkgelder) zu erhalten.', 'signup.nostrAddress': 'Nostr-Adresse', 'signup.nostrAddressPlaceholder': 'benutzername', 'signup.nostrAddressHint': 'Ihre Nostr-Adresse erleichtert das Finden Ihres Profils. Nur Kleinbuchstaben, Zahlen, _ und -.', 'signup.nostrAddressRequired': 'Bitte geben Sie eine Nostr-Adresse ein', 'signup.nostrAddressAvailable': 'Verfügbar!', 'signup.nostrAddressUnavailable': 'Bereits vergeben', 'signup.nostrAddressChecking': 'Wird überprüft...', 'signup.nostrAddressInvalid': 'Ungültiges Benutzernamenformat', 'signup.nostrAddressRegistering': 'Nostr-Adresse wird registriert...', 'signup.nostrAddressSuccess': 'Nostr-Adresse registriert!', 'signup.nostrAddressFailed': 'Nostr-Adresse konnte nicht registriert werden', 'signup.yourUsername': 'Ihr Benutzername', 'signup.yourBio': 'Ihre Bio erscheint hier', 'signup.createAccountBtn': 'Konto erstellen', 'signup.termsAgree': 'Mit der Erstellung eines Kontos akzeptieren Sie unsere', 'signup.and': 'und', 'signup.success': 'Konto erfolgreich erstellt!', 'signup.yourPrivateKey': 'Ihr privater Schlüssel (nsec)', 'signup.keyWarning': 'Dies ist die EINZIGE Möglichkeit, auf Ihr Konto zuzugreifen. Bewahren Sie ihn sicher auf!', 'signup.copyPrivateKey': 'Privaten Schlüssel kopieren', 'signup.howToUseKey': 'So verwenden Sie Ihren privaten Schlüssel', 'signup.continueToPlebs': 'Weiter zu Plebs',
        // Notifications
        'notifications.title': 'Benachrichtigungen', 'notifications.settings': 'Benachrichtigungseinstellungen', 'notifications.reactions': 'Reaktionen (Gefällt mir/Gefällt mir nicht)', 'notifications.replies': 'Kommentare & Antworten', 'notifications.zaps': 'Zaps', 'notifications.chatMentions': 'Live-Chat-Erwähnungen', 'notifications.newFollowers': 'Neue Abonnenten', 'notifications.syncNote': 'Einstellungen werden über Nostr zwischen Geräten synchronisiert',
        // Settings Modal
        'settings.title': 'Einstellungen', 'settings.language': 'Sprache', 'settings.languageDesc': 'Wählen Sie Ihre bevorzugte Sprache', 'settings.saveToNostr': 'Auf Nostr speichern', 'settings.saveToNostrDesc': 'Einstellungen über alle Plebs-Instanzen synchronisieren', 'settings.darkMode': 'Dunkelmodus', 'settings.darkModeDesc': 'Zwischen hellem und dunklem Design wechseln', 'settings.contentWarning': 'Inhaltswarnungseinstellungen', 'settings.showNsfwWarnings': 'NSFW-Warnungen anzeigen', 'settings.showNsfwWarningsDesc': 'Altersverifizierung für NSFW-Inhalte anzeigen', 'settings.showCommunityWarnings': 'Community-Warnungen anzeigen', 'settings.showCommunityWarningsDesc': 'Warnungen für markierte oder stark negativ bewertete Inhalte anzeigen', 'settings.showFollowsReportWarnings': 'Warnungen von gefolgten Berichten anzeigen', 'settings.showFollowsReportWarningsDesc': 'Warnungen anzeigen, wenn 5+ Personen, denen Sie folgen, Inhalte gemeldet haben', 'settings.filterPacks': 'Inhaltsfilter-Pakete', 'settings.filterPacksDesc': 'Aktivieren Sie Filterpakete, um Inhalte mit bestimmten Schlüsselwörtern automatisch auszublenden.', 'settings.customKeywordFilter': 'Benutzerdefinierter Schlüsselwortfilter', 'settings.customKeywordFilterPlaceholder': 'Geben Sie Schlüsselwörter oder Phrasen durch Kommas getrennt ein\nBeispiel: Spam, unerwünschter Inhalt, bestimmter Ausdruck', 'settings.customKeywordFilterDesc': 'Fügen Sie Ihre eigenen Schlüsselwörter zum Filtern hinzu (durch Kommas getrennt)', 'settings.saveSettings': 'Einstellungen speichern', 'settings.resetDefaults': 'Zurücksetzen', 'settings.notificationSettings': 'Benachrichtigungseinstellungen',
        // Upload Modal
        'upload.title': 'Video hochladen', 'upload.videoFile': 'Videodatei', 'upload.clickToSelect': 'Klicken zum Auswählen oder per Drag & Drop', 'upload.fileTypes': 'MP4, AVI, MOV, etc (max 2GB Eingabe, wird auf <100MB komprimiert)', 'upload.preparing': 'Vorbereitung...', 'upload.thumbnail': 'Thumbnail', 'upload.thumbnailHint': 'Klicken zum Auswählen oder automatisch aus Video generieren', 'upload.uploading': 'Wird hochgeladen...', 'upload.titleLabel': 'Titel', 'upload.titlePlaceholder': 'Videotitel eingeben', 'upload.descriptionLabel': 'Beschreibung', 'upload.descriptionPlaceholder': 'Erzählen Sie den Zuschauern von Ihrem Video', 'upload.tagsLabel': 'Tags (kommagetrennt)', 'upload.tagsPlaceholder': 'bitcoin, nostr, tutorial', 'upload.markNsfw': 'Als NSFW markieren (18+)', 'upload.nsfwDesc': 'Inhalte für Erwachsene sollten als NSFW markiert werden', 'upload.saveDraft': 'Als Entwurf speichern', 'upload.publish': 'Veröffentlichen', 'upload.selectVideo': 'Video zum Hochladen auswählen', 'upload.optional': '(optional)', 'upload.remove': 'Entfernen', 'upload.qualityHigh': 'Hoch',
        // Create Modal
        'create.title': 'Erstellen', 'create.goLive': 'Live gehen', 'create.goLiveDesc': 'Starten oder planen Sie einen Livestream', 'create.uploadVideo': 'Video hochladen', 'create.uploadVideoDesc': 'Laden Sie ein Video von Ihrem Gerät hoch', 'create.createShort': 'Short erstellen', 'create.createShortDesc': 'Laden Sie ein vertikales Video hoch (unter 60s)',
        // Go Live Modal
        'goLive.title': 'Live gehen', 'goLive.when': 'Wann möchten Sie live gehen?', 'goLive.now': 'Jetzt live gehen', 'goLive.schedule': 'Stream planen', 'goLive.streamTitle': 'Stream-Titel', 'goLive.streamTitlePlaceholder': 'Geben Sie Ihren Stream-Titel ein', 'goLive.description': 'Beschreibung', 'goLive.descriptionPlaceholder': 'Erzählen Sie den Zuschauern, worum es in Ihrem Stream geht', 'goLive.tags': 'Tags (kommagetrennt)', 'goLive.tagsPlaceholder': 'gaming, bitcoin, tutorial', 'goLive.streamUrl': 'Stream-URL (RTMP, HLS oder WebRTC)', 'goLive.streamUrlPlaceholder': 'https://ihr-streaming-dienst.com/stream.m3u8', 'goLive.zapGoal': 'Zap-Ziel (optional)', 'goLive.zapGoalLabel': 'Zap-Ziel', 'goLive.zapGoalPlaceholder': 'z.B. 10000', 'goLive.cancel': 'Abbrechen', 'goLive.goLiveBtn': 'Live gehen',
        // Video/Live No Description
        'video.noDescription': 'Keine Beschreibung zu diesem Video hinzugefügt.', 'live.noDescription': 'Keine Beschreibung zu diesem Livestream hinzugefügt.',
        // Edit Stream Modal
        'editStream.title': 'Stream bearbeiten', 'editStream.changeThumbnail': 'Thumbnail ändern', 'editStream.titleLabel': 'Titel', 'editStream.saveChanges': 'Änderungen speichern',
        // NSFW Warning Modal
        'nsfw.title': 'Altersverifikation erforderlich', 'nsfw.description': 'Dieser Inhalt ist als NSFW gekennzeichnet und kann Material für Erwachsene enthalten. Sie müssen 18 Jahre oder älter sein.', 'nsfw.confirm': 'Ich bin 18 Jahre oder älter', 'nsfw.remember': 'Nicht mehr fragen (Meine Wahl merken)',
        // Community Warning Modal
        'communityWarning.title': 'Community-Warnung', 'communityWarning.description': 'Dieses Video wurde von der Community markiert und/oder stark negativ bewertet. Dies kann folgende Gründe haben:', 'communityWarning.reason1': 'Unangemessener Inhalt nicht korrekt als NSFW markiert', 'communityWarning.reason2': 'Neue oder verdächtige Benutzerdetails', 'communityWarning.reason3': 'Irreführende oder falsche Informationen', 'communityWarning.reason4': 'Spam oder Inhalte niedriger Qualität', 'communityWarning.reason5': 'Potenziell schädlicher oder illegaler Inhalt', 'communityWarning.proceed': 'Mit Vorsicht fortfahren.', 'communityWarning.goBack': 'Zurück', 'communityWarning.viewAnyway': 'Trotzdem ansehen',
        // Report Modal
        'report.title': 'Video melden', 'report.description': 'Wählen Sie einen Grund für die Meldung dieses Inhalts:', 'report.nudity': 'Nacktheit oder sexuelle Inhalte', 'report.nudityDesc': 'Enthält sexuelle oder explizite Bilder, die nicht als NSFW gekennzeichnet sind', 'report.hate': 'Hassrede oder Belästigung', 'report.hateDesc': 'Fördert Gewalt, Hass oder Belästigung', 'report.illegal': 'Illegaler Inhalt', 'report.illegalDesc': 'Inhalt, der möglicherweise gegen Gesetze verstößt', 'report.spam': 'Spam oder irreführend', 'report.spamDesc': 'Irreführender Inhalt, Betrug oder wiederholter Spam', 'report.impersonation': 'Identitätsdiebstahl', 'report.impersonationDesc': 'Gibt sich als jemand anderes aus', 'report.other': 'Sonstiges', 'report.otherDesc': 'Andere nicht aufgeführte Verstöße', 'report.cancel': 'Abbrechen', 'report.submit': 'Meldung absenden',
        // Share Modal
        'share.title': 'Video teilen', 'share.link': 'Link', 'share.embed': 'Einbetten', 'share.shareWith': 'Teilen Sie dieses Video mit anderen:', 'share.copy': 'Kopieren', 'share.copied': 'In Zwischenablage kopiert!', 'share.embedOnWebsite': 'Betten Sie dieses Video auf Ihrer Website ein:', 'share.size': 'Größe:', 'share.responsive': 'Responsiv (Standard)', 'share.size1280x720': '1280 × 720 (HD)', 'share.embedCodeCopied': 'Einbettungscode kopiert!',
        // Edit Video Modal
        'editVideo.title': 'Video bearbeiten', 'editVideo.video': 'Video', 'editVideo.replaceVideo': 'Video ersetzen', 'editVideo.thumbnail': 'Thumbnail', 'editVideo.changeThumbnail': 'Thumbnail ändern', 'editVideo.titleLabel': 'Titel', 'editVideo.descriptionLabel': 'Beschreibung', 'editVideo.tagsLabel': 'Tags (kommagetrennt)', 'editVideo.cancel': 'Abbrechen', 'editVideo.saveChanges': 'Änderungen speichern',
        // Edit Profile Modal
        'editProfile.title': 'Profil bearbeiten', 'editProfile.displayName': 'Anzeigename', 'editProfile.displayNamePlaceholder': 'Ihr Anzeigename', 'editProfile.about': 'Über mich', 'editProfile.aboutPlaceholder': 'Erzählen Sie anderen von sich', 'editProfile.picture': 'Profilbild', 'editProfile.pictureUrl': 'Oder geben Sie die Bild-URL direkt ein:', 'editProfile.nip05': 'NIP-05 Kennung (optional)', 'editProfile.nip05Hint': 'Eine verifizierte Nostr-Adresse zur Identitätsverifizierung.', 'editProfile.website': 'Website (optional)', 'editProfile.saveChanges': 'Änderungen speichern',
        // Confirmation Modal
        'confirm.title': 'Aktion bestätigen', 'confirm.message': 'Sind Sie sicher, dass Sie fortfahren möchten?', 'confirm.cancel': 'Abbrechen', 'confirm.confirm': 'Bestätigen',
        // Video Page
        'video.views': 'Aufrufe', 'video.view': 'Aufruf', 'video.followers': 'Abonnenten', 'video.follower': 'Abonnent', 'video.follow': 'Abonnieren', 'video.unfollow': 'Deabonnieren', 'video.share': 'Teilen', 'video.comments': 'Kommentare', 'video.writeComment': 'Kommentar schreiben...', 'video.noComments': 'Noch keine Kommentare. Seien Sie der Erste!',
        // Toast Messages
        'toast.loggedIn': 'Erfolgreich angemeldet!', 'toast.settingsSaved': 'Einstellungen gespeichert!', 'toast.settingsLocal': 'Einstellungen lokal gespeichert. Konnte nicht auf Nostr speichern.', 'toast.settingsLocalOnly': 'Einstellungen lokal gespeichert!', 'toast.settingsReset': 'Einstellungen zurückgesetzt!', 'toast.avatarUploaded': 'Avatar erfolgreich hochgeladen!', 'toast.profileUpdated': 'Profil erfolgreich aktualisiert!', 'toast.copied': 'In Zwischenablage kopiert!', 'toast.copyFailed': 'Kopieren fehlgeschlagen. Bitte manuell kopieren.', 'toast.installExtension': 'Bitte installieren Sie eine Nostr-Browsererweiterung wie Alby oder nos2x', 'toast.loginFailed': 'Anmeldung mit Erweiterung fehlgeschlagen. Bitte erneut versuchen.', 'toast.invalidKey': 'Ungültiger privater Schlüssel. Bitte überprüfen und erneut versuchen.', 'toast.enterKey': 'Bitte geben Sie Ihren privaten Schlüssel ein', 'toast.enterUsername': 'Bitte geben Sie einen Benutzernamen ein', 'toast.accountCreated': 'Willkommen bei Plebs! Sie sind jetzt angemeldet.', 'toast.keyCopied': 'Privater Schlüssel in Zwischenablage kopiert!', 'toast.unmuted': 'Benutzer entstummt', 'toast.unmuteFailed': 'Entstummen des Benutzers fehlgeschlagen', 'toast.selectImage': 'Bitte wählen Sie eine Bilddatei', 'toast.imageTooLarge': 'Bild muss kleiner als 5 MB sein', 'toast.avatarFailed': 'Avatar-Upload fehlgeschlagen. Bitte erneut versuchen.', 'toast.mustBeLoggedIn': 'Sie müssen angemeldet sein, um Ihr Profil zu bearbeiten', 'toast.enterDisplayName': 'Bitte geben Sie einen Anzeigenamen ein', 'toast.profileFailed': 'Profil speichern fehlgeschlagen. Bitte erneut versuchen.', 'toast.invalidBunker': 'Bitte geben Sie eine gültige Bunker-URL ein', 'toast.connectFailed': 'Verbindung fehlgeschlagen', 'toast.showingFiltered': 'Zeige gefilterten Inhalt', 'toast.reportSubmitted': 'Meldung erfolgreich gesendet', 'toast.draftSaved': 'Entwurf gespeichert! Sie können später von Meine Videos fortfahren.', 'toast.draftLoaded': 'Entwurf geladen. Schließen Sie Ihren Upload ab und veröffentlichen Sie.', 'toast.draftDeleted': 'Entwurf gelöscht', 'toast.languageChanged': 'Sprache geändert', 'toast.videoBlocked': 'Video blockiert und auf Nostr veröffentlicht', 'toast.waitForUpload': 'Bitte warten Sie, bis der Video-Upload abgeschlossen ist', 'toast.enterTitle': 'Bitte geben Sie einen Titel ein', 'toast.publishing': 'Video wird auf Nostr veröffentlicht...',
        // Time
        'time.justNow': 'gerade eben', 'time.secondAgo': 'vor 1 Sekunde', 'time.secondsAgo': 'vor {n} Sekunden', 'time.minuteAgo': 'vor 1 Minute', 'time.minutesAgo': 'vor {n} Minuten', 'time.hourAgo': 'vor 1 Stunde', 'time.hoursAgo': 'vor {n} Stunden', 'time.dayAgo': 'vor 1 Tag', 'time.daysAgo': 'vor {n} Tagen', 'time.weekAgo': 'vor 1 Woche', 'time.weeksAgo': 'vor {n} Wochen', 'time.monthAgo': 'vor 1 Monat', 'time.monthsAgo': 'vor {n} Monaten', 'time.yearAgo': 'vor 1 Jahr', 'time.yearsAgo': 'vor {n} Jahren',
        // Empty States
        'empty.noVideos': 'Keine Videos gefunden.', 'empty.noLikedVideos': 'Sie haben noch keine Videos geliked.', 'empty.noHistory': 'Kein Verlauf.',
        // Misc
        'misc.loading': 'Laden...', 'misc.close': 'Schließen', 'misc.back': 'Zurück', 'misc.search': 'Suchen',
        // Common
        'common.cancel': 'Abbrechen', 'common.uploading': 'Wird hochgeladen...', 'common.saveChanges': 'Änderungen speichern', 'common.close': 'Schließen',
        // Aria Labels
        'aria.toggleMenu': 'Menü umschalten', 'aria.mainNavigation': 'Hauptnavigation', 'aria.videoContent': 'Videoinhalt', 'aria.loadingContent': 'Inhalt wird geladen',
        // Dynamic JavaScript text
        'button.hideQR': 'QR-Code ausblenden', 'button.showQR': 'QR-Code anzeigen', 'button.copied': 'Kopiert!', 'button.showLess': 'Weniger anzeigen', 'button.showMore': 'Mehr anzeigen', 'button.creatingAccount': 'Konto wird erstellt...', 'button.submitting': 'Wird gesendet...', 'button.scheduleStream': 'Stream planen', 'button.goLive': 'Live gehen', 'button.creatingStream': 'Stream wird erstellt...', 'button.continueCustomAmount': 'Mit benutzerdefiniertem Betrag fortfahren', 'button.recordFromCamera': 'Von Kamera aufnehmen', 'button.requestingCamera': 'Kamera wird angefragt...', 'button.recording': 'Aufnahme...',
        'status.saving': 'Wird gespeichert...', 'status.saved': 'Gespeichert!', 'status.uploading': 'Wird hochgeladen...', 'status.uploadComplete': 'Upload abgeschlossen!', 'status.uploadingToNostrBuild': 'Wird auf nostr.build hochgeladen...', 'status.publishingChanges': 'Änderungen werden veröffentlicht...', 'status.removingOldVersion': 'Alte Version wird entfernt...', 'status.validatingThumbnail': 'Thumbnail wird validiert...', 'status.uploadingThumbnail': 'Thumbnail wird hochgeladen...', 'status.thumbnailUploaded': 'Thumbnail hochgeladen!', 'status.processingVideo': 'Video wird verarbeitet...', 'status.compressingVideo': 'Video wird komprimiert...', 'status.uploadingVideo': 'Video wird hochgeladen...', 'status.videoUploaded': 'Video erfolgreich hochgeladen!', 'status.processing': 'Wird verarbeitet...', 'status.generatingThumbnail': 'Thumbnail wird generiert...', 'status.generatingPreview': 'Vorschau wird generiert...', 'status.uploadingPreview': 'Vorschau wird hochgeladen...', 'status.publishing': 'Wird veröffentlicht...', 'status.publishingToNostr': 'Wird auf Nostr veröffentlicht...', 'status.publishingVideoToNostr': 'Video wird auf Nostr veröffentlicht...', 'status.generatingPoW': 'Proof of Work wird generiert...', 'status.posting': 'Wird gepostet...', 'status.processingVideoAndThumbnail': 'Video und Thumbnail werden verarbeitet...', 'status.uploadFailed': 'Upload fehlgeschlagen - erneut versuchen', 'status.selectVideoToUpload': 'Video zum Hochladen auswählen', 'status.waitingForVideoUpload': 'Warten auf Video-Upload...', 'status.selectVideoAndThumbnail': 'Video und Thumbnail zum Veröffentlichen auswählen', 'status.ready': 'Bereit ✓', 'status.failed': 'Fehlgeschlagen ✗', 'status.fromDraft': 'Aus Entwurf', 'status.startingNow': 'Startet jetzt!', 'status.ended': 'BEENDET', 'status.thumbnailReady': 'Bereit', 'status.thumbnailFailed': 'Fehlgeschlagen', 'status.uploadFailedRetry': 'Upload fehlgeschlagen. Bitte erneut versuchen.',
        'publish.video': 'Video veröffentlichen', 'publish.autoThumbnail': 'Video veröffentlichen (Auto-Thumbnail)',
        'report.titleComment': 'Kommentar melden', 'report.titleUser': 'Benutzer melden', 'report.titleVideo': 'Video melden', 'report.descComment': 'Wählen Sie einen Grund für die Meldung dieses Kommentars:', 'report.descUser': 'Wählen Sie einen Grund für die Meldung dieses Benutzers:', 'report.descVideo': 'Wählen Sie einen Grund für die Meldung dieses Inhalts:',
        'empty.noMutedUsers': 'Keine stummgeschalteten Benutzer.', 'empty.noVideosToMonitor': 'Keine Videos zum Überwachen gefunden.', 'empty.noRecentActivity': 'Keine aktuelle Aktivität.', 'empty.failedLoadNotifications': 'Benachrichtigungen konnten nicht geladen werden', 'empty.loginToViewLiked': 'Bitte <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">anmelden</a>, um Ihre gelikten Videos zu sehen.', 'empty.loginToViewFollowing': 'Bitte <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">anmelden</a>, um zu sehen, wem Sie folgen.', 'empty.loginToViewVideos': 'Bitte <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">anmelden</a>, um Ihre Videos zu sehen.', 'empty.loginToViewAnalytics': 'Bitte <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">anmelden</a>, um Ihre Statistiken zu sehen.', 'empty.noLikedVideosYet': 'Sie haben noch keine Videos geliked.', 'empty.noLikedVideosFound': 'Keine gelikten Videos gefunden.', 'empty.noFullLengthLikedVideos': 'Keine langen gelikten Videos gefunden.', 'empty.noWatchHistory': 'Kein Verlauf. Beginnen Sie Videos anzusehen.', 'empty.noVideosInHistory': 'Keine Videos im Verlauf gefunden.', 'empty.noFullLengthHistory': 'Keine langen Videos im Verlauf.', 'empty.noMatchingVideos': 'Keine passenden Videos gefunden.', 'empty.noFullLengthVideos': 'Keine langen Videos gefunden.', 'empty.failedLoadTrending': 'Trending konnte nicht geladen werden.', 'empty.noTrendingVideos': 'Keine Trend-Videos gefunden.', 'empty.noMatchingUsers': 'Keine passenden Benutzer gefunden.', 'empty.unableLoadProfiles': 'Profile konnten nicht geladen werden.', 'empty.noFollowingVideos': 'Noch keine Videos von Benutzern, denen Sie folgen.', 'empty.noFullLengthFollowing': 'Keine langen Videos von gefolgten Benutzern.', 'empty.failedLoadFollowing': 'Laden fehlgeschlagen. Bitte erneut versuchen.', 'empty.noVideosUploadFirst': 'Keine Videos gefunden. Laden Sie Ihr erstes Video hoch!', 'empty.noFullLengthUploaded': 'Keine langen Videos gefunden.', 'empty.noMatchingLiveStreams': 'Keine passenden Livestreams gefunden.', 'empty.noMatchingShorts': 'Keine passenden Shorts gefunden.', 'empty.noVideosForTag': 'Keine Videos für diesen Tag gefunden.', 'empty.noFullLengthForTag': 'Keine langen Videos für diesen Tag.', 'empty.noUploadedVideos': 'Noch keine Videos hochgeladen.', 'empty.noVideosFound': 'Keine Videos gefunden.', 'empty.failedLoadProfile': 'Profil konnte nicht geladen werden. Erneut versuchen.', 'empty.noComments': 'Noch keine Kommentare. Seien Sie der Erste!', 'empty.failedLoadComments': 'Kommentare konnten nicht geladen werden', 'empty.noLiveNow': 'Niemand ist gerade live. Seien Sie der Erste!',
        'error.videoNotFound': 'Video nicht gefunden.', 'error.contentNotAvailable': 'Dieser Inhalt ist nicht verfügbar.', 'error.invalidVideoData': 'Ungültige Videodaten.', 'error.videoNotAvailable': 'Video nicht verfügbar. Die Datei wurde möglicherweise entfernt.', 'error.failedLoadVideo': 'Video konnte nicht geladen werden. Bitte erneut versuchen.', 'error.failedLoadVideoShort': 'Video konnte nicht geladen werden. Datei möglicherweise entfernt.', 'error.liveStreamNotFound': 'Livestream nicht gefunden.', 'error.invalidLiveStreamData': 'Ungültige Livestream-Daten.', 'error.failedLoadLiveStream': 'Livestream konnte nicht geladen werden.',
        // New Button & Action Labels
        'button.follow': 'Folgen', 'button.unfollow': 'Entfolgen', 'button.mute': 'Stummschalten', 'button.unmute': 'Stummschaltung aufheben', 'button.muteUser': 'Benutzer stummschalten', 'button.unmuteUser': 'Stummschaltung aufheben', 'button.confirm': 'Bestätigen', 'button.cancel': 'Abbrechen', 'button.close': 'Schließen', 'button.boost': 'Boosten', 'button.zap': 'Zap', 'button.viewMore': 'Mehr anzeigen', 'button.viewAnalytics': 'Statistiken anzeigen', 'button.backToMyVideos': 'Zurück zu Meinen Videos', 'button.editDraft': 'Entwurf bearbeiten', 'button.deleteDraft': 'Entwurf löschen', 'button.editVideo': 'Video bearbeiten', 'button.deleteVideo': 'Video löschen', 'button.editShort': 'Short bearbeiten', 'button.deleteShort': 'Short löschen', 'button.editStream': 'Stream bearbeiten', 'button.endStream': 'Stream beenden', 'button.reset': 'Zurücksetzen', 'button.download': 'Herunterladen', 'button.watchRecording': 'Aufnahme ansehen', 'button.show': 'Anzeigen', 'button.login': 'Anmelden', 'button.toggleChat': 'Chat umschalten', 'button.blockVideo': 'Video blockieren', 'button.blockUser': 'Benutzer blockieren', 'button.unblock': 'Entsperren', 'button.removeFromHistory': 'Aus Verlauf entfernen',
        // New Stats & Counts
        'stat.views': 'Aufrufe', 'stat.viewsCount': '{count} Aufrufe', 'stat.videos': 'Videos', 'stat.video': 'Video', 'stat.followers': 'Abonnenten', 'stat.follower': 'Abonnent', 'stat.following': 'Abonniert', 'stat.subscribers': 'Abonnenten', 'stat.comments': 'Kommentare', 'stat.liveCount': '{count} live', 'stat.percentOfGoal': '{percent}% des Ziels', 'stat.netGrowth': 'Nettowachstum', 'stat.newFollowers': 'Neue Abonnenten', 'stat.unfollowed': 'Entfolgt', 'stat.lastUpdated': 'Zuletzt aktualisiert: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'LIVE', 'badge.ended': 'BEENDET', 'badge.scheduled': 'GEPLANT', 'badge.warning': 'WARNUNG', 'badge.communityWarning': 'COMMUNITY-WARNUNG', 'badge.verifiedNip05': 'NIP-05 verifiziert', 'badge.streamer': 'Streamer', 'badge.clickToView': 'Klicken zum Ansehen',
        // New Actions
        'action.report': 'Melden', 'action.reportComment': 'Kommentar melden', 'action.reportVideo': 'Video melden', 'action.reportStream': 'Stream melden', 'action.like': 'Gefällt mir', 'action.dislike': 'Gefällt mir nicht', 'action.reply': 'Antworten',
        // New Placeholders
        'placeholder.searchHistory': 'Verlauf durchsuchen...', 'placeholder.searchUsers': 'Benutzer suchen...', 'placeholder.searchMyVideos': 'Meine Videos durchsuchen...', 'placeholder.eventId': 'Event-ID eingeben (hex oder nevent/note)', 'placeholder.pubkey': 'Pubkey eingeben (hex oder npub)', 'placeholder.customAmount': 'Benutzerdefinierter Betrag', 'placeholder.chatEnded': 'Chat geschlossen - Stream beendet', 'placeholder.addComment': 'Kommentar hinzufügen...', 'placeholder.setNewGoal': 'Neues Ziel setzen (sats)',
        // New Video & Content
        'video.untitledVideo': 'Video ohne Titel', 'video.untitledShort': 'Short ohne Titel', 'video.upNext': 'Als nächstes', 'video.noVideosYet': 'Noch keine Videos', 'video.noShortsYet': 'Noch keine Shorts', 'video.noLiveStreamsYet': 'Noch keine Livestreams', 'video.noBlockedVideos': 'Keine blockierten Videos', 'video.noBlockedUsers': 'Keine blockierten Benutzer',
        // New Stream Messages
        'stream.ended': 'Dieser Stream ist beendet. Der Chat ist jetzt geschlossen.', 'stream.welcomeChat': 'Willkommen im Live-Chat!', 'stream.goalReached': 'Ziel erreicht!', 'stream.zapGoalReached': 'Zap-Ziel erreicht! {amount} Sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Nachricht von stummgeschaltetem Benutzer', 'muted.commentFromMutedUserHidden': 'Kommentar von stummgeschaltetem Benutzer ausgeblendet', 'muted.commentHidden': 'Kommentar ausgeblendet ({packs})', 'muted.messageHidden': 'Nachricht ausgeblendet ({packs})', 'muted.commentReportedByFollows': 'Kommentar von Personen gemeldet, denen Sie folgen', 'muted.messageReportedByFollows': 'Nachricht von Personen gemeldet, denen Sie folgen', 'muted.commentHeavilyDownvoted': 'Kommentar stark negativ bewertet', 'muted.messageHeavilyDownvoted': 'Nachricht stark negativ bewertet',
        // New Admin & Lists
        'list.blockedVideos': 'Blockierte Videos', 'list.blockedUsers': 'Blockierte Benutzer',
        // New Alerts
        'alert.cameraNotSupported': 'Kamerazugriff wird in diesem Browser nicht unterstützt. Bitte verwenden Sie einen modernen Browser wie Chrome, Firefox oder Safari.', 'alert.noCameraFound': 'Keine Kamera gefunden. Bitte schließen Sie eine Kamera an oder verwenden Sie die Datei-Upload-Option.', 'alert.cameraAccessDenied': 'Kamerazugriff verweigert. Bitte erlauben Sie Kameraberechtigungen in Ihren Browsereinstellungen.', 'alert.cameraInUse': 'Kamera wird von einer anderen Anwendung verwendet. Bitte schließen Sie andere Apps, die die Kamera verwenden.', 'alert.cameraUnableAccess': 'Zugriff auf Kamera mit aktuellen Einstellungen nicht möglich. Bitte verwenden Sie die Upload-Option.', 'alert.cameraUnableAccessWithError': 'Kamerazugriff nicht möglich: {error}\n\nBitte verwenden Sie die Upload-Option.', 'alert.fillRequiredFields': 'Bitte füllen Sie alle erforderlichen Felder aus', 'alert.uploadThumbnail': 'Bitte laden Sie ein Thumbnail für Ihren Stream hoch', 'alert.failedCreateStream': 'Stream konnte nicht erstellt werden. Bitte versuchen Sie es erneut.', 'alert.failedUpdateStream': 'Aktualisierung fehlgeschlagen. Bitte versuchen Sie es erneut.', 'alert.streamNotFound': 'Stream nicht gefunden', 'alert.canOnlyEditOwnStreams': 'Sie können nur Ihre eigenen Streams bearbeiten', 'alert.invalidStreamData': 'Ungültige Stream-Daten', 'alert.enterValidGoalAmount': 'Bitte geben Sie einen gültigen Zielbetrag ein', 'alert.canOnlyResetOwnGoals': 'Sie können nur Ihre eigenen Ziele zurücksetzen', 'alert.streamEventNotFound': 'Stream-Event nicht gefunden', 'alert.failedResetZapGoal': 'Zap-Ziel konnte nicht zurückgesetzt werden. Bitte versuchen Sie es erneut.', 'alert.cannotBlockAdmin': 'Admin-Konto kann nicht blockiert werden', 'alert.analyticsLoadFailed': 'Statistiken konnten nicht geladen werden. Bitte versuchen Sie es erneut.', 'alert.cannotReplaceShortWithVideo': 'Ein Short kann nicht durch ein normales Video ersetzt werden. Bitte laden Sie ein vertikales Video (60 Sekunden oder weniger) hoch.', 'alert.cannotReplaceVideoWithShort': 'Ein normales Video kann nicht durch ein Short ersetzt werden. Bitte laden Sie ein horizontales Video hoch.', 'alert.shortsRequireVertical': 'Dieses Video scheint horizontal zu sein. Shorts müssen vertikale Videos sein. Bitte verwenden Sie "Video hochladen" für horizontale Videos.',
        // New Zap Messages
        'zap.cannotZapYourself': 'Sie können sich nicht selbst zappen', 'zap.cannotZapOwnContent': 'Sie können Ihren eigenen Inhalt nicht zappen', 'zap.cannotZapOwnComment': 'Sie können Ihren eigenen Kommentar nicht zappen', 'zap.zapAmount': 'Zap {value} Sats',
        // New Status Messages
        'status.loadingVideo': 'Video wird geladen...', 'status.loading': 'Wird geladen...', 'status.compressingProgress': 'Komprimieren... {progress}%', 'status.uploadingProgress': 'Hochladen... {progress}%', 'status.uploadingServers': 'Hochladen... ({completed}/{total} Server)', 'status.publishedSuccess': '{type} erfolgreich veröffentlicht!',
        // New Warnings
        'warning.webmFormat': 'Hinweis: Ihr Browser gibt das WebM-Format aus (funktioniert möglicherweise nicht auf iOS). Für iOS-kompatibles MP4 verwenden Sie Chrome auf Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Zuletzt aktualisiert: Dezember 2024',
        // DMCA Page
        'dmca.title': 'DMCA und Inhaltsrichtlinie',
        'dmca.lastUpdated': 'Zuletzt aktualisiert: Dezember 2024',
        'dmca.architectureTitle': 'Verständnis der Plebs-Architektur',
        'dmca.architectureDesc': 'Plebs ist eine dezentrale Video-Plattform-Schnittstelle, die anders funktioniert als traditionelle Video-Hosting-Dienste. Es ist wichtig zu verstehen, wie Inhalte auf unserer Plattform verteilt werden:',
        'dmca.architectureItem1': 'Plebs hostet keine Video- oder Bildinhalte.',
        'dmca.architectureItem1Desc': 'Wir sind ein Client/eine Schnittstelle, die anderswo gespeicherte Inhalte anzeigt.',
        'dmca.architectureItem2': 'Alle Mediendateien (Videos, Bilder, Miniaturansichten) werden auf unabhängigen Blossom-Servern gespeichert, die von Dritten betrieben werden.',
        'dmca.architectureItem3': 'Video-Metadaten (Titel, Beschreibungen usw.) werden auf Nostr-Relays veröffentlicht, die ebenfalls unabhängig betrieben werden.',
        'dmca.architectureItem4': 'Plebs aggregiert und zeigt diese verteilten Inhalte einfach über eine benutzerfreundliche Oberfläche an.',
        'dmca.filingTitle': 'Einreichen einer DMCA-Beschwerde',
        'dmca.filingDesc': 'Da Plebs keine Inhalte hostet, können wir rechtsverletzende Materialien nicht direkt entfernen. Um Urheberrechtsverletzungen zu behandeln, müssen Sie die entsprechenden Parteien kontaktieren:',
        'dmca.forVideoTitle': '1. Für Video-/Bildinhalte',
        'dmca.forVideoDesc': 'Mediendateien werden auf Blossom-Servern gespeichert. Sie müssen:',
        'dmca.forVideoItem1': 'Identifizieren Sie, welcher Blossom-Server den Inhalt hostet (die URL zeigt dies an)',
        'dmca.forVideoItem2': 'Kontaktieren Sie den Blossom-Server-Betreiber direkt mit Ihrer DMCA-Löschanfrage',
        'dmca.forVideoItem3': 'Jeder Blossom-Server arbeitet unabhängig und hat seine eigenen Richtlinien',
        'dmca.forMetadataTitle': '2. Für Metadaten/Beschreibungen',
        'dmca.forMetadataDesc': 'Wenn sich der rechtsverletzende Inhalt im Videotitel, der Beschreibung oder anderen Metadaten befindet:',
        'dmca.forMetadataItem1': 'Diese Informationen werden auf Nostr-Relays gespeichert',
        'dmca.forMetadataItem2': 'Kontaktieren Sie die spezifischen Nostr-Relay-Betreiber, auf denen der Inhalt erscheint',
        'dmca.forMetadataItem3': 'Mehrere Relays können aufgrund der verteilten Natur von Nostr dieselben Daten speichern',
        'dmca.whatWeCanDoTitle': 'Was Plebs tun kann',
        'dmca.whatWeCanDoDesc': 'Obwohl wir keine Inhalte hosten, können wir:',
        'dmca.whatWeCanDoItem1': 'Ihnen helfen zu identifizieren, welche Blossom-Server oder Relays bestimmte Inhalte hosten',
        'dmca.whatWeCanDoItem2': 'Inhalte zu einer lokalen Sperrliste hinzufügen, damit sie nicht in unserer Schnittstelle erscheinen (Hinweis: Dies betrifft nur plebs.app, nicht andere Nostr-Clients)',
        'dmca.whatWeCanDoItem3': 'Anleitung geben, wie Sie die entsprechenden Dienstanbieter kontaktieren können',
        'dmca.toRequestAssistance': 'Um Unterstützung anzufordern, kontaktieren Sie uns bitte mit:',
        'dmca.assistanceItem1': 'Die URL oder Kennung des rechtsverletzenden Inhalts',
        'dmca.assistanceItem2': 'Nachweis Ihres Urheberrechtseigentums',
        'dmca.assistanceItem3': 'Eine Beschreibung der geschützten Arbeit',
        'dmca.blossomOperatorsTitle': 'Blossom-Server-Betreiber',
        'dmca.blossomOperatorsDesc': 'Wenn Sie einen Blossom-Server betreiben und eine DMCA-Löschanfrage erhalten, sind Sie dafür verantwortlich, diese gemäß den Gesetzen Ihrer Gerichtsbarkeit zu bearbeiten.',
        'dmca.blossomOperatorsLink': 'Für eine Liste bekannter Blossom-Server, konsultieren Sie die Blossom-Projektdokumentation.',
        'dmca.considerationsTitle': 'Wichtige Überlegungen',
        'dmca.considerationsItem1': 'Dezentralisierung:',
        'dmca.considerationsItem1Desc': 'Aufgrund der dezentralen Natur von Nostr und Blossom ist die vollständige Entfernung von Inhalten aus allen Quellen möglicherweise nicht möglich.',
        'dmca.considerationsItem2': 'Mehrere Kopien:',
        'dmca.considerationsItem2Desc': 'Inhalte können auf mehreren Blossom-Servern repliziert werden, was separate Löschanfragen für jeden erfordert.',
        'dmca.considerationsItem3': 'Metadaten-Persistenz:',
        'dmca.considerationsItem3Desc': 'Selbst wenn Mediendateien entfernt werden, können Metadaten auf Nostr-Relays bestehen bleiben.',
        'dmca.considerationsItem4': 'Keine zentrale Kontrolle:',
        'dmca.considerationsItem4Desc': 'Es gibt keine einzelne Instanz, die Inhalte aus dem gesamten Netzwerk entfernen kann.',
        'dmca.counterNotificationTitle': 'Gegendarstellung',
        'dmca.counterNotificationDesc': 'Wenn Sie glauben, dass Ihr Inhalt fälschlicherweise von einem Blossom-Server entfernt wurde, müssen Sie den Betreiber dieses Servers direkt kontaktieren, um eine Gegendarstellung einzureichen.',
        'dmca.contactTitle': 'Kontakt',
        'dmca.contactDesc': 'Für Fragen zu dieser Richtlinie oder Hilfe bei der Identifizierung von Inhalts-Hosts, bitte',
        'dmca.contactLink': 'kontaktieren Sie uns',
        // Admin Dashboard
        'admin.title': 'Admin-Dashboard',
        'admin.loading': 'Lade Plattform-Analysen...',
        'admin.platformOverview': 'Plattform-Übersicht',
        'admin.totalVideos': 'Gesamtvideos',
        'admin.videos7Days': 'Videos (7 Tage)',
        'admin.videos30Days': 'Videos (30 Tage)',
        'admin.uniqueCreators': 'Einzigartige Ersteller',
        'admin.likes30Days': 'Gefällt mir (30 Tage)',
        'admin.dislikes30Days': 'Gefällt mir nicht (30 Tage)',
        'admin.monthlyActiveUsers': 'Monatlich aktive Benutzer',
        'admin.mauDesc': 'Einzigartige Benutzer, die jeden Monat Videos hochgeladen, reagiert oder kommentiert haben (letzte 6 Monate)',
        'admin.boostRevenue': 'Boost-Einnahmen (Letzte 30 Tage)',
        'admin.totalBoostRevenue': 'Gesamte Boost-Einnahmen',
        'admin.totalBoosts': 'Gesamte Boosts',
        'admin.blocklistManagement': 'Sperrlisten-Verwaltung',
        'admin.blocklistDesc': 'Blockieren Sie bestimmte Videos oder Benutzer, damit sie nicht auf der Plattform erscheinen.',
        'admin.blockedVideos': 'Blockierte Videos',
        'admin.blockedUsers': 'Blockierte Benutzer',
        'admin.blockByEventId': 'Video nach Event-ID blockieren',
        'admin.blockByPubkey': 'Benutzer nach Pubkey blockieren',
        'admin.blockVideo': 'Video blockieren',
        'admin.blockUser': 'Benutzer blockieren',
        'admin.noBlockedVideos': 'Keine blockierten Videos',
        'admin.noBlockedUsers': 'Keine blockierten Benutzer',
        'admin.unblock': 'Entsperren',
        'admin.accessDenied': 'Zugriff verweigert. Nur Administrator.',
        // Search/Trending/Channel/Buttons/Common
        'search.noVideosFound': 'Keine Videos gefunden, die "{query}" entsprechen.',
        'search.noFullLengthVideos': 'Keine Langvideos gefunden, die "{query}" entsprechen.',
        'trending.noVideosToday': 'Heute keine trendenden Videos.',
        'trending.noVideosThisWeek': 'Diese Woche keine trendenden Videos.',
        'channel.video': 'Video',
        'channel.videos': 'Videos',
        'channel.follower': 'Abonnent',
        'channel.followers': 'Abonnenten',
        'button.follow': 'Folgen',
        'button.following': 'Folge ich',
        'button.unfollow': 'Entfolgen',
        'button.mute': 'Stummschalten',
        'button.unmute': 'Stummschaltung aufheben',
        'button.report': 'Melden',
        'button.muteUser': 'Benutzer stummschalten',
        'button.unmuteUser': 'Benutzer-Stummschaltung aufheben',
        'button.reportComment': 'Kommentar melden',
        'button.reportUser': 'Diesen Benutzer melden',
        'live.goalReached': 'Ziel erreicht!',
        'live.goalProgress': '{percent}% des Ziels',
        'common.loading': 'Wird geladen...',
        'common.sats': 'Sats',
        // Analytics Page
        'analytics.title': 'Kanal-Statistiken',
        'analytics.loading': 'Ihre Statistiken werden geladen...',
        'analytics.loadFailed': 'Fehler beim Laden der Statistiken. Bitte versuchen Sie es erneut.',
        'analytics.overview': 'Übersicht',
        'analytics.views': 'Aufrufe',
        'analytics.followers': 'Abonnenten',
        'analytics.topByViews': 'Meistgesehene Videos',
        'analytics.topByEngagement': 'Videos mit höchstem Engagement',
        'analytics.allContent': 'Leistung aller Inhalte',
        'analytics.totalViews': 'Gesamtaufrufe',
        'analytics.likes': 'Gefällt mir',
        'analytics.likesRatio': 'Gefällt mir ({ratio}% Verhältnis)',
        'analytics.dislikes': 'Gefällt mir nicht',
        'analytics.zapsReceived': '{count} erhaltene Zaps',
        'analytics.boostsReceived': 'Erhaltene Boosts',
        'analytics.shares': 'Geteilte',
        'analytics.comments': 'Kommentare',
        'analytics.contentCount': '{videos} Videos, {shorts} Shorts, {streams} Streams',
        'analytics.last7days': 'Letzte 7 Tage',
        'analytics.last30days': 'Letzte 30 Tage',
        'analytics.last90days': 'Letzte 90 Tage',
        'analytics.lastYear': 'Letztes Jahr',
        'analytics.allTime': 'Gesamt',
        'analytics.lastNDays': 'Letzte {n} Tage',
        'analytics.netGrowth': 'Nettowachstum',
        'analytics.newFollowers': 'Neue Abonnenten',
        'analytics.unfollowed': 'Abmeldungen',
        'analytics.noVideosYet': 'Noch keine Videos',
        'analytics.noShortsYet': 'Noch keine Shorts',
        'analytics.noStreamsYet': 'Noch keine Streams',
        'analytics.viewsTooltip': '{count} Aufrufe',
        'analytics.subscribersTooltip': '{count} Abonnenten',
        'analytics.videosTab': 'Videos ({count})',
        'analytics.shortsTab': 'Shorts ({count})',
        'analytics.streamsTab': 'Streams ({count})',
        // About Page
        'about.title': 'Über Plebs',
        'about.whatIs': 'Was ist Plebs?',
        'about.whatIsDesc': 'Plebs ist eine dezentrale und zensurresistente Video-Plattform, die auf dem <a href="https://nostr.com" target="_blank" rel="noopener">Nostr-Protokoll</a> basiert. Anders als traditionelle unternehmensgesteuerte Plattformen gibt Ihnen Plebs echtes Eigentum an Ihren Inhalten und Ihrer Identität.',
        'about.whyNostr': 'Warum Nostr?',
        'about.whyNostrDesc': 'Nostr (Notes and Other Stuff Transmitted by Relays) ist ein einfaches, offenes Protokoll, das ein wirklich dezentrales soziales Netzwerk ermöglicht. Die wichtigsten Vorteile sind:',
        'about.benefit1': 'Zensurresistenz:',
        'about.benefit1Desc': 'Keine Instanz kann Sie sperren oder Ihre Inhalte löschen',
        'about.benefit2': 'Portabilität:',
        'about.benefit2Desc': 'Ihre Identität und Follower funktionieren in allen Nostr-Apps',
        'about.benefit3': 'Keine zentrale Autorität:',
        'about.benefit3Desc': 'Kein Unternehmen besitzt oder kontrolliert das Netzwerk',
        'about.benefit4': 'Kryptographische Identität:',
        'about.benefit4Desc': 'Ihre Schlüssel beweisen, dass Sie sind, wer Sie sagen',
        'about.howItWorks': 'Wie es funktioniert',
        'about.howItWorksDesc': 'Videos auf Plebs werden mit <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom</a> gespeichert, einem verteilten Speichersystem, während Metadaten und soziale Interaktionen zu Nostr-Relays gesendet werden. Das bedeutet, dass Ihre Inhalte nicht auf unseren Servern gespeichert werden - sie sind über das Netzwerk verteilt.',
        'about.features': 'Funktionen',
        'about.feature1': 'Videos hochladen und mit der Nostr-Community teilen',
        'about.feature2': 'Videos mit Nostr-Reaktionen liken, kommentieren und teilen',
        'about.feature3': 'Creators mit Bitcoin über Lightning Network zappen',
        'about.feature4': 'Folgen Sie Ihren Lieblings-Creators auf jeder Nostr-App',
        'about.feature5': 'Themen durchsuchen und neue Inhalte entdecken',
        'about.feature6': 'Funktioniert mit jeder Nostr-Identität (verwenden Sie bestehende Schlüssel)',
        'about.openSource': 'Open Source',
        'about.openSourceDesc': 'Plebs ist Open-Source-Software. Sie können den Code einsehen, beitragen oder Ihre eigene Instanz betreiben:',
        'about.githubRepo': 'GitHub Repository',
        'about.builtBy': 'Entwickelt von',
        'about.builtByDesc': 'Plebs wird von <a href="https://nostrservices.com" target="_blank" rel="noopener" class="accent-link">21 Million LLC</a> entwickelt, einem Unternehmen, das sich dem Aufbau von Tools für das Bitcoin- und Nostr-Ökosystem widmet.',
        // Contact Page
        'contact.title': 'Kontakt',
        'contact.getInTouch': 'Kontaktieren Sie uns',
        'contact.getInTouchDesc': 'Haben Sie Fragen, Feedback oder benötigen Support? Wir würden uns freuen, von Ihnen zu hören!',
        'contact.email': 'E-Mail',
        'contact.emailDesc': 'Der beste Weg, uns zu kontaktieren, ist per E-Mail:',
        'contact.github': 'GitHub',
        'contact.githubDesc': 'Für Bug-Reports, Feature-Anfragen oder technische Probleme öffnen Sie bitte ein Issue in unserem Repository:',
        'contact.githubIssues': 'GitHub Issues',
        'contact.company': 'Unternehmen',
        'contact.companyDesc': 'Plebs wird von 21 Million LLC entwickelt',
        // Terms of Service
        'terms.title': 'Nutzungsbedingungen',
        'terms.lastUpdated': 'Letzte Aktualisierung: Dezember 2024',
        'terms.section1Title': '1. Annahme der Bedingungen',
        'terms.section1Desc': 'Durch den Zugriff auf und die Nutzung von Plebs ("der Dienst") erklären Sie sich damit einverstanden, an diese Nutzungsbedingungen gebunden zu sein. Wenn Sie mit diesen Bedingungen nicht einverstanden sind, nutzen Sie den Dienst bitte nicht.',
        'terms.section2Title': '2. Beschreibung des Dienstes',
        'terms.section2Desc': 'Plebs ist eine dezentrale Video-Plattform, die auf dem Nostr-Protokoll basiert. Der Dienst bietet eine Schnittstelle zum Durchsuchen, Hochladen und Interagieren mit Videoinhalten, die in verteilten Netzwerken gespeichert sind. Plebs hostet oder speichert keine Videoinhalte auf zentralisierten Servern.',
        'terms.section3Title': '3. Verantwortlichkeiten der Nutzer',
        'terms.section3Desc': 'Sie sind verantwortlich für:',
        'terms.section3Item1': 'Die Sicherheit Ihrer privaten Nostr-Schlüssel',
        'terms.section3Item2': 'Alle Inhalte, die Sie über den Dienst hochladen oder teilen',
        'terms.section3Item3': 'Die Einhaltung geltender Gesetze bei Ihrer Nutzung',
        'terms.section3Item4': 'Das Nicht-Hochladen illegaler, rechtsverletzender oder schädlicher Inhalte',
        'terms.section4Title': '4. Inhaltsrichtlinien',
        'terms.section4Desc': 'Sie verpflichten sich, Folgendes nicht hochzuladen, zu teilen oder zu verbreiten:',
        'terms.section4Item1': 'Inhalte, die geistige Eigentumsrechte verletzen',
        'terms.section4Item2': 'Illegale Inhalte, einschließlich aber nicht beschränkt auf Material zur Ausbeutung von Kindern',
        'terms.section4Item3': 'Inhalte, die Gewalt oder Schaden gegenüber anderen fördern',
        'terms.section4Item4': 'Spam, Malware oder irreführende Inhalte',
        'terms.section4Note': 'Inhalte für Erwachsene (NSFW) müssen beim Hochladen ordnungsgemäß mit dem NSFW-Tag gekennzeichnet werden.',
        'terms.section5Title': '5. Dezentrale Natur',
        'terms.section5Desc': 'Aufgrund der dezentralen Natur von Nostr und Blossom-Speicherung:',
        'terms.section5Item1': 'Inhalte können im Netzwerk bestehen bleiben, auch nach Löschanfragen',
        'terms.section5Item2': 'Wir können die Löschung von Inhalten von allen Relays oder Speicherservern nicht garantieren',
        'terms.section5Item3': 'Ihre Inhalte und Interaktionen sind standardmäßig öffentlich',
        'terms.section5Item4': 'Sie allein sind für die Sicherheit Ihres privaten Schlüssels verantwortlich',
        'terms.section6Title': '6. Keine Garantie',
        'terms.section6Desc': 'Der Dienst wird "wie besehen" ohne jegliche Garantien bereitgestellt. Wir garantieren keinen kontinuierlichen und ununterbrochenen Zugang zum Dienst.',
        'terms.section7Title': '7. Haftungsbeschränkung',
        'terms.section7Desc': 'Im maximal gesetzlich zulässigen Umfang haften Plebs und seine Betreiber nicht für indirekte, zufällige, spezielle oder Folgeschäden, die sich aus Ihrer Nutzung des Dienstes ergeben.',
        'terms.section8Title': '8. Änderungen der Bedingungen',
        'terms.section8Desc': 'Wir behalten uns das Recht vor, diese Bedingungen jederzeit zu ändern. Die fortgesetzte Nutzung des Dienstes nach Änderungen stellt die Annahme der neuen Bedingungen dar.',
        'terms.section9Title': '9. Kontakt',
        'terms.section9Desc': 'Bei Fragen zu diesen Bedingungen <a href="#/contact" class="accent-link">kontaktieren Sie uns bitte</a>.',
        // Privacy Policy
        'privacy.title': 'Datenschutzrichtlinie',
        'privacy.lastUpdated': 'Letzte Aktualisierung: Dezember 2024',
        'privacy.section1Title': '1. Übersicht',
        'privacy.section1Desc': 'Plebs verpflichtet sich, Ihre Privatsphäre zu schützen. Diese Richtlinie erklärt, wie wir Informationen verarbeiten, wenn Sie unsere dezentrale Video-Plattform nutzen.',
        'privacy.section2Title': '2. Dezentrale Architektur',
        'privacy.section2Desc': 'Plebs basiert auf Nostr, einem dezentralen Protokoll. Das bedeutet:',
        'privacy.section2Item1': 'Ihre Inhalte werden an öffentliche Relays gesendet, nicht auf unseren Servern gespeichert',
        'privacy.section2Item2': 'Ihr öffentlicher Nostr-Schlüssel dient als Ihre Identität',
        'privacy.section2Item3': 'Videos werden auf verteilten Blossom-Servern gespeichert',
        'privacy.section2Item4': 'Wir haben keinen Zugriff auf Ihre privaten Schlüssel',
        'privacy.section3Title': '3. Informationen, die wir sammeln',
        'privacy.section3LocalTitle': 'Lokal in Ihrem Browser gespeicherte Informationen:',
        'privacy.section3LocalItem1': 'Ihr öffentlicher Nostr-Schlüssel (wenn Sie angemeldet sind)',
        'privacy.section3LocalItem2': 'Wiedergabeverlauf und Einstellungen',
        'privacy.section3LocalItem3': 'Design-Präferenzen und Einstellungen',
        'privacy.section3LocalItem4': 'Privater Schlüssel (nur wenn Sie lokale Speicherung wählen - nicht empfohlen)',
        'privacy.section3CollectTitle': 'Informationen, die wir möglicherweise sammeln:',
        'privacy.section3CollectItem1': 'Grundlegende Analysen (Seitenaufrufe, Funktionsnutzung) zur Verbesserung des Dienstes',
        'privacy.section3CollectItem2': 'Fehlerprotokolle für Debugging',
        'privacy.section4Title': '4. Öffentliche Informationen',
        'privacy.section4Desc': 'Bei der Nutzung von Nostr sind folgende Daten per Design öffentlich:',
        'privacy.section4Item1': 'Ihr öffentlicher Nostr-Schlüssel und Profilinformationen',
        'privacy.section4Item2': 'Videos, die Sie hochladen',
        'privacy.section4Item3': 'Kommentare, Likes und andere Reaktionen',
        'privacy.section4Item4': 'Wem Sie folgen',
        'privacy.section4Item5': 'Zaps (Lightning-Zahlungen), die Sie senden oder empfangen',
        'privacy.section5Title': '5. Datenspeicherung',
        'privacy.section5Desc': 'Lokale Daten werden im localStorage Ihres Browsers gespeichert. Sie können diese Daten jederzeit über Ihre Browsereinstellungen löschen. Auf Nostr veröffentlichte Inhalte werden über Relays verteilt und können von Plebs nicht kontrolliert oder gelöscht werden.',
        'privacy.section6Title': '6. Dienste Dritter',
        'privacy.section6Desc': 'Plebs interagiert mit:',
        'privacy.section6Item1': 'Nostr-Relays (für soziale Daten)',
        'privacy.section6Item2': 'Blossom-Servern (für Videospeicherung)',
        'privacy.section6Item3': 'Lightning Network (für Zaps/Zahlungen)',
        'privacy.section6Note': 'Jeder dieser Dienste hat seine eigenen Datenschutzpraktiken.',
        'privacy.section7Title': '7. Ihre Rechte',
        'privacy.section7Desc': 'Sie können:',
        'privacy.section7Item1': 'Ihre lokalen Browser-Daten jederzeit löschen',
        'privacy.section7Item2': 'Videos durchsuchen, ohne ein Konto zu erstellen',
        'privacy.section7Item3': 'Eine Nostr-Browsererweiterung für erhöhte Privatsphäre verwenden',
        'privacy.section7Item4': 'Wählen, welche Relays und Blossom-Server verwendet werden sollen',
        'privacy.section8Title': '8. Sicherheit',
        'privacy.section8Desc': 'Wir empfehlen:',
        'privacy.section8Item1': 'Eine Nostr-Browsererweiterung oder Hardware-Signer zu verwenden',
        'privacy.section8Item2': 'Ihren privaten Schlüssel (nsec) niemals zu teilen',
        'privacy.section8Item3': 'Ein dediziertes Browserprofil für erhöhte Privatsphäre zu verwenden',
        'privacy.section9Title': '9. Änderungen dieser Richtlinie',
        'privacy.section9Desc': 'Wir können diese Richtlinie von Zeit zu Zeit aktualisieren. Änderungen werden auf dieser Seite mit einem aktualisierten Überarbeitungsdatum veröffentlicht.',
        'privacy.section10Title': '10. Kontakt',
        'privacy.section10Desc': 'Bei datenschutzbezogenen Fragen <a href="#/contact" class="accent-link">kontaktieren Sie uns bitte</a>.',
        // FAQ Page
        'faq.title': 'Häufig gestellte Fragen',
        'faq.aboutPlebs': 'Über Plebs',
        'faq.nostrProtocol': 'Nostr-Protokoll',
        'faq.videoStorage': 'Videospeicherung und Blossom',
        'faq.featuresUsage': 'Funktionen und Nutzung',
        'faq.q1': 'Was ist Plebs?',
        'faq.a1': 'Plebs ist eine dezentrale und zensurresistente Video-Plattform, die auf dem Nostr-Protokoll basiert. Anders als traditionelle unternehmensgesteuerte Plattformen gibt Ihnen Plebs echtes Eigentum an Ihren Inhalten und Ihrer Identität. Es gibt keine zentralen Server, die Sie sperren oder Ihre Inhalte löschen können.',
        'faq.q2': 'Ist Plebs kostenlos?',
        'faq.a2': 'Ja, Plebs ist völlig kostenlos zum Ansehen von Videos. Sie können Inhalte durchsuchen und ansehen, ohne ein Konto zu erstellen. Um Videos hochzuladen, zu kommentieren, zu liken oder mit anderen Nutzern zu interagieren, benötigen Sie eine Nostr-Identität (die ebenfalls kostenlos ist).',
        'faq.q3': 'Wer entwickelt Plebs?',
        'faq.a3': 'Plebs wird von <a href="https://nostrservices.com" target="_blank" rel="noopener">21 Million LLC</a> entwickelt, einem Unternehmen, das sich dem Aufbau von Tools für das Bitcoin- und Nostr-Ökosystem widmet. Plebs ist Open Source, und Sie können den Code einsehen oder auf <a href="https://github.com/Spl0itable/plebs-app" target="_blank" rel="noopener">GitHub</a> beitragen.',
        'faq.q4': 'Was ist Nostr?',
        'faq.a4': 'Nostr steht für "Notes and Other Stuff Transmitted by Relays". Es ist ein einfaches, offenes Protokoll, das ein wirklich dezentrales soziales Netzwerk ermöglicht. Anders als traditionelle Plattformen verlässt sich Nostr nicht auf einen zentralen Server. Stattdessen nutzt es ein Netzwerk von Relays, um Nachrichten zwischen Nutzern zu übertragen, und kryptographische Schlüssel für die Identität.',
        'faq.q5': 'Warum nutzt Plebs Nostr?',
        'faq.a5Title': 'Nostr bietet mehrere wichtige Vorteile:',
        'faq.a5Item1': 'Zensurresistenz:',
        'faq.a5Item1Desc': 'Keine Instanz kann Sie sperren oder Ihre Inhalte löschen',
        'faq.a5Item2': 'Portabilität:',
        'faq.a5Item2Desc': 'Ihre Identität und Follower funktionieren in allen Nostr-Apps',
        'faq.a5Item3': 'Keine zentrale Autorität:',
        'faq.a5Item3Desc': 'Kein Unternehmen besitzt oder kontrolliert das Netzwerk',
        'faq.a5Item4': 'Kryptographische Identität:',
        'faq.a5Item4Desc': 'Ihre Schlüssel beweisen, dass Sie sind, wer Sie sagen',
        'faq.q6': 'Was sind Nostr-Schlüssel (npub/nsec)?',
        'faq.a6': 'Ihre Nostr-Identität besteht aus zwei Schlüsseln: einem öffentlichen Schlüssel (npub) und einem privaten Schlüssel (nsec). Ihr npub ist wie Ihr Benutzername - Sie können ihn mit jedem teilen. Ihr nsec ist wie Ihr Passwort - teilen Sie ihn niemals! Jeder mit Ihrem nsec kann in Ihrem Namen posten und auf Ihr Konto zugreifen. Wir empfehlen die Verwendung einer Browsererweiterung wie Alby oder nos2x zur sicheren Verwaltung Ihrer Schlüssel.',
        'faq.q7': 'Kann ich mein bestehendes Nostr-Konto verwenden?',
        'faq.a7': 'Absolut! Wenn Sie bereits eine Nostr-Identität von Apps wie Damus, Primal, Amethyst oder einem anderen Nostr-Client haben, können Sie dieselben Schlüssel verwenden, um sich bei Plebs anzumelden. Ihre Follower, Ihr Profil und Ihre Reputation werden automatisch übertragen.',
        'faq.q8': 'Was sind Nostr-Relays?',
        'faq.a8': 'Relays sind Server, die Nostr-Nachrichten speichern und übertragen. Wenn Sie etwas posten, wird es an mehrere Relays gesendet. Andere Nutzer verbinden sich mit Relays, um Nachrichten zu lesen. Da es viele unabhängige Relays gibt, kann Sie keines zensieren - wenn ein Relay Sie blockiert, existieren Ihre Inhalte immer noch auf anderen.',
        'faq.q9': 'Wo werden Videos gespeichert?',
        'faq.a9': 'Videos werden auf Blossom-Servern gespeichert, nicht auf Plebs selbst. Blossom ist ein verteiltes Speichersystem, das für die Zusammenarbeit mit Nostr entwickelt wurde. Wenn Sie ein Video hochladen, gelangt es zu einem oder mehreren Blossom-Servern Ihrer Wahl. Video-Metadaten (Titel, Beschreibung usw.) werden auf Nostr-Relays veröffentlicht.',
        'faq.q10': 'Was ist Blossom?',
        'faq.a10': 'Blossom ist ein offenes Protokoll zum dezentralen Speichern und Bereitstellen von Mediendateien. Dateien werden durch ihren SHA-256-Hash identifiziert, was bedeutet, dass dieselbe Datei dieselbe Adresse hat, unabhängig davon, welcher Server sie hostet. Dies ermöglicht Redundanz - Ihre Dateien können auf mehreren Servern existieren. Erfahren Sie mehr auf <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom GitHub</a>.',
        'faq.q11': 'Hostet Plebs meine Videos?',
        'faq.a11': 'Nein. Plebs ist ein Client/Interface, der Ihnen beim Durchsuchen und Hochladen von Inhalten hilft, aber keine Video- oder Bilddateien speichert. Alle Medien werden auf unabhängigen Blossom-Servern gespeichert. Plebs zeigt einfach Inhalte von diesen verteilten Speicheranbietern an.',
        'faq.q12': 'Kann ich wählen, welchen Blossom-Server ich verwende?',
        'faq.a12': 'Ja! Sie können in Ihren Einstellungen konfigurieren, welche Blossom-Server Sie zum Hochladen verwenden möchten. Sie können sogar Ihren eigenen Blossom-Server betreiben, wenn Sie vollständige Kontrolle über Ihre Medienspeicherung wünschen.',
        'faq.q13': 'Wie erstelle ich ein Konto?',
        'faq.a13Title': 'Klicken Sie auf die Schaltfläche "Anmelden" und wählen Sie Ihre bevorzugte Methode:',
        'faq.a13Item1': 'Browsererweiterung:',
        'faq.a13Item1Desc': 'Wenn Sie eine Nostr-Erweiterung wie Alby oder nos2x installiert haben, können Sie diese zur sicheren Anmeldung verwenden',
        'faq.a13Item2': 'Neue Schlüssel generieren:',
        'faq.a13Item2Desc': 'Erstellen Sie eine brandneue Nostr-Identität',
        'faq.a13Item3': 'Schlüssel importieren:',
        'faq.a13Item3Desc': 'Verwenden Sie Ihren bestehenden privaten Nostr-Schlüssel (nsec)',
        'faq.a13Note': 'Wir empfehlen die Verwendung einer Browsererweiterung für die beste Sicherheit.',
        'faq.q14': 'Was sind Zaps?',
        'faq.a14': 'Zaps sind Bitcoin-Zahlungen, die über das Lightning Network gesendet werden. Sie ermöglichen es Ihnen, echtes Geld (Satoshis oder "Sats") an Content-Creator als Trinkgeld oder Wertschätzung zu senden. Anders als traditionelle Plattform-Trinkgelder, die hohe Gebühren erheben, gehen Zaps direkt an den Creator. Um Zaps zu senden, benötigen Sie eine Lightning-Wallet mit Nostr-Verbindung (wie Alby oder Zeus).',
        'faq.q15': 'Wie lade ich ein Video hoch?',
        'faq.a15Title': 'Um ein Video hochzuladen:',
        'faq.a15Item1': 'Melden Sie sich mit Ihrer Nostr-Identität an',
        'faq.a15Item2': 'Klicken Sie auf die Schaltfläche "Erstellen" und wählen Sie "Video hochladen"',
        'faq.a15Item3': 'Wählen Sie Ihre Videodatei aus (unterstützt die meisten gängigen Formate)',
        'faq.a15Item4': 'Fügen Sie einen Titel, eine Beschreibung und Tags hinzu',
        'faq.a15Item5': 'Klicken Sie auf "Veröffentlichen", um mit dem Netzwerk zu teilen',
        'faq.a15Note': 'Videos werden automatisch komprimiert und auf Blossom-Server hochgeladen.',
        // FAQ Self-Moderation Section
        'faq.selfModeration': 'Selbst-Moderation',
        'faq.q16': 'Wie funktioniert die Moderation auf einer dezentralen Plattform?',
        'faq.a16': 'Im Gegensatz zu traditionellen Plattformen mit zentralisierten Moderatoren gibt Ihnen Plebs die Kontrolle darüber, was Sie sehen. Wir bieten leistungsstarke Selbst-Moderationstools einschließlich Inhaltsfilter-Paketen, Benutzer-Stummschaltung, Community-Warnungen und Indikatoren für stark negativ bewertete Videos. Sie entscheiden, welche Inhalte für Sie angemessen sind - es gibt keine zentrale Autorität, die diese Entscheidungen trifft.',
        'faq.q17': 'Was sind Inhaltsfilter-Pakete?',
        'faq.a17Intro': 'Inhaltsfilter-Pakete sind vordefinierte Schlüsselwort-Filter, die Sie aktivieren können, um bestimmte Arten von Inhalten auszublenden. Verfügbare Pakete umfassen:',
        'faq.a17Pack1': 'Rassismus & Hassrede:',
        'faq.a17Pack1Desc': 'Filtert rassistische Beleidigungen und diskriminierenden Inhalt',
        'faq.a17Pack2': 'Sexuell Explizit:',
        'faq.a17Pack2Desc': 'Filtert pornografische und erwachsene Inhalte',
        'faq.a17Pack3': 'Gewalt & Gore:',
        'faq.a17Pack3Desc': 'Filtert grafische Gewalt und Selbstverletzungsinhalte',
        'faq.a17Pack4': 'Drogen & Substanzen:',
        'faq.a17Pack4Desc': 'Filtert drogenbezogene Inhalte',
        'faq.a17Pack5': 'Spam & Betrug:',
        'faq.a17Pack5Desc': 'Filtert gängige Spam- und Betrugsmuster',
        'faq.a17Pack6': 'Kryptowährung:',
        'faq.a17Pack6Desc': 'Filtert Krypto-Werbung und Token-Shilling',
        'faq.a17Pack7': 'Politischer Inhalt:',
        'faq.a17Pack7Desc': 'Filtert parteiische politische Inhalte',
        'faq.a17Pack8': 'Starke Schimpfwörter:',
        'faq.a17Pack8Desc': 'Filtert vulgäre Sprache',
        'faq.a17Note': 'Aktivieren Sie diese unter Einstellungen > Inhaltsfilter. Sie können auch benutzerdefinierte Schlüsselwörter hinzufügen. Gefilterter Inhalt zeigt einen Platzhalter mit einer "Trotzdem anzeigen"-Schaltfläche, wenn Sie ihn vorübergehend sehen möchten.',
        'faq.q18': 'Wie schalte ich einen Benutzer stumm?',
        'faq.a18': 'Um einen Benutzer stummzuschalten, besuchen Sie sein Profil und klicken Sie auf die Stummschalt-Schaltfläche. Einmal stummgeschaltet, werden alle ihre Videos aus Ihrem Feed ausgeblendet, ihre Kommentare werden als "Nachricht von stummgeschaltetem Benutzer" angezeigt und ihre Live-Chat-Nachrichten werden ausgeblendet. Ihre Stummschaltungsliste wird auf Nostr gespeichert, sodass sie geräteübergreifend synchronisiert wird. Sie können stummgeschaltete Benutzer in Ihren Profileinstellungen unter "Stummgeschaltete Benutzer" verwalten.',
        'faq.q19': 'Was bedeutet "Ratioed"?',
        'faq.a19': 'Ein Video wird als "ratioed" markiert, wenn es deutlich mehr Dislikes als Likes hat, was auf eine negative Reaktion der Community hinweist. Konkret ist ein Video ratioed, wenn es mindestens 10 Reaktionen hat, Dislikes mindestens doppelt so viele wie Likes sind und Dislikes 70% oder mehr der Gesamtreaktionen ausmachen. Ratioed-Videos zeigen ein Warnabzeichen an, und Sie werden vor dem Ansehen um Bestätigung gebeten.',
        'faq.q20': 'Wie funktionieren Community-Warnungen?',
        'faq.a20': 'Benutzer können Inhalte aus verschiedenen Gründen melden (Spam, illegaler Inhalt, Missbrauch, irreführend usw.). Wenn ein Video oder Benutzer 5 oder mehr Meldungen von Personen erhält, denen Sie folgen, erscheint ein Warnindikator. Dies nutzt Ihren sozialen Graph - Warnungen kommen von Ihrem vertrauenswürdigen Netzwerk, nicht von anonymen Fremden. Sie können "Warnungen von Konten anzeigen, denen ich folge" in den Einstellungen aktivieren.',
        'faq.q21': 'Wie melde ich Inhalte?',
        'faq.a21': 'Klicken Sie auf das Flaggen-Symbol bei jedem Video, Kommentar oder Benutzerprofil, um es zu melden. Wählen Sie einen Grund (Spam, Illegal, Missbrauch, Irreführend, Identitätsdiebstahl, Urheberrecht oder Sonstiges) und fügen Sie optional Details hinzu. Meldungen werden als Ereignisse auf Nostr veröffentlicht, was sie transparent und dezentral macht. Ihre Meldungen helfen anderen in Ihrem Netzwerk, problematische Inhalte zu identifizieren.',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': 'Privatsphäre & Sicherheit',
        'faq.q22': 'Ist meine Aktivität privat?',
        'faq.a22': 'Auf Nostr ist die meiste Aktivität standardmäßig öffentlich. Ihre Likes, Kommentare, Follower und Zaps sind im öffentlichen Netzwerk sichtbar. Allerdings speichert Plebs Ihren Wiedergabeverlauf lokal in Ihrem Browser - er wird niemals an einen Server gesendet. Sie können Ihre lokalen Daten jederzeit löschen.',
        'faq.q23': 'Wie halte ich mein Konto sicher?',
        'faq.a23': 'Teilen Sie niemals Ihren privaten Schlüssel (nsec) mit jemandem. Wir empfehlen dringend, eine Nostr-Browsererweiterung wie Alby, nos2x oder einen Hardware-Signer zu verwenden. Diese halten Ihren privaten Schlüssel sicher und signieren Ereignisse nur, wenn Sie sie genehmigen. Vermeiden Sie es, Ihren nsec direkt auf Websites zu speichern.',
        'faq.q24': 'Kann ich meine Inhalte löschen?',
        'faq.a24': 'Sie können die Löschung anfordern, indem Sie ein Löschereignis auf Nostr veröffentlichen. Die meisten gut verhaltenen Relays und Clients werden dies respektieren. Aufgrund der dezentralen Natur des Netzwerks können Inhalte jedoch auf einigen Relays oder Blossom-Servern bestehen bleiben. Es gibt keine zentrale Autorität, die eine vollständige Löschung im gesamten Netzwerk erzwingen kann.',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': 'Fehlerbehebung',
        'faq.q25': 'Videos werden nicht geladen - was soll ich tun?',
        'faq.a25Intro': 'Wenn Videos nicht geladen werden, versuchen Sie diese Schritte:',
        'faq.a25Item1': 'Seite aktualisieren',
        'faq.a25Item2': 'Internetverbindung überprüfen',
        'faq.a25Item3': 'Der Blossom-Server, der das Video hostet, könnte ausgefallen sein - dies ist unabhängig von Plebs',
        'faq.a25Item4': 'Versuchen Sie, Browsererweiterungen zu deaktivieren, die Inhalte blockieren könnten',
        'faq.a25Item5': 'Browser-Cache löschen und erneut versuchen',
        'faq.q26': 'Ich habe meinen privaten Schlüssel verloren - können Sie mir helfen, ihn wiederherzustellen?',
        'faq.a26': 'Leider nein. Nostr-Schlüssel sind kryptographisch - es gibt kein Passwort-Reset oder Konto-Wiederherstellung, weil es keine zentrale Autorität gibt. Deshalb empfehlen wir dringend, Ihre Schlüssel zu sichern und eine sichere Schlüsselverwaltungslösung zu verwenden. Wenn Sie Ihren nsec verlieren, müssen Sie eine neue Identität erstellen.',
        'faq.q27': 'Wie melde ich einen Fehler oder fordere eine Funktion an?',
        'faq.a27': 'Sie können Fehler melden oder Funktionen auf unserer <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a>-Seite anfordern. Sie können uns auch auf Nostr erreichen - besuchen Sie unsere <a href="#/contact">Kontakt</a>-Seite für Details.',
        // Page Titles
        'pageTitle.following': 'Abonniert', 'pageTitle.myVideos': 'Meine Videos', 'pageTitle.likedVideos': 'Gelikte Videos', 'pageTitle.watchHistory': 'Wiedergabeverlauf', 'pageTitle.liveStreams': 'Livestreams', 'pageTitle.suffix': '- Plebs', 'pageTitle.liveSuffix': '- Live auf Plebs',
        // Home Page Sections
        'section.trending': 'Trends', 'section.recommended': 'Für Dich Empfohlen', 'section.shorts': 'Shorts', 'section.live': 'Live', 'section.liveNow': 'Jetzt Live', 'section.latestVideos': 'Neueste Videos', 'section.videos': 'Videos', 'section.usersYouFollow': 'Benutzer, Denen Du Folgst',
        // Trending Period
        'trending.thisWeek': 'Diese Woche', 'trending.today': 'Heute',
        // Buttons
        'button.viewMore': 'Mehr anzeigen', 'button.clearAll': 'Alles löschen', 'button.showAnyway': 'Trotzdem anzeigen',
        // Confirmation Modals
        'confirm.logout': 'Abmelden', 'confirm.logoutMessage': 'Sind Sie sicher, dass Sie sich abmelden möchten?', 'confirm.resetSettings': 'Einstellungen zurücksetzen', 'confirm.resetSettingsMessage': 'Sind Sie sicher, dass Sie alle Einstellungen auf die Standardwerte zurücksetzen möchten?', 'confirm.reset': 'Zurücksetzen', 'confirm.clearHistory': 'Verlauf löschen', 'confirm.clearHistoryMessage': 'Sind Sie sicher, dass Sie Ihren gesamten Wiedergabeverlauf löschen möchten? Dies kann nicht rückgängig gemacht werden.', 'confirm.deleteDraft': 'Entwurf löschen', 'confirm.deleteDraftMessage': 'Sind Sie sicher, dass Sie diesen Entwurf löschen möchten?', 'confirm.delete': 'Löschen', 'confirm.deleteVideo': 'Video löschen', 'confirm.deleteVideoMessage': 'Sind Sie sicher, dass Sie dieses Video löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.', 'confirm.endStream': 'Livestream beenden', 'confirm.endStreamMessage': 'Sind Sie sicher, dass Sie diesen Livestream beenden möchten? Diese Aktion kann nicht rückgängig gemacht werden.', 'confirm.endStreamButton': 'Stream beenden',
        // Content Filters
        'filter.hiddenByPack': 'Versteckt durch {pack}', 'filter.showAnyway': 'Trotzdem anzeigen', 'filter.contentHidden': 'Inhalt durch Inhaltsfilter versteckt',
        // Filter Packs
        'filter.racism': 'Rassismus & Hassrede', 'filter.racismDesc': 'Filtert rassistische Beleidigungen, ethnische Hassrede und diskriminierende Inhalte', 'filter.sexualExplicit': 'Sexuell Explizit', 'filter.sexualExplicitDesc': 'Filtert pornografische Begriffe und sexuell explizite Inhalte', 'filter.violence': 'Gewalt & Gore', 'filter.violenceDesc': 'Filtert grafische Gewalt, Gore und Gewaltdrohungen', 'filter.drugs': 'Drogen & Substanzen', 'filter.drugsDesc': 'Filtert drogenbezogene Inhalte und Substanzmissbrauch', 'filter.spam': 'Spam & Betrug', 'filter.spamDesc': 'Filtert gängigen Spam, Betrug und Werbeinhalte', 'filter.crypto': 'Kryptowährung', 'filter.cryptoDesc': 'Filtert Kryptowährungswerbung, Trading-Signale und Token-Promotion', 'filter.politics': 'Politische Inhalte', 'filter.politicsDesc': 'Filtert parteiische politische Inhalte und spaltende Rhetorik', 'filter.profanity': 'Starke Schimpfwörter', 'filter.profanityDesc': 'Filtert starke Schimpfwörter und vulgäre Sprache', 'filter.customFilter': 'Benutzerdefinierter Filter',
        // Following Page
        'following.noFollowingYet': 'Du folgst noch niemandem. Finde Creator zum Folgen!',
    },
    pt: {
        // Navigation & Header
        'nav.home': 'Início', 'nav.following': 'Seguindo', 'nav.myVideos': 'Meus Vídeos', 'nav.liked': 'Curtidos', 'nav.history': 'Histórico', 'nav.topics': 'TÓPICOS', 'nav.live': 'Ao Vivo', 'nav.bitcoin': 'Bitcoin', 'nav.nostr': 'Nostr', 'nav.technology': 'Tecnologia', 'nav.gaming': 'Jogos', 'nav.tutorials': 'Tutoriais', 'nav.podcasts': 'Podcasts', 'nav.music': 'Música', 'nav.nsfw': 'NSFW', 'nav.about': 'Sobre', 'nav.contact': 'Contato', 'nav.terms': 'Termos', 'nav.privacy': 'Privacidade', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.playlists': 'Playlists', 'nav.downloads': 'Downloads', 'nav.subscriptions': 'Inscrições', 'nav.trending': 'Em Alta', 'nav.explore': 'Explorar', 'nav.categories': 'Categorias', 'nav.liveStreams': 'Transmissões ao Vivo', 'nav.github': 'GitHub',
        'header.search': 'Pesquisar vídeos...', 'header.notifications': 'Notificações', 'header.settings': 'Configurações', 'header.create': 'Criar', 'header.admin': 'Admin', 'header.viewProfile': 'Ver Perfil', 'header.logout': 'Sair',
        // Login Modal
        'login.title': 'Entrar com Nostr', 'login.extension': 'Entrar com Extensão', 'login.extensionDesc': 'Use Alby, nos2x ou outras extensões Nostr', 'login.connect': 'Nostr Connect', 'login.connectDesc': 'Conecte com assinantes remotos como Amber, nsec.app', 'login.privateKey': 'Chave Privada', 'login.privateKeyDesc': 'Digite sua nsec ou chave hex (somente local)', 'login.newToNostr': 'Novo no Nostr?', 'login.createAccount': 'Criar Conta', 'login.createAccountDesc': 'Comece com uma nova identidade Nostr para usar no Plebs',
        // Connect Modal
        'connect.title': 'Conectar com Nostr', 'connect.option1': 'Opção 1: Use esta string de conexão', 'connect.option1Desc': 'Copie e cole isso em qualquer app compatível com NIP-46 (nsec.app, Amber, etc.)', 'connect.copyString': 'Copiar String de Conexão', 'connect.showQR': 'Mostrar Código QR', 'connect.listening': 'Aguardando conexão...', 'connect.option2': 'Opção 2: Colar uma URL bunker', 'connect.option2Desc': 'Se você já tem uma URL bunker:// de um assinante remoto', 'connect.withBunker': 'Conectar com Bunker', 'connect.or': 'OU', 'connect.bunkerPlaceholder': 'bunker://...',
        // Private Key Modal
        'privateKey.title': 'Entrar com Chave Privada', 'privateKey.warning': 'Aviso de Segurança', 'privateKey.warningText': 'Sua chave privada será armazenada localmente no seu navegador. Para maior segurança, considere usar uma extensão de navegador ou Nostr Connect.', 'privateKey.label': 'Chave Privada (nsec ou hex)', 'privateKey.showKey': 'Mostrar chave', 'privateKey.login': 'Entrar', 'privateKey.placeholder': 'nsec1...',
        // Signup Modal
        'signup.title': 'Criar Conta Nostr', 'signup.whatIsNostr': 'O que é Nostr?', 'signup.nostrExplanation': 'Nostr é um protocolo social descentralizado que dá a você a propriedade de sua identidade e conteúdo. Diferente das plataformas tradicionais, nenhuma empresa pode bani-lo, censurar seu conteúdo ou fechar sua conta.', 'signup.whyPlebs': 'Por que o Plebs usa Nostr?', 'signup.plebsExplanation': 'Plebs é construído no Nostr para fornecer compartilhamento de vídeos resistente à censura. Seus vídeos, comentários e interações são armazenados em uma rede de relays, não em nossos servidores.', 'signup.howItWorks': 'Como funciona', 'signup.keysIdentity': 'Suas chaves = Sua identidade.', 'signup.keysIdentityDesc': 'Você receberá uma chave privada (nsec) que prova que você é dono da sua conta.', 'signup.keepSecret': 'Mantenha sua chave privada em segredo!', 'signup.keepSecretDesc': 'É como uma senha que nunca pode ser redefinida.', 'signup.oneIdentity': 'Uma identidade, vários apps.', 'signup.oneIdentityDesc': 'Use a mesma conta no Damus, Primal, Amethyst e mais.', 'signup.gotIt': 'Entendi, vamos criar minha conta', 'signup.username': 'Nome de Usuário', 'signup.usernamePlaceholder': 'Escolha um nome de exibição', 'signup.about': 'Sobre (opcional)', 'signup.aboutPlaceholder': 'Conte aos outros sobre você', 'signup.profilePicture': 'Foto de Perfil (opcional)', 'signup.uploadPhoto': 'Enviar Foto', 'signup.remove': 'Remover', 'signup.avatarHint': 'Imagens quadradas funcionam melhor. Máx 5MB.', 'signup.uploading': 'Enviando...', 'signup.lightningAddress': 'Endereço Lightning (opcional)', 'signup.lightningPlaceholder': 'voce@walletofsatoshi.com', 'signup.lightningHint': 'Adicione um endereço Lightning para receber zaps (gorjetas em Bitcoin) em seus vídeos e perfil.', 'signup.nostrAddress': 'Endereço Nostr', 'signup.nostrAddressPlaceholder': 'usuario', 'signup.nostrAddressHint': 'Seu endereço Nostr facilita encontrar seu perfil. Apenas letras minúsculas, números, _ e -.', 'signup.nostrAddressRequired': 'Por favor, insira um endereço Nostr', 'signup.nostrAddressAvailable': 'Disponível!', 'signup.nostrAddressUnavailable': 'Já está em uso', 'signup.nostrAddressChecking': 'Verificando...', 'signup.nostrAddressInvalid': 'Formato de nome de usuário inválido', 'signup.nostrAddressRegistering': 'Registrando seu endereço Nostr...', 'signup.nostrAddressSuccess': 'Endereço Nostr registrado!', 'signup.nostrAddressFailed': 'Não foi possível registrar o endereço Nostr', 'signup.yourUsername': 'Seu Nome de Usuário', 'signup.yourBio': 'Sua bio aparecerá aqui', 'signup.createAccountBtn': 'Criar Conta', 'signup.termsAgree': 'Ao criar uma conta, você concorda com nossos', 'signup.and': 'e', 'signup.success': 'Conta Criada com Sucesso!', 'signup.yourPrivateKey': 'Sua Chave Privada (nsec)', 'signup.keyWarning': 'Esta é a ÚNICA forma de acessar sua conta. Guarde-a em segurança!', 'signup.copyPrivateKey': 'Copiar Chave Privada', 'signup.howToUseKey': 'Como usar sua chave privada', 'signup.continueToPlebs': 'Continuar para o Plebs',
        // Notifications
        'notifications.title': 'Notificações', 'notifications.settings': 'Configurações de Notificações', 'notifications.reactions': 'Reações (curtir/não curtir)', 'notifications.replies': 'Comentários & Respostas', 'notifications.zaps': 'Zaps', 'notifications.chatMentions': 'Menções no Chat ao Vivo', 'notifications.newFollowers': 'Novos Seguidores', 'notifications.syncNote': 'Configurações são sincronizadas entre dispositivos via Nostr',
        // Settings Modal
        'settings.title': 'Configurações', 'settings.language': 'Idioma', 'settings.languageDesc': 'Escolha seu idioma preferido', 'settings.saveToNostr': 'Salvar no Nostr', 'settings.saveToNostrDesc': 'Sincronizar configurações em todas as instâncias do Plebs', 'settings.darkMode': 'Modo Escuro', 'settings.darkModeDesc': 'Alternar entre tema claro e escuro', 'settings.contentWarning': 'Preferências de Aviso de Conteúdo', 'settings.showNsfwWarnings': 'Mostrar avisos NSFW', 'settings.showNsfwWarningsDesc': 'Exibir verificação de idade para conteúdo NSFW', 'settings.showCommunityWarnings': 'Mostrar avisos da comunidade', 'settings.showCommunityWarningsDesc': 'Exibir avisos para conteúdo sinalizado ou com muitos votos negativos', 'settings.showFollowsReportWarnings': 'Mostrar avisos de relatórios de seguidos', 'settings.showFollowsReportWarningsDesc': 'Exibir avisos quando 5+ pessoas que você segue reportaram conteúdo', 'settings.filterPacks': 'Pacotes de Filtros de Conteúdo', 'settings.filterPacksDesc': 'Ative pacotes de filtros para ocultar automaticamente conteúdo com palavras-chave específicas.', 'settings.customKeywordFilter': 'Filtro de Palavras-chave Personalizado', 'settings.customKeywordFilterPlaceholder': 'Digite palavras-chave ou frases separadas por vírgulas\nExemplo: spam, conteúdo indesejado, frase específica', 'settings.customKeywordFilterDesc': 'Adicione suas próprias palavras-chave para filtrar (separadas por vírgulas)', 'settings.saveSettings': 'Salvar Configurações', 'settings.resetDefaults': 'Redefinir', 'settings.notificationSettings': 'Configurações de Notificação',
        // Upload Modal
        'upload.title': 'Enviar Vídeo', 'upload.videoFile': 'Arquivo de Vídeo', 'upload.clickToSelect': 'Clique para selecionar vídeo ou arraste e solte', 'upload.fileTypes': 'MP4, AVI, MOV, etc (máx 2GB entrada, será comprimido para <100MB)', 'upload.preparing': 'Preparando...', 'upload.thumbnail': 'Miniatura', 'upload.thumbnailHint': 'Clique para selecionar ou gerar automaticamente do vídeo', 'upload.uploading': 'Enviando...', 'upload.titleLabel': 'Título', 'upload.titlePlaceholder': 'Digite o título do vídeo', 'upload.descriptionLabel': 'Descrição', 'upload.descriptionPlaceholder': 'Conte aos espectadores sobre seu vídeo', 'upload.tagsLabel': 'Tags (separadas por vírgula)', 'upload.tagsPlaceholder': 'bitcoin, nostr, tutorial', 'upload.markNsfw': 'Marcar como NSFW (18+)', 'upload.nsfwDesc': 'Conteúdo adulto deve ser marcado como NSFW', 'upload.saveDraft': 'Salvar como Rascunho', 'upload.publish': 'Publicar', 'upload.selectVideo': 'Selecione um vídeo para enviar', 'upload.optional': '(opcional)', 'upload.remove': 'Remover', 'upload.qualityHigh': 'Alta',
        // Create Modal
        'create.title': 'Criar', 'create.goLive': 'Ao Vivo', 'create.goLiveDesc': 'Inicie uma transmissão ao vivo ou agende uma', 'create.uploadVideo': 'Enviar Vídeo', 'create.uploadVideoDesc': 'Envie um vídeo do seu dispositivo', 'create.createShort': 'Criar Short', 'create.createShortDesc': 'Envie um vídeo vertical (menos de 60s)',
        // Go Live Modal
        'goLive.title': 'Ao Vivo', 'goLive.when': 'Quando você quer transmitir ao vivo?', 'goLive.now': 'Transmitir Agora', 'goLive.schedule': 'Agendar Transmissão', 'goLive.streamTitle': 'Título da Transmissão', 'goLive.streamTitlePlaceholder': 'Digite o título da sua transmissão', 'goLive.description': 'Descrição', 'goLive.descriptionPlaceholder': 'Conte aos espectadores sobre o que é sua transmissão', 'goLive.tags': 'Tags (separadas por vírgula)', 'goLive.tagsPlaceholder': 'gaming, bitcoin, tutorial', 'goLive.streamUrl': 'URL da Transmissão (RTMP, HLS ou WebRTC)', 'goLive.streamUrlPlaceholder': 'https://seu-servico-streaming.com/stream.m3u8', 'goLive.zapGoal': 'Meta de Zaps (opcional)', 'goLive.zapGoalLabel': 'Meta de Zaps', 'goLive.zapGoalPlaceholder': 'ex. 10000', 'goLive.cancel': 'Cancelar', 'goLive.goLiveBtn': 'Transmitir',
        // Video/Live No Description
        'video.noDescription': 'Nenhuma descrição foi adicionada a este vídeo.', 'live.noDescription': 'Nenhuma descrição foi adicionada a esta transmissão ao vivo.',
        // Edit Stream Modal
        'editStream.title': 'Editar Transmissão', 'editStream.changeThumbnail': 'Alterar Miniatura', 'editStream.titleLabel': 'Título', 'editStream.saveChanges': 'Salvar Alterações',
        // NSFW Warning Modal
        'nsfw.title': 'Verificação de Idade Necessária', 'nsfw.description': 'Este conteúdo está marcado como NSFW e pode conter material adulto. Você deve ter 18 anos ou mais para ver este conteúdo.', 'nsfw.confirm': 'Eu tenho 18 anos ou mais', 'nsfw.remember': 'Não perguntar novamente (Lembrar minha escolha)',
        // Community Warning Modal
        'communityWarning.title': 'Aviso da Comunidade', 'communityWarning.description': 'Este vídeo foi sinalizado e/ou teve muitos votos negativos da comunidade. Isso pode ser devido a:', 'communityWarning.reason1': 'Conteúdo inadequado não marcado corretamente como NSFW', 'communityWarning.reason2': 'Detalhes de usuário novo ou suspeito', 'communityWarning.reason3': 'Informações enganosas ou falsas', 'communityWarning.reason4': 'Spam ou conteúdo de baixa qualidade', 'communityWarning.reason5': 'Conteúdo potencialmente prejudicial ou ilegal', 'communityWarning.proceed': 'Prossiga com cautela.', 'communityWarning.goBack': 'Voltar', 'communityWarning.viewAnyway': 'Ver Mesmo Assim',
        // Report Modal
        'report.title': 'Denunciar Vídeo', 'report.description': 'Selecione um motivo para denunciar este conteúdo:', 'report.nudity': 'Nudez ou Conteúdo Sexual', 'report.nudityDesc': 'Contém imagens sexuais ou explícitas não marcadas como NSFW', 'report.hate': 'Discurso de Ódio ou Assédio', 'report.hateDesc': 'Promove violência, ódio ou assédio', 'report.illegal': 'Conteúdo Ilegal', 'report.illegalDesc': 'Conteúdo que pode violar leis', 'report.spam': 'Spam ou Enganoso', 'report.spamDesc': 'Conteúdo enganoso, golpes ou spam repetitivo', 'report.impersonation': 'Falsificação de Identidade', 'report.impersonationDesc': 'Fingir ser outra pessoa', 'report.other': 'Outro', 'report.otherDesc': 'Outra violação não listada', 'report.cancel': 'Cancelar', 'report.submit': 'Enviar Denúncia',
        // Share Modal
        'share.title': 'Compartilhar Vídeo', 'share.link': 'Link', 'share.embed': 'Incorporar', 'share.shareWith': 'Compartilhe este vídeo com outros:', 'share.copy': 'Copiar', 'share.copied': 'Copiado para a área de transferência!', 'share.embedOnWebsite': 'Incorpore este vídeo no seu site:', 'share.size': 'Tamanho:', 'share.responsive': 'Responsivo (Padrão)', 'share.size1280x720': '1280 × 720 (HD)', 'share.embedCodeCopied': 'Código de incorporação copiado!',
        // Edit Video Modal
        'editVideo.title': 'Editar Vídeo', 'editVideo.video': 'Vídeo', 'editVideo.replaceVideo': 'Substituir Vídeo', 'editVideo.thumbnail': 'Miniatura', 'editVideo.changeThumbnail': 'Alterar Miniatura', 'editVideo.titleLabel': 'Título', 'editVideo.descriptionLabel': 'Descrição', 'editVideo.tagsLabel': 'Tags (separadas por vírgula)', 'editVideo.cancel': 'Cancelar', 'editVideo.saveChanges': 'Salvar Alterações',
        // Edit Profile Modal
        'editProfile.title': 'Editar Perfil', 'editProfile.displayName': 'Nome de Exibição', 'editProfile.displayNamePlaceholder': 'Seu nome de exibição', 'editProfile.about': 'Sobre', 'editProfile.aboutPlaceholder': 'Conte aos outros sobre você', 'editProfile.picture': 'Foto de Perfil', 'editProfile.pictureUrl': 'Ou digite a URL da imagem diretamente:', 'editProfile.nip05': 'Identificador NIP-05 (opcional)', 'editProfile.nip05Hint': 'Um endereço Nostr verificado para verificação de identidade.', 'editProfile.website': 'Site (opcional)', 'editProfile.saveChanges': 'Salvar Alterações',
        // Confirmation Modal
        'confirm.title': 'Confirmar Ação', 'confirm.message': 'Tem certeza que deseja continuar?', 'confirm.cancel': 'Cancelar', 'confirm.confirm': 'Confirmar',
        // Video Page
        'video.views': 'visualizações', 'video.view': 'visualização', 'video.followers': 'seguidores', 'video.follower': 'seguidor', 'video.follow': 'Seguir', 'video.unfollow': 'Deixar de Seguir', 'video.share': 'Compartilhar', 'video.comments': 'Comentários', 'video.writeComment': 'Escrever um comentário...', 'video.noComments': 'Ainda não há comentários. Seja o primeiro!',
        // Toast Messages
        'toast.loggedIn': 'Login realizado!', 'toast.settingsSaved': 'Configurações salvas!', 'toast.settingsLocal': 'Configurações salvas localmente. Não foi possível salvar no Nostr.', 'toast.settingsLocalOnly': 'Configurações salvas localmente!', 'toast.settingsReset': 'Configurações redefinidas!', 'toast.avatarUploaded': 'Avatar enviado com sucesso!', 'toast.profileUpdated': 'Perfil atualizado com sucesso!', 'toast.copied': 'Copiado para a área de transferência!', 'toast.copyFailed': 'Falha ao copiar. Por favor, copie manualmente.', 'toast.installExtension': 'Por favor, instale uma extensão Nostr como Alby ou nos2x', 'toast.loginFailed': 'Falha no login com a extensão. Por favor, tente novamente.', 'toast.invalidKey': 'Chave privada inválida. Por favor, verifique e tente novamente.', 'toast.enterKey': 'Por favor, insira sua chave privada', 'toast.enterUsername': 'Por favor, insira um nome de usuário', 'toast.accountCreated': 'Bem-vindo ao Plebs! Você está conectado.', 'toast.keyCopied': 'Chave privada copiada para a área de transferência!', 'toast.unmuted': 'Usuário reativado', 'toast.unmuteFailed': 'Falha ao reativar usuário', 'toast.selectImage': 'Por favor, selecione um arquivo de imagem', 'toast.imageTooLarge': 'A imagem deve ter menos de 5MB', 'toast.avatarFailed': 'Falha ao enviar avatar. Por favor, tente novamente.', 'toast.mustBeLoggedIn': 'Você precisa estar logado para editar seu perfil', 'toast.enterDisplayName': 'Por favor, insira um nome de exibição', 'toast.profileFailed': 'Falha ao salvar perfil. Por favor, tente novamente.', 'toast.invalidBunker': 'Por favor, insira uma URL bunker válida', 'toast.connectFailed': 'Falha na conexão', 'toast.showingFiltered': 'Mostrando conteúdo filtrado', 'toast.reportSubmitted': 'Denúncia enviada com sucesso', 'toast.draftSaved': 'Rascunho salvo! Você pode continuar depois em Meus Vídeos.', 'toast.draftLoaded': 'Rascunho carregado. Complete seu upload e publique.', 'toast.draftDeleted': 'Rascunho excluído', 'toast.languageChanged': 'Idioma alterado', 'toast.videoBlocked': 'Vídeo bloqueado e publicado no Nostr', 'toast.waitForUpload': 'Por favor, aguarde o upload do vídeo terminar', 'toast.enterTitle': 'Por favor, insira um título', 'toast.publishing': 'Publicando vídeo no Nostr...',
        // Time
        'time.justNow': 'agora mesmo', 'time.secondAgo': 'há 1 segundo', 'time.secondsAgo': 'há {n} segundos', 'time.minuteAgo': 'há 1 minuto', 'time.minutesAgo': 'há {n} minutos', 'time.hourAgo': 'há 1 hora', 'time.hoursAgo': 'há {n} horas', 'time.dayAgo': 'há 1 dia', 'time.daysAgo': 'há {n} dias', 'time.weekAgo': 'há 1 semana', 'time.weeksAgo': 'há {n} semanas', 'time.monthAgo': 'há 1 mês', 'time.monthsAgo': 'há {n} meses', 'time.yearAgo': 'há 1 ano', 'time.yearsAgo': 'há {n} anos',
        // Empty States
        'empty.noVideos': 'Nenhum vídeo encontrado.', 'empty.noLikedVideos': 'Você ainda não curtiu nenhum vídeo.', 'empty.noHistory': 'Sem histórico.',
        // Misc
        'misc.loading': 'Carregando...', 'misc.close': 'Fechar', 'misc.back': 'Voltar', 'misc.search': 'Pesquisar',
        // Common
        'common.cancel': 'Cancelar', 'common.uploading': 'Enviando...', 'common.saveChanges': 'Salvar Alterações', 'common.close': 'Fechar',
        // Aria Labels
        'aria.toggleMenu': 'Alternar menu', 'aria.mainNavigation': 'Navegação principal', 'aria.videoContent': 'Conteúdo de vídeo', 'aria.loadingContent': 'Carregando conteúdo',
        // Dynamic JavaScript text
        'button.hideQR': 'Ocultar Código QR', 'button.showQR': 'Mostrar Código QR', 'button.copied': 'Copiado!', 'button.showLess': 'Ver Menos', 'button.showMore': 'Ver Mais', 'button.creatingAccount': 'Criando conta...', 'button.submitting': 'Enviando...', 'button.scheduleStream': 'Agendar Transmissão', 'button.goLive': 'Transmitir', 'button.creatingStream': 'Criando transmissão...', 'button.continueCustomAmount': 'Continuar com Valor Personalizado', 'button.recordFromCamera': 'Gravar da Câmera', 'button.requestingCamera': 'Solicitando câmera...', 'button.recording': 'Gravando...',
        'status.saving': 'Salvando...', 'status.saved': 'Salvo!', 'status.uploading': 'Enviando...', 'status.uploadComplete': 'Envio completo!', 'status.uploadingToNostrBuild': 'Enviando para nostr.build...', 'status.publishingChanges': 'Publicando alterações...', 'status.removingOldVersion': 'Removendo versão antiga...', 'status.validatingThumbnail': 'Validando miniatura...', 'status.uploadingThumbnail': 'Enviando miniatura...', 'status.thumbnailUploaded': 'Miniatura enviada!', 'status.processingVideo': 'Processando vídeo...', 'status.compressingVideo': 'Comprimindo vídeo...', 'status.uploadingVideo': 'Enviando vídeo...', 'status.videoUploaded': 'Vídeo enviado com sucesso!', 'status.processing': 'Processando...', 'status.generatingThumbnail': 'Gerando miniatura...', 'status.generatingPreview': 'Gerando prévia...', 'status.uploadingPreview': 'Enviando prévia...', 'status.publishing': 'Publicando...', 'status.publishingToNostr': 'Publicando no Nostr...', 'status.publishingVideoToNostr': 'Publicando vídeo no Nostr...', 'status.generatingPoW': 'Gerando prova de trabalho...', 'status.posting': 'Postando...', 'status.processingVideoAndThumbnail': 'Processando vídeo e miniatura...', 'status.uploadFailed': 'Envio falhou - tente novamente', 'status.selectVideoToUpload': 'Selecione um vídeo para enviar', 'status.waitingForVideoUpload': 'Aguardando envio do vídeo...', 'status.selectVideoAndThumbnail': 'Selecione vídeo e miniatura para publicar', 'status.ready': 'Pronto ✓', 'status.failed': 'Falhou ✗', 'status.fromDraft': 'Do rascunho', 'status.startingNow': 'Começando agora!', 'status.ended': 'ENCERRADO', 'status.thumbnailReady': 'Pronto', 'status.thumbnailFailed': 'Falhou', 'status.uploadFailedRetry': 'Envio falhou. Tente novamente.',
        'publish.video': 'Publicar Vídeo', 'publish.autoThumbnail': 'Publicar Vídeo (miniatura auto)',
        'report.titleComment': 'Denunciar Comentário', 'report.titleUser': 'Denunciar Usuário', 'report.titleVideo': 'Denunciar Vídeo', 'report.descComment': 'Selecione um motivo para denunciar este comentário:', 'report.descUser': 'Selecione um motivo para denunciar este usuário:', 'report.descVideo': 'Selecione um motivo para denunciar este conteúdo:',
        'empty.noMutedUsers': 'Sem usuários silenciados.', 'empty.noVideosToMonitor': 'Nenhum vídeo para monitorar.', 'empty.noRecentActivity': 'Sem atividade recente.', 'empty.failedLoadNotifications': 'Falha ao carregar notificações', 'empty.loginToViewLiked': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">faça login</a> para ver seus vídeos curtidos.', 'empty.loginToViewFollowing': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">faça login</a> para ver quem você segue.', 'empty.loginToViewVideos': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">faça login</a> para ver seus vídeos.', 'empty.loginToViewAnalytics': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">faça login</a> para ver suas estatísticas.', 'empty.noLikedVideosYet': 'Você ainda não curtiu nenhum vídeo.', 'empty.noLikedVideosFound': 'Nenhum vídeo curtido encontrado.', 'empty.noFullLengthLikedVideos': 'Nenhum vídeo longo curtido encontrado.', 'empty.noWatchHistory': 'Sem histórico. Comece a assistir vídeos.', 'empty.noVideosInHistory': 'Nenhum vídeo no histórico.', 'empty.noFullLengthHistory': 'Nenhum vídeo longo no histórico.', 'empty.noMatchingVideos': 'Nenhum vídeo correspondente encontrado.', 'empty.noFullLengthVideos': 'Nenhum vídeo longo encontrado.', 'empty.failedLoadTrending': 'Falha ao carregar tendências.', 'empty.noTrendingVideos': 'Nenhum vídeo em alta encontrado.', 'empty.noMatchingUsers': 'Nenhum usuário correspondente encontrado.', 'empty.unableLoadProfiles': 'Não foi possível carregar perfis.', 'empty.noFollowingVideos': 'Ainda não há vídeos de quem você segue.', 'empty.noFullLengthFollowing': 'Nenhum vídeo longo de quem você segue.', 'empty.failedLoadFollowing': 'Falha ao carregar. Tente novamente.', 'empty.noVideosUploadFirst': 'Nenhum vídeo. Envie seu primeiro vídeo!', 'empty.noFullLengthUploaded': 'Nenhum vídeo longo encontrado.', 'empty.noMatchingLiveStreams': 'Nenhuma transmissão correspondente.', 'empty.noMatchingShorts': 'Nenhum short correspondente.', 'empty.noVideosForTag': 'Nenhum vídeo para esta tag.', 'empty.noFullLengthForTag': 'Nenhum vídeo longo para esta tag.', 'empty.noUploadedVideos': 'Nenhum vídeo enviado ainda.', 'empty.noVideosFound': 'Nenhum vídeo encontrado.', 'empty.failedLoadProfile': 'Falha ao carregar perfil. Tente novamente.', 'empty.noComments': 'Sem comentários ainda. Seja o primeiro!', 'empty.failedLoadComments': 'Falha ao carregar comentários', 'empty.noLiveNow': 'Ninguém está ao vivo. Seja o primeiro!',
        'error.videoNotFound': 'Vídeo não encontrado.', 'error.contentNotAvailable': 'Este conteúdo não está disponível.', 'error.invalidVideoData': 'Dados de vídeo inválidos.', 'error.videoNotAvailable': 'Vídeo não disponível. O arquivo pode ter sido removido.', 'error.failedLoadVideo': 'Falha ao carregar vídeo. Tente novamente.', 'error.failedLoadVideoShort': 'Falha ao carregar. Arquivo pode ter sido removido.', 'error.liveStreamNotFound': 'Transmissão ao vivo não encontrada.', 'error.invalidLiveStreamData': 'Dados de transmissão inválidos.', 'error.failedLoadLiveStream': 'Falha ao carregar transmissão.',
        // New Button & Action Labels
        'button.follow': 'Seguir', 'button.unfollow': 'Deixar de seguir', 'button.mute': 'Silenciar', 'button.unmute': 'Reativar som', 'button.muteUser': 'Silenciar usuário', 'button.unmuteUser': 'Reativar usuário', 'button.confirm': 'Confirmar', 'button.cancel': 'Cancelar', 'button.close': 'Fechar', 'button.boost': 'Impulsionar', 'button.zap': 'Zap', 'button.viewMore': 'Ver mais', 'button.viewAnalytics': 'Ver estatísticas', 'button.backToMyVideos': 'Voltar aos Meus Vídeos', 'button.editDraft': 'Editar rascunho', 'button.deleteDraft': 'Excluir rascunho', 'button.editVideo': 'Editar vídeo', 'button.deleteVideo': 'Excluir vídeo', 'button.editShort': 'Editar short', 'button.deleteShort': 'Excluir short', 'button.editStream': 'Editar transmissão', 'button.endStream': 'Encerrar transmissão', 'button.reset': 'Redefinir', 'button.download': 'Baixar', 'button.watchRecording': 'Assistir gravação', 'button.show': 'Mostrar', 'button.login': 'Entrar', 'button.toggleChat': 'Alternar chat', 'button.blockVideo': 'Bloquear vídeo', 'button.blockUser': 'Bloquear usuário', 'button.unblock': 'Desbloquear', 'button.removeFromHistory': 'Remover do histórico',
        // New Stats & Counts
        'stat.views': 'visualizações', 'stat.viewsCount': '{count} visualizações', 'stat.videos': 'vídeos', 'stat.video': 'vídeo', 'stat.followers': 'seguidores', 'stat.follower': 'seguidor', 'stat.following': 'Seguindo', 'stat.subscribers': 'inscritos', 'stat.comments': 'Comentários', 'stat.liveCount': '{count} ao vivo', 'stat.percentOfGoal': '{percent}% da meta', 'stat.netGrowth': 'Crescimento líquido', 'stat.newFollowers': 'Novos seguidores', 'stat.unfollowed': 'Deixaram de seguir', 'stat.lastUpdated': 'Última atualização: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'AO VIVO', 'badge.ended': 'ENCERRADO', 'badge.scheduled': 'AGENDADO', 'badge.warning': 'AVISO', 'badge.communityWarning': 'AVISO DA COMUNIDADE', 'badge.verifiedNip05': 'NIP-05 verificado', 'badge.streamer': 'Streamer', 'badge.clickToView': 'Clique para ver',
        // New Actions
        'action.report': 'Denunciar', 'action.reportComment': 'Denunciar comentário', 'action.reportVideo': 'Denunciar este vídeo', 'action.reportStream': 'Denunciar esta transmissão', 'action.like': 'Curtir', 'action.dislike': 'Não curtir', 'action.reply': 'Responder',
        // New Placeholders
        'placeholder.searchHistory': 'Pesquisar histórico...', 'placeholder.searchUsers': 'Pesquisar usuários...', 'placeholder.searchMyVideos': 'Pesquisar meus vídeos...', 'placeholder.eventId': 'Digite ID do evento (hex ou nevent/note)', 'placeholder.pubkey': 'Digite pubkey (hex ou npub)', 'placeholder.customAmount': 'Valor personalizado', 'placeholder.chatEnded': 'Chat fechado - transmissão encerrada', 'placeholder.addComment': 'Adicione um comentário...', 'placeholder.setNewGoal': 'Definir nova meta (sats)',
        // New Video & Content
        'video.untitledVideo': 'Vídeo sem título', 'video.untitledShort': 'Short sem título', 'video.upNext': 'A seguir', 'video.noVideosYet': 'Ainda não há vídeos', 'video.noShortsYet': 'Ainda não há shorts', 'video.noLiveStreamsYet': 'Ainda não há transmissões ao vivo', 'video.noBlockedVideos': 'Nenhum vídeo bloqueado', 'video.noBlockedUsers': 'Nenhum usuário bloqueado',
        // New Stream Messages
        'stream.ended': 'Esta transmissão terminou. O chat está fechado.', 'stream.welcomeChat': 'Bem-vindo ao chat ao vivo!', 'stream.goalReached': 'Meta atingida!', 'stream.zapGoalReached': 'Meta de zap atingida! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Mensagem de usuário silenciado', 'muted.commentFromMutedUserHidden': 'Comentário de usuário silenciado oculto', 'muted.commentHidden': 'Comentário oculto ({packs})', 'muted.messageHidden': 'Mensagem oculta ({packs})', 'muted.commentReportedByFollows': 'Comentário denunciado por pessoas que você segue', 'muted.messageReportedByFollows': 'Mensagem denunciada por pessoas que você segue', 'muted.commentHeavilyDownvoted': 'Comentário muito negativo pela comunidade', 'muted.messageHeavilyDownvoted': 'Mensagem muito negativa',
        // New Admin & Lists
        'list.blockedVideos': 'Vídeos bloqueados', 'list.blockedUsers': 'Usuários bloqueados',
        // New Alerts
        'alert.cameraNotSupported': 'O acesso à câmera não é suportado neste navegador. Por favor, use um navegador moderno como Chrome, Firefox ou Safari.', 'alert.noCameraFound': 'Nenhuma câmera encontrada neste dispositivo. Por favor, conecte uma câmera ou use a opção de upload de arquivo.', 'alert.cameraAccessDenied': 'Acesso à câmera negado. Por favor, permita as permissões de câmera nas configurações do navegador.', 'alert.cameraInUse': 'A câmera está sendo usada por outro aplicativo. Por favor, feche outros apps que estão usando a câmera.', 'alert.cameraUnableAccess': 'Não foi possível acessar a câmera com as configurações atuais. Por favor, tente usar a opção de upload.', 'alert.cameraUnableAccessWithError': 'Não foi possível acessar a câmera: {error}\n\nPor favor, use a opção de upload.', 'alert.fillRequiredFields': 'Por favor, preencha todos os campos obrigatórios', 'alert.uploadThumbnail': 'Por favor, faça upload de uma miniatura para sua transmissão', 'alert.failedCreateStream': 'Falha ao criar transmissão ao vivo. Por favor, tente novamente.', 'alert.failedUpdateStream': 'Falha ao atualizar. Por favor, tente novamente.', 'alert.streamNotFound': 'Transmissão não encontrada', 'alert.canOnlyEditOwnStreams': 'Você só pode editar suas próprias transmissões', 'alert.invalidStreamData': 'Dados de transmissão inválidos', 'alert.enterValidGoalAmount': 'Por favor, insira um valor de meta válido', 'alert.canOnlyResetOwnGoals': 'Você só pode redefinir suas próprias metas', 'alert.streamEventNotFound': 'Evento de transmissão não encontrado', 'alert.failedResetZapGoal': 'Falha ao redefinir meta de zap. Por favor, tente novamente.', 'alert.cannotBlockAdmin': 'Não é possível bloquear a conta de administrador', 'alert.analyticsLoadFailed': 'Falha ao carregar estatísticas. Por favor, tente novamente.', 'alert.cannotReplaceShortWithVideo': 'Não é possível substituir um Short por um vídeo normal. Por favor, faça upload de um vídeo vertical (60 segundos ou menos).', 'alert.cannotReplaceVideoWithShort': 'Não é possível substituir um vídeo normal por um Short. Por favor, faça upload de um vídeo horizontal.', 'alert.shortsRequireVertical': 'Este vídeo parece ser horizontal. Shorts devem ser vídeos verticais. Por favor, use "Enviar Vídeo" para vídeos horizontais.',
        // New Zap Messages
        'zap.cannotZapYourself': 'Você não pode enviar zap para si mesmo', 'zap.cannotZapOwnContent': 'Você não pode enviar zap para seu próprio conteúdo', 'zap.cannotZapOwnComment': 'Você não pode enviar zap para seu próprio comentário', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'Carregando vídeo...', 'status.loading': 'Carregando...', 'status.compressingProgress': 'Comprimindo... {progress}%', 'status.uploadingProgress': 'Enviando... {progress}%', 'status.uploadingServers': 'Enviando... ({completed}/{total} servidores)', 'status.publishedSuccess': '{type} publicado com sucesso!',
        // New Warnings
        'warning.webmFormat': 'Nota: Seu navegador produzirá formato WebM (pode não funcionar no iOS). Para MP4 compatível com iOS, use Chrome no Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Última atualização: Dezembro 2024',
        // DMCA Page
        'dmca.title': 'DMCA e Política de Conteúdo',
        'dmca.lastUpdated': 'Última atualização: Dezembro 2024',
        'dmca.architectureTitle': 'Entendendo a Arquitetura do Plebs',
        'dmca.architectureDesc': 'Plebs é uma interface de plataforma de vídeo descentralizada que opera diferente dos serviços tradicionais.',
        'dmca.architectureItem1': 'Plebs não hospeda nenhum conteúdo de vídeo ou imagem.',
        'dmca.architectureItem1Desc': 'Somos um cliente/interface que exibe conteúdo armazenado em outro lugar.',
        'dmca.architectureItem2': 'Todos os arquivos de mídia são armazenados em servidores Blossom independentes.',
        'dmca.architectureItem3': 'Os metadados de vídeo são publicados em relays Nostr.',
        'dmca.architectureItem4': 'Plebs simplesmente agrega e exibe este conteúdo distribuído.',
        'dmca.filingTitle': 'Apresentar uma Reclamação DMCA',
        'dmca.filingDesc': 'Como o Plebs não hospeda conteúdo, não podemos remover diretamente material infrator.',
        'dmca.forVideoTitle': '1. Para Conteúdo de Vídeo/Imagem',
        'dmca.forVideoDesc': 'Os arquivos de mídia são armazenados em servidores Blossom.',
        'dmca.forVideoItem1': 'Identificar qual servidor Blossom hospeda o conteúdo',
        'dmca.forVideoItem2': 'Contatar diretamente o operador do servidor Blossom',
        'dmca.forVideoItem3': 'Cada servidor Blossom opera independentemente',
        'dmca.forMetadataTitle': '2. Para Metadados/Descrições',
        'dmca.forMetadataDesc': 'Se o conteúdo infrator estiver no título ou descrição:',
        'dmca.forMetadataItem1': 'Estas informações são armazenadas em relays Nostr',
        'dmca.forMetadataItem2': 'Contate os operadores de relay Nostr específicos',
        'dmca.forMetadataItem3': 'Múltiplos relays podem armazenar os mesmos dados',
        'dmca.whatWeCanDoTitle': 'O que o Plebs Pode Fazer',
        'dmca.whatWeCanDoDesc': 'Embora não hospedemos conteúdo, podemos:',
        'dmca.whatWeCanDoItem1': 'Ajudá-lo a identificar quais servidores hospedam conteúdo específico',
        'dmca.whatWeCanDoItem2': 'Adicionar conteúdo a uma lista de bloqueio local',
        'dmca.whatWeCanDoItem3': 'Fornecer orientação sobre como contatar os operadores apropriados',
        'dmca.toRequestAssistance': 'Para solicitar assistência, entre em contato conosco com:',
        'dmca.assistanceItem1': 'A URL ou identificador do conteúdo infrator',
        'dmca.assistanceItem2': 'Prova de sua propriedade de direitos autorais',
        'dmca.assistanceItem3': 'Uma descrição da obra protegida',
        'dmca.blossomOperatorsTitle': 'Operadores de Servidores Blossom',
        'dmca.blossomOperatorsDesc': 'Se você opera um servidor Blossom, é responsável por lidar com solicitações DMCA.',
        'dmca.blossomOperatorsLink': 'Para uma lista de servidores Blossom conhecidos, consulte a documentação.',
        'dmca.considerationsTitle': 'Considerações Importantes',
        'dmca.considerationsItem1': 'Descentralização:',
        'dmca.considerationsItem1Desc': 'A remoção completa do conteúdo pode não ser possível.',
        'dmca.considerationsItem2': 'Múltiplas Cópias:',
        'dmca.considerationsItem2Desc': 'O conteúdo pode estar replicado em múltiplos servidores.',
        'dmca.considerationsItem3': 'Persistência de Metadados:',
        'dmca.considerationsItem3Desc': 'Os metadados podem persistir mesmo após a remoção.',
        'dmca.considerationsItem4': 'Sem Controle Central:',
        'dmca.considerationsItem4Desc': 'Nenhuma entidade única pode remover conteúdo de toda a rede.',
        'dmca.counterNotificationTitle': 'Contra-Notificação',
        'dmca.counterNotificationDesc': 'Se você acredita que seu conteúdo foi removido por engano, contate o operador do servidor.',
        'dmca.contactTitle': 'Contato',
        'dmca.contactDesc': 'Para perguntas, por favor',
        'dmca.contactLink': 'entre em contato conosco',
        // Admin Dashboard
        'admin.title': 'Painel de Administração',
        'admin.loading': 'Carregando análises da plataforma...',
        'admin.platformOverview': 'Visão Geral da Plataforma',
        'admin.totalVideos': 'Total de Vídeos',
        'admin.videos7Days': 'Vídeos (7 dias)',
        'admin.videos30Days': 'Vídeos (30 dias)',
        'admin.uniqueCreators': 'Criadores Únicos',
        'admin.likes30Days': 'Curtidas (30 dias)',
        'admin.dislikes30Days': 'Descurtidas (30 dias)',
        'admin.monthlyActiveUsers': 'Usuários Ativos Mensais',
        'admin.mauDesc': 'Usuários únicos que enviaram vídeos, reagiram ou comentaram (últimos 6 meses)',
        'admin.boostRevenue': 'Receita de Boost (Últimos 30 Dias)',
        'admin.totalBoostRevenue': 'Receita Total de Boost',
        'admin.totalBoosts': 'Total de Boosts',
        'admin.blocklistManagement': 'Gerenciamento de Lista de Bloqueio',
        'admin.blocklistDesc': 'Bloqueie vídeos ou usuários específicos.',
        'admin.blockedVideos': 'Vídeos Bloqueados',
        'admin.blockedUsers': 'Usuários Bloqueados',
        'admin.blockByEventId': 'Bloquear Vídeo por ID',
        'admin.blockByPubkey': 'Bloquear Usuário por Pubkey',
        'admin.blockVideo': 'Bloquear Vídeo',
        'admin.blockUser': 'Bloquear Usuário',
        'admin.noBlockedVideos': 'Nenhum vídeo bloqueado',
        'admin.noBlockedUsers': 'Nenhum usuário bloqueado',
        'admin.unblock': 'Desbloquear',
        'admin.accessDenied': 'Acesso negado. Apenas administrador.',
        // Search/Trending/Channel/Buttons/Common
        'search.noVideosFound': 'Nenhum vídeo encontrado para "{query}".',
        'search.noFullLengthVideos': 'Nenhum vídeo longo encontrado para "{query}".',
        'trending.noVideosToday': 'Sem vídeos em alta hoje.',
        'trending.noVideosThisWeek': 'Sem vídeos em alta esta semana.',
        'channel.video': 'vídeo',
        'channel.videos': 'vídeos',
        'channel.follower': 'seguidor',
        'channel.followers': 'seguidores',
        'button.follow': 'Seguir',
        'button.following': 'Seguindo',
        'button.unfollow': 'Deixar de seguir',
        'button.mute': 'Silenciar',
        'button.unmute': 'Ativar som',
        'button.report': 'Denunciar',
        'button.muteUser': 'Silenciar usuário',
        'button.unmuteUser': 'Ativar som do usuário',
        'button.reportComment': 'Denunciar comentário',
        'button.reportUser': 'Denunciar este usuário',
        'live.goalReached': 'Meta Alcançada!',
        'live.goalProgress': '{percent}% da meta',
        'common.loading': 'Carregando...',
        'common.sats': 'sats',
        // Analytics
        'analytics.title': 'Análise do Canal',
        'analytics.loading': 'Carregando suas análises...',
        'analytics.loadFailed': 'Falha ao carregar análises. Por favor, tente novamente.',
        'analytics.overview': 'Visão Geral',
        'analytics.views': 'Visualizações',
        'analytics.followers': 'Seguidores',
        'analytics.topByViews': 'Vídeos Mais Vistos',
        'analytics.topByEngagement': 'Vídeos com Maior Engajamento',
        'analytics.allContent': 'Desempenho de Todo o Conteúdo',
        'analytics.totalViews': 'Visualizações Totais',
        'analytics.likes': 'Curtidas',
        'analytics.likesRatio': 'Curtidas ({ratio}% proporção)',
        'analytics.dislikes': 'Descurtidas',
        'analytics.zapsReceived': '{count} Zaps Recebidos',
        'analytics.boostsReceived': 'Boosts Recebidos',
        'analytics.shares': 'Compartilhamentos',
        'analytics.comments': 'Comentários',
        'analytics.contentCount': '{videos} Vídeos, {shorts} Shorts, {streams} Streams',
        'analytics.last7days': 'Últimos 7 dias',
        'analytics.last30days': 'Últimos 30 dias',
        'analytics.last90days': 'Últimos 90 dias',
        'analytics.lastYear': 'Último ano',
        'analytics.allTime': 'Todo o tempo',
        'analytics.lastNDays': 'Últimos {n} dias',
        'analytics.netGrowth': 'Crescimento Líquido',
        'analytics.newFollowers': 'Novos Seguidores',
        'analytics.unfollowed': 'Deixaram de Seguir',
        'analytics.noVideosYet': 'Ainda sem vídeos',
        'analytics.noShortsYet': 'Ainda sem shorts',
        'analytics.noStreamsYet': 'Ainda sem transmissões',
        'analytics.viewsTooltip': '{count} visualizações',
        'analytics.subscribersTooltip': '{count} inscritos',
        'analytics.videosTab': 'Vídeos ({count})',
        'analytics.shortsTab': 'Shorts ({count})',
        'analytics.streamsTab': 'Transmissões ({count})',
        // About Page
        'about.title': 'Sobre o Plebs',
        'about.whatIs': 'O que é o Plebs?',
        'about.whatIsDesc': 'Plebs é uma plataforma de vídeos descentralizada e resistente à censura construída sobre o <a href="https://nostr.com" target="_blank" rel="noopener">protocolo Nostr</a>. Diferente das plataformas tradicionais controladas por corporações, o Plebs te dá verdadeira propriedade do seu conteúdo e identidade.',
        'about.whyNostr': 'Por que Nostr?',
        'about.whyNostrDesc': 'Nostr (Notes and Other Stuff Transmitted by Relays) é um protocolo simples e aberto que permite uma rede social verdadeiramente descentralizada. Os principais benefícios incluem:',
        'about.benefit1': 'Resistência à Censura:',
        'about.benefit1Desc': 'Nenhuma entidade pode te banir ou remover seu conteúdo',
        'about.benefit2': 'Portabilidade:',
        'about.benefit2Desc': 'Sua identidade e seguidores funcionam em todos os apps Nostr',
        'about.benefit3': 'Sem Autoridade Central:',
        'about.benefit3Desc': 'Nenhuma empresa possui ou controla a rede',
        'about.benefit4': 'Identidade Criptográfica:',
        'about.benefit4Desc': 'Suas chaves provam que você é quem diz ser',
        'about.howItWorks': 'Como Funciona',
        'about.howItWorksDesc': 'Os vídeos no Plebs são armazenados usando <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom</a>, um sistema de armazenamento distribuído, enquanto os metadados e interações sociais são transmitidos para relays Nostr. Isso significa que seu conteúdo não é armazenado em nossos servidores - está distribuído pela rede.',
        'about.features': 'Recursos',
        'about.feature1': 'Envie e compartilhe vídeos com a comunidade Nostr',
        'about.feature2': 'Curta, comente e compartilhe vídeos usando reações Nostr',
        'about.feature3': 'Envie Zaps aos criadores com Bitcoin via Lightning Network',
        'about.feature4': 'Siga seus criadores favoritos em qualquer app Nostr',
        'about.feature5': 'Explore tópicos e descubra novo conteúdo',
        'about.feature6': 'Funciona com qualquer identidade Nostr (use chaves existentes)',
        'about.openSource': 'Código Aberto',
        'about.openSourceDesc': 'Plebs é software de código aberto. Você pode ver o código, contribuir ou executar sua própria instância:',
        'about.githubRepo': 'Repositório GitHub',
        'about.builtBy': 'Desenvolvido Por',
        'about.builtByDesc': 'Plebs é desenvolvido pela <a href="https://nostrservices.com" target="_blank" rel="noopener" class="accent-link">21 Million LLC</a>, uma empresa dedicada a construir ferramentas para o ecossistema Bitcoin e Nostr.',
        // Contact Page
        'contact.title': 'Entre em Contato',
        'contact.getInTouch': 'Fale Conosco',
        'contact.getInTouchDesc': 'Tem dúvidas, comentários ou precisa de suporte? Adoraríamos ouvir de você!',
        'contact.email': 'E-mail',
        'contact.emailDesc': 'A melhor forma de entrar em contato conosco é por e-mail:',
        'contact.github': 'GitHub',
        'contact.githubDesc': 'Para reportar bugs, solicitar recursos ou problemas técnicos, abra uma issue em nosso repositório:',
        'contact.githubIssues': 'Issues do GitHub',
        'contact.company': 'Empresa',
        'contact.companyDesc': 'Plebs é desenvolvido pela 21 Million LLC',
        // Terms of Service
        'terms.title': 'Termos de Serviço',
        'terms.lastUpdated': 'Última atualização: Dezembro 2024',
        'terms.section1Title': '1. Aceitação dos Termos',
        'terms.section1Desc': 'Ao acessar e usar o Plebs ("o Serviço"), você concorda em estar sujeito a estes Termos de Serviço. Se você não concorda com estes termos, por favor não use o Serviço.',
        'terms.section2Title': '2. Descrição do Serviço',
        'terms.section2Desc': 'Plebs é uma plataforma de vídeos descentralizada construída sobre o protocolo Nostr. O Serviço fornece uma interface para navegar, enviar e interagir com conteúdo de vídeo armazenado em redes distribuídas. Plebs não hospeda nem armazena conteúdo de vídeo em servidores centralizados.',
        'terms.section3Title': '3. Responsabilidades do Usuário',
        'terms.section3Desc': 'Você é responsável por:',
        'terms.section3Item1': 'Manter a segurança de suas chaves privadas Nostr',
        'terms.section3Item2': 'Todo o conteúdo que você enviar ou compartilhar através do Serviço',
        'terms.section3Item3': 'Garantir que seu uso esteja em conformidade com as leis aplicáveis',
        'terms.section3Item4': 'Não enviar conteúdo ilegal, infrator ou prejudicial',
        'terms.section4Title': '4. Diretrizes de Conteúdo',
        'terms.section4Desc': 'Você concorda em não enviar, compartilhar ou distribuir:',
        'terms.section4Item1': 'Conteúdo que infrinja direitos de propriedade intelectual',
        'terms.section4Item2': 'Conteúdo ilegal incluindo mas não limitado a material de exploração infantil',
        'terms.section4Item3': 'Conteúdo que promova violência ou dano a outros',
        'terms.section4Item4': 'Spam, malware ou conteúdo enganoso',
        'terms.section4Note': 'Conteúdo adulto (NSFW) deve ser apropriadamente marcado usando a tag NSFW ao enviar.',
        'terms.section5Title': '5. Natureza Descentralizada',
        'terms.section5Desc': 'Devido à natureza descentralizada do Nostr e armazenamento Blossom:',
        'terms.section5Item1': 'O conteúdo pode persistir na rede mesmo após solicitações de remoção',
        'terms.section5Item2': 'Não podemos garantir a remoção de conteúdo de todos os relays ou servidores',
        'terms.section5Item3': 'Seu conteúdo e interações são públicos por padrão',
        'terms.section5Item4': 'Você é o único responsável pela segurança de sua chave privada',
        'terms.section6Title': '6. Sem Garantia',
        'terms.section6Desc': 'O Serviço é fornecido "como está" sem garantias de qualquer tipo. Não garantimos acesso contínuo e ininterrupto ao Serviço.',
        'terms.section7Title': '7. Limitação de Responsabilidade',
        'terms.section7Desc': 'Na máxima extensão permitida pela lei, Plebs e seus operadores não serão responsáveis por quaisquer danos indiretos, incidentais, especiais ou consequenciais decorrentes do seu uso do Serviço.',
        'terms.section8Title': '8. Alterações nos Termos',
        'terms.section8Desc': 'Reservamo-nos o direito de modificar estes termos a qualquer momento. O uso continuado do Serviço após as alterações constitui aceitação dos novos termos.',
        'terms.section9Title': '9. Contato',
        'terms.section9Desc': 'Para perguntas sobre estes Termos, por favor <a href="#/contact" class="accent-link">entre em contato conosco</a>.',
        // Privacy Policy
        'privacy.title': 'Política de Privacidade',
        'privacy.lastUpdated': 'Última atualização: Dezembro 2024',
        'privacy.section1Title': '1. Resumo',
        'privacy.section1Desc': 'Plebs está comprometido em proteger sua privacidade. Esta política explica como lidamos com informações quando você usa nossa plataforma de vídeos descentralizada.',
        'privacy.section2Title': '2. Arquitetura Descentralizada',
        'privacy.section2Desc': 'Plebs é construído sobre Nostr, um protocolo descentralizado. Isso significa:',
        'privacy.section2Item1': 'Seu conteúdo é transmitido para relays públicos, não armazenado em nossos servidores',
        'privacy.section2Item2': 'Sua chave pública Nostr serve como sua identidade',
        'privacy.section2Item3': 'Os vídeos são armazenados em servidores Blossom distribuídos',
        'privacy.section2Item4': 'Não temos acesso às suas chaves privadas',
        'privacy.section3Title': '3. Informações que Coletamos',
        'privacy.section3LocalTitle': 'Informações armazenadas localmente no seu navegador:',
        'privacy.section3LocalItem1': 'Sua chave pública Nostr (quando você faz login)',
        'privacy.section3LocalItem2': 'Histórico de visualização e preferências',
        'privacy.section3LocalItem3': 'Preferências de tema e configurações',
        'privacy.section3LocalItem4': 'Chave privada (somente se você escolher armazenamento local - não recomendado)',
        'privacy.section3CollectTitle': 'Informações que podemos coletar:',
        'privacy.section3CollectItem1': 'Análises básicas (visualizações de página, uso de recursos) para melhorar o serviço',
        'privacy.section3CollectItem2': 'Registros de erros para depuração',
        'privacy.section4Title': '4. Informações Públicas',
        'privacy.section4Desc': 'Ao usar Nostr, o seguinte é público por design:',
        'privacy.section4Item1': 'Sua chave pública Nostr e informações de perfil',
        'privacy.section4Item2': 'Vídeos que você enviar',
        'privacy.section4Item3': 'Comentários, curtidas e outras reações',
        'privacy.section4Item4': 'Quem você segue',
        'privacy.section4Item5': 'Zaps (pagamentos Lightning) que você envia ou recebe',
        'privacy.section5Title': '5. Armazenamento de Dados',
        'privacy.section5Desc': 'Os dados locais são armazenados no localStorage do seu navegador. Você pode limpar esses dados a qualquer momento através das configurações do navegador. O conteúdo publicado no Nostr é distribuído através de relays e não pode ser controlado ou removido pelo Plebs.',
        'privacy.section6Title': '6. Serviços de Terceiros',
        'privacy.section6Desc': 'Plebs interage com:',
        'privacy.section6Item1': 'Relays Nostr (para dados sociais)',
        'privacy.section6Item2': 'Servidores Blossom (para armazenamento de vídeo)',
        'privacy.section6Item3': 'Lightning Network (para zaps/pagamentos)',
        'privacy.section6Note': 'Cada um desses serviços tem suas próprias práticas de privacidade.',
        'privacy.section7Title': '7. Seus Direitos',
        'privacy.section7Desc': 'Você pode:',
        'privacy.section7Item1': 'Limpar seus dados locais do navegador a qualquer momento',
        'privacy.section7Item2': 'Navegar vídeos sem criar uma conta',
        'privacy.section7Item3': 'Usar uma extensão de navegador Nostr para maior privacidade',
        'privacy.section7Item4': 'Escolher quais relays e servidores Blossom usar',
        'privacy.section8Title': '8. Segurança',
        'privacy.section8Desc': 'Recomendamos:',
        'privacy.section8Item1': 'Usar uma extensão de navegador Nostr ou assinador de hardware',
        'privacy.section8Item2': 'Nunca compartilhar sua chave privada (nsec)',
        'privacy.section8Item3': 'Usar um perfil de navegador dedicado para maior privacidade',
        'privacy.section9Title': '9. Alterações a Esta Política',
        'privacy.section9Desc': 'Podemos atualizar esta política de tempos em tempos. As alterações serão publicadas nesta página com uma data de revisão atualizada.',
        'privacy.section10Title': '10. Contato',
        'privacy.section10Desc': 'Para questões relacionadas à privacidade, por favor <a href="#/contact" class="accent-link">entre em contato conosco</a>.',
        // FAQ Page
        'faq.title': 'Perguntas Frequentes',
        'faq.aboutPlebs': 'Sobre o Plebs',
        'faq.nostrProtocol': 'Protocolo Nostr',
        'faq.videoStorage': 'Armazenamento de Vídeo e Blossom',
        'faq.featuresUsage': 'Recursos e Uso',
        'faq.q1': 'O que é o Plebs?',
        'faq.a1': 'Plebs é uma plataforma de vídeos descentralizada e resistente à censura construída sobre o protocolo Nostr. Diferente das plataformas tradicionais controladas por corporações, o Plebs te dá verdadeira propriedade do seu conteúdo e identidade. Não há servidores centrais que possam te banir ou remover seu conteúdo.',
        'faq.q2': 'O Plebs é gratuito?',
        'faq.a2': 'Sim, o Plebs é completamente gratuito para assistir vídeos. Você pode navegar e assistir conteúdo sem criar uma conta. Para enviar vídeos, comentar, curtir ou interagir com outros usuários, você precisará de uma identidade Nostr (que também é gratuita).',
        'faq.q3': 'Quem desenvolve o Plebs?',
        'faq.a3': 'Plebs é desenvolvido pela <a href="https://nostrservices.com" target="_blank" rel="noopener">21 Million LLC</a>, uma empresa dedicada a construir ferramentas para o ecossistema Bitcoin e Nostr. Plebs é de código aberto, e você pode ver o código ou contribuir no <a href="https://github.com/Spl0itable/plebs-app" target="_blank" rel="noopener">GitHub</a>.',
        'faq.q4': 'O que é Nostr?',
        'faq.a4': 'Nostr significa "Notes and Other Stuff Transmitted by Relays." É um protocolo simples e aberto que permite uma rede social verdadeiramente descentralizada. Diferente das plataformas tradicionais, Nostr não depende de nenhum servidor central. Em vez disso, usa uma rede de relays para transmitir mensagens entre usuários, e chaves criptográficas para identidade.',
        'faq.q5': 'Por que o Plebs usa Nostr?',
        'faq.a5Title': 'Nostr fornece vários benefícios importantes:',
        'faq.a5Item1': 'Resistência à Censura:',
        'faq.a5Item1Desc': 'Nenhuma entidade pode te banir ou remover seu conteúdo',
        'faq.a5Item2': 'Portabilidade:',
        'faq.a5Item2Desc': 'Sua identidade e seguidores funcionam em todos os apps Nostr',
        'faq.a5Item3': 'Sem Autoridade Central:',
        'faq.a5Item3Desc': 'Nenhuma empresa possui ou controla a rede',
        'faq.a5Item4': 'Identidade Criptográfica:',
        'faq.a5Item4Desc': 'Suas chaves provam que você é quem diz ser',
        'faq.q6': 'O que são as chaves Nostr (npub/nsec)?',
        'faq.a6': 'Sua identidade Nostr consiste em duas chaves: uma chave pública (npub) e uma chave privada (nsec). Sua npub é como seu nome de usuário - você pode compartilhá-la com qualquer pessoa. Sua nsec é como sua senha - nunca a compartilhe! Qualquer pessoa com sua nsec pode publicar como você e acessar sua conta. Recomendamos usar uma extensão de navegador como Alby ou nos2x para gerenciar suas chaves com segurança.',
        'faq.q7': 'Posso usar minha conta Nostr existente?',
        'faq.a7': 'Absolutamente! Se você já tem uma identidade Nostr de apps como Damus, Primal, Amethyst ou outro cliente Nostr, pode usar as mesmas chaves para fazer login no Plebs. Seus seguidores, perfil e reputação são transferidos automaticamente.',
        'faq.q8': 'O que são relays Nostr?',
        'faq.a8': 'Relays são servidores que armazenam e transmitem mensagens Nostr. Quando você publica algo, é enviado para múltiplos relays. Outros usuários se conectam aos relays para ler mensagens. Como há muitos relays independentes, nenhum pode censurar você - se um relay te bloquear, seu conteúdo ainda existe em outros.',
        'faq.q9': 'Onde os vídeos são armazenados?',
        'faq.a9': 'Os vídeos são armazenados em servidores Blossom, não no Plebs. Blossom é um sistema de armazenamento distribuído projetado para funcionar com Nostr. Quando você envia um vídeo, ele vai para um ou mais servidores Blossom de sua escolha. Os metadados do vídeo (título, descrição, etc.) são publicados em relays Nostr.',
        'faq.q10': 'O que é Blossom?',
        'faq.a10': 'Blossom é um protocolo aberto para armazenar e servir arquivos de mídia de forma descentralizada. Os arquivos são identificados por seu hash SHA-256, o que significa que o mesmo arquivo terá o mesmo endereço independentemente de qual servidor o hospede. Isso permite redundância - seus arquivos podem existir em múltiplos servidores. Saiba mais em <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom GitHub</a>.',
        'faq.q11': 'O Plebs hospeda meus vídeos?',
        'faq.a11': 'Não. Plebs é um cliente/interface que te ajuda a navegar e enviar conteúdo, mas não armazena nenhum arquivo de vídeo ou imagem. Todas as mídias são armazenadas em servidores Blossom independentes. Plebs simplesmente exibe conteúdo desses provedores de armazenamento distribuído.',
        'faq.q12': 'Posso escolher qual servidor Blossom usar?',
        'faq.a12': 'Sim! Você pode configurar quais servidores Blossom quer usar para envios em suas configurações. Você pode até executar seu próprio servidor Blossom se quiser controle total sobre seu armazenamento de mídia.',
        'faq.q13': 'Como criar uma conta?',
        'faq.a13Title': 'Clique no botão "Entrar" e escolha seu método preferido:',
        'faq.a13Item1': 'Extensão de Navegador:',
        'faq.a13Item1Desc': 'Se você tem uma extensão Nostr como Alby ou nos2x instalada, pode usá-la para fazer login com segurança',
        'faq.a13Item2': 'Gerar Novas Chaves:',
        'faq.a13Item2Desc': 'Crie uma nova identidade Nostr',
        'faq.a13Item3': 'Importar Chaves:',
        'faq.a13Item3Desc': 'Use sua chave privada Nostr existente (nsec)',
        'faq.a13Note': 'Recomendamos usar uma extensão de navegador para melhor segurança.',
        'faq.q14': 'O que são Zaps?',
        'faq.a14': 'Zaps são pagamentos de Bitcoin enviados através da Lightning Network. Eles permitem que você envie dinheiro real (satoshis, ou "sats") para criadores de conteúdo como gorjetas ou apreciação. Diferente das gorjetas tradicionais de plataformas que cobram altas taxas, os zaps vão diretamente para o criador. Para enviar zaps, você precisa de uma carteira Lightning com conexão Nostr (como Alby ou Zeus).',
        'faq.q15': 'Como enviar um vídeo?',
        'faq.a15Title': 'Para enviar um vídeo:',
        'faq.a15Item1': 'Faça login com sua identidade Nostr',
        'faq.a15Item2': 'Clique no botão "Criar" e selecione "Enviar Vídeo"',
        'faq.a15Item3': 'Selecione seu arquivo de vídeo (suporta a maioria dos formatos comuns)',
        'faq.a15Item4': 'Adicione um título, descrição e tags',
        'faq.a15Item5': 'Clique em "Publicar" para compartilhar com a rede',
        'faq.a15Note': 'Os vídeos são comprimidos automaticamente e enviados para servidores Blossom.',
        // FAQ Self-Moderation Section
        'faq.selfModeration': 'Auto-Moderação',
        'faq.q16': 'Como funciona a moderação em uma plataforma descentralizada?',
        'faq.a16': 'Diferente das plataformas tradicionais com moderadores centralizados, o Plebs coloca você no controle do que você vê. Fornecemos ferramentas poderosas de auto-moderação incluindo pacotes de filtros de conteúdo, silenciamento de usuários, avisos da comunidade e indicadores de vídeos com proporção negativa. Você decide qual conteúdo é apropriado para você - não há autoridade central tomando essas decisões.',
        'faq.q17': 'O que são Pacotes de Filtros de Conteúdo?',
        'faq.a17Intro': 'Pacotes de Filtros de Conteúdo são filtros de palavras-chave predefinidos que você pode habilitar para ocultar tipos específicos de conteúdo. Os pacotes disponíveis incluem:',
        'faq.a17Pack1': 'Racismo e Discurso de Ódio:',
        'faq.a17Pack1Desc': 'Filtra insultos raciais e conteúdo discriminatório',
        'faq.a17Pack2': 'Conteúdo Sexualmente Explícito:',
        'faq.a17Pack2Desc': 'Filtra conteúdo pornográfico e adulto',
        'faq.a17Pack3': 'Violência e Gore:',
        'faq.a17Pack3Desc': 'Filtra violência gráfica e conteúdo de automutilação',
        'faq.a17Pack4': 'Drogas e Substâncias:',
        'faq.a17Pack4Desc': 'Filtra conteúdo relacionado a drogas',
        'faq.a17Pack5': 'Spam e Golpes:',
        'faq.a17Pack5Desc': 'Filtra padrões comuns de spam e golpes',
        'faq.a17Pack6': 'Criptomoedas:',
        'faq.a17Pack6Desc': 'Filtra promoção de criptomoedas e tokens',
        'faq.a17Pack7': 'Conteúdo Político:',
        'faq.a17Pack7Desc': 'Filtra conteúdo político partidário',
        'faq.a17Pack8': 'Profanação Forte:',
        'faq.a17Pack8Desc': 'Filtra linguagem vulgar',
        'faq.a17Note': 'Habilite estes em Configurações > Filtros de Conteúdo. Você também pode adicionar palavras-chave personalizadas. Conteúdo filtrado mostra um marcador com um botão "Mostrar mesmo assim" se você quiser visualizá-lo temporariamente.',
        'faq.q18': 'Como silenciar um usuário?',
        'faq.a18': 'Para silenciar um usuário, visite o perfil dele e clique no botão silenciar. Uma vez silenciado, todos os vídeos dele serão ocultados do seu feed, seus comentários aparecerão como "Mensagem de usuário silenciado" e suas mensagens de chat ao vivo serão ocultadas. Sua lista de silenciados é armazenada no Nostr, então sincroniza entre dispositivos. Você pode gerenciar usuários silenciados nas Configurações do Perfil em "Usuários Silenciados".',
        'faq.q19': 'O que significa "Ratioed"?',
        'faq.a19': 'Um vídeo é marcado como "ratioed" quando tem significativamente mais dislikes do que likes, indicando recepção negativa da comunidade. Especificamente, um vídeo é ratioed quando tem pelo menos 10 reações, dislikes são pelo menos o dobro dos likes e dislikes representam 70% ou mais das reações totais. Vídeos ratioed exibem um distintivo de aviso e você será solicitado a confirmar antes de visualizar.',
        'faq.q20': 'Como funcionam os avisos da comunidade?',
        'faq.a20': 'Usuários podem denunciar conteúdo por vários motivos (spam, conteúdo ilegal, abuso, enganoso, etc.). Quando um vídeo ou usuário recebe 5 ou mais denúncias de pessoas que você segue, um indicador de aviso aparece. Isso aproveita seu gráfico social - avisos vêm de sua rede confiável, não de estranhos anônimos. Você pode alternar "Mostrar avisos de contas que eu sigo" nas Configurações.',
        'faq.q21': 'Como denunciar conteúdo?',
        'faq.a21': 'Clique no ícone de bandeira em qualquer vídeo, comentário ou perfil de usuário para denunciá-lo. Selecione um motivo (Spam, Ilegal, Abuso, Enganoso, Falsificação de Identidade, Direitos Autorais ou Outro) e opcionalmente adicione detalhes. Denúncias são publicadas no Nostr como eventos, tornando-as transparentes e descentralizadas. Suas denúncias ajudam outros em sua rede a identificar conteúdo problemático.',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': 'Privacidade e Segurança',
        'faq.q22': 'Minha atividade é privada?',
        'faq.a22': 'No Nostr, a maior parte da atividade é pública por design. Suas curtidas, comentários, seguidas e zaps são visíveis na rede pública. No entanto, o Plebs armazena seu histórico de visualização localmente no seu navegador - nunca é enviado para nenhum servidor. Você pode limpar seus dados locais a qualquer momento.',
        'faq.q23': 'Como manter minha conta segura?',
        'faq.a23': 'Nunca compartilhe sua chave privada (nsec) com ninguém. Recomendamos fortemente usar uma extensão de navegador Nostr como Alby, nos2x ou um assinante de hardware. Estes mantêm sua chave privada segura e apenas assinam eventos quando você os aprova. Evite armazenar sua nsec diretamente em sites.',
        'faq.q24': 'Posso deletar meu conteúdo?',
        'faq.a24': 'Você pode solicitar a exclusão publicando um evento de exclusão no Nostr. A maioria dos relays e clientes bem comportados respeitará isso. No entanto, devido à natureza descentralizada da rede, o conteúdo pode persistir em alguns relays ou servidores Blossom. Não há autoridade central que possa forçar a exclusão completa em toda a rede.',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': 'Solução de Problemas',
        'faq.q25': 'Os vídeos não estão carregando - o que devo fazer?',
        'faq.a25Intro': 'Se os vídeos não estiverem carregando, tente estas etapas:',
        'faq.a25Item1': 'Atualize a página',
        'faq.a25Item2': 'Verifique sua conexão com a internet',
        'faq.a25Item3': 'O servidor Blossom hospedando o vídeo pode estar fora do ar - isso é independente do Plebs',
        'faq.a25Item4': 'Tente desabilitar extensões do navegador que possam bloquear conteúdo',
        'faq.a25Item5': 'Limpe o cache do navegador e tente novamente',
        'faq.q26': 'Perdi minha chave privada - você pode me ajudar a recuperá-la?',
        'faq.a26': 'Infelizmente, não. As chaves Nostr são criptográficas - não há redefinição de senha ou recuperação de conta porque não há autoridade central. É por isso que recomendamos fortemente fazer backup de suas chaves e usar uma solução segura de gerenciamento de chaves. Se você perder sua nsec, precisará criar uma nova identidade.',
        'faq.q27': 'Como reportar um bug ou solicitar um recurso?',
        'faq.a27': 'Você pode reportar bugs ou solicitar recursos em nossa página de <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">Issues do GitHub</a>. Você também pode entrar em contato conosco no Nostr - visite nossa página de <a href="#/contact">Contato</a> para detalhes.',
        // Page Titles
        'pageTitle.following': 'Seguindo',
        'pageTitle.myVideos': 'Meus Vídeos',
        'pageTitle.likedVideos': 'Vídeos Curtidos',
        'pageTitle.watchHistory': 'Histórico de Visualização',
        'pageTitle.liveStreams': 'Transmissões ao Vivo',
        'pageTitle.suffix': '- Plebs',
        'pageTitle.liveSuffix': '- Ao Vivo no Plebs',
        // Home Page Sections
        'section.trending': 'Em Alta',
        'section.recommended': 'Recomendado Para Você',
        'section.shorts': 'Shorts',
        'section.live': 'Ao Vivo',
        'section.liveNow': 'Ao Vivo Agora',
        'section.latestVideos': 'Vídeos Recentes',
        'section.videos': 'Vídeos',
        'section.usersYouFollow': 'Usuários que Você Segue',
        // Trending Period
        'trending.thisWeek': 'Esta Semana',
        'trending.today': 'Hoje',
        // Buttons
        'button.viewMore': 'Ver Mais',
        'button.clearAll': 'Limpar Tudo',
        'button.showAnyway': 'Mostrar mesmo assim',
        // Confirmation Modals
        'confirm.logout': 'Sair',
        'confirm.logoutMessage': 'Tem certeza que deseja sair?',
        'confirm.resetSettings': 'Redefinir Configurações',
        'confirm.resetSettingsMessage': 'Tem certeza que deseja redefinir todas as configurações para os padrões?',
        'confirm.reset': 'Redefinir',
        'confirm.clearHistory': 'Limpar Histórico',
        'confirm.clearHistoryMessage': 'Tem certeza que deseja limpar todo o seu histórico de visualização? Isso não pode ser desfeito.',
        'confirm.deleteDraft': 'Excluir Rascunho',
        'confirm.deleteDraftMessage': 'Tem certeza que deseja excluir este rascunho?',
        'confirm.delete': 'Excluir',
        'confirm.deleteVideo': 'Excluir Vídeo',
        'confirm.deleteVideoMessage': 'Tem certeza que deseja excluir este vídeo? Esta ação não pode ser desfeita.',
        'confirm.endStream': 'Encerrar Transmissão ao Vivo',
        'confirm.endStreamMessage': 'Tem certeza que deseja encerrar esta transmissão ao vivo? Esta ação não pode ser desfeita.',
        'confirm.endStreamButton': 'Encerrar Transmissão',
        // Content Filters
        'filter.hiddenByPack': 'Oculto por {pack}',
        'filter.showAnyway': 'Mostrar mesmo assim',
        'filter.contentHidden': 'Conteúdo oculto pelo filtro de conteúdo',
        // Filter Packs
        'filter.racism': 'Racismo e Discurso de Ódio', 'filter.racismDesc': 'Filtra insultos raciais, discurso de ódio étnico e conteúdo discriminatório', 'filter.sexualExplicit': 'Sexualmente Explícito', 'filter.sexualExplicitDesc': 'Filtra termos pornográficos e conteúdo sexualmente explícito', 'filter.violence': 'Violência e Gore', 'filter.violenceDesc': 'Filtra violência gráfica, gore e ameaças violentas', 'filter.drugs': 'Drogas e Substâncias', 'filter.drugsDesc': 'Filtra conteúdo relacionado a drogas e abuso de substâncias', 'filter.spam': 'Spam e Golpes', 'filter.spamDesc': 'Filtra spam comum, golpes e conteúdo promocional', 'filter.crypto': 'Criptomoeda', 'filter.cryptoDesc': 'Filtra promoção de criptomoedas, sinais de trading e promoção de tokens', 'filter.politics': 'Conteúdo Político', 'filter.politicsDesc': 'Filtra conteúdo político partidário e retórica divisiva', 'filter.profanity': 'Linguagem Forte', 'filter.profanityDesc': 'Filtra palavrões fortes e linguagem vulgar', 'filter.customFilter': 'Filtro Personalizado',
        // Following Page
        'following.noFollowingYet': 'Você ainda não está seguindo ninguém. Encontre criadores para seguir!',
    },
    ru: {
        // Navigation & Header
        'nav.home': 'Главная', 'nav.following': 'Подписки', 'nav.myVideos': 'Мои Видео', 'nav.liked': 'Понравившиеся', 'nav.history': 'История', 'nav.topics': 'ТЕМЫ', 'nav.live': 'Прямой эфир', 'nav.bitcoin': 'Биткоин', 'nav.nostr': 'Nostr', 'nav.technology': 'Технологии', 'nav.gaming': 'Игры', 'nav.tutorials': 'Уроки', 'nav.podcasts': 'Подкасты', 'nav.music': 'Музыка', 'nav.nsfw': 'NSFW', 'nav.about': 'О нас', 'nav.contact': 'Контакты', 'nav.terms': 'Условия', 'nav.privacy': 'Конфиденциальность', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': 'Трансляции', 'nav.github': 'GitHub',
        'header.search': 'Поиск видео...', 'header.notifications': 'Уведомления', 'header.settings': 'Настройки', 'header.create': 'Создать', 'header.viewProfile': 'Мой профиль', 'header.logout': 'Выйти',
        // Login Modal
        'login.title': 'Вход через Nostr', 'login.extensionButton': 'Войти через расширение Nostr', 'login.extensionDesc': 'Использовать расширение-подписчик (Alby, nos2x и др.)', 'login.orDivider': 'ИЛИ', 'login.nsecLabel': 'Войти с приватным ключом (nsec)', 'login.nsecPlaceholder': 'Введите nsec...', 'login.nsecButton': 'Войти с nsec', 'login.nsecWarning': 'Внимание: Ввод nsec напрямую менее безопасен, чем использование расширения. Рассмотрите NIP-07 расширение для лучшей защиты.', 'login.newToNostr': 'Новичок в Nostr?', 'login.createAccount': 'Создать аккаунт', 'login.learnMore': 'Узнать больше о Nostr',
        // Connect Modal
        'connect.title': 'Подключение к Nostr', 'connect.or': 'ИЛИ', 'connect.extensionButton': 'Подключить расширение Nostr', 'connect.extensionDesc': 'Использовать расширение (Alby, nos2x и др.)', 'connect.nsecLabel': 'Войти с приватным ключом', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'Подключиться с nsec', 'connect.nsecWarning': 'Внимание: Ввод nsec напрямую менее безопасен. Используйте NIP-07 расширение для лучшей защиты.', 'connect.newToNostr': 'Новичок в Nostr?', 'connect.createAccount': 'Создать аккаунт',
        // Private Key Modal
        'privateKey.title': 'Ваш приватный ключ', 'privateKey.warning': 'ВАЖНО: Сохраните это в безопасном месте. Если вы потеряете этот ключ, вы потеряете доступ к аккаунту. Никогда никому его не показывайте!', 'privateKey.show': 'Показать приватный ключ', 'privateKey.hide': 'Скрыть приватный ключ', 'privateKey.copy': 'Копировать', 'privateKey.saved': 'Я сохранил(а) свой ключ', 'privateKey.yourPublicKey': 'Ваш публичный ключ (npub):', 'privateKey.yourPrivateKey': 'Ваш приватный ключ (nsec):',
        // Signup Modal
        'signup.title': 'Создать аккаунт Nostr', 'signup.whatIsNostr': 'Что такое Nostr?', 'signup.nostrDescription': 'Nostr — это децентрализованный протокол, который даёт вам контроль над вашей идентичностью и данными. Нет центрального сервера — ваш аккаунт — это криптографическая пара ключей.', 'signup.whyNostr': 'Почему Nostr?', 'signup.benefit1': 'Владейте своей идентичностью', 'signup.benefit2': 'Нет цензуры', 'signup.benefit3': 'Портативность между платформами', 'signup.createNew': 'Создать новый аккаунт', 'signup.haveAccount': 'Уже есть аккаунт?', 'signup.login': 'Войти', 'signup.createButton': 'Создать аккаунт', 'signup.generating': 'Генерация ключей...', 'signup.displayName': 'Имя', 'signup.displayNamePlaceholder': 'Введите имя', 'signup.username': 'Имя пользователя', 'signup.usernamePlaceholder': 'Введите имя пользователя', 'signup.about': 'О себе (необязательно)', 'signup.profilePicture': 'Фото профиля (необязательно)', 'signup.lightningAddress': 'Lightning адрес (необязательно)', 'signup.nostrAddress': 'Nostr адрес', 'signup.nostrAddressPlaceholder': 'имяпользователя', 'signup.nostrAddressHint': 'Ваш Nostr адрес упрощает поиск вашего профиля. Только строчные буквы, цифры, _ и -.', 'signup.nostrAddressRequired': 'Пожалуйста, введите Nostr адрес', 'signup.nostrAddressAvailable': 'Доступно!', 'signup.nostrAddressUnavailable': 'Уже занято', 'signup.nostrAddressChecking': 'Проверка...', 'signup.nostrAddressInvalid': 'Неверный формат имени пользователя', 'signup.nostrAddressRegistering': 'Регистрация вашего Nostr адреса...', 'signup.nostrAddressSuccess': 'Nostr адрес зарегистрирован!', 'signup.nostrAddressFailed': 'Не удалось зарегистрировать Nostr адрес', 'signup.createAccountBtn': 'Создать аккаунт', 'signup.termsAgree': 'Создавая аккаунт, вы соглашаетесь с нашими', 'signup.and': 'и', 'signup.success': 'Аккаунт успешно создан!', 'signup.yourPrivateKey': 'Ваш приватный ключ (nsec)', 'signup.keyWarning': 'Это ЕДИНСТВЕННЫЙ способ получить доступ к вашему аккаунту. Сохраните его в безопасном месте!', 'signup.copyPrivateKey': 'Копировать приватный ключ', 'signup.howToUseKey': 'Как использовать ваш приватный ключ', 'signup.continueToPlebs': 'Продолжить на Plebs', 'signup.step1': 'Сохраните надёжно:', 'signup.step1Desc': 'Храните nsec в менеджере паролей, запишите или сохраните в зашифрованном файле. Никогда не делитесь публично!', 'signup.step2': 'Для повторного входа:', 'signup.step2Desc': 'Нажмите "Приватный ключ" на экране входа и вставьте nsec. Работает как пароль.', 'signup.step3': 'Использование в других приложениях:', 'signup.step3Desc': 'Ваш nsec работает во всех Nostr приложениях - Damus, Primal, Amethyst и сотнях других!', 'signup.step4': 'Рассмотрите приложение для подписи:', 'signup.step4Desc': 'Для большей безопасности используйте приложения как Amber (Android) или расширение браузера Alby.',
        // Notifications
        'notifications.title': 'Уведомления', 'notifications.empty': 'Пока нет уведомлений', 'notifications.viewAll': 'Смотреть все уведомления', 'notifications.markAllRead': 'Отметить все как прочитанные', 'notifications.settings': 'Настройки уведомлений', 'notifications.loading': 'Загрузка уведомлений...', 'notifications.zap': 'отправил(а) вам зап', 'notifications.like': 'понравился ваш контент', 'notifications.comment': 'оставил(а) комментарий', 'notifications.follow': 'подписался(ась) на вас', 'notifications.repost': 'сделал(а) репост', 'notifications.mention': 'упомянул(а) вас',
        // Settings Modal
        'settings.title': 'Настройки', 'settings.language': 'Язык', 'settings.languageDesc': 'Выберите язык', 'settings.saveToNostr': 'Сохранить в Nostr', 'settings.darkMode': 'Тёмная тема', 'settings.darkModeDesc': 'Переключение тёмной темы', 'settings.contentWarning': 'Настройки предупреждений о контенте', 'settings.showNsfwWarnings': 'Показывать предупреждения NSFW', 'settings.showNsfwWarningsDesc': 'Отображать проверку возраста для контента NSFW', 'settings.showCommunityWarnings': 'Показывать предупреждения сообщества', 'settings.showCommunityWarningsDesc': 'Отображать предупреждения для помеченного или негативно оцененного контента', 'settings.showFollowsReportWarnings': 'Показывать предупреждения от подписок', 'settings.showFollowsReportWarningsDesc': 'Отображать предупреждения, когда 5+ людей, на которых вы подписаны, пожаловались на контент', 'settings.filterPacks': 'Пакеты фильтров контента', 'settings.filterPacksDesc': 'Включите пакеты фильтров для автоматического скрытия контента с определёнными ключевыми словами.', 'settings.customKeywordFilter': 'Пользовательский фильтр ключевых слов', 'settings.customKeywordFilterPlaceholder': 'Введите ключевые слова или фразы через запятую\nПример: спам, нежелательный контент, конкретная фраза', 'settings.customKeywordFilterDesc': 'Добавьте свои ключевые слова для фильтрации (через запятую)', 'settings.autoplay': 'Автовоспроизведение', 'settings.autoplayDesc': 'Автоматически воспроизводить видео', 'settings.saveSettings': 'Сохранить настройки', 'settings.resetDefaults': 'Сбросить', 'settings.notificationSettings': 'Настройки уведомлений', 'settings.notifications': 'Уведомления', 'settings.notificationsDesc': 'Получать push-уведомления', 'settings.quality': 'Качество по умолчанию', 'settings.qualityDesc': 'Качество воспроизведения видео',
        // Upload Modal
        'upload.title': 'Загрузить видео', 'upload.dragDrop': 'Перетащите видеофайл сюда', 'upload.or': 'или', 'upload.browse': 'Выбрать файлы', 'upload.supportedFormats': 'Поддерживаемые форматы: MP4, WebM, MOV', 'upload.maxSize': 'Максимальный размер: 2ГБ', 'upload.videoTitle': 'Название', 'upload.titlePlaceholder': 'Введите название видео', 'upload.description': 'Описание', 'upload.descriptionPlaceholder': 'Опишите ваше видео...', 'upload.tags': 'Теги', 'upload.tagsPlaceholder': 'Добавьте теги через запятую', 'upload.visibility': 'Видимость', 'upload.public': 'Публичное', 'upload.unlisted': 'По ссылке', 'upload.uploadButton': 'Загрузить видео', 'upload.uploading': 'Загрузка...', 'upload.processing': 'Обработка...', 'upload.complete': 'Завершено!', 'upload.error': 'Ошибка загрузки', 'upload.nsfw': 'Контент NSFW', 'upload.nsfwDesc': 'Отметить как контент для взрослых', 'upload.thumbnail': 'Обложка', 'upload.thumbnailDesc': 'Загрузите обложку для видео', 'upload.preparing': 'Подготовка...', 'upload.cancel': 'Отмена', 'upload.progress': 'Прогресс загрузки', 'upload.transcoding': 'Транскодирование', 'upload.complete': 'Завершено', 'upload.status.preparing': 'Подготовка загрузки...', 'upload.status.uploading': 'Загрузка видео...', 'upload.status.transcoding': 'Транскодирование видео...', 'upload.status.complete': 'Загрузка завершена!', 'upload.qualityHigh': 'Высокое', 'upload.qualityMedium': 'Среднее', 'upload.qualityLow': 'Низкое',
        // Create Modal
        'create.title': 'Создать', 'create.uploadVideo': 'Загрузить видео', 'create.uploadDesc': 'Поделиться видео', 'create.goLive': 'Начать трансляцию', 'create.goLiveDesc': 'Запустить прямую трансляцию', 'create.createPost': 'Создать пост', 'create.createPostDesc': 'Поделиться текстом',
        // Go Live Modal
        'goLive.title': 'Начать трансляцию', 'goLive.streamTitle': 'Название трансляции', 'goLive.streamTitlePlaceholder': 'Введите название трансляции', 'goLive.description': 'Описание', 'goLive.descriptionPlaceholder': 'Опишите вашу трансляцию...', 'goLive.category': 'Категория', 'goLive.selectCategory': 'Выберите категорию', 'goLive.tags': 'Теги', 'goLive.tagsPlaceholder': 'Добавьте теги через запятую', 'goLive.startStream': 'Начать трансляцию', 'goLive.streamKey': 'Ключ трансляции', 'goLive.streamUrl': 'URL трансляции', 'goLive.copy': 'Копировать', 'goLive.hideKey': 'Скрыть ключ', 'goLive.showKey': 'Показать ключ', 'goLive.connecting': 'Подключение...', 'goLive.live': 'В ЭФИРЕ', 'goLive.offline': 'Не в сети', 'goLive.viewers': 'зрителей', 'goLive.endStream': 'Завершить трансляцию', 'goLive.nsfw': 'Контент NSFW', 'goLive.nsfwDesc': 'Отметить как контент для взрослых', 'goLive.thumbnail': 'Обложка трансляции', 'goLive.thumbnailDesc': 'Загрузите обложку', 'goLive.zapGoal': 'Цель Zap (опционально)', 'goLive.zapGoalLabel': 'Цель Zap',
        // Video/Live No Description
        'video.noDescription': 'К этому видео не добавлено описание.', 'live.noDescription': 'К этой трансляции не добавлено описание.',
        // Edit Stream Modal
        'editStream.title': 'Редактировать трансляцию', 'editStream.save': 'Сохранить изменения',
        // NSFW Warning Modal
        'nsfw.title': 'Внимание: контент для взрослых', 'nsfw.warning': 'Этот контент отмечен как NSFW (Not Safe For Work) и может содержать материалы для взрослых.', 'nsfw.confirm': 'Подтвердите свой возраст', 'nsfw.confirmAge': 'Мне 18 лет или больше', 'nsfw.cancel': 'Назад', 'nsfw.continue': 'Продолжить', 'nsfw.dontShowAgain': 'Не показывать это предупреждение',
        // Community Warning Modal
        'community.title': 'Правила сообщества', 'community.warning': 'Перед продолжением ознакомьтесь с правилами нашего сообщества.', 'community.guidelines': 'Будьте уважительны и соблюдайте стандарты сообщества.', 'community.accept': 'Принимаю', 'community.decline': 'Отклоняю',
        'communityWarning.title': 'Предупреждение сообщества', 'communityWarning.description': 'Это видео было отмечено и/или имеет много негативных оценок от сообщества. Это может быть связано с:', 'communityWarning.reason1': 'Неприемлемый контент не отмечен как NSFW', 'communityWarning.reason2': 'Новый или подозрительный профиль пользователя', 'communityWarning.reason3': 'Вводящая в заблуждение или ложная информация', 'communityWarning.reason4': 'Спам или низкокачественный контент', 'communityWarning.reason5': 'Потенциально опасный или незаконный контент', 'communityWarning.proceed': 'Продолжайте с осторожностью.', 'communityWarning.goBack': 'Назад', 'communityWarning.viewAnyway': 'Всё равно посмотреть',
        // Report Modal
        'report.title': 'Пожаловаться на контент', 'report.reason': 'Причина жалобы', 'report.selectReason': 'Выберите причину', 'report.spam': 'Спам или вводящий в заблуждение', 'report.inappropriate': 'Неприемлемый контент', 'report.violence': 'Насилие или опасный контент', 'report.copyright': 'Нарушение авторских прав', 'report.other': 'Другое', 'report.details': 'Дополнительно', 'report.detailsPlaceholder': 'Опишите проблему подробнее...', 'report.submit': 'Отправить жалобу', 'report.cancel': 'Отмена',
        // Share Modal
        'share.title': 'Поделиться', 'share.copyLink': 'Копировать ссылку', 'share.embed': 'Код для вставки', 'share.copyEmbed': 'Копировать код', 'share.social': 'Поделиться в соцсетях', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': 'Email', 'share.copied': 'Скопировано!', 'share.nostr': 'Поделиться в Nostr', 'share.generateImage': 'Создать изображение', 'share.downloadImage': 'Скачать', 'share.shareImage': 'Поделиться', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (квадрат)', 'share.size1080x1920': '1080 × 1920 (сторис)',
        // Edit Video Modal
        'editVideo.title': 'Редактировать видео', 'editVideo.videoTitle': 'Название', 'editVideo.description': 'Описание', 'editVideo.tags': 'Теги', 'editVideo.thumbnail': 'Обложка', 'editVideo.changeThumbnail': 'Изменить обложку', 'editVideo.visibility': 'Видимость', 'editVideo.nsfw': 'Контент NSFW', 'editVideo.save': 'Сохранить изменения', 'editVideo.delete': 'Удалить видео', 'editVideo.confirmDelete': 'Вы уверены, что хотите удалить это видео?',
        // Edit Profile Modal
        'editProfile.title': 'Редактировать профиль', 'editProfile.displayName': 'Имя', 'editProfile.displayNamePlaceholder': 'Введите имя', 'editProfile.username': 'Имя пользователя', 'editProfile.usernamePlaceholder': 'Введите имя пользователя', 'editProfile.about': 'О себе', 'editProfile.aboutPlaceholder': 'Расскажите о себе...', 'editProfile.website': 'Веб-сайт', 'editProfile.websitePlaceholder': 'https://ваш-сайт.com', 'editProfile.lightning': 'Lightning-адрес', 'editProfile.lightningPlaceholder': 'вы@getalby.com', 'editProfile.nip05': 'NIP-05 верификация', 'editProfile.nip05Placeholder': 'вы@домен.com', 'editProfile.avatar': 'Аватар', 'editProfile.changeAvatar': 'Изменить аватар', 'editProfile.banner': 'Баннер', 'editProfile.changeBanner': 'Изменить баннер', 'editProfile.save': 'Сохранить профиль',
        // Confirmation Modal
        'confirm.title': 'Подтвердить действие', 'confirm.message': 'Вы уверены, что хотите продолжить?', 'confirm.confirm': 'Подтвердить', 'confirm.cancel': 'Отмена',
        // Video Page
        'video.views': 'просмотров', 'video.like': 'Нравится', 'video.dislike': 'Не нравится', 'video.share': 'Поделиться', 'video.save': 'Сохранить', 'video.report': 'Пожаловаться', 'video.follow': 'Подписаться', 'video.unfollow': 'Отписаться', 'video.subscribe': 'Подписаться', 'video.subscribed': 'Подписан(а)', 'video.comments': 'Комментарии', 'video.addComment': 'Добавить комментарий...', 'video.reply': 'Ответить', 'video.replies': 'ответов', 'video.loadMore': 'Загрузить ещё', 'video.noComments': 'Комментариев пока нет. Будьте первым!', 'video.zap': 'Зап', 'video.zapAmount': 'Сумма зап (сатоши)', 'video.sendZap': 'Отправить зап', 'video.boost': 'Буст', 'video.description': 'Описание', 'video.showMore': 'Показать больше', 'video.showLess': 'Показать меньше', 'video.publishedOn': 'Опубликовано',
        // Toast Messages
        'toast.loggedIn': 'Вход выполнен!', 'toast.loggedOut': 'Выход выполнен', 'toast.settingsSaved': 'Настройки сохранены!', 'toast.settingsLocal': 'Настройки сохранены локально. Не удалось сохранить в Nostr.', 'toast.settingsLocalOnly': 'Настройки сохранены локально!', 'toast.settingsReset': 'Настройки сброшены', 'toast.avatarUploaded': 'Аватар загружен!', 'toast.videoUploaded': 'Видео загружено!', 'toast.videoDeleted': 'Видео удалено', 'toast.profileUpdated': 'Профиль обновлён!', 'toast.copied': 'Скопировано в буфер обмена!', 'toast.copyFailed': 'Ошибка копирования. Скопируйте вручную.', 'toast.linkCopied': 'Ссылка скопирована!', 'toast.embedCopied': 'Код скопирован!', 'toast.installExtension': 'Установите расширение Nostr, например Alby или nos2x', 'toast.loginFailed': 'Ошибка входа. Попробуйте снова.', 'toast.invalidKey': 'Неверный приватный ключ. Проверьте и попробуйте снова.', 'toast.enterKey': 'Введите приватный ключ', 'toast.enterUsername': 'Введите имя пользователя', 'toast.accountCreated': 'Добро пожаловать в Plebs! Вы вошли в систему.', 'toast.keyCopied': 'Ключ скопирован!', 'toast.unmuted': 'Пользователь разблокирован', 'toast.unmuteFailed': 'Не удалось разблокировать пользователя', 'toast.selectImage': 'Выберите файл изображения', 'toast.imageTooLarge': 'Изображение должно быть менее 5 МБ', 'toast.avatarFailed': 'Ошибка загрузки аватара. Попробуйте снова.', 'toast.mustBeLoggedIn': 'Войдите, чтобы редактировать профиль', 'toast.enterDisplayName': 'Введите отображаемое имя', 'toast.profileFailed': 'Ошибка сохранения профиля. Попробуйте снова.', 'toast.invalidBunker': 'Введите действительный URL bunker', 'toast.connectFailed': 'Ошибка подключения', 'toast.showingFiltered': 'Показан отфильтрованный контент', 'toast.reportSubmitted': 'Жалоба отправлена', 'toast.draftSaved': 'Черновик сохранён! Продолжите позже из Моих видео.', 'toast.draftLoaded': 'Черновик загружен. Завершите загрузку и опубликуйте.', 'toast.draftDeleted': 'Черновик удалён', 'toast.zapSent': 'Зап отправлен!', 'toast.followed': 'Вы подписались!', 'toast.unfollowed': 'Вы отписались', 'toast.reported': 'Жалоба отправлена', 'toast.saved': 'Сохранено!', 'toast.error': 'Произошла ошибка', 'toast.networkError': 'Ошибка сети. Попробуйте снова.', 'toast.uploadError': 'Ошибка загрузки. Попробуйте снова.', 'toast.languageChanged': 'Язык изменён', 'toast.videoBlocked': 'Видео заблокировано и опубликовано в Nostr', 'toast.waitForUpload': 'Дождитесь завершения загрузки видео', 'toast.enterTitle': 'Введите заголовок', 'toast.publishing': 'Публикация видео в Nostr...', 'toast.commentPosted': 'Комментарий опубликован',
        // Time
        'time.justNow': 'только что', 'time.secondAgo': '1 сек. назад', 'time.secondsAgo': '{n} сек. назад', 'time.minuteAgo': '1 мин. назад', 'time.minutesAgo': '{n} мин. назад', 'time.hourAgo': '1 ч. назад', 'time.hoursAgo': '{n} ч. назад', 'time.dayAgo': '1 дн. назад', 'time.daysAgo': '{n} дн. назад', 'time.weekAgo': '1 нед. назад', 'time.weeksAgo': '{n} нед. назад', 'time.monthAgo': '1 мес. назад', 'time.monthsAgo': '{n} мес. назад', 'time.yearAgo': '1 г. назад', 'time.yearsAgo': '{n} г. назад',
        // Empty States
        'empty.noVideos': 'Видео не найдены', 'empty.noVideosDesc': 'Попробуйте другой поиск', 'empty.noFollowing': 'Вы ещё никого не подписаны', 'empty.noFollowingDesc': 'Следите за авторами, чтобы видеть их видео', 'empty.noHistory': 'История пуста', 'empty.noHistoryDesc': 'Посмотренные видео появятся здесь', 'empty.noLiked': 'Понравившихся видео пока нет', 'empty.noLikedDesc': 'Лайкайте видео, и они появятся здесь', 'empty.noResults': 'Результатов не найдено', 'empty.noResultsDesc': 'Попробуйте другие ключевые слова',
        // Misc
        'misc.loading': 'Загрузка...', 'misc.loadingMore': 'Загрузка...', 'misc.refresh': 'Обновить', 'misc.retry': 'Повторить', 'misc.close': 'Закрыть', 'misc.back': 'Назад', 'misc.next': 'Далее', 'misc.previous': 'Назад', 'misc.search': 'Поиск', 'misc.filter': 'Фильтр', 'misc.sort': 'Сортировка', 'misc.newest': 'Новые', 'misc.oldest': 'Старые', 'misc.popular': 'Популярные', 'misc.trending': 'В тренде', 'misc.sats': 'сатоши', 'misc.all': 'Все', 'misc.copiedToClipboard': 'Скопировано!',
        // Common
        'common.submit': 'Отправить', 'common.cancel': 'Отмена', 'common.save': 'Сохранить', 'common.delete': 'Удалить', 'common.edit': 'Редактировать', 'common.close': 'Закрыть', 'common.confirm': 'Подтвердить', 'common.yes': 'Да', 'common.no': 'Нет', 'common.ok': 'ОК', 'common.loading': 'Загрузка...', 'common.uploading': 'Загрузка...', 'common.error': 'Ошибка', 'common.success': 'Успешно',
        // Aria Labels
        'aria.toggleMenu': 'Переключить меню', 'aria.mainNavigation': 'Главная навигация', 'aria.videoContent': 'Видеоконтент', 'aria.loadingContent': 'Загрузка контента', 'aria.closeModal': 'Закрыть окно', 'aria.playVideo': 'Воспроизвести видео', 'aria.pauseVideo': 'Приостановить видео', 'aria.muteVideo': 'Отключить звук', 'aria.unmuteVideo': 'Включить звук', 'aria.fullscreen': 'Полный экран', 'aria.exitFullscreen': 'Выйти из полного экрана', 'aria.settings': 'Настройки', 'aria.notifications': 'Уведомления', 'aria.userMenu': 'Меню пользователя', 'aria.searchInput': 'Поиск видео', 'aria.videoPlayer': 'Видеоплеер',
        // Dynamic JavaScript text
        'button.hideQR': 'Скрыть QR-код', 'button.showQR': 'Показать QR-код', 'button.copied': 'Скопировано!', 'button.showLess': 'Показать меньше', 'button.showMore': 'Показать больше', 'button.creatingAccount': 'Создание аккаунта...', 'button.submitting': 'Отправка...', 'button.scheduleStream': 'Запланировать трансляцию', 'button.goLive': 'Начать трансляцию', 'button.creatingStream': 'Создание трансляции...', 'button.continueCustomAmount': 'Продолжить с произвольной суммой', 'button.recordFromCamera': 'Записать с камеры', 'button.requestingCamera': 'Запрос камеры...', 'button.recording': 'Запись...',
        'status.saving': 'Сохранение...', 'status.saved': 'Сохранено!', 'status.uploading': 'Загрузка...', 'status.uploadComplete': 'Загрузка завершена!', 'status.uploadingToNostrBuild': 'Загрузка на nostr.build...', 'status.publishingChanges': 'Публикация изменений...', 'status.removingOldVersion': 'Удаление старой версии...', 'status.validatingThumbnail': 'Проверка миниатюры...', 'status.uploadingThumbnail': 'Загрузка миниатюры...', 'status.thumbnailUploaded': 'Миниатюра загружена!', 'status.processingVideo': 'Обработка видео...', 'status.compressingVideo': 'Сжатие видео...', 'status.uploadingVideo': 'Загрузка видео...', 'status.videoUploaded': 'Видео успешно загружено!', 'status.processing': 'Обработка...', 'status.generatingThumbnail': 'Генерация миниатюры...', 'status.generatingPreview': 'Генерация превью...', 'status.uploadingPreview': 'Загрузка превью...', 'status.publishing': 'Публикация...', 'status.publishingToNostr': 'Публикация в Nostr...', 'status.publishingVideoToNostr': 'Публикация видео в Nostr...', 'status.generatingPoW': 'Генерация proof of work...', 'status.posting': 'Публикация...', 'status.processingVideoAndThumbnail': 'Обработка видео и миниатюры...', 'status.uploadFailed': 'Ошибка загрузки - попробуйте снова', 'status.selectVideoToUpload': 'Выберите видео для загрузки', 'status.waitingForVideoUpload': 'Ожидание загрузки видео...', 'status.selectVideoAndThumbnail': 'Выберите видео и миниатюру для публикации', 'status.ready': 'Готово ✓', 'status.failed': 'Ошибка ✗', 'status.fromDraft': 'Из черновика', 'status.startingNow': 'Начинается сейчас!', 'status.ended': 'ЗАВЕРШЕНО', 'status.thumbnailReady': 'Готово', 'status.thumbnailFailed': 'Ошибка', 'status.uploadFailedRetry': 'Ошибка загрузки. Попробуйте снова.',
        'publish.video': 'Опубликовать видео', 'publish.autoThumbnail': 'Опубликовать видео (авто-миниатюра)',
        'report.titleComment': 'Пожаловаться на комментарий', 'report.titleUser': 'Пожаловаться на пользователя', 'report.titleVideo': 'Пожаловаться на видео', 'report.descComment': 'Выберите причину жалобы на комментарий:', 'report.descUser': 'Выберите причину жалобы на пользователя:', 'report.descVideo': 'Выберите причину жалобы на контент:',
        'empty.noMutedUsers': 'Нет заглушенных пользователей.', 'empty.noVideosToMonitor': 'Нет видео для мониторинга.', 'empty.noRecentActivity': 'Нет недавней активности.', 'empty.failedLoadNotifications': 'Не удалось загрузить уведомления', 'empty.loginToViewLiked': 'Пожалуйста <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">войдите</a>, чтобы увидеть понравившиеся видео.', 'empty.loginToViewFollowing': 'Пожалуйста <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">войдите</a>, чтобы увидеть подписки.', 'empty.loginToViewVideos': 'Пожалуйста <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">войдите</a>, чтобы увидеть ваши видео.', 'empty.loginToViewAnalytics': 'Пожалуйста <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">войдите</a>, чтобы увидеть статистику.', 'empty.noLikedVideosYet': 'Вы ещё не лайкнули ни одного видео.', 'empty.noLikedVideosFound': 'Понравившиеся видео не найдены.', 'empty.noFullLengthLikedVideos': 'Длинные понравившиеся видео не найдены.', 'empty.noWatchHistory': 'Нет истории. Начните смотреть видео.', 'empty.noVideosInHistory': 'Видео в истории не найдены.', 'empty.noFullLengthHistory': 'Длинные видео в истории не найдены.', 'empty.noMatchingVideos': 'Подходящие видео не найдены.', 'empty.noFullLengthVideos': 'Длинные видео не найдены.', 'empty.failedLoadTrending': 'Не удалось загрузить тренды.', 'empty.noTrendingVideos': 'Трендовые видео не найдены.', 'empty.noMatchingUsers': 'Подходящие пользователи не найдены.', 'empty.unableLoadProfiles': 'Не удалось загрузить профили.', 'empty.noFollowingVideos': 'Пока нет видео от подписок.', 'empty.noFullLengthFollowing': 'Нет длинных видео от подписок.', 'empty.failedLoadFollowing': 'Не удалось загрузить. Попробуйте снова.', 'empty.noVideosUploadFirst': 'Нет видео. Загрузите первое видео!', 'empty.noFullLengthUploaded': 'Длинные видео не найдены.', 'empty.noMatchingLiveStreams': 'Подходящие трансляции не найдены.', 'empty.noMatchingShorts': 'Подходящие шортсы не найдены.', 'empty.noVideosForTag': 'Нет видео для этого тега.', 'empty.noFullLengthForTag': 'Нет длинных видео для этого тега.', 'empty.noUploadedVideos': 'Видео ещё не загружены.', 'empty.noVideosFound': 'Видео не найдены.', 'empty.failedLoadProfile': 'Не удалось загрузить профиль. Попробуйте снова.', 'empty.noComments': 'Пока нет комментариев. Будьте первым!', 'empty.failedLoadComments': 'Не удалось загрузить комментарии', 'empty.noLiveNow': 'Сейчас никто не в эфире. Будьте первым!',
        'error.videoNotFound': 'Видео не найдено.', 'error.contentNotAvailable': 'Этот контент недоступен.', 'error.invalidVideoData': 'Неверные данные видео.', 'error.videoNotAvailable': 'Видео недоступно. Файл мог быть удалён.', 'error.failedLoadVideo': 'Не удалось загрузить видео. Попробуйте снова.', 'error.failedLoadVideoShort': 'Не удалось загрузить. Файл мог быть удалён.', 'error.liveStreamNotFound': 'Трансляция не найдена.', 'error.invalidLiveStreamData': 'Неверные данные трансляции.', 'error.failedLoadLiveStream': 'Не удалось загрузить трансляцию.',
        // New Button & Action Labels
        'button.follow': 'Подписаться', 'button.unfollow': 'Отписаться', 'button.mute': 'Заглушить', 'button.unmute': 'Включить звук', 'button.muteUser': 'Заглушить пользователя', 'button.unmuteUser': 'Включить пользователя', 'button.confirm': 'Подтвердить', 'button.cancel': 'Отмена', 'button.close': 'Закрыть', 'button.boost': 'Продвинуть', 'button.zap': 'Zap', 'button.viewMore': 'Показать ещё', 'button.viewAnalytics': 'Статистика', 'button.backToMyVideos': 'Назад к Моим Видео', 'button.editDraft': 'Редактировать черновик', 'button.deleteDraft': 'Удалить черновик', 'button.editVideo': 'Редактировать видео', 'button.deleteVideo': 'Удалить видео', 'button.editShort': 'Редактировать short', 'button.deleteShort': 'Удалить short', 'button.editStream': 'Редактировать трансляцию', 'button.endStream': 'Завершить трансляцию', 'button.reset': 'Сбросить', 'button.download': 'Скачать', 'button.watchRecording': 'Смотреть запись', 'button.show': 'Показать', 'button.login': 'Войти', 'button.toggleChat': 'Переключить чат', 'button.blockVideo': 'Заблокировать видео', 'button.blockUser': 'Заблокировать пользователя', 'button.unblock': 'Разблокировать', 'button.removeFromHistory': 'Удалить из истории',
        // New Stats & Counts
        'stat.views': 'просмотров', 'stat.viewsCount': '{count} просмотров', 'stat.videos': 'видео', 'stat.video': 'видео', 'stat.followers': 'подписчиков', 'stat.follower': 'подписчик', 'stat.following': 'Подписки', 'stat.subscribers': 'подписчиков', 'stat.comments': 'Комментарии', 'stat.liveCount': '{count} в эфире', 'stat.percentOfGoal': '{percent}% от цели', 'stat.netGrowth': 'Чистый рост', 'stat.newFollowers': 'Новые подписчики', 'stat.unfollowed': 'Отписались', 'stat.lastUpdated': 'Обновлено: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'В ЭФИРЕ', 'badge.ended': 'ЗАВЕРШЕНО', 'badge.scheduled': 'ЗАПЛАНИРОВАНО', 'badge.warning': 'ПРЕДУПРЕЖДЕНИЕ', 'badge.communityWarning': 'ПРЕДУПРЕЖДЕНИЕ СООБЩЕСТВА', 'badge.verifiedNip05': 'NIP-05 подтверждён', 'badge.streamer': 'Стример', 'badge.clickToView': 'Нажмите для просмотра',
        // New Actions
        'action.report': 'Пожаловаться', 'action.reportComment': 'Пожаловаться на комментарий', 'action.reportVideo': 'Пожаловаться на видео', 'action.reportStream': 'Пожаловаться на трансляцию', 'action.like': 'Нравится', 'action.dislike': 'Не нравится', 'action.reply': 'Ответить',
        // New Placeholders
        'placeholder.searchHistory': 'Поиск в истории...', 'placeholder.searchUsers': 'Поиск пользователей...', 'placeholder.searchMyVideos': 'Поиск моих видео...', 'placeholder.eventId': 'Введите ID события (hex или nevent/note)', 'placeholder.pubkey': 'Введите pubkey (hex или npub)', 'placeholder.customAmount': 'Своя сумма', 'placeholder.chatEnded': 'Чат закрыт - трансляция завершена', 'placeholder.addComment': 'Добавить комментарий...', 'placeholder.setNewGoal': 'Установить новую цель (sats)',
        // New Video & Content
        'video.untitledVideo': 'Видео без названия', 'video.untitledShort': 'Short без названия', 'video.upNext': 'Далее', 'video.noVideosYet': 'Пока нет видео', 'video.noShortsYet': 'Пока нет shorts', 'video.noLiveStreamsYet': 'Пока нет трансляций', 'video.noBlockedVideos': 'Нет заблокированных видео', 'video.noBlockedUsers': 'Нет заблокированных пользователей',
        // New Stream Messages
        'stream.ended': 'Трансляция завершена. Чат закрыт.', 'stream.welcomeChat': 'Добро пожаловать в чат!', 'stream.goalReached': 'Цель достигнута!', 'stream.zapGoalReached': 'Цель zap достигнута! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Сообщение от заглушённого пользователя', 'muted.commentFromMutedUserHidden': 'Комментарий от заглушённого пользователя скрыт', 'muted.commentHidden': 'Комментарий скрыт ({packs})', 'muted.messageHidden': 'Сообщение скрыто ({packs})', 'muted.commentReportedByFollows': 'Комментарий отмечен людьми, на которых вы подписаны', 'muted.messageReportedByFollows': 'Сообщение отмечено людьми, на которых вы подписаны', 'muted.commentHeavilyDownvoted': 'Комментарий сильно минусован', 'muted.messageHeavilyDownvoted': 'Сообщение сильно минусовано',
        // New Admin & Lists
        'list.blockedVideos': 'Заблокированные видео', 'list.blockedUsers': 'Заблокированные пользователи',
        // New Alerts
        'alert.cameraNotSupported': 'Доступ к камере не поддерживается в этом браузере. Используйте современный браузер: Chrome, Firefox или Safari.', 'alert.noCameraFound': 'Камера не найдена. Подключите камеру или используйте загрузку файла.', 'alert.cameraAccessDenied': 'Доступ к камере запрещён. Разрешите камеру в настройках браузера.', 'alert.cameraInUse': 'Камера используется другим приложением. Закройте другие приложения.', 'alert.cameraUnableAccess': 'Не удаётся получить доступ к камере. Используйте загрузку файла.', 'alert.cameraUnableAccessWithError': 'Не удаётся получить доступ к камере: {error}\n\nИспользуйте загрузку файла.', 'alert.fillRequiredFields': 'Заполните все обязательные поля', 'alert.uploadThumbnail': 'Загрузите миниатюру для трансляции', 'alert.failedCreateStream': 'Не удалось создать трансляцию. Попробуйте снова.', 'alert.failedUpdateStream': 'Не удалось обновить. Попробуйте снова.', 'alert.streamNotFound': 'Трансляция не найдена', 'alert.canOnlyEditOwnStreams': 'Вы можете редактировать только свои трансляции', 'alert.invalidStreamData': 'Неверные данные трансляции', 'alert.enterValidGoalAmount': 'Введите правильную сумму цели', 'alert.canOnlyResetOwnGoals': 'Вы можете сбрасывать только свои цели', 'alert.streamEventNotFound': 'Событие трансляции не найдено', 'alert.failedResetZapGoal': 'Не удалось сбросить цель zap. Попробуйте снова.', 'alert.cannotBlockAdmin': 'Нельзя заблокировать админа', 'alert.analyticsLoadFailed': 'Не удалось загрузить статистику. Попробуйте снова.', 'alert.cannotReplaceShortWithVideo': 'Нельзя заменить Short обычным видео. Загрузите вертикальное видео (60 секунд или меньше).', 'alert.cannotReplaceVideoWithShort': 'Нельзя заменить видео на Short. Загрузите горизонтальное видео.', 'alert.shortsRequireVertical': 'Это видео горизонтальное. Shorts должны быть вертикальными. Используйте "Загрузить видео" для горизонтальных.',
        // New Zap Messages
        'zap.cannotZapYourself': 'Нельзя отправить zap себе', 'zap.cannotZapOwnContent': 'Нельзя отправить zap своему контенту', 'zap.cannotZapOwnComment': 'Нельзя отправить zap своему комментарию', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'Загрузка видео...', 'status.loading': 'Загрузка...', 'status.compressingProgress': 'Сжатие... {progress}%', 'status.uploadingProgress': 'Загрузка... {progress}%', 'status.uploadingServers': 'Загрузка... ({completed}/{total} серверов)', 'status.publishedSuccess': '{type} успешно опубликовано!',
        // New Warnings
        'warning.webmFormat': 'Примечание: Ваш браузер выводит формат WebM (может не работать на iOS). Для iOS используйте Chrome на Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Обновлено: Декабрь 2024',
        // DMCA Page
        'dmca.title': 'DMCA и Политика Контента',
        'dmca.lastUpdated': 'Последнее обновление: Декабрь 2024',
        'dmca.architectureTitle': 'Понимание Архитектуры Plebs',
        'dmca.architectureDesc': 'Plebs — это децентрализованный интерфейс видеоплатформы, который работает иначе, чем традиционные сервисы.',
        'dmca.architectureItem1': 'Plebs не размещает никакого видео- или изображенческого контента.',
        'dmca.architectureItem1Desc': 'Мы — клиент/интерфейс, который отображает контент, хранящийся в другом месте.',
        'dmca.architectureItem2': 'Все медиафайлы хранятся на независимых серверах Blossom.',
        'dmca.architectureItem3': 'Метаданные видео публикуются на релеях Nostr.',
        'dmca.architectureItem4': 'Plebs просто агрегирует и отображает этот распределённый контент.',
        'dmca.filingTitle': 'Подача Жалобы DMCA',
        'dmca.filingDesc': 'Поскольку Plebs не размещает контент, мы не можем напрямую удалять нарушающий материал.',
        'dmca.forVideoTitle': '1. Для Видео/Изображений',
        'dmca.forVideoDesc': 'Медиафайлы хранятся на серверах Blossom.',
        'dmca.forVideoItem1': 'Определите, какой сервер Blossom размещает контент',
        'dmca.forVideoItem2': 'Свяжитесь напрямую с оператором сервера Blossom',
        'dmca.forVideoItem3': 'Каждый сервер Blossom работает независимо',
        'dmca.forMetadataTitle': '2. Для Метаданных/Описаний',
        'dmca.forMetadataDesc': 'Если нарушающий контент находится в заголовке или описании:',
        'dmca.forMetadataItem1': 'Эта информация хранится на релеях Nostr',
        'dmca.forMetadataItem2': 'Свяжитесь с конкретными операторами релеев Nostr',
        'dmca.forMetadataItem3': 'Несколько релеев могут хранить одни и те же данные',
        'dmca.whatWeCanDoTitle': 'Что Может Сделать Plebs',
        'dmca.whatWeCanDoDesc': 'Хотя мы не размещаем контент, мы можем:',
        'dmca.whatWeCanDoItem1': 'Помочь вам определить, какие серверы размещают конкретный контент',
        'dmca.whatWeCanDoItem2': 'Добавить контент в локальный список блокировки',
        'dmca.whatWeCanDoItem3': 'Предоставить рекомендации по связи с соответствующими операторами',
        'dmca.toRequestAssistance': 'Для запроса помощи свяжитесь с нами с:',
        'dmca.assistanceItem1': 'URL или идентификатор нарушающего контента',
        'dmca.assistanceItem2': 'Доказательство вашего владения авторскими правами',
        'dmca.assistanceItem3': 'Описание защищённого произведения',
        'dmca.blossomOperatorsTitle': 'Операторы Серверов Blossom',
        'dmca.blossomOperatorsDesc': 'Если вы управляете сервером Blossom, вы несёте ответственность за обработку запросов DMCA.',
        'dmca.blossomOperatorsLink': 'Список известных серверов Blossom см. в документации.',
        'dmca.considerationsTitle': 'Важные Соображения',
        'dmca.considerationsItem1': 'Децентрализация:',
        'dmca.considerationsItem1Desc': 'Полное удаление контента может быть невозможным.',
        'dmca.considerationsItem2': 'Множественные Копии:',
        'dmca.considerationsItem2Desc': 'Контент может быть реплицирован на нескольких серверах.',
        'dmca.considerationsItem3': 'Сохранение Метаданных:',
        'dmca.considerationsItem3Desc': 'Метаданные могут сохраняться даже после удаления.',
        'dmca.considerationsItem4': 'Отсутствие Централизованного Контроля:',
        'dmca.considerationsItem4Desc': 'Ни одна организация не может удалить контент из всей сети.',
        'dmca.counterNotificationTitle': 'Встречное Уведомление',
        'dmca.counterNotificationDesc': 'Если вы считаете, что ваш контент был удалён по ошибке, свяжитесь с оператором сервера.',
        'dmca.contactTitle': 'Контакт',
        'dmca.contactDesc': 'По вопросам',
        'dmca.contactLink': 'свяжитесь с нами',
        // Admin Dashboard
        'admin.title': 'Панель Администратора',
        'admin.loading': 'Загрузка аналитики платформы...',
        'admin.platformOverview': 'Обзор Платформы',
        'admin.totalVideos': 'Всего Видео',
        'admin.videos7Days': 'Видео (7 дней)',
        'admin.videos30Days': 'Видео (30 дней)',
        'admin.uniqueCreators': 'Уникальные Создатели',
        'admin.likes30Days': 'Лайки (30 дней)',
        'admin.dislikes30Days': 'Дизлайки (30 дней)',
        'admin.monthlyActiveUsers': 'Активные Пользователи за Месяц',
        'admin.mauDesc': 'Уникальные пользователи, которые загрузили видео, отреагировали или прокомментировали (последние 6 месяцев)',
        'admin.boostRevenue': 'Доход от Буста (Последние 30 Дней)',
        'admin.totalBoostRevenue': 'Общий Доход от Буста',
        'admin.totalBoosts': 'Всего Бустов',
        'admin.blocklistManagement': 'Управление Списком Блокировки',
        'admin.blocklistDesc': 'Блокируйте конкретные видео или пользователей.',
        'admin.blockedVideos': 'Заблокированные Видео',
        'admin.blockedUsers': 'Заблокированные Пользователи',
        'admin.blockByEventId': 'Блокировать Видео по ID',
        'admin.blockByPubkey': 'Блокировать Пользователя по Pubkey',
        'admin.blockVideo': 'Блокировать Видео',
        'admin.blockUser': 'Блокировать Пользователя',
        'admin.noBlockedVideos': 'Нет заблокированных видео',
        'admin.noBlockedUsers': 'Нет заблокированных пользователей',
        'admin.unblock': 'Разблокировать',
        'admin.accessDenied': 'Доступ запрещён. Только администратор.',
        // Search/Trending/Channel/Buttons/Common
        'search.noVideosFound': 'Видео не найдено для "{query}".',
        'search.noFullLengthVideos': 'Полнометражные видео не найдены для "{query}".',
        'trending.noVideosToday': 'Сегодня нет популярных видео.',
        'trending.noVideosThisWeek': 'На этой неделе нет популярных видео.',
        'channel.video': 'видео',
        'channel.videos': 'видео',
        'channel.follower': 'подписчик',
        'channel.followers': 'подписчиков',
        'button.follow': 'Подписаться',
        'button.following': 'Подписан',
        'button.unfollow': 'Отписаться',
        'button.mute': 'Отключить звук',
        'button.unmute': 'Включить звук',
        'button.report': 'Пожаловаться',
        'button.muteUser': 'Заглушить пользователя',
        'button.unmuteUser': 'Разглушить пользователя',
        'button.reportComment': 'Пожаловаться на комментарий',
        'button.reportUser': 'Пожаловаться на пользователя',
        'live.goalReached': 'Цель Достигнута!',
        'live.goalProgress': '{percent}% от цели',
        'common.loading': 'Загрузка...',
        'common.sats': 'sats',
        // Analytics
        'analytics.title': 'Аналитика Канала',
        'analytics.loading': 'Загрузка аналитики...',
        'analytics.loadFailed': 'Не удалось загрузить аналитику. Попробуйте снова.',
        'analytics.overview': 'Обзор',
        'analytics.views': 'Просмотры',
        'analytics.followers': 'Подписчики',
        'analytics.topByViews': 'Топ Видео по Просмотрам',
        'analytics.topByEngagement': 'Топ Видео по Вовлечённости',
        'analytics.allContent': 'Производительность Всего Контента',
        'analytics.totalViews': 'Всего Просмотров',
        'analytics.likes': 'Лайки',
        'analytics.likesRatio': 'Лайки ({ratio}% соотношение)',
        'analytics.dislikes': 'Дизлайки',
        'analytics.zapsReceived': '{count} Zaps Получено',
        'analytics.boostsReceived': 'Boosts Получено',
        'analytics.shares': 'Поделились',
        'analytics.comments': 'Комментарии',
        'analytics.contentCount': '{videos} Видео, {shorts} Shorts, {streams} Стримов',
        'analytics.last7days': 'Последние 7 дней',
        'analytics.last30days': 'Последние 30 дней',
        'analytics.last90days': 'Последние 90 дней',
        'analytics.lastYear': 'Последний год',
        'analytics.allTime': 'За всё время',
        'analytics.lastNDays': 'Последние {n} дней',
        'analytics.netGrowth': 'Чистый Прирост',
        'analytics.newFollowers': 'Новые Подписчики',
        'analytics.unfollowed': 'Отписались',
        'analytics.noVideosYet': 'Пока нет видео',
        'analytics.noShortsYet': 'Пока нет shorts',
        'analytics.noStreamsYet': 'Пока нет стримов',
        'analytics.viewsTooltip': '{count} просмотров',
        'analytics.subscribersTooltip': '{count} подписчиков',
        'analytics.videosTab': 'Видео ({count})',
        'analytics.shortsTab': 'Shorts ({count})',
        'analytics.streamsTab': 'Стримы ({count})',
        // About
        'about.title': 'О Plebs',
        'about.whatIs': 'Что такое Plebs?',
        'about.whatIsDesc': 'Plebs — это децентрализованная платформа видео, устойчивая к цензуре, построенная на <a href="https://nostr.com" target="_blank" rel="noopener">протоколе Nostr</a>. В отличие от традиционных видеоплатформ, контролируемых корпорациями, Plebs даёт вам истинное владение вашим контентом и личностью.',
        'about.whyNostr': 'Почему Nostr?',
        'about.whyNostrDesc': 'Nostr (Notes and Other Stuff Transmitted by Relays) — это простой, открытый протокол, который обеспечивает действительно децентрализованную социальную сеть. Ключевые преимущества включают:',
        'about.benefit1': 'Устойчивость к Цензуре:',
        'about.benefit1Desc': 'Ни одна организация не может забанить вас или удалить ваш контент',
        'about.benefit2': 'Портативность:',
        'about.benefit2Desc': 'Ваша личность и подписчики работают во всех приложениях Nostr',
        'about.benefit3': 'Нет Центральной Власти:',
        'about.benefit3Desc': 'Ни одна компания не владеет и не контролирует сеть',
        'about.benefit4': 'Криптографическая Личность:',
        'about.benefit4Desc': 'Ваши ключи доказывают, что вы — это вы',
        'about.howItWorks': 'Как Это Работает',
        'about.howItWorksDesc': 'Видео на Plebs хранятся с использованием <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom</a>, распределённой системы хранения файлов, в то время как метаданные видео и социальные взаимодействия транслируются на релеи Nostr. Это означает, что ваш контент не хранится на наших серверах — он распределён по сети.',
        'about.features': 'Возможности',
        'about.feature1': 'Загружайте и делитесь видео с сообществом Nostr',
        'about.feature2': 'Ставьте лайки, комментируйте и делитесь видео, используя реакции Nostr',
        'about.feature3': 'Отправляйте Zaps создателям с помощью Bitcoin через Lightning Network',
        'about.feature4': 'Подписывайтесь на любимых создателей в любом приложении Nostr',
        'about.feature5': 'Просматривайте темы и открывайте новый контент',
        'about.feature6': 'Работает с любой личностью Nostr (используйте существующие ключи)',
        'about.openSource': 'Открытый Исходный Код',
        'about.openSourceDesc': 'Plebs — это программное обеспечение с открытым исходным кодом. Вы можете просмотреть код, внести свой вклад или запустить собственный экземпляр:',
        'about.githubRepo': 'Репозиторий GitHub',
        'about.builtBy': 'Создано',
        'about.builtByDesc': 'Plebs разработан <a href="https://nostrservices.com" target="_blank" rel="noopener" class="accent-link">21 Million LLC</a>, компанией, посвящённой созданию инструментов для экосистемы Bitcoin и Nostr.',
        // Contact
        'contact.title': 'Связаться с Нами',
        'contact.getInTouch': 'Связаться',
        'contact.getInTouchDesc': 'Есть вопросы, отзывы или нужна поддержка? Мы будем рады услышать вас!',
        'contact.email': 'Электронная Почта',
        'contact.emailDesc': 'Лучший способ связаться с нами — через электронную почту:',
        'contact.github': 'GitHub',
        'contact.githubDesc': 'Для сообщений об ошибках, запросов функций или технических проблем, пожалуйста, откройте issue в нашем репозитории GitHub:',
        'contact.githubIssues': 'GitHub Issues',
        'contact.company': 'Компания',
        'contact.companyDesc': 'Plebs разработан 21 Million LLC',
        // Terms
        'terms.title': 'Условия Использования',
        'terms.lastUpdated': 'Последнее обновление: Декабрь 2024',
        'terms.section1Title': '1. Принятие Условий',
        'terms.section1Desc': 'Получая доступ и используя Plebs ("Сервис"), вы соглашаетесь соблюдать эти Условия Использования. Если вы не согласны с этими условиями, пожалуйста, не используйте Сервис.',
        'terms.section2Title': '2. Описание Сервиса',
        'terms.section2Desc': 'Plebs — это децентрализованная видеоплатформа, построенная на протоколе Nostr. Сервис предоставляет интерфейс для просмотра, загрузки и взаимодействия с видеоконтентом, хранящимся в распределённых сетях. Plebs не размещает и не хранит видеоконтент на централизованных серверах.',
        'terms.section3Title': '3. Обязанности Пользователя',
        'terms.section3Desc': 'Вы несёте ответственность за:',
        'terms.section3Item1': 'Обеспечение безопасности ваших приватных ключей Nostr',
        'terms.section3Item2': 'Весь контент, который вы загружаете или делитесь через Сервис',
        'terms.section3Item3': 'Обеспечение соответствия вашего использования применимым законам',
        'terms.section3Item4': 'Не загружать незаконный, нарушающий права или вредный контент',
        'terms.section4Title': '4. Руководство по Контенту',
        'terms.section4Desc': 'Вы соглашаетесь не загружать, не делиться и не распространять:',
        'terms.section4Item1': 'Контент, нарушающий права интеллектуальной собственности',
        'terms.section4Item2': 'Незаконный контент, включая, но не ограничиваясь материалами эксплуатации детей',
        'terms.section4Item3': 'Контент, пропагандирующий насилие или вред другим',
        'terms.section4Item4': 'Спам, вредоносное ПО или обманчивый контент',
        'terms.section4Note': 'Контент для взрослых (NSFW) должен быть правильно помечен тегом NSFW при загрузке.',
        'terms.section5Title': '5. Децентрализованная Природа',
        'terms.section5Desc': 'Из-за децентрализованной природы Nostr и хранилища Blossom:',
        'terms.section5Item1': 'Контент может сохраняться в сети даже после запросов на удаление',
        'terms.section5Item2': 'Мы не можем гарантировать удаление контента со всех релеев или серверов хранения',
        'terms.section5Item3': 'Ваш контент и взаимодействия являются публичными по умолчанию',
        'terms.section5Item4': 'Вы несёте единоличную ответственность за безопасность вашего приватного ключа',
        'terms.section6Title': '6. Отсутствие Гарантий',
        'terms.section6Desc': 'Сервис предоставляется "как есть" без каких-либо гарантий. Мы не гарантируем непрерывный, бесперебойный доступ к Сервису.',
        'terms.section7Title': '7. Ограничение Ответственности',
        'terms.section7Desc': 'В максимальной степени, разрешённой законом, Plebs и его операторы не несут ответственности за любые косвенные, случайные, особые или последующие убытки, возникающие в результате вашего использования Сервиса.',
        'terms.section8Title': '8. Изменения Условий',
        'terms.section8Desc': 'Мы оставляем за собой право изменять эти условия в любое время. Продолжение использования Сервиса после изменений означает принятие новых условий.',
        'terms.section9Title': '9. Контакт',
        'terms.section9Desc': 'По вопросам об этих Условиях, пожалуйста, <a href="#/contact" class="accent-link">свяжитесь с нами</a>.',
        // Privacy
        'privacy.title': 'Политика Конфиденциальности',
        'privacy.lastUpdated': 'Последнее обновление: Декабрь 2024',
        'privacy.section1Title': '1. Обзор',
        'privacy.section1Desc': 'Plebs привержен защите вашей конфиденциальности. Эта политика объясняет, как мы обрабатываем информацию при использовании нашей децентрализованной видеоплатформы.',
        'privacy.section2Title': '2. Децентрализованная Архитектура',
        'privacy.section2Desc': 'Plebs построен на Nostr, децентрализованном протоколе. Это означает:',
        'privacy.section2Item1': 'Ваш контент транслируется на публичные релеи, а не хранится на наших серверах',
        'privacy.section2Item2': 'Ваш публичный ключ Nostr служит вашей личностью',
        'privacy.section2Item3': 'Видео хранятся на распределённых серверах Blossom',
        'privacy.section2Item4': 'У нас нет доступа к вашим приватным ключам',
        'privacy.section3Title': '3. Информация, Которую Мы Собираем',
        'privacy.section3LocalTitle': 'Информация, хранящаяся локально в вашем браузере:',
        'privacy.section3LocalItem1': 'Ваш публичный ключ Nostr (при входе в систему)',
        'privacy.section3LocalItem2': 'История просмотров и предпочтения',
        'privacy.section3LocalItem3': 'Предпочтения темы и настроек',
        'privacy.section3LocalItem4': 'Приватный ключ (только если вы выбираете локальное хранилище ключей - не рекомендуется)',
        'privacy.section3CollectTitle': 'Информация, которую мы можем собирать:',
        'privacy.section3CollectItem1': 'Базовая аналитика (просмотры страниц, использование функций) для улучшения сервиса',
        'privacy.section3CollectItem2': 'Журналы ошибок для отладки',
        'privacy.section4Title': '4. Публичная Информация',
        'privacy.section4Desc': 'При использовании Nostr следующая информация является публичной по умолчанию:',
        'privacy.section4Item1': 'Ваш публичный ключ Nostr и информация профиля',
        'privacy.section4Item2': 'Видео, которые вы загружаете',
        'privacy.section4Item3': 'Комментарии, лайки и другие реакции',
        'privacy.section4Item4': 'На кого вы подписаны',
        'privacy.section4Item5': 'Zaps (платежи Lightning), которые вы отправляете или получаете',
        'privacy.section5Title': '5. Хранение Данных',
        'privacy.section5Desc': 'Локальные данные хранятся в localStorage вашего браузера. Вы можете очистить эти данные в любое время через настройки браузера. Контент, опубликованный в Nostr, распределяется по релеям и не может контролироваться или удаляться Plebs.',
        'privacy.section6Title': '6. Сторонние Сервисы',
        'privacy.section6Desc': 'Plebs взаимодействует с:',
        'privacy.section6Item1': 'Релеями Nostr (для социальных данных)',
        'privacy.section6Item2': 'Серверами Blossom (для хранения видео)',
        'privacy.section6Item3': 'Lightning Network (для zaps/платежей)',
        'privacy.section6Note': 'Каждый из этих сервисов имеет свои собственные практики конфиденциальности.',
        'privacy.section7Title': '7. Ваши Права',
        'privacy.section7Desc': 'Вы можете:',
        'privacy.section7Item1': 'Очистить локальные данные браузера в любое время',
        'privacy.section7Item2': 'Просматривать видео без создания учётной записи',
        'privacy.section7Item3': 'Использовать расширение браузера Nostr для повышенной конфиденциальности',
        'privacy.section7Item4': 'Выбирать, какие релеи и серверы Blossom использовать',
        'privacy.section8Title': '8. Безопасность',
        'privacy.section8Desc': 'Мы рекомендуем:',
        'privacy.section8Item1': 'Использовать расширение браузера Nostr или аппаратный подписант',
        'privacy.section8Item2': 'Никогда не делиться вашим приватным ключом (nsec)',
        'privacy.section8Item3': 'Использовать выделенный профиль браузера для повышенной конфиденциальности',
        'privacy.section9Title': '9. Изменения в Этой Политике',
        'privacy.section9Desc': 'Мы можем обновлять эту политику время от времени. Изменения будут опубликованы на этой странице с обновлённой датой редакции.',
        'privacy.section10Title': '10. Контакт',
        'privacy.section10Desc': 'По вопросам, связанным с конфиденциальностью, пожалуйста, <a href="#/contact" class="accent-link">свяжитесь с нами</a>.',
        // FAQ
        'faq.title': 'Часто Задаваемые Вопросы',
        'faq.aboutPlebs': 'О Plebs',
        'faq.nostrProtocol': 'Протокол Nostr',
        'faq.videoStorage': 'Хранение Видео и Blossom',
        'faq.featuresUsage': 'Функции и Использование',
        'faq.q1': 'Что такое Plebs?',
        'faq.a1': 'Plebs — это децентрализованная платформа видео, устойчивая к цензуре, построенная на протоколе Nostr. В отличие от традиционных видеоплатформ, контролируемых корпорациями, Plebs даёт вам истинное владение вашим контентом и личностью. Нет центральных серверов, которые могут забанить вас или удалить ваш контент.',
        'faq.q2': 'Бесплатен ли Plebs?',
        'faq.a2': 'Да, Plebs полностью бесплатен для просмотра видео. Вы можете просматривать и смотреть контент без создания учётной записи. Для загрузки видео, комментирования, лайков или взаимодействия с другими пользователями вам понадобится личность Nostr (которая также бесплатна).',
        'faq.q3': 'Кто разрабатывает Plebs?',
        'faq.a3': 'Plebs разработан <a href="https://nostrservices.com" target="_blank" rel="noopener">21 Million LLC</a>, компанией, посвящённой созданию инструментов для экосистемы Bitcoin и Nostr. Plebs имеет открытый исходный код, и вы можете просмотреть код или внести свой вклад на <a href="https://github.com/Spl0itable/plebs-app" target="_blank" rel="noopener">GitHub</a>.',
        'faq.q4': 'Что такое Nostr?',
        'faq.a4': 'Nostr означает "Notes and Other Stuff Transmitted by Relays." Это простой, открытый протокол, который обеспечивает действительно децентрализованную социальную сеть. В отличие от традиционных платформ, Nostr не полагается на какой-либо центральный сервер. Вместо этого он использует сеть релеев для передачи сообщений между пользователями и криптографические ключи для идентификации.',
        'faq.q5': 'Почему Plebs использует Nostr?',
        'faq.a5Title': 'Nostr предоставляет несколько ключевых преимуществ:',
        'faq.a5Item1': 'Устойчивость к Цензуре:',
        'faq.a5Item1Desc': 'Ни одна организация не может забанить вас или удалить ваш контент',
        'faq.a5Item2': 'Портативность:',
        'faq.a5Item2Desc': 'Ваша личность и подписчики работают во всех приложениях Nostr',
        'faq.a5Item3': 'Нет Центральной Власти:',
        'faq.a5Item3Desc': 'Ни одна компания не владеет и не контролирует сеть',
        'faq.a5Item4': 'Криптографическая Личность:',
        'faq.a5Item4Desc': 'Ваши ключи доказывают, что вы — это вы',
        'faq.q6': 'Что такое ключи Nostr (npub/nsec)?',
        'faq.a6': 'Ваша личность Nostr состоит из двух ключей: публичного ключа (npub) и приватного ключа (nsec). Ваш npub похож на ваше имя пользователя — вы можете делиться им с кем угодно. Ваш nsec похож на ваш пароль — никогда не делитесь им! Любой, у кого есть ваш nsec, может публиковать от вашего имени и получать доступ к вашей учётной записи. Мы рекомендуем использовать расширение браузера, такое как Alby или nos2x, для безопасного управления вашими ключами.',
        'faq.q7': 'Могу ли я использовать свою существующую учётную запись Nostr?',
        'faq.a7': 'Абсолютно! Если у вас уже есть личность Nostr из приложений, таких как Damus, Primal, Amethyst или любого другого клиента Nostr, вы можете использовать те же ключи для входа в Plebs. Ваши подписчики, профиль и репутация переносятся автоматически.',
        'faq.q8': 'Что такое релеи Nostr?',
        'faq.a8': 'Релеи — это серверы, которые хранят и передают сообщения Nostr. Когда вы публикуете что-то, оно отправляется на несколько релеев. Другие пользователи подключаются к релеям для чтения сообщений. Поскольку существует множество независимых релеев, ни один из них не может подвергнуть вас цензуре — если один релей блокирует вас, ваш контент всё ещё существует на других.',
        'faq.q9': 'Где хранятся видео?',
        'faq.a9': 'Видео хранятся на серверах Blossom, а не на самом Plebs. Blossom — это распределённая система хранения файлов, разработанная для работы с Nostr. Когда вы загружаете видео, оно попадает на один или несколько серверов Blossom по вашему выбору. Метаданные видео (название, описание и т.д.) публикуются на релеях Nostr.',
        'faq.q10': 'Что такое Blossom?',
        'faq.a10': 'Blossom — это открытый протокол для хранения и обслуживания медиафайлов децентрализованным способом. Файлы идентифицируются по их хешу SHA-256, что означает, что один и тот же файл будет иметь один и тот же адрес независимо от того, какой сервер его размещает. Это обеспечивает избыточность — ваши файлы могут существовать на нескольких серверах. Узнайте больше на <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom GitHub</a>.',
        'faq.q11': 'Размещает ли Plebs мои видео?',
        'faq.a11': 'Нет. Plebs — это клиент/интерфейс, который помогает вам просматривать и загружать контент, но он не хранит никаких видео- или изображений. Все медиа хранятся на независимых серверах Blossom. Plebs просто отображает контент от этих распределённых провайдеров хранилища.',
        'faq.q12': 'Могу ли я выбрать, какой сервер Blossom использовать?',
        'faq.a12': 'Да! Вы можете настроить, какие серверы Blossom вы хотите использовать для загрузки в своих настройках. Вы даже можете запустить свой собственный сервер Blossom, если хотите полный контроль над хранением ваших медиа.',
        'faq.q13': 'Как создать учётную запись?',
        'faq.a13Title': 'Нажмите кнопку "Войти" и выберите предпочитаемый метод:',
        'faq.a13Item1': 'Расширение Браузера:',
        'faq.a13Item1Desc': 'Если у вас установлено расширение Nostr, такое как Alby или nos2x, вы можете использовать его для безопасного входа',
        'faq.a13Item2': 'Сгенерировать Новые Ключи:',
        'faq.a13Item2Desc': 'Создайте совершенно новую личность Nostr',
        'faq.a13Item3': 'Импортировать Ключи:',
        'faq.a13Item3Desc': 'Используйте свой существующий приватный ключ Nostr (nsec)',
        'faq.a13Note': 'Мы рекомендуем использовать расширение браузера для лучшей безопасности.',
        'faq.q14': 'Что такое Zaps?',
        'faq.a14': 'Zaps — это платежи в Bitcoin, отправленные через Lightning Network. Они позволяют отправлять реальные деньги (сатоши, или "sats") создателям контента в качестве чаевых или благодарности. В отличие от традиционных чаевых на платформах, которые берут большие комиссии, zaps идут напрямую создателю. Для отправки zaps вам нужен кошелёк Lightning с подключением Nostr (например, Alby или Zeus).',
        'faq.q15': 'Как загрузить видео?',
        'faq.a15Title': 'Чтобы загрузить видео:',
        'faq.a15Item1': 'Войдите с вашей личностью Nostr',
        'faq.a15Item2': 'Нажмите кнопку "Создать" и выберите "Загрузить Видео"',
        'faq.a15Item3': 'Выберите ваш видеофайл (поддерживает большинство распространённых форматов)',
        'faq.a15Item4': 'Добавьте название, описание и теги',
        'faq.a15Item5': 'Нажмите "Опубликовать", чтобы поделиться с сетью',
        'faq.a15Note': 'Видео автоматически сжимаются и загружаются на серверы Blossom.',
        // FAQ Self-Moderation Section
        'faq.selfModeration': 'Самомодерация',
        'faq.q16': 'Как работает модерация на децентрализованной платформе?',
        'faq.a16': 'В отличие от традиционных платформ с централизованными модераторами, Plebs даёт вам контроль над тем, что вы видите. Мы предоставляем мощные инструменты самомодерации, включая пакеты фильтров контента, отключение пользователей, предупреждения сообщества и индикаторы видео с негативным соотношением. Вы решаете, какой контент для вас приемлем - нет центральной власти, принимающей эти решения.',
        'faq.q17': 'Что такое Пакеты Фильтров Контента?',
        'faq.a17Intro': 'Пакеты Фильтров Контента - это предопределённые фильтры ключевых слов, которые вы можете включить, чтобы скрыть определённые типы контента. Доступные пакеты включают:',
        'faq.a17Pack1': 'Расизм и разжигание ненависти:',
        'faq.a17Pack1Desc': 'Фильтрует расовые оскорбления и дискриминационный контент',
        'faq.a17Pack2': 'Откровенно сексуальное:',
        'faq.a17Pack2Desc': 'Фильтрует порнографический и взрослый контент',
        'faq.a17Pack3': 'Насилие и жестокость:',
        'faq.a17Pack3Desc': 'Фильтрует графическое насилие и контент с самоповреждением',
        'faq.a17Pack4': 'Наркотики и вещества:',
        'faq.a17Pack4Desc': 'Фильтрует контент, связанный с наркотиками',
        'faq.a17Pack5': 'Спам и мошенничество:',
        'faq.a17Pack5Desc': 'Фильтрует распространённые паттерны спама и мошенничества',
        'faq.a17Pack6': 'Криптовалюта:',
        'faq.a17Pack6Desc': 'Фильтрует продвижение криптовалюты и токенов',
        'faq.a17Pack7': 'Политический контент:',
        'faq.a17Pack7Desc': 'Фильтрует партийный политический контент',
        'faq.a17Pack8': 'Грубая ненормативная лексика:',
        'faq.a17Pack8Desc': 'Фильтрует вульгарную лексику',
        'faq.a17Note': 'Включите их в Настройки > Фильтры Контента. Вы также можете добавить свои ключевые слова. Отфильтрованный контент показывает заполнитель с кнопкой "Всё равно показать", если вы хотите временно его просмотреть.',
        'faq.q18': 'Как отключить пользователя?',
        'faq.a18': 'Чтобы отключить пользователя, посетите его профиль и нажмите кнопку отключения. После отключения все его видео будут скрыты из вашей ленты, его комментарии будут показаны как "Сообщение от отключённого пользователя", а его сообщения в чате будут скрыты. Ваш список отключённых хранится в Nostr, поэтому синхронизируется между устройствами. Вы можете управлять отключёнными пользователями в Настройках Профиля в разделе "Отключённые пользователи".',
        'faq.q19': 'Что означает "Ratioed"?',
        'faq.a19': 'Видео помечается как "ratioed", когда у него значительно больше дизлайков, чем лайков, что указывает на негативную реакцию сообщества. Конкретно, видео считается ratioed, когда у него есть как минимум 10 реакций, дизлайков как минимум в два раза больше лайков, и дизлайки составляют 70% или более от общего числа реакций. Видео с ratioed отображают значок предупреждения, и вас попросят подтвердить перед просмотром.',
        'faq.q20': 'Как работают предупреждения сообщества?',
        'faq.a20': 'Пользователи могут сообщать о контенте по разным причинам (спам, незаконный контент, оскорбления, вводящий в заблуждение и т.д.). Когда видео или пользователь получает 5 или более жалоб от людей, на которых вы подписаны, появляется индикатор предупреждения. Это использует ваш социальный граф - предупреждения приходят от вашей доверенной сети, а не от анонимных незнакомцев. Вы можете переключить "Показывать предупреждения от аккаунтов, на которые я подписан" в Настройках.',
        'faq.q21': 'Как пожаловаться на контент?',
        'faq.a21': 'Нажмите значок флага на любом видео, комментарии или профиле пользователя, чтобы пожаловаться на него. Выберите причину (Спам, Незаконный, Оскорбление, Вводящий в заблуждение, Выдача себя за другого, Авторское право или Другое) и при желании добавьте подробности. Жалобы публикуются в Nostr как события, делая их прозрачными и децентрализованными. Ваши жалобы помогают другим в вашей сети идентифицировать проблемный контент.',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': 'Конфиденциальность и Безопасность',
        'faq.q22': 'Является ли моя активность приватной?',
        'faq.a22': 'В Nostr большая часть активности является публичной по дизайну. Ваши лайки, комментарии, подписки и зап видны в публичной сети. Однако Plebs хранит вашу историю просмотров локально в вашем браузере - она никогда не отправляется на какой-либо сервер. Вы можете очистить свои локальные данные в любое время.',
        'faq.q23': 'Как сохранить мой аккаунт в безопасности?',
        'faq.a23': 'Никогда не делитесь своим приватным ключом (nsec) ни с кем. Мы настоятельно рекомендуем использовать расширение для браузера Nostr, такое как Alby, nos2x или аппаратный подписчик. Они хранят ваш приватный ключ в безопасности и подписывают события только когда вы их одобряете. Избегайте хранения вашего nsec непосредственно на веб-сайтах.',
        'faq.q24': 'Могу ли я удалить свой контент?',
        'faq.a24': 'Вы можете запросить удаление, опубликовав событие удаления в Nostr. Большинство хорошо себя ведущих релеев и клиентов будут это уважать. Однако из-за децентрализованной природы сети контент может сохраниться на некоторых релеях или серверах Blossom. Нет центральной власти, которая могла бы принудительно удалить контент во всей сети.',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': 'Устранение неполадок',
        'faq.q25': 'Видео не загружаются - что делать?',
        'faq.a25Intro': 'Если видео не загружаются, попробуйте эти шаги:',
        'faq.a25Item1': 'Обновите страницу',
        'faq.a25Item2': 'Проверьте ваше интернет-соединение',
        'faq.a25Item3': 'Сервер Blossom, хостящий видео, может быть недоступен - это независимо от Plebs',
        'faq.a25Item4': 'Попробуйте отключить расширения браузера, которые могут блокировать контент',
        'faq.a25Item5': 'Очистите кеш браузера и попробуйте снова',
        'faq.q26': 'Я потерял свой приватный ключ - можете помочь мне восстановить его?',
        'faq.a26': 'К сожалению, нет. Ключи Nostr криптографические - нет сброса пароля или восстановления аккаунта, потому что нет центральной власти. Вот почему мы настоятельно рекомендуем делать резервные копии ваших ключей и использовать безопасное решение для управления ключами. Если вы потеряете свой nsec, вам нужно будет создать новую личность.',
        'faq.q27': 'Как сообщить об ошибке или запросить функцию?',
        'faq.a27': 'Вы можете сообщить об ошибках или запросить функции на нашей странице <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a>. Вы также можете связаться с нами в Nostr - посетите нашу страницу <a href="#/contact">Контакты</a> для подробностей.',
        // Page Titles
        'pageTitle.following': 'Подписки',
        'pageTitle.myVideos': 'Мои Видео',
        'pageTitle.likedVideos': 'Понравившиеся Видео',
        'pageTitle.watchHistory': 'История Просмотров',
        'pageTitle.liveStreams': 'Прямые Трансляции',
        'pageTitle.suffix': '- Plebs',
        'pageTitle.liveSuffix': '- Прямой эфир на Plebs',
        // Home Page Sections
        'section.trending': 'В тренде',
        'section.recommended': 'Рекомендовано для вас',
        'section.shorts': 'Shorts',
        'section.live': 'Прямой эфир',
        'section.liveNow': 'Прямой эфир сейчас',
        'section.latestVideos': 'Последние видео',
        'section.videos': 'Видео',
        'section.usersYouFollow': 'Пользователи, на которых вы подписаны',
        // Trending Period
        'trending.thisWeek': 'На этой неделе',
        'trending.today': 'Сегодня',
        // Buttons
        'button.viewMore': 'Посмотреть больше',
        'button.clearAll': 'Очистить всё',
        'button.showAnyway': 'Показать в любом случае',
        // Confirmation Modals
        'confirm.logout': 'Выход',
        'confirm.logoutMessage': 'Вы уверены, что хотите выйти?',
        'confirm.resetSettings': 'Сбросить настройки',
        'confirm.resetSettingsMessage': 'Вы уверены, что хотите сбросить все настройки до значений по умолчанию?',
        'confirm.reset': 'Сбросить',
        'confirm.clearHistory': 'Очистить историю',
        'confirm.clearHistoryMessage': 'Вы уверены, что хотите очистить всю историю просмотров? Это действие нельзя отменить.',
        'confirm.deleteDraft': 'Удалить черновик',
        'confirm.deleteDraftMessage': 'Вы уверены, что хотите удалить этот черновик?',
        'confirm.delete': 'Удалить',
        'confirm.deleteVideo': 'Удалить видео',
        'confirm.deleteVideoMessage': 'Вы уверены, что хотите удалить это видео? Это действие нельзя отменить.',
        'confirm.endStream': 'Завершить прямую трансляцию',
        'confirm.endStreamMessage': 'Вы уверены, что хотите завершить эту прямую трансляцию? Это действие нельзя отменить.',
        'confirm.endStreamButton': 'Завершить трансляцию',
        // Content Filters
        'filter.hiddenByPack': 'Скрыто {pack}',
        'filter.showAnyway': 'Показать в любом случае',
        'filter.contentHidden': 'Контент скрыт фильтром контента',
        // Filter Packs
        'filter.racism': 'Расизм и разжигание ненависти', 'filter.racismDesc': 'Фильтрует расовые оскорбления, этническую ненависть и дискриминационный контент', 'filter.sexualExplicit': 'Сексуально откровенный', 'filter.sexualExplicitDesc': 'Фильтрует порнографические термины и сексуально откровенный контент', 'filter.violence': 'Насилие и жестокость', 'filter.violenceDesc': 'Фильтрует графическое насилие, жестокость и угрозы насилия', 'filter.drugs': 'Наркотики и вещества', 'filter.drugsDesc': 'Фильтрует контент, связанный с наркотиками и злоупотреблением веществами', 'filter.spam': 'Спам и мошенничество', 'filter.spamDesc': 'Фильтрует распространённый спам, мошенничество и рекламный контент', 'filter.crypto': 'Криптовалюта', 'filter.cryptoDesc': 'Фильтрует продвижение криптовалют, торговые сигналы и продвижение токенов', 'filter.politics': 'Политический контент', 'filter.politicsDesc': 'Фильтрует партийный политический контент и разделяющую риторику', 'filter.profanity': 'Сильная ненормативная лексика', 'filter.profanityDesc': 'Фильтрует грубую ненормативную лексику и вульгарный язык', 'filter.customFilter': 'Пользовательский фильтр',
        // Following Page
        'following.noFollowingYet': 'Вы пока ни на кого не подписаны. Найдите авторов, на которых можно подписаться!',
    },
    zh: {
        // Navigation & Header
        'nav.home': '首页', 'nav.following': '关注', 'nav.myVideos': '我的视频', 'nav.liked': '已赞', 'nav.history': '历史记录', 'nav.topics': '话题', 'nav.live': '直播', 'nav.bitcoin': '比特币', 'nav.nostr': 'Nostr', 'nav.technology': '科技', 'nav.gaming': '游戏', 'nav.tutorials': '教程', 'nav.podcasts': '播客', 'nav.music': '音乐', 'nav.nsfw': 'NSFW', 'nav.about': '关于', 'nav.contact': '联系', 'nav.terms': '条款', 'nav.privacy': '隐私', 'nav.faq': '常见问题', 'nav.dmca': 'DMCA', 'nav.liveStreams': '直播', 'nav.github': 'GitHub',
        'header.search': '搜索视频...', 'header.notifications': '通知', 'header.settings': '设置', 'header.create': '创建', 'header.viewProfile': '查看主页', 'header.logout': '登出',
        // Login Modal
        'login.title': '使用 Nostr 登录', 'login.extensionButton': '使用 Nostr 扩展登录', 'login.extensionDesc': '使用签名扩展 (Alby, nos2x 等)', 'login.orDivider': '或', 'login.nsecLabel': '使用私钥登录 (nsec)', 'login.nsecPlaceholder': '输入您的 nsec...', 'login.nsecButton': '使用 nsec 登录', 'login.nsecWarning': '警告：直接输入 nsec 不如使用扩展安全。请考虑使用 NIP-07 扩展以获得更好的安全性。', 'login.newToNostr': 'Nostr 新手？', 'login.createAccount': '创建账户', 'login.learnMore': '了解更多关于 Nostr',
        // Connect Modal
        'connect.title': '连接到 Nostr', 'connect.or': '或', 'connect.extensionButton': '连接 Nostr 扩展', 'connect.extensionDesc': '使用扩展 (Alby, nos2x 等)', 'connect.nsecLabel': '使用私钥登录', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': '使用 nsec 连接', 'connect.nsecWarning': '警告：直接输入 nsec 安全性较低。请使用 NIP-07 扩展以获得更好的安全性。', 'connect.newToNostr': 'Nostr 新手？', 'connect.createAccount': '创建账户',
        // Private Key Modal
        'privateKey.title': '您的私钥', 'privateKey.warning': '重要：请将此保存在安全的地方。如果您丢失此密钥，您将失去对账户的访问权限。切勿与任何人分享！', 'privateKey.show': '显示私钥', 'privateKey.hide': '隐藏私钥', 'privateKey.copy': '复制', 'privateKey.saved': '我已保存我的密钥', 'privateKey.yourPublicKey': '您的公钥 (npub)：', 'privateKey.yourPrivateKey': '您的私钥 (nsec)：',
        // Signup Modal
        'signup.title': '创建 Nostr 账户', 'signup.whatIsNostr': '什么是 Nostr？', 'signup.nostrDescription': 'Nostr 是一个去中心化协议，让您掌控自己的身份和数据。没有中央服务器 - 您的账户就是一对加密密钥。', 'signup.whyNostr': '为什么选择 Nostr？', 'signup.benefit1': '掌控您的身份', 'signup.benefit2': '无审查', 'signup.benefit3': '跨平台可移植', 'signup.createNew': '创建新账户', 'signup.haveAccount': '已有账户？', 'signup.login': '登录', 'signup.createButton': '创建账户', 'signup.generating': '正在生成密钥...', 'signup.displayName': '显示名称', 'signup.displayNamePlaceholder': '输入显示名称', 'signup.username': '用户名', 'signup.usernamePlaceholder': '输入用户名', 'signup.about': '简介（可选）', 'signup.profilePicture': '头像（可选）', 'signup.lightningAddress': '闪电地址（可选）', 'signup.nostrAddress': 'Nostr 地址', 'signup.nostrAddressPlaceholder': '用户名', 'signup.nostrAddressHint': '您的 Nostr 地址使您的个人资料更容易被找到。仅限小写字母、数字、_ 和 -。', 'signup.nostrAddressRequired': '请输入 Nostr 地址', 'signup.nostrAddressAvailable': '可用！', 'signup.nostrAddressUnavailable': '已被使用', 'signup.nostrAddressChecking': '检查中...', 'signup.nostrAddressInvalid': '用户名格式无效', 'signup.nostrAddressRegistering': '正在注册您的 Nostr 地址...', 'signup.nostrAddressSuccess': 'Nostr 地址已注册！', 'signup.nostrAddressFailed': '无法注册 Nostr 地址', 'signup.createAccountBtn': '创建账户', 'signup.termsAgree': '创建账户即表示您同意我们的', 'signup.and': '和', 'signup.success': '账户创建成功！', 'signup.yourPrivateKey': '您的私钥 (nsec)', 'signup.keyWarning': '这是访问您账户的唯一方式。请妥善保管！', 'signup.copyPrivateKey': '复制私钥', 'signup.howToUseKey': '如何使用您的私钥', 'signup.continueToPlebs': '继续前往 Plebs', 'signup.step1': '安全保存：', 'signup.step1Desc': '将 nsec 保存在密码管理器中，写下来或保存在加密文件中。切勿公开分享！', 'signup.step2': '再次登录：', 'signup.step2Desc': '点击登录屏幕上的"私钥"并粘贴您的 nsec。它就像密码一样工作。', 'signup.step3': '在其他应用中使用：', 'signup.step3Desc': '您的 nsec 适用于所有 Nostr 应用 - Damus、Primal、Amethyst 等数百个！', 'signup.step4': '考虑使用签名应用：', 'signup.step4Desc': '为了更安全，使用 Amber（Android）或 Alby 等浏览器扩展来管理您的密钥。',
        // Notifications
        'notifications.title': '通知', 'notifications.empty': '暂无通知', 'notifications.viewAll': '查看全部通知', 'notifications.markAllRead': '全部标记为已读', 'notifications.settings': '通知设置', 'notifications.loading': '加载通知中...', 'notifications.zap': '给您发送了打赏', 'notifications.like': '喜欢了您的内容', 'notifications.comment': '评论了', 'notifications.follow': '关注了您', 'notifications.repost': '转发了', 'notifications.mention': '提到了您',
        // Settings Modal
        'settings.title': '设置', 'settings.language': '语言', 'settings.languageDesc': '选择您的语言', 'settings.saveToNostr': '保存到 Nostr', 'settings.darkMode': '深色模式', 'settings.darkModeDesc': '切换深色/浅色主题', 'settings.autoplay': '自动播放', 'settings.autoplayDesc': '自动播放视频', 'settings.saveSettings': '保存设置', 'settings.resetDefaults': '重置默认', 'settings.notificationSettings': '通知设置', 'settings.notifications': '通知', 'settings.notificationsDesc': '接收推送通知', 'settings.quality': '默认质量', 'settings.qualityDesc': '视频播放质量', 'settings.contentWarning': '内容警告偏好', 'settings.showNsfwWarnings': '显示 NSFW 警告', 'settings.showNsfwWarningsDesc': '对 NSFW 内容显示年龄验证', 'settings.showCommunityWarnings': '显示社区警告', 'settings.showCommunityWarningsDesc': '对被标记或大量差评的内容显示警告', 'settings.showFollowsReportWarnings': '显示关注者举报警告', 'settings.showFollowsReportWarningsDesc': '当 5 个以上关注的人举报内容时显示警告', 'settings.filterPacks': '内容过滤器包', 'settings.filterPacksDesc': '启用过滤器包以自动隐藏包含特定关键词的内容。', 'settings.customKeywordFilter': '自定义关键词过滤器', 'settings.customKeywordFilterPlaceholder': '输入关键词或短语，用逗号分隔\n例如：垃圾信息，不想要的内容，特定短语', 'settings.customKeywordFilterDesc': '添加您自己的关键词进行过滤（用逗号分隔）',
        // Upload Modal
        'upload.title': '上传视频', 'upload.dragDrop': '拖放视频文件到此处', 'upload.or': '或', 'upload.browse': '浏览文件', 'upload.supportedFormats': '支持格式：MP4、WebM、MOV', 'upload.maxSize': '最大文件大小：2GB', 'upload.videoTitle': '标题', 'upload.titlePlaceholder': '输入视频标题', 'upload.description': '描述', 'upload.descriptionPlaceholder': '描述您的视频...', 'upload.tags': '标签', 'upload.tagsPlaceholder': '添加标签，用逗号分隔', 'upload.visibility': '可见性', 'upload.public': '公开', 'upload.unlisted': '不公开', 'upload.uploadButton': '上传视频', 'upload.uploading': '上传中...', 'upload.processing': '处理中...', 'upload.complete': '完成！', 'upload.error': '上传失败', 'upload.nsfw': 'NSFW 内容', 'upload.nsfwDesc': '标记为成人内容', 'upload.thumbnail': '缩略图', 'upload.thumbnailDesc': '上传视频缩略图', 'upload.preparing': '准备中...', 'upload.cancel': '取消', 'upload.progress': '上传进度', 'upload.transcoding': '转码中', 'upload.status.preparing': '准备上传...', 'upload.status.uploading': '上传视频中...', 'upload.status.transcoding': '转码视频中...', 'upload.status.complete': '上传完成！', 'upload.qualityHigh': '高', 'upload.qualityMedium': '中', 'upload.qualityLow': '低',
        // Create Modal
        'create.title': '创建', 'create.uploadVideo': '上传视频', 'create.uploadDesc': '分享视频', 'create.goLive': '开始直播', 'create.goLiveDesc': '开始直播', 'create.createPost': '创建帖子', 'create.createPostDesc': '分享文字帖子',
        // Go Live Modal
        'goLive.title': '开始直播', 'goLive.streamTitle': '直播标题', 'goLive.streamTitlePlaceholder': '输入直播标题', 'goLive.description': '描述', 'goLive.descriptionPlaceholder': '描述您的直播...', 'goLive.category': '分类', 'goLive.selectCategory': '选择分类', 'goLive.tags': '标签', 'goLive.tagsPlaceholder': '添加标签，用逗号分隔', 'goLive.startStream': '开始直播', 'goLive.streamKey': '直播密钥', 'goLive.streamUrl': '直播 URL', 'goLive.copy': '复制', 'goLive.hideKey': '隐藏密钥', 'goLive.showKey': '显示密钥', 'goLive.connecting': '连接中...', 'goLive.live': '直播中', 'goLive.offline': '离线', 'goLive.viewers': '观众', 'goLive.endStream': '结束直播', 'goLive.nsfw': 'NSFW 内容', 'goLive.nsfwDesc': '标记为成人内容', 'goLive.thumbnail': '直播缩略图', 'goLive.thumbnailDesc': '上传缩略图', 'goLive.zapGoal': 'Zap 目标（可选）', 'goLive.zapGoalLabel': 'Zap 目标',
        // Video/Live No Description
        'video.noDescription': '此视频未添加描述。', 'live.noDescription': '此直播未添加描述。',
        // Edit Stream Modal
        'editStream.title': '编辑直播', 'editStream.save': '保存更改',
        // Live Stream
        'live.live': '直播', 'live.scheduled': '已预约', 'live.ended': '直播已结束', 'live.viewers': '观众', 'live.viewer': '观众', 'live.chat': '直播聊天', 'live.sendMessage': '发送消息...', 'live.send': '发送', 'live.goalReached': '目标达成！', 'live.goalProgress': '目标的 {percent}%',
        // NSFW Warning Modal
        'nsfw.title': '成人内容警告', 'nsfw.warning': '此内容已被标记为 NSFW（工作场所不宜），可能包含成人内容。', 'nsfw.confirm': '确认您的年龄', 'nsfw.confirmAge': '我已年满 18 岁', 'nsfw.cancel': '返回', 'nsfw.continue': '继续', 'nsfw.dontShowAgain': '不再显示此警告',
        // Community Warning Modal
        'community.title': '社区准则', 'community.warning': '继续前请查看我们的社区准则。', 'community.guidelines': '请尊重他人并遵循社区标准。', 'community.accept': '接受', 'community.decline': '拒绝',
        'communityWarning.title': '社区警告', 'communityWarning.description': '此视频已被社区标记和/或大量差评。这可能是由于:', 'communityWarning.reason1': '不当内容未正确标记为 NSFW', 'communityWarning.reason2': '新用户或可疑的用户信息', 'communityWarning.reason3': '误导性或虚假信息', 'communityWarning.reason4': '垃圾信息或低质量内容', 'communityWarning.reason5': '可能有害或非法的内容', 'communityWarning.proceed': '请谨慎继续。', 'communityWarning.goBack': '返回', 'communityWarning.viewAnyway': '仍然查看',
        // Report Modal
        'report.title': '举报内容', 'report.reason': '举报原因', 'report.selectReason': '选择原因', 'report.spam': '垃圾信息或误导', 'report.inappropriate': '不当内容', 'report.violence': '暴力或危险内容', 'report.copyright': '版权侵犯', 'report.other': '其他', 'report.details': '详细信息', 'report.detailsPlaceholder': '提供更多详情...', 'report.submit': '提交举报', 'report.cancel': '取消',
        // Share Modal
        'share.title': '分享', 'share.copyLink': '复制链接', 'share.embed': '嵌入代码', 'share.copyEmbed': '复制嵌入代码', 'share.social': '分享到社交媒体', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': '邮件', 'share.copied': '已复制！', 'share.nostr': '分享到 Nostr', 'share.generateImage': '生成图片', 'share.downloadImage': '下载', 'share.shareImage': '分享', 'share.size1280x720': '1280 × 720 (高清)', 'share.size1080x1080': '1080 × 1080 (方形)', 'share.size1080x1920': '1080 × 1920 (故事)',
        // Edit Video Modal
        'editVideo.title': '编辑视频', 'editVideo.videoTitle': '标题', 'editVideo.description': '描述', 'editVideo.tags': '标签', 'editVideo.thumbnail': '缩略图', 'editVideo.changeThumbnail': '更改缩略图', 'editVideo.visibility': '可见性', 'editVideo.nsfw': 'NSFW 内容', 'editVideo.save': '保存更改', 'editVideo.delete': '删除视频', 'editVideo.confirmDelete': '确定要删除此视频吗？',
        // Edit Profile Modal
        'editProfile.title': '编辑个人资料', 'editProfile.displayName': '显示名称', 'editProfile.displayNamePlaceholder': '输入显示名称', 'editProfile.username': '用户名', 'editProfile.usernamePlaceholder': '输入用户名', 'editProfile.about': '简介', 'editProfile.aboutPlaceholder': '介绍一下自己...', 'editProfile.website': '网站', 'editProfile.websitePlaceholder': 'https://yourwebsite.com', 'editProfile.lightning': '闪电地址', 'editProfile.lightningPlaceholder': 'you@getalby.com', 'editProfile.nip05': 'NIP-05 验证', 'editProfile.nip05Placeholder': 'you@domain.com', 'editProfile.avatar': '头像', 'editProfile.changeAvatar': '更改头像', 'editProfile.banner': '横幅', 'editProfile.changeBanner': '更改横幅', 'editProfile.save': '保存个人资料',
        // Confirmation Modal
        'confirm.title': '确认操作', 'confirm.message': '确定要继续吗？', 'confirm.confirm': '确认', 'confirm.cancel': '取消',
        // Video Page
        'video.views': '次观看', 'video.like': '点赞', 'video.dislike': '踩', 'video.share': '分享', 'video.save': '保存', 'video.report': '举报', 'video.follow': '关注', 'video.unfollow': '取消关注', 'video.subscribe': '订阅', 'video.subscribed': '已订阅', 'video.comments': '评论', 'video.addComment': '添加评论...', 'video.reply': '回复', 'video.replies': '条回复', 'video.loadMore': '加载更多', 'video.noComments': '暂无评论。成为第一个评论的人！', 'video.zap': '打赏', 'video.zapAmount': '打赏金额 (聪)', 'video.sendZap': '发送打赏', 'video.boost': '推广', 'video.description': '描述', 'video.showMore': '展开', 'video.showLess': '收起', 'video.publishedOn': '发布于',
        // Toast Messages
        'toast.loggedIn': '登录成功！', 'toast.loggedOut': '已登出', 'toast.settingsSaved': '设置已保存！', 'toast.settingsLocal': '设置已保存到本地。无法保存到 Nostr。', 'toast.settingsLocalOnly': '设置已保存到本地！', 'toast.settingsReset': '设置已重置', 'toast.avatarUploaded': '头像上传成功！', 'toast.videoUploaded': '视频已上传！', 'toast.videoDeleted': '视频已删除', 'toast.profileUpdated': '个人资料已更新！', 'toast.copied': '已复制到剪贴板！', 'toast.copyFailed': '复制失败。请手动复制。', 'toast.linkCopied': '链接已复制！', 'toast.embedCopied': '嵌入代码已复制！', 'toast.installExtension': '请安装 Nostr 浏览器扩展，如 Alby 或 nos2x', 'toast.loginFailed': '登录失败。请重试。', 'toast.invalidKey': '私钥无效。请检查后重试。', 'toast.enterKey': '请输入您的私钥', 'toast.enterUsername': '请输入用户名', 'toast.accountCreated': '欢迎来到 Plebs！您已登录。', 'toast.keyCopied': '密钥已复制！', 'toast.unmuted': '用户已取消静音', 'toast.unmuteFailed': '取消静音失败', 'toast.selectImage': '请选择图片文件', 'toast.imageTooLarge': '图片必须小于 5MB', 'toast.avatarFailed': '头像上传失败。请重试。', 'toast.mustBeLoggedIn': '请先登录才能编辑个人资料', 'toast.enterDisplayName': '请输入显示名称', 'toast.profileFailed': '保存个人资料失败。请重试。', 'toast.invalidBunker': '请输入有效的 bunker URL', 'toast.connectFailed': '连接失败', 'toast.showingFiltered': '正在显示筛选内容', 'toast.reportSubmitted': '举报已提交', 'toast.draftSaved': '草稿已保存！您可以稍后从我的视频继续。', 'toast.draftLoaded': '草稿已加载。完成上传并发布。', 'toast.draftDeleted': '草稿已删除', 'toast.zapSent': '打赏已发送！', 'toast.followed': '已关注！', 'toast.unfollowed': '已取消关注', 'toast.reported': '举报已提交', 'toast.saved': '已保存！', 'toast.error': '发生错误', 'toast.networkError': '网络错误。请重试。', 'toast.uploadError': '上传失败。请重试。', 'toast.languageChanged': '语言已更改', 'toast.videoBlocked': '视频已屏蔽并发布到 Nostr', 'toast.waitForUpload': '请等待视频上传完成', 'toast.enterTitle': '请输入标题', 'toast.publishing': '正在发布视频到 Nostr...', 'toast.commentPosted': '评论已发布',
        // Time
        'time.justNow': '刚刚', 'time.secondAgo': '1 秒前', 'time.secondsAgo': '{n} 秒前', 'time.minuteAgo': '1 分钟前', 'time.minutesAgo': '{n} 分钟前', 'time.hourAgo': '1 小时前', 'time.hoursAgo': '{n} 小时前', 'time.dayAgo': '1 天前', 'time.daysAgo': '{n} 天前', 'time.weekAgo': '1 周前', 'time.weeksAgo': '{n} 周前', 'time.monthAgo': '1 个月前', 'time.monthsAgo': '{n} 个月前', 'time.yearAgo': '1 年前', 'time.yearsAgo': '{n} 年前',
        // Empty States
        'empty.noVideos': '没有找到视频', 'empty.noVideosDesc': '尝试其他搜索词', 'empty.noFollowing': '您还没有关注任何人', 'empty.noFollowingDesc': '关注创作者以查看他们的视频', 'empty.noHistory': '没有观看历史', 'empty.noHistoryDesc': '您观看的视频将显示在这里', 'empty.noLiked': '还没有喜欢的视频', 'empty.noLikedDesc': '喜欢视频后将显示在这里', 'empty.noResults': '没有找到结果', 'empty.noResultsDesc': '尝试其他关键词',
        // Misc
        'misc.loading': '加载中...', 'misc.loadingMore': '加载更多...', 'misc.refresh': '刷新', 'misc.retry': '重试', 'misc.close': '关闭', 'misc.back': '返回', 'misc.next': '下一步', 'misc.previous': '上一步', 'misc.search': '搜索', 'misc.filter': '筛选', 'misc.sort': '排序', 'misc.newest': '最新', 'misc.oldest': '最早', 'misc.popular': '热门', 'misc.trending': '趋势', 'misc.sats': '聪', 'misc.all': '全部', 'misc.copiedToClipboard': '已复制到剪贴板！',
        // Common
        'common.submit': '提交', 'common.cancel': '取消', 'common.save': '保存', 'common.delete': '删除', 'common.edit': '编辑', 'common.close': '关闭', 'common.confirm': '确认', 'common.yes': '是', 'common.no': '否', 'common.ok': '确定', 'common.loading': '加载中...', 'common.uploading': '上传中...', 'common.error': '错误', 'common.success': '成功',
        // Aria Labels
        'aria.toggleMenu': '切换菜单', 'aria.mainNavigation': '主导航', 'aria.videoContent': '视频内容', 'aria.loadingContent': '加载内容中', 'aria.closeModal': '关闭弹窗', 'aria.playVideo': '播放视频', 'aria.pauseVideo': '暂停视频', 'aria.muteVideo': '静音', 'aria.unmuteVideo': '取消静音', 'aria.fullscreen': '全屏', 'aria.exitFullscreen': '退出全屏', 'aria.settings': '设置', 'aria.notifications': '通知', 'aria.userMenu': '用户菜单', 'aria.searchInput': '搜索视频', 'aria.videoPlayer': '视频播放器',
        // Dynamic JavaScript text
        'button.hideQR': '隐藏二维码', 'button.showQR': '显示二维码', 'button.copied': '已复制！', 'button.showLess': '显示更少', 'button.showMore': '显示更多', 'button.creatingAccount': '创建账户中...', 'button.submitting': '提交中...', 'button.scheduleStream': '计划直播', 'button.goLive': '开始直播', 'button.creatingStream': '创建直播中...', 'button.continueCustomAmount': '使用自定义金额继续', 'button.recordFromCamera': '从摄像头录制', 'button.requestingCamera': '请求摄像头...', 'button.recording': '录制中...',
        'status.saving': '保存中...', 'status.saved': '已保存！', 'status.uploading': '上传中...', 'status.uploadComplete': '上传完成！', 'status.uploadingToNostrBuild': '上传到nostr.build...', 'status.publishingChanges': '发布更改...', 'status.removingOldVersion': '删除旧版本...', 'status.validatingThumbnail': '验证缩略图...', 'status.uploadingThumbnail': '上传缩略图...', 'status.thumbnailUploaded': '缩略图已上传！', 'status.processingVideo': '处理视频中...', 'status.compressingVideo': '压缩视频中...', 'status.uploadingVideo': '上传视频中...', 'status.videoUploaded': '视频上传成功！', 'status.processing': '处理中...', 'status.generatingThumbnail': '生成缩略图...', 'status.generatingPreview': '生成预览...', 'status.uploadingPreview': '上传预览...', 'status.publishing': '发布中...', 'status.publishingToNostr': '发布到Nostr...', 'status.publishingVideoToNostr': '发布视频到Nostr...', 'status.generatingPoW': '生成工作量证明...', 'status.posting': '发布中...', 'status.processingVideoAndThumbnail': '处理视频和缩略图...', 'status.uploadFailed': '上传失败 - 请重试', 'status.selectVideoToUpload': '选择要上传的视频', 'status.waitingForVideoUpload': '等待视频上传...', 'status.selectVideoAndThumbnail': '选择视频和缩略图进行发布', 'status.ready': '准备就绪 ✓', 'status.failed': '失败 ✗', 'status.fromDraft': '来自草稿', 'status.startingNow': '即将开始！', 'status.ended': '已结束', 'status.thumbnailReady': '就绪', 'status.thumbnailFailed': '失败', 'status.uploadFailedRetry': '上传失败，请重试。',
        'publish.video': '发布视频', 'publish.autoThumbnail': '发布视频（自动缩略图）',
        'report.titleComment': '举报评论', 'report.titleUser': '举报用户', 'report.titleVideo': '举报视频', 'report.descComment': '选择举报此评论的原因：', 'report.descUser': '选择举报此用户的原因：', 'report.descVideo': '选择举报此内容的原因：',
        'empty.noMutedUsers': '没有屏蔽的用户。', 'empty.noVideosToMonitor': '没有要监控的视频。', 'empty.noRecentActivity': '没有最近活动。', 'empty.failedLoadNotifications': '加载通知失败', 'empty.loginToViewLiked': '请<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">登录</a>查看您喜欢的视频。', 'empty.loginToViewFollowing': '请<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">登录</a>查看您的关注。', 'empty.loginToViewVideos': '请<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">登录</a>查看您的视频。', 'empty.loginToViewAnalytics': '请<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">登录</a>查看您的统计数据。', 'empty.noLikedVideosYet': '您还没有喜欢任何视频。', 'empty.noLikedVideosFound': '未找到喜欢的视频。', 'empty.noFullLengthLikedVideos': '未找到喜欢的长视频。', 'empty.noWatchHistory': '没有观看历史。开始观看视频吧。', 'empty.noVideosInHistory': '历史记录中没有视频。', 'empty.noFullLengthHistory': '历史记录中没有长视频。', 'empty.noMatchingVideos': '未找到匹配的视频。', 'empty.noFullLengthVideos': '未找到长视频。', 'empty.failedLoadTrending': '加载热门视频失败。', 'empty.noTrendingVideos': '未找到热门视频。', 'empty.noMatchingUsers': '未找到匹配的用户。', 'empty.unableLoadProfiles': '无法加载用户资料。', 'empty.noFollowingVideos': '您关注的用户还没有视频。', 'empty.noFullLengthFollowing': '关注用户没有长视频。', 'empty.failedLoadFollowing': '加载失败，请重试。', 'empty.noVideosUploadFirst': '没有视频。上传您的第一个视频！', 'empty.noFullLengthUploaded': '未找到长视频。', 'empty.noMatchingLiveStreams': '未找到匹配的直播。', 'empty.noMatchingShorts': '未找到匹配的短视频。', 'empty.noVideosForTag': '此标签没有视频。', 'empty.noFullLengthForTag': '此标签没有长视频。', 'empty.noUploadedVideos': '还没有上传视频。', 'empty.noVideosFound': '未找到视频。', 'empty.failedLoadProfile': '加载个人资料失败，请重试。', 'empty.noComments': '还没有评论，成为第一个！', 'empty.failedLoadComments': '加载评论失败', 'empty.noLiveNow': '现在没有人在直播，成为第一个！',
        'error.videoNotFound': '视频未找到。', 'error.contentNotAvailable': '此内容不可用。', 'error.invalidVideoData': '视频数据无效。', 'error.videoNotAvailable': '视频不可用，文件可能已被删除。', 'error.failedLoadVideo': '加载视频失败，请重试。', 'error.failedLoadVideoShort': '加载失败，文件可能已被删除。', 'error.liveStreamNotFound': '直播未找到。', 'error.invalidLiveStreamData': '直播数据无效。', 'error.failedLoadLiveStream': '加载直播失败。',
        // New Button & Action Labels
        'button.follow': '关注', 'button.unfollow': '取消关注', 'button.mute': '静音', 'button.unmute': '取消静音', 'button.muteUser': '屏蔽用户', 'button.unmuteUser': '取消屏蔽', 'button.confirm': '确认', 'button.cancel': '取消', 'button.close': '关闭', 'button.boost': '推广', 'button.zap': 'Zap', 'button.viewMore': '查看更多', 'button.viewAnalytics': '查看统计', 'button.backToMyVideos': '返回我的视频', 'button.editDraft': '编辑草稿', 'button.deleteDraft': '删除草稿', 'button.editVideo': '编辑视频', 'button.deleteVideo': '删除视频', 'button.editShort': '编辑短视频', 'button.deleteShort': '删除短视频', 'button.editStream': '编辑直播', 'button.endStream': '结束直播', 'button.reset': '重置', 'button.download': '下载', 'button.watchRecording': '观看录像', 'button.show': '显示', 'button.login': '登录', 'button.toggleChat': '切换聊天', 'button.blockVideo': '屏蔽视频', 'button.blockUser': '屏蔽用户', 'button.unblock': '解除屏蔽', 'button.removeFromHistory': '从历史记录中删除',
        // New Stats & Counts
        'stat.views': '次观看', 'stat.viewsCount': '{count} 次观看', 'stat.videos': '个视频', 'stat.video': '个视频', 'stat.followers': '位粉丝', 'stat.follower': '位粉丝', 'stat.following': '关注中', 'stat.subscribers': '位订阅者', 'stat.comments': '评论', 'stat.liveCount': '{count} 直播中', 'stat.percentOfGoal': '目标的{percent}%', 'stat.netGrowth': '净增长', 'stat.newFollowers': '新粉丝', 'stat.unfollowed': '取消关注', 'stat.lastUpdated': '最后更新: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': '直播中', 'badge.ended': '已结束', 'badge.scheduled': '已预定', 'badge.warning': '警告', 'badge.communityWarning': '社区警告', 'badge.verifiedNip05': 'NIP-05 已验证', 'badge.streamer': '主播', 'badge.clickToView': '点击查看',
        // New Actions
        'action.report': '举报', 'action.reportComment': '举报评论', 'action.reportVideo': '举报此视频', 'action.reportStream': '举报此直播', 'action.like': '喜欢', 'action.dislike': '不喜欢', 'action.reply': '回复',
        // New Placeholders
        'placeholder.searchHistory': '搜索历史...', 'placeholder.searchUsers': '搜索用户...', 'placeholder.searchMyVideos': '搜索我的视频...', 'placeholder.eventId': '输入事件ID (hex或nevent/note)', 'placeholder.pubkey': '输入pubkey (hex或npub)', 'placeholder.customAmount': '自定义金额', 'placeholder.chatEnded': '聊天已关闭 - 直播已结束', 'placeholder.addComment': '添加评论...', 'placeholder.setNewGoal': '设置新目标 (sats)',
        // New Video & Content
        'video.untitledVideo': '无标题视频', 'video.untitledShort': '无标题短视频', 'video.upNext': '接下来', 'video.noVideosYet': '暂无视频', 'video.noShortsYet': '暂无短视频', 'video.noLiveStreamsYet': '暂无直播', 'video.noBlockedVideos': '无屏蔽视频', 'video.noBlockedUsers': '无屏蔽用户',
        // New Stream Messages
        'stream.ended': '直播已结束。聊天已关闭。', 'stream.welcomeChat': '欢迎来到直播聊天！', 'stream.goalReached': '目标达成！', 'stream.zapGoalReached': 'Zap目标达成！{amount} sats！',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': '来自已静音用户的消息', 'muted.commentFromMutedUserHidden': '已静音用户的评论已隐藏', 'muted.commentHidden': '评论已隐藏 ({packs})', 'muted.messageHidden': '消息已隐藏 ({packs})', 'muted.commentReportedByFollows': '您关注的人举报了此评论', 'muted.messageReportedByFollows': '您关注的人举报了此消息', 'muted.commentHeavilyDownvoted': '评论被社区大量踩', 'muted.messageHeavilyDownvoted': '消息被大量踩',
        // New Admin & Lists
        'list.blockedVideos': '屏蔽的视频', 'list.blockedUsers': '屏蔽的用户',
        // New Alerts
        'alert.cameraNotSupported': '此浏览器不支持摄像头访问。请使用Chrome、Firefox或Safari等现代浏览器。', 'alert.noCameraFound': '未找到摄像头。请连接摄像头或使用文件上传选项。', 'alert.cameraAccessDenied': '摄像头访问被拒绝。请在浏览器设置中允许摄像头权限。', 'alert.cameraInUse': '摄像头正被其他应用程序使用。请关闭其他使用摄像头的应用。', 'alert.cameraUnableAccess': '无法访问摄像头。请尝试使用上传选项。', 'alert.cameraUnableAccessWithError': '无法访问摄像头: {error}\n\n请使用上传选项。', 'alert.fillRequiredFields': '请填写所有必填字段', 'alert.uploadThumbnail': '请上传直播缩略图', 'alert.failedCreateStream': '创建直播失败。请重试。', 'alert.failedUpdateStream': '更新失败。请重试。', 'alert.streamNotFound': '未找到直播', 'alert.canOnlyEditOwnStreams': '您只能编辑自己的直播', 'alert.invalidStreamData': '直播数据无效', 'alert.enterValidGoalAmount': '请输入有效的目标金额', 'alert.canOnlyResetOwnGoals': '您只能重置自己的目标', 'alert.streamEventNotFound': '未找到直播事件', 'alert.failedResetZapGoal': '重置zap目标失败。请重试。', 'alert.cannotBlockAdmin': '无法屏蔽管理员账户', 'alert.analyticsLoadFailed': '加载统计失败。请重试。', 'alert.cannotReplaceShortWithVideo': '无法用普通视频替换短视频。请上传竖版视频（60秒或更短）。', 'alert.cannotReplaceVideoWithShort': '无法用短视频替换普通视频。请上传横版视频。', 'alert.shortsRequireVertical': '此视频为横版。短视频必须是竖版视频。请使用"上传视频"上传横版视频。',
        // New Zap Messages
        'zap.cannotZapYourself': '不能给自己发Zap', 'zap.cannotZapOwnContent': '不能给自己的内容发Zap', 'zap.cannotZapOwnComment': '不能给自己的评论发Zap', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': '加载视频中...', 'status.loading': '加载中...', 'status.compressingProgress': '压缩中... {progress}%', 'status.uploadingProgress': '上传中... {progress}%', 'status.uploadingServers': '上传中... ({completed}/{total} 服务器)', 'status.publishedSuccess': '{type} 发布成功！',
        // New Warnings
        'warning.webmFormat': '注意：您的浏览器将输出WebM格式（可能无法在iOS上播放）。如需iOS兼容的MP4，请在Windows/Mac上使用Chrome。',
        // New Footer
        'footer.lastUpdated': '最后更新: 2024年12月',
        // DMCA Page
        'dmca.title': 'DMCA 与内容政策',
        'dmca.lastUpdated': '最后更新: 2024年12月',
        'dmca.architectureTitle': '了解 Plebs 架构',
        'dmca.architectureDesc': 'Plebs 是一个去中心化视频平台界面，其运作方式与传统视频托管服务不同。了解我们平台上的内容是如何分发的很重要：',
        'dmca.architectureItem1': 'Plebs 不托管任何视频或图片内容。',
        'dmca.architectureItem1Desc': '我们是一个客户端/界面，展示存储在其他地方的内容。',
        'dmca.architectureItem2': '所有媒体文件（视频、图片、缩略图）存储在由第三方运营的独立 Blossom 服务器上。',
        'dmca.architectureItem3': '视频元数据（标题、描述等）发布到独立运营的 Nostr 中继。',
        'dmca.architectureItem4': 'Plebs 只是通过用户友好的界面聚合和显示这些分布式内容。',
        'dmca.filingTitle': '提交 DMCA 申诉',
        'dmca.filingDesc': '由于 Plebs 不托管内容，我们无法直接删除侵权材料。要处理版权侵权，您必须联系相应的方：',
        'dmca.forVideoTitle': '1. 针对视频/图片内容',
        'dmca.forVideoDesc': '媒体文件存储在 Blossom 服务器上。您需要：',
        'dmca.forVideoItem1': '确定哪个 Blossom 服务器托管该内容（URL 会显示）',
        'dmca.forVideoItem2': '直接联系 Blossom 服务器运营商提交 DMCA 删除请求',
        'dmca.forVideoItem3': '每个 Blossom 服务器独立运营，有自己的政策',
        'dmca.forMetadataTitle': '2. 针对元数据/描述',
        'dmca.forMetadataDesc': '如果侵权内容在视频标题、描述或其他元数据中：',
        'dmca.forMetadataItem1': '此信息存储在 Nostr 中继上',
        'dmca.forMetadataItem2': '联系内容出现的特定 Nostr 中继运营商',
        'dmca.forMetadataItem3': '由于 Nostr 的分布式特性，多个中继可能存储相同数据',
        'dmca.whatWeCanDoTitle': 'Plebs 能做什么',
        'dmca.whatWeCanDoDesc': '虽然我们不托管内容，但我们可以：',
        'dmca.whatWeCanDoItem1': '帮助您确定哪些 Blossom 服务器或中继托管特定内容',
        'dmca.whatWeCanDoItem2': '将内容添加到本地屏蔽列表，使其不在我们的界面中显示（注意：这仅影响 plebs.app，不影响其他 Nostr 客户端）',
        'dmca.whatWeCanDoItem3': '提供如何联系相应服务运营商的指导',
        'dmca.toRequestAssistance': '要请求协助，请联系我们并提供：',
        'dmca.assistanceItem1': '侵权内容的 URL 或标识符',
        'dmca.assistanceItem2': '您的版权所有权证明',
        'dmca.assistanceItem3': '受版权保护作品的描述',
        'dmca.blossomOperatorsTitle': 'Blossom 服务器运营商',
        'dmca.blossomOperatorsDesc': '如果您运营 Blossom 服务器并收到 DMCA 删除请求，您有责任根据您所在司法管辖区的法律进行处理。',
        'dmca.blossomOperatorsLink': '有关已知 Blossom 服务器列表，请参阅 Blossom 项目文档。',
        'dmca.considerationsTitle': '重要考虑事项',
        'dmca.considerationsItem1': '去中心化：',
        'dmca.considerationsItem1Desc': '由于 Nostr 和 Blossom 的去中心化特性，可能无法从所有来源完全删除内容。',
        'dmca.considerationsItem2': '多个副本：',
        'dmca.considerationsItem2Desc': '内容可能存在于多个 Blossom 服务器和中继上。您可能需要联系多个运营商。',
        'dmca.considerationsItem3': '基于哈希的存储：',
        'dmca.considerationsItem3Desc': 'Blossom 使用内容寻址存储。相同的文件在任何服务器上都有相同的哈希值。',
        'dmca.considerationsItem4': '无中央控制：',
        'dmca.considerationsItem4Desc': 'Plebs 和任何单一实体都没有能力从整个网络中删除内容。',
        'dmca.counterNotificationTitle': '反通知',
        'dmca.counterNotificationDesc': '如果您认为您的内容被错误地从 Blossom 服务器删除，您应该直接联系该服务器运营商提交反通知。',
        'dmca.contactTitle': '联系方式',
        'dmca.contactDesc': '如有关于此政策的问题或需要帮助识别内容托管方，请',
        'dmca.contactLink': '联系我们',

        // Analytics
        'analytics.title': '频道分析',
        'analytics.description': '查看您频道的表现指标和见解。',
        'analytics.loading': '正在加载分析数据...',
        'analytics.error': '加载分析数据失败',
        'analytics.overview': '概览',
        'analytics.videos': '视频',
        'analytics.engagement': '互动',
        'analytics.totalViews': '总观看次数',
        'analytics.totalVideos': '总视频数',
        'analytics.totalLikes': '总点赞数',
        'analytics.totalZaps': '总打赏',
        'analytics.avgViews': '平均观看次数',
        'analytics.avgLikes': '平均点赞数',
        'analytics.avgZaps': '平均打赏',
        'analytics.viewsOverTime': '观看趋势',
        'analytics.topVideos': '热门视频',
        'analytics.recentActivity': '近期活动',
        'analytics.viewsLabel': '观看次数',
        'analytics.likesLabel': '点赞数',
        'analytics.zapsLabel': '打赏',
        'analytics.dateLabel': '日期',
        'analytics.videoTitle': '视频标题',
        'analytics.performance': '表现',
        'analytics.noData': '暂无分析数据',
        'analytics.noDataDesc': '开始上传视频以查看您的分析数据。',
        'analytics.last7Days': '最近7天',
        'analytics.last30Days': '最近30天',
        'analytics.last90Days': '最近90天',
        'analytics.allTime': '全部时间',
        'analytics.views': '观看',
        'analytics.likes': '点赞',
        'analytics.zaps': '打赏',
        'analytics.rank': '排名',
        'analytics.noVideos': '暂无视频',
        'analytics.noVideosDesc': '上传您的第一个视频以开始追踪表现。',

        // About Page
        'about.title': '关于 Plebs.place',
        'about.subtitle': '去中心化视频平台',
        'about.welcome': '欢迎来到 Plebs.place',
        'about.description': 'Plebs.place 是一个建立在 Nostr 协议上的去中心化视频共享平台，让创作者能够完全掌控自己的内容和受众。',
        'about.feature1Title': '去中心化',
        'about.feature1Desc': '建立在 Nostr 上，确保抗审查并实现真正的内容所有权。',
        'about.feature2Title': '创作者优先',
        'about.feature2Desc': '保留对内容、数据和与受众关系的完全控制权。',
        'about.feature3Title': '通过比特币变现',
        'about.feature3Desc': '通过闪电网络和打赏直接从观众获得支持。',
        'about.feature4Title': '开源',
        'about.feature4Desc': '透明、社区驱动的开发，与我们的去中心化理念相符。',
        'about.missionTitle': '我们的使命',
        'about.missionDesc': '为创作者和观众创建一个免于审查、平台锁定和任意规则变更的视频平台。您的内容属于您自己。',
        'about.techTitle': '技术',
        'about.techDesc': '使用 Nostr 进行身份验证和社交功能，使用闪电网络进行即时小额支付，以及去中心化存储解决方案构建。',

        // Contact Page
        'contact.title': '联系我们',
        'contact.subtitle': '联系方式',
        'contact.description': '有问题、反馈或建议？我们很乐意听取您的意见。',
        'contact.nostrTitle': '在 Nostr 上关注我们',
        'contact.nostrDesc': '在 Nostr 上关注我们获取更新和社区讨论。',
        'contact.githubTitle': 'GitHub',
        'contact.githubDesc': '查看源代码、报告问题或为项目做贡献。',
        'contact.emailTitle': '电子邮件',
        'contact.emailDesc': '如有商业咨询或支持问题，请联系我们的团队。',

        // Terms Page
        'terms.title': '服务条款',
        'terms.lastUpdated': '最后更新',
        'terms.section1Title': '1. 条款接受',
        'terms.section1Content': '使用 Plebs.place 即表示您同意受这些条款的约束。如果您不同意这些条款，请不要使用该平台。',
        'terms.section2Title': '2. 服务描述',
        'terms.section2Content': 'Plebs.place 是一个利用 Nostr 协议的去中心化视频共享平台。我们提供视频托管、共享和通过闪电网络进行变现的工具。',
        'terms.section3Title': '3. 用户责任',
        'terms.section3Content': '您对通过平台发布的所有内容负责。您同意不上传任何非法、有害或侵犯他人权利的内容。',
        'terms.section4Title': '4. 内容所有权',
        'terms.section4Content': '您保留对内容的完全所有权。上传即表示您授予 Plebs.place 一个有限许可来托管和提供您的视频。',
        'terms.section5Title': '5. 禁止使用',
        'terms.section5Content': '您不得将平台用于任何非法活动、骚扰、垃圾信息或散布恶意内容。',
        'terms.section6Title': '6. 账户管理',
        'terms.section6Content': '您有责任通过正确管理 Nostr 密钥来保护您的账户。我们不存储您的私钥，也无法恢复丢失的账户。',
        'terms.section7Title': '7. 支付条款',
        'terms.section7Content': '所有支付均通过闪电网络进行。交易是最终的，无法撤销。请确保交易前仔细核实所有支付详情。',
        'terms.section8Title': '8. 责任限制',
        'terms.section8Content': 'Plebs.place 按"原样"提供，不作任何保证。我们对任何损失、损害或服务中断概不负责。',
        'terms.section9Title': '9. 条款变更',
        'terms.section9Content': '我们可能会不时更新这些条款。继续使用即表示接受更新后的条款。',

        // Privacy Page
        'privacy.title': '隐私政策',
        'privacy.lastUpdated': '最后更新',
        'privacy.section1Title': '1. 引言',
        'privacy.section1Content': '本隐私政策解释了 Plebs.place 如何处理与您对我们去中心化视频平台的使用相关的信息。',
        'privacy.section2Title': '2. 我们收集的信息',
        'privacy.section2Content': '作为去中心化平台，我们收集的数据极少。您的 Nostr 公钥用于身份验证，视频元数据存储在 Nostr 中继上。',
        'privacy.section3Title': '3. 数据存储',
        'privacy.section3Content': '您的内容存储在去中心化存储解决方案上。我们不会在集中式服务器上存储个人数据。您的私钥永远不会与我们分享。',
        'privacy.section4Title': '4. 数据使用',
        'privacy.section4Content': '我们收集的任何数据仅用于提供和改进平台服务。我们绝不会将您的数据出售给第三方。',
        'privacy.section5Title': '5. Cookie 和追踪',
        'privacy.section5Content': '我们使用最少的 cookie 以确保基本功能。我们不会进行广告追踪或出于营销目的收集数据。',
        'privacy.section6Title': '6. 第三方服务',
        'privacy.section6Content': '我们与 Nostr 中继和闪电网络节点集成。这些服务有各自的隐私政策。',
        'privacy.section7Title': '7. 数据安全',
        'privacy.section7Content': '我们通过去中心化架构来保护您的信息。但是，您有责任保护您的私钥。',
        'privacy.section8Title': '8. 您的权利',
        'privacy.section8Content': '您完全控制您的数据。您可以随时删除内容或停止使用该平台。',
        'privacy.section9Title': '9. 儿童隐私',
        'privacy.section9Content': 'Plebs.place 不适用于 13 岁以下的儿童。我们不会有意收集未成年人的信息。',
        'privacy.section10Title': '10. 隐私政策变更',
        'privacy.section10Content': '我们可能会更新本隐私政策。变更将在此页面上发布，并附有更新日期。',

        // FAQ Page
        'faq.title': '常见问题',
        'faq.subtitle': '常见问题及解答',
        'faq.general': '一般问题',
        'faq.technical': '技术问题',
        'faq.monetization': '变现',
        'faq.content': '内容',
        'faq.q1': 'Plebs.place 是什么？',
        'faq.a1': 'Plebs.place 是一个建立在 Nostr 协议上的去中心化视频共享平台，让您完全拥有自己的内容和受众。',
        'faq.q2': 'Plebs.place 是如何工作的？',
        'faq.a2': '平台使用 Nostr 进行身份验证和社交功能，使用去中心化存储托管视频，使用闪电网络进行即时支付。',
        'faq.q3': '使用 Plebs.place 是免费的吗？',
        'faq.a3': '是的，创建账户、上传和观看视频都是免费的。您只需要一个 Nostr 密钥即可开始。',
        'faq.q4': '什么是 Nostr？',
        'faq.a4': 'Nostr 是一种去中心化的通信协议，让您能够控制自己的身份和数据，无需依赖中心化平台。',
        'faq.q5': '我如何创建账户？',
        'faq.a5': '您可以使用 Alby 或 nos2x 等 Nostr 浏览器扩展登录，或生成新的 Nostr 密钥。',
        'faq.q6': '支持哪些视频格式？',
        'faq.a6': '我们支持大多数常见格式，包括 MP4、WebM 和 MOV。视频在上传后会进行转码以获得最佳播放效果。',
        'faq.q7': '我的视频存储在哪里？',
        'faq.a7': '视频存储在去中心化存储解决方案上，确保您的内容不受任何单一服务器的控制。',
        'faq.q8': '什么是闪电网络？',
        'faq.a8': '闪电网络是比特币的第二层支付协议，可实现即时、低费用的交易。',
        'faq.q9': '什么是打赏？',
        'faq.a9': '打赏是通过闪电网络发送的比特币小额支付，用于支持创作者。',
        'faq.q10': '我如何通过内容变现？',
        'faq.a10': '创作者可以通过观众打赏、付费内容和闪电网络直接捐赠获得收入。',
        'faq.q11': '我如何提取收入？',
        'faq.a11': '收入直接到达您的闪电钱包。无需最低提现金额或等待期。',
        'faq.q12': '哪些内容是允许的？',
        'faq.a12': '合法内容均可发布。请遵守我们的服务条款，避免有害或非法材料。',
        'faq.q13': '我可以删除我的视频吗？',
        'faq.a13': '是的，您可以随时删除视频。由于去中心化的特性，已分发的副本可能仍然存在于其他节点上。',
        'faq.q14': '有内容审核吗？',
        'faq.a14': '作为去中心化平台，审核通过社区驱动的方法和用户控制进行。',
        'faq.q15': '我如何报告有问题的内容？',
        'faq.a15': '使用视频上的举报功能或通过我们的联系方式告知我们。社区反馈有助于维护平台质量。',
        // FAQ Self-Moderation Section
        'faq.selfModeration': '自我审核',
        'faq.q16': '去中心化平台上的审核是如何工作的？',
        'faq.a16': '与拥有中心化审核员的传统平台不同，Plebs 让您掌控自己看到的内容。我们提供强大的自我审核工具，包括内容过滤包、用户屏蔽、社区警告和负面反应视频指示器。您决定什么内容适合您 - 没有中央机构做出这些决定。',
        'faq.q17': '什么是内容过滤包？',
        'faq.a17Intro': '内容过滤包是预定义的关键词过滤器，您可以启用它们来隐藏特定类型的内容。可用的过滤包包括：',
        'faq.a17Pack1': '种族主义和仇恨言论：',
        'faq.a17Pack1Desc': '过滤种族诽谤和歧视性内容',
        'faq.a17Pack2': '露骨色情：',
        'faq.a17Pack2Desc': '过滤色情和成人内容',
        'faq.a17Pack3': '暴力和血腥：',
        'faq.a17Pack3Desc': '过滤血腥暴力和自残内容',
        'faq.a17Pack4': '毒品和物质：',
        'faq.a17Pack4Desc': '过滤与毒品相关的内容',
        'faq.a17Pack5': '垃圾信息和诈骗：',
        'faq.a17Pack5Desc': '过滤常见的垃圾信息和诈骗模式',
        'faq.a17Pack6': '加密货币：',
        'faq.a17Pack6Desc': '过滤加密货币推广和代币营销',
        'faq.a17Pack7': '政治内容：',
        'faq.a17Pack7Desc': '过滤党派政治内容',
        'faq.a17Pack8': '严重亵渎：',
        'faq.a17Pack8Desc': '过滤粗俗语言',
        'faq.a17Note': '在设置 > 内容过滤器中启用这些。您还可以添加自定义关键词。过滤的内容会显示一个占位符，如果您想临时查看，可以点击"仍然显示"按钮。',
        'faq.q18': '如何屏蔽用户？',
        'faq.a18': '要屏蔽用户，请访问他们的个人资料并点击屏蔽按钮。屏蔽后，他们的所有视频将从您的信息流中隐藏，他们的评论将显示为"来自屏蔽用户的消息"，他们的直播聊天消息将被隐藏。您的屏蔽列表存储在 Nostr 上，因此可以跨设备同步。您可以在个人资料设置的"屏蔽用户"下管理屏蔽的用户。',
        'faq.q19': '"Ratioed"是什么意思？',
        'faq.a19': '当一个视频的不喜欢数量明显多于喜欢数量时，会被标记为"ratioed"，表示社区的负面反应。具体来说，当视频至少有 10 个反应，不喜欢至少是喜欢的两倍，并且不喜欢占总反应的 70% 或更多时，视频就会被标记为 ratioed。Ratioed 视频会显示警告徽章，在查看之前会要求您确认。',
        'faq.q20': '社区警告是如何工作的？',
        'faq.a20': '用户可以出于各种原因举报内容（垃圾信息、非法内容、滥用、误导等）。当一个视频或用户收到来自您关注的人的 5 个或更多举报时，会出现警告指示器。这利用了您的社交图谱 - 警告来自您信任的网络，而不是匿名陌生人。您可以在设置中切换"显示来自我关注账户的警告"。',
        'faq.q21': '如何举报内容？',
        'faq.a21': '点击任何视频、评论或用户个人资料上的旗帜图标进行举报。选择一个原因（垃圾信息、非法、滥用、误导、冒充、版权或其他）并可选择添加详细信息。举报作为事件发布到 Nostr，使其透明和去中心化。您的举报帮助您网络中的其他人识别有问题的内容。',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': '隐私与安全',
        'faq.q22': '我的活动是私密的吗？',
        'faq.a22': '在 Nostr 上，大多数活动在设计上是公开的。您的点赞、评论、关注和 zap 在公共网络上是可见的。然而，Plebs 将您的观看历史本地存储在浏览器中 - 它从不发送到任何服务器。您可以随时清除本地数据。',
        'faq.q23': '如何保持账户安全？',
        'faq.a23': '永远不要与任何人分享您的私钥（nsec）。我们强烈建议使用 Nostr 浏览器扩展，如 Alby、nos2x 或硬件签名器。这些工具会安全地保存您的私钥，并且只在您批准时签署事件。避免直接在网站上存储您的 nsec。',
        'faq.q24': '我可以删除我的内容吗？',
        'faq.a24': '您可以通过在 Nostr 上发布删除事件来请求删除。大多数行为良好的中继和客户端会尊重这一点。然而，由于网络的去中心化性质，内容可能会在某些中继或 Blossom 服务器上持续存在。没有中央机构可以强制在整个网络中完全删除。',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': '故障排除',
        'faq.q25': '视频无法加载 - 我应该怎么做？',
        'faq.a25Intro': '如果视频无法加载，请尝试以下步骤：',
        'faq.a25Item1': '刷新页面',
        'faq.a25Item2': '检查您的互联网连接',
        'faq.a25Item3': '托管视频的 Blossom 服务器可能已关闭 - 这与 Plebs 无关',
        'faq.a25Item4': '尝试禁用可能阻止内容的浏览器扩展',
        'faq.a25Item5': '清除浏览器缓存并重试',
        'faq.q26': '我丢失了私钥 - 您能帮我恢复吗？',
        'faq.a26': '不幸的是，不能。Nostr 密钥是加密的 - 没有密码重置或账户恢复，因为没有中央机构。这就是为什么我们强烈建议备份您的密钥并使用安全的密钥管理解决方案。如果您丢失了 nsec，您将需要创建一个新身份。',
        'faq.q27': '如何报告错误或请求功能？',
        'faq.a27': '您可以在我们的 <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a> 页面上报告错误或请求功能。您也可以在 Nostr 上联系我们 - 访问我们的<a href="#/contact">联系</a>页面了解详情。',
        // Page Titles
        'pageTitle.following': '关注',
        'pageTitle.myVideos': '我的视频',
        'pageTitle.likedVideos': '已赞视频',
        'pageTitle.watchHistory': '观看历史',
        'pageTitle.liveStreams': '直播',
        'pageTitle.suffix': '- Plebs',
        'pageTitle.liveSuffix': '- Plebs 直播',
        // Home Page Sections
        'section.trending': '热门',
        'section.recommended': '为您推荐',
        'section.shorts': '短视频',
        'section.live': '直播',
        'section.liveNow': '正在直播',
        'section.latestVideos': '最新视频',
        'section.videos': '视频',
        'section.usersYouFollow': '您关注的用户',
        // Trending Period
        'trending.thisWeek': '本周',
        'trending.today': '今天',
        // Buttons
        'button.viewMore': '查看更多',
        'button.clearAll': '全部清除',
        'button.showAnyway': '仍然显示',
        // Confirmation Modals
        'confirm.logout': '登出',
        'confirm.logoutMessage': '您确定要登出吗？',
        'confirm.resetSettings': '重置设置',
        'confirm.resetSettingsMessage': '您确定要将所有设置重置为默认值吗？',
        'confirm.reset': '重置',
        'confirm.clearHistory': '清除历史',
        'confirm.clearHistoryMessage': '您确定要清除整个观看历史吗？此操作无法撤销。',
        'confirm.deleteDraft': '删除草稿',
        'confirm.deleteDraftMessage': '您确定要删除此草稿吗？',
        'confirm.delete': '删除',
        'confirm.deleteVideo': '删除视频',
        'confirm.deleteVideoMessage': '您确定要删除此视频吗？此操作无法撤销。',
        'confirm.endStream': '结束直播',
        'confirm.endStreamMessage': '您确定要结束此直播吗？此操作无法撤销。',
        'confirm.endStreamButton': '结束直播',
        // Content Filters
        'filter.hiddenByPack': '被{pack}隐藏',
        'filter.showAnyway': '仍然显示',
        'filter.contentHidden': '内容已被内容过滤器隐藏',
        // Filter Packs
        'filter.racism': '种族主义和仇恨言论', 'filter.racismDesc': '过滤种族歧视、民族仇恨言论和歧视性内容', 'filter.sexualExplicit': '色情内容', 'filter.sexualExplicitDesc': '过滤色情术语和性暴露内容', 'filter.violence': '暴力和血腥', 'filter.violenceDesc': '过滤暴力画面、血腥内容和暴力威胁', 'filter.drugs': '毒品和物质', 'filter.drugsDesc': '过滤与毒品相关的内容和物质滥用', 'filter.spam': '垃圾信息和诈骗', 'filter.spamDesc': '过滤常见垃圾信息、诈骗和推广内容', 'filter.crypto': '加密货币', 'filter.cryptoDesc': '过滤加密货币推广、交易信号和代币推广', 'filter.politics': '政治内容', 'filter.politicsDesc': '过滤党派政治内容和分裂性言论', 'filter.profanity': '粗俗语言', 'filter.profanityDesc': '过滤粗俗脏话和低俗语言', 'filter.customFilter': '自定义过滤器',
        // Following Page
        'following.noFollowingYet': '您还没有关注任何人。找到创作者关注吧！',
    },
    ja: {
        // Navigation & Header
        'nav.home': 'ホーム', 'nav.following': 'フォロー中', 'nav.myVideos': 'マイ動画', 'nav.liked': 'いいね', 'nav.history': '履歴', 'nav.topics': 'トピック', 'nav.live': 'ライブ', 'nav.bitcoin': 'ビットコイン', 'nav.nostr': 'Nostr', 'nav.technology': 'テクノロジー', 'nav.gaming': 'ゲーム', 'nav.tutorials': 'チュートリアル', 'nav.podcasts': 'ポッドキャスト', 'nav.music': '音楽', 'nav.nsfw': 'NSFW', 'nav.about': '概要', 'nav.contact': 'お問い合わせ', 'nav.terms': '利用規約', 'nav.privacy': 'プライバシー', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': 'ライブ配信', 'nav.github': 'GitHub',
        'header.search': '動画を検索...', 'header.notifications': '通知', 'header.settings': '設定', 'header.create': '作成', 'header.viewProfile': 'プロフィール', 'header.logout': 'ログアウト',
        // Login Modal
        'login.title': 'Nostrでログイン', 'login.extensionButton': 'Nostr拡張機能でログイン', 'login.extensionDesc': '署名拡張機能を使用 (Alby, nos2x など)', 'login.orDivider': 'または', 'login.nsecLabel': '秘密鍵でログイン (nsec)', 'login.nsecPlaceholder': 'nsecを入力...', 'login.nsecButton': 'nsecでログイン', 'login.nsecWarning': '警告：nsecの直接入力は拡張機能を使用するより安全性が低くなります。より良いセキュリティのためにNIP-07拡張機能をご検討ください。', 'login.newToNostr': 'Nostrが初めてですか？', 'login.createAccount': 'アカウント作成', 'login.learnMore': 'Nostrについて詳しく',
        // Connect Modal
        'connect.title': 'Nostrに接続', 'connect.or': 'または', 'connect.extensionButton': 'Nostr拡張機能を接続', 'connect.extensionDesc': '拡張機能を使用 (Alby, nos2x など)', 'connect.nsecLabel': '秘密鍵でログイン', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'nsecで接続', 'connect.nsecWarning': '警告：nsecの直接入力は安全性が低くなります。より良いセキュリティのためにNIP-07拡張機能をご使用ください。', 'connect.newToNostr': 'Nostrが初めてですか？', 'connect.createAccount': 'アカウント作成',
        // Private Key Modal
        'privateKey.title': 'あなたの秘密鍵', 'privateKey.warning': '重要：これを安全な場所に保存してください。この鍵を紛失すると、アカウントにアクセスできなくなります。絶対に誰にも共有しないでください！', 'privateKey.show': '秘密鍵を表示', 'privateKey.hide': '秘密鍵を隠す', 'privateKey.copy': 'コピー', 'privateKey.saved': '鍵を保存しました', 'privateKey.yourPublicKey': 'あなたの公開鍵 (npub):', 'privateKey.yourPrivateKey': 'あなたの秘密鍵 (nsec):',
        // Signup Modal
        'signup.title': 'Nostrアカウント作成', 'signup.whatIsNostr': 'Nostrとは？', 'signup.nostrDescription': 'Nostrは分散型プロトコルで、あなた自身のアイデンティティとデータを管理できます。中央サーバーはなく、アカウントは暗号鍵ペアです。', 'signup.whyNostr': 'なぜNostr？', 'signup.benefit1': 'アイデンティティの所有', 'signup.benefit2': '検閲なし', 'signup.benefit3': 'プラットフォーム間で移植可能', 'signup.createNew': '新規アカウント作成', 'signup.haveAccount': 'アカウントをお持ちですか？', 'signup.login': 'ログイン', 'signup.createButton': 'アカウント作成', 'signup.generating': '鍵を生成中...', 'signup.displayName': '表示名', 'signup.displayNamePlaceholder': '表示名を入力', 'signup.username': 'ユーザー名', 'signup.usernamePlaceholder': 'ユーザー名を入力', 'signup.about': '自己紹介（任意）', 'signup.profilePicture': 'プロフィール画像（任意）', 'signup.lightningAddress': 'Lightningアドレス（任意）', 'signup.nostrAddress': 'Nostrアドレス', 'signup.nostrAddressPlaceholder': 'ユーザー名', 'signup.nostrAddressHint': 'Nostrアドレスでプロフィールが見つけやすくなります。小文字、数字、_、-のみ使用可能。', 'signup.nostrAddressRequired': 'Nostrアドレスを入力してください', 'signup.nostrAddressAvailable': '利用可能！', 'signup.nostrAddressUnavailable': '既に使用されています', 'signup.nostrAddressChecking': '確認中...', 'signup.nostrAddressInvalid': '無効なユーザー名形式', 'signup.nostrAddressRegistering': 'Nostrアドレスを登録中...', 'signup.nostrAddressSuccess': 'Nostrアドレスが登録されました！', 'signup.nostrAddressFailed': 'Nostrアドレスを登録できませんでした', 'signup.createAccountBtn': 'アカウント作成', 'signup.termsAgree': 'アカウントを作成することで、', 'signup.and': 'と', 'signup.success': 'アカウントが正常に作成されました！', 'signup.yourPrivateKey': 'あなたの秘密鍵 (nsec)', 'signup.keyWarning': 'これがアカウントにアクセスする唯一の方法です。安全に保管してください！', 'signup.copyPrivateKey': '秘密鍵をコピー', 'signup.howToUseKey': '秘密鍵の使い方', 'signup.continueToPlebs': 'Plebsへ続ける', 'signup.step1': '安全に保存：', 'signup.step1Desc': 'nsecをパスワードマネージャーに保存するか、書き留めるか、暗号化ファイルに保存してください。公開しないでください！', 'signup.step2': '再ログイン：', 'signup.step2Desc': 'ログイン画面で「秘密鍵」をクリックしてnsecを貼り付けます。パスワードのように機能します。', 'signup.step3': '他のアプリで使用：', 'signup.step3Desc': 'nsecはすべてのNostrアプリ（Damus、Primal、Amethystなど）で使用できます！', 'signup.step4': '署名アプリの検討：', 'signup.step4Desc': 'より安全に、Amber（Android）やAlbyなどのブラウザ拡張機能で鍵を管理しましょう。',
        // Notifications
        'notifications.title': '通知', 'notifications.empty': '通知はありません', 'notifications.viewAll': 'すべての通知を見る', 'notifications.markAllRead': 'すべて既読にする', 'notifications.settings': '通知設定', 'notifications.loading': '通知を読み込み中...', 'notifications.zap': 'Zapを送りました', 'notifications.like': 'いいねしました', 'notifications.comment': 'コメントしました', 'notifications.follow': 'フォローしました', 'notifications.repost': 'リポストしました', 'notifications.mention': 'メンションしました',
        // Settings Modal
        'settings.title': '設定', 'settings.language': '言語', 'settings.languageDesc': '言語を選択', 'settings.saveToNostr': 'Nostrに保存', 'settings.darkMode': 'ダークモード', 'settings.darkModeDesc': 'ダーク/ライトテーマを切り替え', 'settings.autoplay': '自動再生', 'settings.autoplayDesc': '動画を自動再生', 'settings.saveSettings': '設定を保存', 'settings.resetDefaults': 'リセット', 'settings.notificationSettings': '通知設定', 'settings.notifications': '通知', 'settings.notificationsDesc': 'プッシュ通知を受け取る', 'settings.quality': 'デフォルト画質', 'settings.qualityDesc': '動画再生の画質', 'settings.contentWarning': 'コンテンツ警告設定', 'settings.showNsfwWarnings': 'NSFW警告を表示', 'settings.showNsfwWarningsDesc': 'NSFWコンテンツに年齢確認を表示', 'settings.showCommunityWarnings': 'コミュニティ警告を表示', 'settings.showCommunityWarningsDesc': 'フラグ付きまたは低評価のコンテンツに警告を表示', 'settings.showFollowsReportWarnings': 'フォロー中の報告警告を表示', 'settings.showFollowsReportWarningsDesc': 'フォロー中の5人以上がコンテンツを報告した場合に警告を表示', 'settings.filterPacks': 'コンテンツフィルターパック', 'settings.filterPacksDesc': 'フィルターパックを有効にして、特定のキーワードに一致するコンテンツを自動的に非表示にします。', 'settings.customKeywordFilter': 'カスタムキーワードフィルター', 'settings.customKeywordFilterPlaceholder': 'キーワードまたはフレーズをカンマ区切りで入力\n例：スパム、不要なコンテンツ、特定のフレーズ', 'settings.customKeywordFilterDesc': '独自のフィルターキーワードを追加（カンマ区切り）',
        // Upload Modal
        'upload.title': '動画をアップロード', 'upload.dragDrop': 'ここに動画ファイルをドロップ', 'upload.or': 'または', 'upload.browse': 'ファイルを選択', 'upload.supportedFormats': '対応形式: MP4, WebM, MOV', 'upload.maxSize': '最大ファイルサイズ: 2GB', 'upload.videoTitle': 'タイトル', 'upload.titlePlaceholder': '動画タイトルを入力', 'upload.description': '説明', 'upload.descriptionPlaceholder': '動画の説明...', 'upload.tags': 'タグ', 'upload.tagsPlaceholder': 'カンマ区切りでタグを追加', 'upload.visibility': '公開設定', 'upload.public': '公開', 'upload.unlisted': '限定公開', 'upload.uploadButton': '動画をアップロード', 'upload.uploading': 'アップロード中...', 'upload.processing': '処理中...', 'upload.complete': '完了！', 'upload.error': 'アップロード失敗', 'upload.nsfw': 'NSFWコンテンツ', 'upload.nsfwDesc': 'アダルトコンテンツとしてマーク', 'upload.thumbnail': 'サムネイル', 'upload.thumbnailDesc': 'サムネイルをアップロード', 'upload.preparing': '準備中...', 'upload.cancel': 'キャンセル', 'upload.progress': 'アップロード進捗', 'upload.transcoding': 'トランスコード中', 'upload.status.preparing': 'アップロード準備中...', 'upload.status.uploading': '動画をアップロード中...', 'upload.status.transcoding': '動画をトランスコード中...', 'upload.status.complete': 'アップロード完了！', 'upload.qualityHigh': '高', 'upload.qualityMedium': '中', 'upload.qualityLow': '低',
        // Create Modal
        'create.title': '作成', 'create.uploadVideo': '動画をアップロード', 'create.uploadDesc': '動画を共有', 'create.goLive': 'ライブ配信', 'create.goLiveDesc': 'ライブ配信を開始', 'create.createPost': '投稿を作成', 'create.createPostDesc': 'テキスト投稿を共有',
        // Go Live Modal
        'goLive.title': 'ライブ配信', 'goLive.streamTitle': '配信タイトル', 'goLive.streamTitlePlaceholder': '配信タイトルを入力', 'goLive.description': '説明', 'goLive.descriptionPlaceholder': '配信の説明...', 'goLive.category': 'カテゴリ', 'goLive.selectCategory': 'カテゴリを選択', 'goLive.tags': 'タグ', 'goLive.tagsPlaceholder': 'カンマ区切りでタグを追加', 'goLive.startStream': '配信開始', 'goLive.streamKey': 'ストリームキー', 'goLive.streamUrl': 'ストリームURL', 'goLive.copy': 'コピー', 'goLive.hideKey': 'キーを隠す', 'goLive.showKey': 'キーを表示', 'goLive.connecting': '接続中...', 'goLive.live': 'ライブ中', 'goLive.offline': 'オフライン', 'goLive.viewers': '視聴者', 'goLive.endStream': '配信終了', 'goLive.nsfw': 'NSFWコンテンツ', 'goLive.nsfwDesc': 'アダルトコンテンツとしてマーク', 'goLive.thumbnail': '配信サムネイル', 'goLive.thumbnailDesc': 'サムネイルをアップロード', 'goLive.zapGoal': 'Zap目標（オプション）', 'goLive.zapGoalLabel': 'Zap目標',
        // Video/Live No Description
        'video.noDescription': 'この動画に説明は追加されていません。', 'live.noDescription': 'この配信に説明は追加されていません。',
        // Edit Stream Modal
        'editStream.title': '配信を編集', 'editStream.save': '変更を保存',
        // Live Stream
        'live.live': 'ライブ', 'live.scheduled': '予定', 'live.ended': '配信終了', 'live.viewers': '視聴者', 'live.viewer': '視聴者', 'live.chat': 'ライブチャット', 'live.sendMessage': 'メッセージを送信...', 'live.send': '送信', 'live.goalReached': '目標達成！', 'live.goalProgress': '目標の {percent}%',
        // NSFW Warning Modal
        'nsfw.title': 'アダルトコンテンツの警告', 'nsfw.warning': 'このコンテンツはNSFW（職場閲覧注意）としてマークされており、アダルトコンテンツを含む可能性があります。', 'nsfw.confirm': '年齢を確認', 'nsfw.confirmAge': '18歳以上です', 'nsfw.cancel': '戻る', 'nsfw.continue': '続行', 'nsfw.dontShowAgain': 'この警告を表示しない',
        // Community Warning Modal
        'community.title': 'コミュニティガイドライン', 'community.warning': '続行する前にコミュニティガイドラインをご確認ください。', 'community.guidelines': '他者を尊重し、コミュニティ基準に従ってください。', 'community.accept': '同意する', 'community.decline': '同意しない',
        'communityWarning.title': 'コミュニティ警告', 'communityWarning.description': 'この動画はコミュニティによってフラグ付けされているか、多くの低評価を受けています。これは以下の理由が考えられます:', 'communityWarning.reason1': 'NSFWとして適切にマークされていない不適切なコンテンツ', 'communityWarning.reason2': '新規または不審なユーザー情報', 'communityWarning.reason3': '誤解を招くまたは虚偽の情報', 'communityWarning.reason4': 'スパムまたは低品質なコンテンツ', 'communityWarning.reason5': '潜在的に有害または違法なコンテンツ', 'communityWarning.proceed': '慎重に進んでください。', 'communityWarning.goBack': '戻る', 'communityWarning.viewAnyway': 'それでも見る',
        // Report Modal
        'report.title': 'コンテンツを報告', 'report.reason': '報告理由', 'report.selectReason': '理由を選択', 'report.spam': 'スパムまたは誤解を招く内容', 'report.inappropriate': '不適切なコンテンツ', 'report.violence': '暴力的または危険なコンテンツ', 'report.copyright': '著作権侵害', 'report.other': 'その他', 'report.details': '詳細', 'report.detailsPlaceholder': '詳細を入力...', 'report.submit': '報告を送信', 'report.cancel': 'キャンセル',
        // Share Modal
        'share.title': '共有', 'share.copyLink': 'リンクをコピー', 'share.embed': '埋め込みコード', 'share.copyEmbed': '埋め込みコードをコピー', 'share.social': 'SNSでシェア', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': 'メール', 'share.copied': 'コピーしました！', 'share.nostr': 'Nostrでシェア', 'share.generateImage': '画像を生成', 'share.downloadImage': 'ダウンロード', 'share.shareImage': 'シェア', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (正方形)', 'share.size1080x1920': '1080 × 1920 (ストーリー)',
        // Edit Video Modal
        'editVideo.title': '動画を編集', 'editVideo.videoTitle': 'タイトル', 'editVideo.description': '説明', 'editVideo.tags': 'タグ', 'editVideo.thumbnail': 'サムネイル', 'editVideo.changeThumbnail': 'サムネイルを変更', 'editVideo.visibility': '公開設定', 'editVideo.nsfw': 'NSFWコンテンツ', 'editVideo.save': '変更を保存', 'editVideo.delete': '動画を削除', 'editVideo.confirmDelete': 'この動画を削除しますか？',
        // Edit Profile Modal
        'editProfile.title': 'プロフィールを編集', 'editProfile.displayName': '表示名', 'editProfile.displayNamePlaceholder': '表示名を入力', 'editProfile.username': 'ユーザー名', 'editProfile.usernamePlaceholder': 'ユーザー名を入力', 'editProfile.about': '自己紹介', 'editProfile.aboutPlaceholder': '自己紹介を入力...', 'editProfile.website': 'ウェブサイト', 'editProfile.websitePlaceholder': 'https://yourwebsite.com', 'editProfile.lightning': 'Lightningアドレス', 'editProfile.lightningPlaceholder': 'you@getalby.com', 'editProfile.nip05': 'NIP-05認証', 'editProfile.nip05Placeholder': 'you@domain.com', 'editProfile.avatar': 'アバター', 'editProfile.changeAvatar': 'アバターを変更', 'editProfile.banner': 'バナー', 'editProfile.changeBanner': 'バナーを変更', 'editProfile.save': 'プロフィールを保存',
        // Confirmation Modal
        'confirm.title': '操作を確認', 'confirm.message': '続行しますか？', 'confirm.confirm': '確認', 'confirm.cancel': 'キャンセル',
        // Video Page
        'video.views': '回視聴', 'video.like': 'いいね', 'video.dislike': '低評価', 'video.share': '共有', 'video.save': '保存', 'video.report': '報告', 'video.follow': 'フォロー', 'video.unfollow': 'フォロー解除', 'video.subscribe': '登録', 'video.subscribed': '登録済み', 'video.comments': 'コメント', 'video.addComment': 'コメントを追加...', 'video.reply': '返信', 'video.replies': '件の返信', 'video.loadMore': 'もっと見る', 'video.noComments': 'コメントはありません。最初のコメントを投稿しましょう！', 'video.zap': 'Zap', 'video.zapAmount': 'Zap金額 (sats)', 'video.sendZap': 'Zapを送る', 'video.boost': 'ブースト', 'video.description': '説明', 'video.showMore': 'もっと見る', 'video.showLess': '折りたたむ', 'video.publishedOn': '公開日',
        // Toast Messages
        'toast.loggedIn': 'ログインしました！', 'toast.settingsSaved': '設定を保存しました！', 'toast.settingsLocal': '設定をローカルに保存しました。Nostrへの保存に失敗しました。', 'toast.settingsLocalOnly': '設定をローカルに保存しました！', 'toast.settingsReset': '設定を初期値に戻しました！', 'toast.avatarUploaded': 'アバターをアップロードしました！', 'toast.profileUpdated': 'プロフィールを更新しました！', 'toast.copied': 'クリップボードにコピーしました！', 'toast.copyFailed': 'コピーに失敗しました。手動でコピーしてください。', 'toast.installExtension': 'AlbyやNos2xなどのNostrブラウザ拡張をインストールしてください', 'toast.loginFailed': '拡張機能でのログインに失敗しました。再試行してください。', 'toast.invalidKey': '無効な秘密鍵です。確認して再試行してください。', 'toast.enterKey': '秘密鍵を入力してください', 'toast.enterUsername': 'ユーザー名を入力してください', 'toast.accountCreated': 'Plebsへようこそ！ログインしました。', 'toast.keyCopied': '秘密鍵をコピーしました！', 'toast.unmuted': 'ユーザーのミュートを解除しました', 'toast.unmuteFailed': 'ミュート解除に失敗しました', 'toast.selectImage': '画像ファイルを選択してください', 'toast.imageTooLarge': '画像は5MB以下にしてください', 'toast.avatarFailed': 'アバターのアップロードに失敗しました。再試行してください。', 'toast.mustBeLoggedIn': 'プロフィールを編集するにはログインが必要です', 'toast.enterDisplayName': '表示名を入力してください', 'toast.profileFailed': 'プロフィールの保存に失敗しました。再試行してください。', 'toast.invalidBunker': '有効なバンカーURLを入力してください', 'toast.connectFailed': '接続に失敗しました', 'toast.showingFiltered': 'フィルタリングされたコンテンツを表示中', 'toast.reportSubmitted': '報告を送信しました', 'toast.draftSaved': '下書きを保存しました！マイ動画から続けられます。', 'toast.draftLoaded': '下書きを読み込みました。アップロードを完了して公開してください。', 'toast.draftDeleted': '下書きを削除しました', 'toast.languageChanged': '言語を変更しました', 'toast.videoBlocked': '動画をブロックしてNostrに公開しました', 'toast.waitForUpload': '動画のアップロード完了をお待ちください', 'toast.enterTitle': 'タイトルを入力してください', 'toast.publishing': '動画をNostrに公開中...',
        // Time
        'time.justNow': 'たった今', 'time.secondAgo': '1秒前', 'time.secondsAgo': '{n}秒前', 'time.minuteAgo': '1分前', 'time.minutesAgo': '{n}分前', 'time.hourAgo': '1時間前', 'time.hoursAgo': '{n}時間前', 'time.dayAgo': '1日前', 'time.daysAgo': '{n}日前', 'time.weekAgo': '1週間前', 'time.weeksAgo': '{n}週間前', 'time.monthAgo': '1ヶ月前', 'time.monthsAgo': '{n}ヶ月前', 'time.yearAgo': '1年前', 'time.yearsAgo': '{n}年前',
        // Empty States
        'empty.noVideos': '動画が見つかりません', 'empty.noVideosDesc': '別の検索をお試しください', 'empty.noFollowing': 'まだ誰もフォローしていません', 'empty.noFollowingDesc': 'クリエイターをフォローして動画を見る', 'empty.noHistory': '視聴履歴はありません', 'empty.noHistoryDesc': '視聴した動画がここに表示されます', 'empty.noLiked': 'いいねした動画はありません', 'empty.noLikedDesc': 'いいねした動画がここに表示されます', 'empty.noResults': '結果が見つかりません', 'empty.noResultsDesc': '別のキーワードをお試しください',
        // Misc
        'misc.loading': '読み込み中...', 'misc.loadingMore': 'さらに読み込み中...', 'misc.refresh': '更新', 'misc.retry': '再試行', 'misc.close': '閉じる', 'misc.back': '戻る', 'misc.next': '次へ', 'misc.previous': '前へ', 'misc.search': '検索', 'misc.filter': 'フィルター', 'misc.sort': '並び替え', 'misc.newest': '新しい順', 'misc.oldest': '古い順', 'misc.popular': '人気', 'misc.trending': 'トレンド', 'misc.sats': 'sats', 'misc.all': 'すべて', 'misc.copiedToClipboard': 'クリップボードにコピーしました！',
        // Common
        'common.submit': '送信', 'common.cancel': 'キャンセル', 'common.save': '保存', 'common.delete': '削除', 'common.edit': '編集', 'common.close': '閉じる', 'common.confirm': '確認', 'common.yes': 'はい', 'common.no': 'いいえ', 'common.ok': 'OK', 'common.loading': '読み込み中...', 'common.uploading': 'アップロード中...', 'common.error': 'エラー', 'common.success': '成功',
        // Aria Labels
        'aria.toggleMenu': 'メニューを切り替え', 'aria.mainNavigation': 'メインナビゲーション', 'aria.videoContent': '動画コンテンツ', 'aria.loadingContent': 'コンテンツを読み込み中', 'aria.closeModal': 'モーダルを閉じる', 'aria.playVideo': '動画を再生', 'aria.pauseVideo': '動画を一時停止', 'aria.muteVideo': 'ミュート', 'aria.unmuteVideo': 'ミュート解除', 'aria.fullscreen': 'フルスクリーン', 'aria.exitFullscreen': 'フルスクリーン解除', 'aria.settings': '設定', 'aria.notifications': '通知', 'aria.userMenu': 'ユーザーメニュー', 'aria.searchInput': '動画を検索', 'aria.videoPlayer': '動画プレイヤー',
        // Dynamic JavaScript text
        'button.hideQR': 'QRコードを隠す', 'button.showQR': 'QRコードを表示', 'button.copied': 'コピーしました！', 'button.showLess': '少なく表示', 'button.showMore': 'もっと見る', 'button.creatingAccount': 'アカウント作成中...', 'button.submitting': '送信中...', 'button.scheduleStream': '配信を予約', 'button.goLive': 'ライブ開始', 'button.creatingStream': '配信を作成中...', 'button.continueCustomAmount': 'カスタム金額で続行', 'button.recordFromCamera': 'カメラから録画', 'button.requestingCamera': 'カメラを要求中...', 'button.recording': '録画中...',
        'status.saving': '保存中...', 'status.saved': '保存しました！', 'status.uploading': 'アップロード中...', 'status.uploadComplete': 'アップロード完了！', 'status.uploadingToNostrBuild': 'nostr.buildにアップロード中...', 'status.publishingChanges': '変更を公開中...', 'status.removingOldVersion': '古いバージョンを削除中...', 'status.validatingThumbnail': 'サムネイルを検証中...', 'status.uploadingThumbnail': 'サムネイルをアップロード中...', 'status.thumbnailUploaded': 'サムネイルアップロード完了！', 'status.processingVideo': '動画を処理中...', 'status.compressingVideo': '動画を圧縮中...', 'status.uploadingVideo': '動画をアップロード中...', 'status.videoUploaded': '動画のアップロードに成功しました！', 'status.processing': '処理中...', 'status.generatingThumbnail': 'サムネイルを生成中...', 'status.generatingPreview': 'プレビューを生成中...', 'status.uploadingPreview': 'プレビューをアップロード中...', 'status.publishing': '公開中...', 'status.publishingToNostr': 'Nostrに公開中...', 'status.publishingVideoToNostr': '動画をNostrに公開中...', 'status.generatingPoW': 'プルーフオブワークを生成中...', 'status.posting': '投稿中...', 'status.processingVideoAndThumbnail': '動画とサムネイルを処理中...', 'status.uploadFailed': 'アップロード失敗 - 再試行してください', 'status.selectVideoToUpload': 'アップロードする動画を選択', 'status.waitingForVideoUpload': '動画のアップロードを待っています...', 'status.selectVideoAndThumbnail': '公開する動画とサムネイルを選択', 'status.ready': '準備完了 ✓', 'status.failed': '失敗 ✗', 'status.fromDraft': '下書きから', 'status.startingNow': 'まもなく開始！', 'status.ended': '終了', 'status.thumbnailReady': '準備完了', 'status.thumbnailFailed': '失敗', 'status.uploadFailedRetry': 'アップロード失敗。再試行してください。',
        'publish.video': '動画を公開', 'publish.autoThumbnail': '動画を公開（自動サムネイル）',
        'report.titleComment': 'コメントを報告', 'report.titleUser': 'ユーザーを報告', 'report.titleVideo': '動画を報告', 'report.descComment': 'このコメントを報告する理由を選択:', 'report.descUser': 'このユーザーを報告する理由を選択:', 'report.descVideo': 'このコンテンツを報告する理由を選択:',
        'empty.noMutedUsers': 'ミュートしているユーザーはいません。', 'empty.noVideosToMonitor': '監視する動画がありません。', 'empty.noRecentActivity': '最近のアクティビティはありません。', 'empty.failedLoadNotifications': '通知の読み込みに失敗しました', 'empty.loginToViewLiked': '<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">ログイン</a>していいねした動画を見る。', 'empty.loginToViewFollowing': '<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">ログイン</a>してフォローを見る。', 'empty.loginToViewVideos': '<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">ログイン</a>して動画を見る。', 'empty.loginToViewAnalytics': '<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">ログイン</a>して統計を見る。', 'empty.noLikedVideosYet': 'まだ動画にいいねしていません。', 'empty.noLikedVideosFound': 'いいねした動画が見つかりません。', 'empty.noFullLengthLikedVideos': 'いいねした長編動画が見つかりません。', 'empty.noWatchHistory': '視聴履歴がありません。動画を見てみましょう。', 'empty.noVideosInHistory': '履歴に動画がありません。', 'empty.noFullLengthHistory': '履歴に長編動画がありません。', 'empty.noMatchingVideos': '一致する動画が見つかりません。', 'empty.noFullLengthVideos': '長編動画が見つかりません。', 'empty.failedLoadTrending': 'トレンドの読み込みに失敗しました。', 'empty.noTrendingVideos': 'トレンド動画が見つかりません。', 'empty.noMatchingUsers': '一致するユーザーが見つかりません。', 'empty.unableLoadProfiles': 'プロフィールを読み込めません。', 'empty.noFollowingVideos': 'フォロー中のユーザーの動画がまだありません。', 'empty.noFullLengthFollowing': 'フォロー中の長編動画がありません。', 'empty.failedLoadFollowing': '読み込みに失敗しました。再試行してください。', 'empty.noVideosUploadFirst': '動画がありません。最初の動画をアップロード！', 'empty.noFullLengthUploaded': '長編動画が見つかりません。', 'empty.noMatchingLiveStreams': '一致するライブ配信が見つかりません。', 'empty.noMatchingShorts': '一致するショート動画が見つかりません。', 'empty.noVideosForTag': 'このタグの動画がありません。', 'empty.noFullLengthForTag': 'このタグの長編動画がありません。', 'empty.noUploadedVideos': 'まだ動画がアップロードされていません。', 'empty.noVideosFound': '動画が見つかりません。', 'empty.failedLoadProfile': 'プロフィールの読み込みに失敗しました。再試行してください。', 'empty.noComments': 'まだコメントがありません。最初のコメントを！', 'empty.failedLoadComments': 'コメントの読み込みに失敗しました', 'empty.noLiveNow': '今は誰もライブしていません。最初になりましょう！',
        'error.videoNotFound': '動画が見つかりません。', 'error.contentNotAvailable': 'このコンテンツは利用できません。', 'error.invalidVideoData': '無効な動画データです。', 'error.videoNotAvailable': '動画が利用できません。ファイルが削除された可能性があります。', 'error.failedLoadVideo': '動画の読み込みに失敗しました。再試行してください。', 'error.failedLoadVideoShort': '読み込みに失敗。ファイルが削除された可能性があります。', 'error.liveStreamNotFound': 'ライブ配信が見つかりません。', 'error.invalidLiveStreamData': '無効なライブ配信データです。', 'error.failedLoadLiveStream': 'ライブ配信の読み込みに失敗しました。',
        // New Button & Action Labels
        'button.follow': 'フォロー', 'button.unfollow': 'フォロー解除', 'button.mute': 'ミュート', 'button.unmute': 'ミュート解除', 'button.muteUser': 'ユーザーをミュート', 'button.unmuteUser': 'ミュート解除', 'button.confirm': '確認', 'button.cancel': 'キャンセル', 'button.close': '閉じる', 'button.boost': 'ブースト', 'button.zap': 'Zap', 'button.viewMore': 'もっと見る', 'button.viewAnalytics': '統計を見る', 'button.backToMyVideos': 'マイ動画に戻る', 'button.editDraft': '下書きを編集', 'button.deleteDraft': '下書きを削除', 'button.editVideo': '動画を編集', 'button.deleteVideo': '動画を削除', 'button.editShort': 'ショートを編集', 'button.deleteShort': 'ショートを削除', 'button.editStream': '配信を編集', 'button.endStream': '配信を終了', 'button.reset': 'リセット', 'button.download': 'ダウンロード', 'button.watchRecording': '録画を見る', 'button.show': '表示', 'button.login': 'ログイン', 'button.toggleChat': 'チャット切替', 'button.blockVideo': '動画をブロック', 'button.blockUser': 'ユーザーをブロック', 'button.unblock': 'ブロック解除', 'button.removeFromHistory': '履歴から削除',
        // New Stats & Counts
        'stat.views': '回視聴', 'stat.viewsCount': '{count}回視聴', 'stat.videos': '本の動画', 'stat.video': '本の動画', 'stat.followers': '人のフォロワー', 'stat.follower': '人のフォロワー', 'stat.following': 'フォロー中', 'stat.subscribers': '人の登録者', 'stat.comments': 'コメント', 'stat.liveCount': '{count}件ライブ中', 'stat.percentOfGoal': '目標の{percent}%', 'stat.netGrowth': '純増', 'stat.newFollowers': '新規フォロワー', 'stat.unfollowed': 'フォロー解除', 'stat.lastUpdated': '最終更新: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'ライブ', 'badge.ended': '終了', 'badge.scheduled': '予定', 'badge.warning': '警告', 'badge.communityWarning': 'コミュニティ警告', 'badge.verifiedNip05': 'NIP-05認証済み', 'badge.streamer': '配信者', 'badge.clickToView': 'クリックして表示',
        // New Actions
        'action.report': '報告', 'action.reportComment': 'コメントを報告', 'action.reportVideo': 'この動画を報告', 'action.reportStream': 'この配信を報告', 'action.like': 'いいね', 'action.dislike': '低評価', 'action.reply': '返信',
        // New Placeholders
        'placeholder.searchHistory': '履歴を検索...', 'placeholder.searchUsers': 'ユーザーを検索...', 'placeholder.searchMyVideos': 'マイ動画を検索...', 'placeholder.eventId': 'イベントID入力 (hex or nevent/note)', 'placeholder.pubkey': 'pubkey入力 (hex or npub)', 'placeholder.customAmount': 'カスタム金額', 'placeholder.chatEnded': 'チャット終了 - 配信は終了しました', 'placeholder.addComment': 'コメントを追加...', 'placeholder.setNewGoal': '新しい目標を設定 (sats)',
        // New Video & Content
        'video.untitledVideo': '無題の動画', 'video.untitledShort': '無題のショート', 'video.upNext': '次の動画', 'video.noVideosYet': '動画はまだありません', 'video.noShortsYet': 'ショートはまだありません', 'video.noLiveStreamsYet': 'ライブ配信はまだありません', 'video.noBlockedVideos': 'ブロックされた動画はありません', 'video.noBlockedUsers': 'ブロックされたユーザーはいません',
        // New Stream Messages
        'stream.ended': 'この配信は終了しました。チャットは閉鎖されました。', 'stream.welcomeChat': 'ライブチャットへようこそ！', 'stream.goalReached': '目標達成！', 'stream.zapGoalReached': 'Zap目標達成！{amount} sats！',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'ミュートされたユーザーからのメッセージ', 'muted.commentFromMutedUserHidden': 'ミュートされたユーザーのコメントは非表示', 'muted.commentHidden': 'コメントは非表示 ({packs})', 'muted.messageHidden': 'メッセージは非表示 ({packs})', 'muted.commentReportedByFollows': 'フォロー中のユーザーが報告したコメント', 'muted.messageReportedByFollows': 'フォロー中のユーザーが報告したメッセージ', 'muted.commentHeavilyDownvoted': 'コミュニティで大量に低評価されたコメント', 'muted.messageHeavilyDownvoted': '大量に低評価されたメッセージ',
        // New Admin & Lists
        'list.blockedVideos': 'ブロックされた動画', 'list.blockedUsers': 'ブロックされたユーザー',
        // New Alerts
        'alert.cameraNotSupported': 'このブラウザではカメラアクセスがサポートされていません。Chrome、Firefox、Safariなどの最新ブラウザをお使いください。', 'alert.noCameraFound': 'カメラが見つかりません。カメラを接続するか、ファイルアップロードをお使いください。', 'alert.cameraAccessDenied': 'カメラアクセスが拒否されました。ブラウザ設定でカメラを許可してください。', 'alert.cameraInUse': 'カメラは他のアプリで使用中です。他のアプリを閉じてください。', 'alert.cameraUnableAccess': 'カメラにアクセスできません。ファイルアップロードをお試しください。', 'alert.cameraUnableAccessWithError': 'カメラにアクセスできません: {error}\n\nファイルアップロードをお使いください。', 'alert.fillRequiredFields': '必須項目をすべて入力してください', 'alert.uploadThumbnail': '配信のサムネイルをアップロードしてください', 'alert.failedCreateStream': '配信の作成に失敗しました。再度お試しください。', 'alert.failedUpdateStream': '更新に失敗しました。再度お試しください。', 'alert.streamNotFound': '配信が見つかりません', 'alert.canOnlyEditOwnStreams': '自分の配信のみ編集できます', 'alert.invalidStreamData': '配信データが無効です', 'alert.enterValidGoalAmount': '有効な目標金額を入力してください', 'alert.canOnlyResetOwnGoals': '自分の目標のみリセットできます', 'alert.streamEventNotFound': '配信イベントが見つかりません', 'alert.failedResetZapGoal': 'Zap目標のリセットに失敗しました。再度お試しください。', 'alert.cannotBlockAdmin': '管理者アカウントはブロックできません', 'alert.analyticsLoadFailed': '統計の読み込みに失敗しました。再度お試しください。', 'alert.cannotReplaceShortWithVideo': 'ショートを通常動画で置き換えることはできません。縦動画（60秒以下）をアップロードしてください。', 'alert.cannotReplaceVideoWithShort': '通常動画をショートで置き換えることはできません。横動画をアップロードしてください。', 'alert.shortsRequireVertical': 'この動画は横動画のようです。ショートは縦動画である必要があります。横動画には「動画をアップロード」をお使いください。',
        // New Zap Messages
        'zap.cannotZapYourself': '自分にZapを送ることはできません', 'zap.cannotZapOwnContent': '自分のコンテンツにZapを送ることはできません', 'zap.cannotZapOwnComment': '自分のコメントにZapを送ることはできません', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': '動画を読み込み中...', 'status.loading': '読み込み中...', 'status.compressingProgress': '圧縮中... {progress}%', 'status.uploadingProgress': 'アップロード中... {progress}%', 'status.uploadingServers': 'アップロード中... ({completed}/{total} サーバー)', 'status.publishedSuccess': '{type}が正常に公開されました！',
        // New Warnings
        'warning.webmFormat': '注意: ブラウザはWebM形式で出力します（iOSでは再生できない場合があります）。iOS互換のMP4にはWindows/MacのChromeをお使いください。',
        // New Footer
        'footer.lastUpdated': '最終更新: 2024年12月',
        // DMCA Page
        'dmca.title': 'DMCA とコンテンツポリシー',
        'dmca.lastUpdated': '最終更新: 2024年12月',
        'dmca.architectureTitle': 'Plebs のアーキテクチャを理解する',
        'dmca.architectureDesc': 'Plebs は従来の動画ホスティングサービスとは異なる方法で動作する分散型ビデオプラットフォームインターフェースです。当プラットフォームでのコンテンツの配信方法を理解することが重要です：',
        'dmca.architectureItem1': 'Plebs は動画や画像コンテンツをホストしていません。',
        'dmca.architectureItem1Desc': '私たちは他の場所に保存されたコンテンツを表示するクライアント/インターフェースです。',
        'dmca.architectureItem2': 'すべてのメディアファイル（動画、画像、サムネイル）は第三者が運営する独立したBlossomサーバーに保存されています。',
        'dmca.architectureItem3': '動画のメタデータ（タイトル、説明など）は独立して運営されるNostrリレーに公開されます。',
        'dmca.architectureItem4': 'Plebs は単にこれらの分散コンテンツをユーザーフレンドリーなインターフェースを通じて集約・表示しています。',
        'dmca.filingTitle': 'DMCA 申請の提出',
        'dmca.filingDesc': 'Plebs はコンテンツをホストしていないため、侵害コンテンツを直接削除することはできません。著作権侵害に対処するには、適切な当事者に連絡する必要があります：',
        'dmca.forVideoTitle': '1. 動画/画像コンテンツについて',
        'dmca.forVideoDesc': 'メディアファイルはBlossomサーバーに保存されています。以下が必要です：',
        'dmca.forVideoItem1': 'コンテンツをホストしているBlossomサーバーを特定する（URLに表示されます）',
        'dmca.forVideoItem2': 'BlossomサーバーオペレーターにDMCA削除リクエストを直接連絡する',
        'dmca.forVideoItem3': '各Blossomサーバーは独立して運営されており、独自のポリシーがあります',
        'dmca.forMetadataTitle': '2. メタデータ/説明について',
        'dmca.forMetadataDesc': '侵害コンテンツが動画タイトル、説明、その他のメタデータに含まれている場合：',
        'dmca.forMetadataItem1': 'この情報はNostrリレーに保存されています',
        'dmca.forMetadataItem2': 'コンテンツが表示される特定のNostrリレーオペレーターに連絡してください',
        'dmca.forMetadataItem3': 'Nostrの分散型の性質により、複数のリレーが同じデータを保存している場合があります',
        'dmca.whatWeCanDoTitle': 'Plebs ができること',
        'dmca.whatWeCanDoDesc': 'コンテンツをホストしていませんが、以下のことができます：',
        'dmca.whatWeCanDoItem1': '特定のコンテンツをホストしているBlossomサーバーやリレーの特定を支援',
        'dmca.whatWeCanDoItem2': 'コンテンツをローカルブロックリストに追加し、当インターフェースに表示されないようにする（注意：これはplebs.appにのみ影響し、他のNostrクライアントには影響しません）',
        'dmca.whatWeCanDoItem3': '適切なサービスオペレーターへの連絡方法のガイダンスを提供',
        'dmca.toRequestAssistance': '支援をリクエストするには、以下を添えてご連絡ください：',
        'dmca.assistanceItem1': '侵害コンテンツのURLまたは識別子',
        'dmca.assistanceItem2': '著作権所有の証明',
        'dmca.assistanceItem3': '著作権で保護された作品の説明',
        'dmca.blossomOperatorsTitle': 'Blossom サーバーオペレーター',
        'dmca.blossomOperatorsDesc': 'Blossomサーバーを運営していてDMCA削除リクエストを受け取った場合、管轄区域の法律に従って処理する責任があります。',
        'dmca.blossomOperatorsLink': '既知のBlossomサーバーのリストについては、Blossomプロジェクトのドキュメントを参照してください。',
        'dmca.considerationsTitle': '重要な考慮事項',
        'dmca.considerationsItem1': '分散化：',
        'dmca.considerationsItem1Desc': 'NostrとBlossomの分散型の性質により、すべてのソースからコンテンツを完全に削除することは不可能な場合があります。',
        'dmca.considerationsItem2': '複数のコピー：',
        'dmca.considerationsItem2Desc': 'コンテンツは複数のBlossomサーバーやリレーに存在する場合があります。複数のオペレーターに連絡する必要があるかもしれません。',
        'dmca.considerationsItem3': 'ハッシュベースのストレージ：',
        'dmca.considerationsItem3Desc': 'Blossomはコンテンツアドレス型ストレージを使用しています。同じファイルはどのサーバーでも同じハッシュを持ちます。',
        'dmca.considerationsItem4': '中央管理なし：',
        'dmca.considerationsItem4Desc': 'Plebsも他の単一の組織も、ネットワーク全体からコンテンツを削除する能力を持っていません。',
        'dmca.counterNotificationTitle': '対抗通知',
        'dmca.counterNotificationDesc': 'コンテンツがBlossomサーバーから誤って削除されたと思われる場合は、そのサーバーオペレーターに直接連絡して対抗通知を提出してください。',
        'dmca.contactTitle': 'お問い合わせ',
        'dmca.contactDesc': 'このポリシーに関する質問やコンテンツホストの特定についてのサポートは',
        'dmca.contactLink': 'お問い合わせください',

        // Analytics
        'analytics.title': 'チャンネル分析',
        'analytics.description': 'チャンネルのパフォーマンス指標とインサイトを確認できます。',
        'analytics.loading': '分析データを読み込み中...',
        'analytics.error': '分析データの読み込みに失敗しました',
        'analytics.overview': '概要',
        'analytics.videos': '動画',
        'analytics.engagement': 'エンゲージメント',
        'analytics.totalViews': '総再生回数',
        'analytics.totalVideos': '総動画数',
        'analytics.totalLikes': '総いいね数',
        'analytics.totalZaps': '総Zaps',
        'analytics.avgViews': '平均再生回数',
        'analytics.avgLikes': '平均いいね数',
        'analytics.avgZaps': '平均Zaps',
        'analytics.viewsOverTime': '再生回数の推移',
        'analytics.topVideos': '人気動画',
        'analytics.recentActivity': '最近のアクティビティ',
        'analytics.viewsLabel': '再生回数',
        'analytics.likesLabel': 'いいね',
        'analytics.zapsLabel': 'Zaps',
        'analytics.dateLabel': '日付',
        'analytics.videoTitle': '動画タイトル',
        'analytics.performance': 'パフォーマンス',
        'analytics.noData': '分析データがありません',
        'analytics.noDataDesc': '動画をアップロードして分析を開始しましょう。',
        'analytics.last7Days': '過去7日間',
        'analytics.last30Days': '過去30日間',
        'analytics.last90Days': '過去90日間',
        'analytics.allTime': '全期間',
        'analytics.views': '再生',
        'analytics.likes': 'いいね',
        'analytics.zaps': 'Zaps',
        'analytics.rank': '順位',
        'analytics.noVideos': '動画がありません',
        'analytics.noVideosDesc': '最初の動画をアップロードしてパフォーマンスを追跡しましょう。',

        // About Page
        'about.title': 'Plebs.placeについて',
        'about.subtitle': '分散型ビデオプラットフォーム',
        'about.welcome': 'Plebs.placeへようこそ',
        'about.description': 'Plebs.placeはNostrプロトコル上に構築された分散型ビデオ共有プラットフォームで、クリエイターがコンテンツと視聴者を完全にコントロールできます。',
        'about.feature1Title': '分散型',
        'about.feature1Desc': 'Nostr上に構築されており、検閲耐性と真のコンテンツ所有権を確保します。',
        'about.feature2Title': 'クリエイター優先',
        'about.feature2Desc': 'コンテンツ、データ、視聴者との関係を完全にコントロールできます。',
        'about.feature3Title': 'ビットコインで収益化',
        'about.feature3Desc': 'ライトニングネットワークとZapsを通じて視聴者から直接サポートを受け取れます。',
        'about.feature4Title': 'オープンソース',
        'about.feature4Desc': '分散化の理念に沿った、透明でコミュニティ主導の開発です。',
        'about.missionTitle': '私たちのミッション',
        'about.missionDesc': '検閲、プラットフォームロックイン、恣意的なルール変更のないビデオプラットフォームを作ること。あなたのコンテンツはあなたのものです。',
        'about.techTitle': 'テクノロジー',
        'about.techDesc': 'Nostrで認証とソーシャル機能、ライトニングで即時マイクロペイメント、分散型ストレージソリューションで構築されています。',

        // Contact Page
        'contact.title': 'お問い合わせ',
        'contact.subtitle': '連絡先',
        'contact.description': 'ご質問、フィードバック、提案がありましたらお聞かせください。',
        'contact.nostrTitle': 'Nostrでフォロー',
        'contact.nostrDesc': 'Nostrでフォローして最新情報やコミュニティの議論に参加しましょう。',
        'contact.githubTitle': 'GitHub',
        'contact.githubDesc': 'ソースコードの閲覧、問題の報告、プロジェクトへの貢献ができます。',
        'contact.emailTitle': 'メール',
        'contact.emailDesc': 'ビジネスに関するお問い合わせやサポートはチームまでご連絡ください。',

        // Terms Page
        'terms.title': '利用規約',
        'terms.lastUpdated': '最終更新日',
        'terms.section1Title': '1. 規約への同意',
        'terms.section1Content': 'Plebs.placeを使用することで、これらの規約に拘束されることに同意したものとみなされます。同意されない場合は、プラットフォームを使用しないでください。',
        'terms.section2Title': '2. サービスの説明',
        'terms.section2Content': 'Plebs.placeはNostrプロトコルを活用した分散型ビデオ共有プラットフォームです。動画のホスティング、共有、ライトニングネットワークによる収益化ツールを提供しています。',
        'terms.section3Title': '3. ユーザーの責任',
        'terms.section3Content': 'プラットフォームを通じて投稿するすべてのコンテンツについて、あなたが責任を負います。違法、有害、または他者の権利を侵害するコンテンツをアップロードしないことに同意するものとします。',
        'terms.section4Title': '4. コンテンツの所有権',
        'terms.section4Content': 'あなたのコンテンツの完全な所有権はあなたにあります。アップロードすることで、Plebs.placeにあなたの動画をホストし提供するための限定的なライセンスを付与します。',
        'terms.section5Title': '5. 禁止事項',
        'terms.section5Content': '違法行為、ハラスメント、スパム、有害コンテンツの配布にプラットフォームを使用することはできません。',
        'terms.section6Title': '6. アカウント管理',
        'terms.section6Content': 'Nostrキーを適切に管理してアカウントを保護する責任はあなたにあります。私たちはあなたの秘密鍵を保存しておらず、失われたアカウントを復旧することはできません。',
        'terms.section7Title': '7. 支払い条件',
        'terms.section7Content': 'すべての支払いはライトニングネットワークを通じて処理されます。取引は最終的で不可逆です。支払い前にすべての詳細を確認してください。',
        'terms.section8Title': '8. 責任の制限',
        'terms.section8Content': 'Plebs.placeは保証なしで「現状のまま」提供されます。いかなる損失、損害、またはサービスの中断についても責任を負いません。',
        'terms.section9Title': '9. 規約の変更',
        'terms.section9Content': 'これらの規約は随時更新される場合があります。継続して使用することは、更新された規約への同意を意味します。',

        // Privacy Page
        'privacy.title': 'プライバシーポリシー',
        'privacy.lastUpdated': '最終更新日',
        'privacy.section1Title': '1. はじめに',
        'privacy.section1Content': 'このプライバシーポリシーは、Plebs.placeの分散型ビデオプラットフォームの使用に関連する情報の取り扱いについて説明します。',
        'privacy.section2Title': '2. 収集する情報',
        'privacy.section2Content': '分散型プラットフォームとして、最小限のデータのみを収集します。Nostr公開鍵は認証に使用され、動画メタデータはNostrリレーに保存されます。',
        'privacy.section3Title': '3. データの保存',
        'privacy.section3Content': 'コンテンツは分散型ストレージソリューションに保存されます。中央サーバーに個人データは保存しません。秘密鍵は私たちと共有されることはありません。',
        'privacy.section4Title': '4. データの使用',
        'privacy.section4Content': '収集したデータはプラットフォームサービスの提供と改善にのみ使用します。データを第三者に販売することは一切ありません。',
        'privacy.section5Title': '5. Cookieとトラッキング',
        'privacy.section5Content': '基本機能のために最小限のCookieを使用します。広告トラッキングやマーケティング目的のデータ収集は行いません。',
        'privacy.section6Title': '6. サードパーティサービス',
        'privacy.section6Content': 'Nostrリレーやライトニングネットワークノードと連携しています。これらのサービスには独自のプライバシーポリシーがあります。',
        'privacy.section7Title': '7. データセキュリティ',
        'privacy.section7Content': '分散型アーキテクチャを通じてあなたの情報を保護します。ただし、秘密鍵を保護する責任はあなたにあります。',
        'privacy.section8Title': '8. あなたの権利',
        'privacy.section8Content': 'あなたのデータを完全にコントロールできます。いつでもコンテンツを削除したり、プラットフォームの使用を停止したりできます。',
        'privacy.section9Title': '9. 子どものプライバシー',
        'privacy.section9Content': 'Plebs.placeは13歳未満のお子様向けではありません。未成年者の情報を意図的に収集することはありません。',
        'privacy.section10Title': '10. ポリシーの変更',
        'privacy.section10Content': 'このプライバシーポリシーを更新する場合があります。変更はこのページに更新日とともに掲載されます。',

        // FAQ Page
        'faq.title': 'よくある質問',
        'faq.subtitle': 'よくある質問と回答',
        'faq.general': '一般',
        'faq.technical': '技術',
        'faq.monetization': '収益化',
        'faq.content': 'コンテンツ',
        'faq.q1': 'Plebs.placeとは何ですか？',
        'faq.a1': 'Plebs.placeはNostrプロトコル上に構築された分散型ビデオ共有プラットフォームで、コンテンツと視聴者を完全に所有できます。',
        'faq.q2': 'Plebs.placeはどのように機能しますか？',
        'faq.a2': 'プラットフォームはNostrで認証とソーシャル機能、分散型ストレージで動画ホスティング、ライトニングネットワークで即時支払いを行います。',
        'faq.q3': 'Plebs.placeは無料で使えますか？',
        'faq.a3': 'はい、アカウント作成、アップロード、視聴は無料です。始めるにはNostrキーが必要です。',
        'faq.q4': 'Nostrとは何ですか？',
        'faq.a4': 'Nostrは分散型通信プロトコルで、中央集権的なプラットフォームに依存せずにアイデンティティとデータをコントロールできます。',
        'faq.q5': 'アカウントを作成するにはどうすればいいですか？',
        'faq.a5': 'AlbyやNos2xなどのNostrブラウザ拡張機能でサインインするか、新しいNostrキーを生成できます。',
        'faq.q6': 'どの動画形式がサポートされていますか？',
        'faq.a6': 'MP4、WebM、MOVなど、ほとんどの一般的な形式をサポートしています。動画はアップロード後にトランスコードされます。',
        'faq.q7': '動画はどこに保存されますか？',
        'faq.a7': '動画は分散型ストレージソリューションに保存され、コンテンツが単一のサーバーに支配されないようになっています。',
        'faq.q8': 'ライトニングネットワークとは何ですか？',
        'faq.a8': 'ライトニングネットワークはビットコインのレイヤー2決済プロトコルで、即時かつ低手数料の取引を可能にします。',
        'faq.q9': 'Zapsとは何ですか？',
        'faq.a9': 'Zapsはライトニングネットワークを通じて送られるビットコインのマイクロペイメントで、クリエイターをサポートするために使用されます。',
        'faq.q10': 'コンテンツをどのように収益化できますか？',
        'faq.a10': 'クリエイターは視聴者のZaps、有料コンテンツ、ライトニング経由の直接寄付で収入を得ることができます。',
        'faq.q11': '収益を引き出すにはどうすればいいですか？',
        'faq.a11': '収益はライトニングウォレットに直接届きます。最低引き出し額や待機期間はありません。',
        'faq.q12': 'どのようなコンテンツが許可されていますか？',
        'faq.a12': '合法的なコンテンツは歓迎です。利用規約を遵守し、有害または違法なコンテンツは避けてください。',
        'faq.q13': '動画を削除できますか？',
        'faq.a13': 'はい、いつでも動画を削除できます。分散型の性質上、すでに配布されたコピーは他のノードに残る場合があります。',
        'faq.q14': 'コンテンツモデレーションはありますか？',
        'faq.a14': '分散型プラットフォームとして、モデレーションはコミュニティ主導のアプローチとユーザーコントロールを通じて行われます。',
        'faq.q15': '問題のあるコンテンツを報告するにはどうすればいいですか？',
        'faq.a15': '動画の報告機能を使用するか、連絡先情報を通じてお知らせください。コミュニティからのフィードバックがプラットフォームの品質維持に役立ちます。',
        // FAQ Self-Moderation Section
        'faq.selfModeration': 'セルフモデレーション',
        'faq.q16': '分散型プラットフォームではモデレーションはどのように機能しますか？',
        'faq.a16': '中央管理者を持つ従来のプラットフォームとは異なり、Plebsはあなたが見るものをコントロールします。コンテンツフィルターパック、ユーザーミュート、コミュニティ警告、レシオ動画インジケーターなど、強力なセルフモデレーションツールを提供しています。何が適切なコンテンツかを決めるのはあなた自身です - 中央権限がその決定を下すことはありません。',
        'faq.q17': 'コンテンツフィルターパックとは何ですか？',
        'faq.a17Intro': 'コンテンツフィルターパックは、特定の種類のコンテンツを非表示にするために有効にできる事前定義されたキーワードフィルターです。利用可能なパックには以下が含まれます：',
        'faq.a17Pack1': '人種差別とヘイトスピーチ：',
        'faq.a17Pack1Desc': '人種的中傷や差別的なコンテンツをフィルタリング',
        'faq.a17Pack2': '性的に露骨な内容：',
        'faq.a17Pack2Desc': 'ポルノや成人向けコンテンツをフィルタリング',
        'faq.a17Pack3': '暴力とゴア：',
        'faq.a17Pack3Desc': 'グラフィック暴力や自傷行為のコンテンツをフィルタリング',
        'faq.a17Pack4': '薬物と物質：',
        'faq.a17Pack4Desc': '薬物関連のコンテンツをフィルタリング',
        'faq.a17Pack5': 'スパムと詐欺：',
        'faq.a17Pack5Desc': '一般的なスパムや詐欺のパターンをフィルタリング',
        'faq.a17Pack6': '暗号通貨：',
        'faq.a17Pack6Desc': '暗号通貨のプロモーションやトークン勧誘をフィルタリング',
        'faq.a17Pack7': '政治的コンテンツ：',
        'faq.a17Pack7Desc': '党派的な政治コンテンツをフィルタリング',
        'faq.a17Pack8': '強い冒涜：',
        'faq.a17Pack8Desc': '下品な言葉をフィルタリング',
        'faq.a17Note': '設定 > コンテンツフィルターで有効にできます。カスタムキーワードも追加できます。フィルタリングされたコンテンツには、一時的に表示したい場合は「とにかく表示」ボタン付きのプレースホルダーが表示されます。',
        'faq.q18': 'ユーザーをミュートするにはどうすればいいですか？',
        'faq.a18': 'ユーザーをミュートするには、そのユーザーのプロフィールを訪問してミュートボタンをクリックします。ミュートされると、そのユーザーのすべての動画がフィードから非表示になり、コメントは「ミュートされたユーザーからのメッセージ」として表示され、ライブチャットメッセージも非表示になります。ミュートリストはNostrに保存されるため、デバイス間で同期されます。プロフィール設定の「ミュートされたユーザー」でミュートされたユーザーを管理できます。',
        'faq.q19': '「レシオ」とはどういう意味ですか？',
        'faq.a19': '動画は、いいねよりも著しく多くの低評価を受けると「レシオ」としてマークされ、ネガティブなコミュニティの反応を示します。具体的には、動画に少なくとも10のリアクションがあり、低評価がいいねの少なくとも2倍あり、低評価が全リアクションの70%以上を占める場合にレシオとなります。レシオされた動画には警告バッジが表示され、視聴前に確認を求められます。',
        'faq.q20': 'コミュニティ警告はどのように機能しますか？',
        'faq.a20': 'ユーザーはさまざまな理由（スパム、違法コンテンツ、虐待、誤解を招く内容など）でコンテンツを報告できます。動画やユーザーがフォローしている人から5件以上の報告を受けると、警告インジケーターが表示されます。これはあなたのソーシャルグラフを活用しています - 警告は匿名の見知らぬ人ではなく、信頼できるネットワークから来ます。設定で「フォローしているアカウントからの警告を表示」を切り替えることができます。',
        'faq.q21': 'コンテンツを報告するにはどうすればいいですか？',
        'faq.a21': '任意の動画、コメント、ユーザープロフィールのフラグアイコンをクリックして報告します。理由（スパム、違法、虐待、誤解を招く、なりすまし、著作権、その他）を選択し、オプションで詳細を追加します。報告はイベントとしてNostrに公開され、透明で分散化されています。あなたの報告は、ネットワーク内の他の人が問題のあるコンテンツを特定するのに役立ちます。',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': 'プライバシーとセキュリティ',
        'faq.q22': '私の活動はプライベートですか？',
        'faq.a22': 'Nostrでは、ほとんどの活動は設計上公開されています。いいね、コメント、フォロー、Zapは公開ネットワーク上で表示されます。ただし、Plebsは視聴履歴をブラウザにローカルに保存します - サーバーに送信されることはありません。いつでもローカルデータをクリアできます。',
        'faq.q23': 'アカウントを安全に保つにはどうすればいいですか？',
        'faq.a23': '秘密鍵（nsec）を誰とも共有しないでください。Alby、nos2x、またはハードウェア署名者などのNostrブラウザ拡張機能の使用を強くお勧めします。これらは秘密鍵を安全に保ち、承認したときにのみイベントに署名します。ウェブサイトに直接nsecを保存することは避けてください。',
        'faq.q24': 'コンテンツを削除できますか？',
        'faq.a24': 'Nostrで削除イベントを公開することで削除をリクエストできます。ほとんどの適切に動作するリレーとクライアントはこれを尊重します。ただし、ネットワークの分散型の性質上、コンテンツは一部のリレーやBlossomサーバーに残る可能性があります。ネットワーク全体で完全な削除を強制できる中央権限はありません。',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': 'トラブルシューティング',
        'faq.q25': '動画が読み込まれません - どうすればいいですか？',
        'faq.a25Intro': '動画が読み込まれない場合は、以下の手順を試してください：',
        'faq.a25Item1': 'ページを更新',
        'faq.a25Item2': 'インターネット接続を確認',
        'faq.a25Item3': '動画をホストしているBlossomサーバーがダウンしている可能性があります - これはPlebsとは独立しています',
        'faq.a25Item4': 'コンテンツをブロックする可能性のあるブラウザ拡張機能を無効にしてみる',
        'faq.a25Item5': 'ブラウザのキャッシュをクリアして再試行',
        'faq.q26': '秘密鍵を紛失しました - 復旧を手伝ってもらえますか？',
        'faq.a26': '残念ながらできません。Nostr鍵は暗号化されています - パスワードリセットやアカウント復旧はありません。中央権限が存在しないためです。だからこそ、鍵をバックアップし、安全な鍵管理ソリューションを使用することを強くお勧めします。nsecを紛失した場合は、新しいアイデンティティを作成する必要があります。',
        'faq.q27': 'バグを報告したり、機能をリクエストしたりするにはどうすればいいですか？',
        'faq.a27': '<a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a>ページでバグを報告したり、機能をリクエストしたりできます。Nostrで連絡することもできます - 詳細は<a href="#/contact">お問い合わせ</a>ページをご覧ください。',

        // Page Titles
        'pageTitle.following': 'フォロー中',
        'pageTitle.myVideos': 'マイ動画',
        'pageTitle.likedVideos': 'いいねした動画',
        'pageTitle.watchHistory': '視聴履歴',
        'pageTitle.liveStreams': 'ライブ配信',
        'pageTitle.suffix': '- Plebs',
        'pageTitle.liveSuffix': '- Plebsでライブ配信中',
        // Home Page Sections
        'section.trending': 'トレンド',
        'section.recommended': 'おすすめ',
        'section.shorts': 'ショート',
        'section.live': 'ライブ',
        'section.liveNow': 'ライブ配信中',
        'section.latestVideos': '最新の動画',
        'section.videos': '動画',
        'section.usersYouFollow': 'フォロー中のユーザー',
        // Trending Period
        'trending.thisWeek': '今週',
        'trending.today': '今日',
        // Buttons
        'button.viewMore': 'もっと見る',
        'button.clearAll': 'すべてクリア',
        'button.showAnyway': 'とにかく表示',
        // Confirmation Modals
        'confirm.logout': 'ログアウト',
        'confirm.logoutMessage': '本当にログアウトしますか？',
        'confirm.resetSettings': '設定をリセット',
        'confirm.resetSettingsMessage': 'すべての設定をデフォルトに戻しますか？',
        'confirm.reset': 'リセット',
        'confirm.clearHistory': '履歴をクリア',
        'confirm.clearHistoryMessage': '視聴履歴をすべて削除しますか？この操作は元に戻せません。',
        'confirm.deleteDraft': '下書きを削除',
        'confirm.deleteDraftMessage': 'この下書きを削除しますか？',
        'confirm.delete': '削除',
        'confirm.deleteVideo': '動画を削除',
        'confirm.deleteVideoMessage': 'この動画を削除しますか？この操作は元に戻せません。',
        'confirm.endStream': 'ライブ配信を終了',
        'confirm.endStreamMessage': 'ライブ配信を終了しますか？この操作は元に戻せません。',
        'confirm.endStreamButton': '配信を終了',
        // Content Filters
        'filter.hiddenByPack': '{pack}により非表示',
        'filter.showAnyway': 'とにかく表示',
        'filter.contentHidden': 'コンテンツフィルターにより非表示',
        // Filter Packs
        'filter.racism': '人種差別とヘイトスピーチ', 'filter.racismDesc': '人種差別的な中傷、民族に対するヘイトスピーチ、差別的なコンテンツをフィルタリング', 'filter.sexualExplicit': '性的に露骨なコンテンツ', 'filter.sexualExplicitDesc': 'ポルノ用語や性的に露骨なコンテンツをフィルタリング', 'filter.violence': '暴力とグロ', 'filter.violenceDesc': 'グラフィックな暴力、グロテスクな内容、暴力的な脅迫をフィルタリング', 'filter.drugs': '薬物と物質', 'filter.drugsDesc': '薬物関連のコンテンツと物質乱用をフィルタリング', 'filter.spam': 'スパムと詐欺', 'filter.spamDesc': '一般的なスパム、詐欺、プロモーションコンテンツをフィルタリング', 'filter.crypto': '暗号通貨', 'filter.cryptoDesc': '暗号通貨のプロモーション、取引シグナル、トークンの宣伝をフィルタリング', 'filter.politics': '政治的コンテンツ', 'filter.politicsDesc': '党派的な政治コンテンツと分裂的なレトリックをフィルタリング', 'filter.profanity': '強い罵倒語', 'filter.profanityDesc': '強い罵倒語と下品な言葉をフィルタリング', 'filter.customFilter': 'カスタムフィルター',
        // Following Page
        'following.noFollowingYet': 'まだ誰もフォローしていません。フォローするクリエイターを見つけましょう！',
    },
    ko: {
        // Navigation & Header
        'nav.home': '홈', 'nav.following': '팔로잉', 'nav.myVideos': '내 동영상', 'nav.liked': '좋아요', 'nav.history': '기록', 'nav.topics': '주제', 'nav.live': '라이브', 'nav.bitcoin': '비트코인', 'nav.nostr': 'Nostr', 'nav.technology': '기술', 'nav.gaming': '게임', 'nav.tutorials': '튜토리얼', 'nav.podcasts': '팟캐스트', 'nav.music': '음악', 'nav.nsfw': 'NSFW', 'nav.about': '소개', 'nav.contact': '문의', 'nav.terms': '약관', 'nav.privacy': '개인정보', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': '라이브 스트림', 'nav.github': 'GitHub',
        'header.search': '동영상 검색...', 'header.notifications': '알림', 'header.settings': '설정', 'header.create': '만들기', 'header.viewProfile': '프로필 보기', 'header.logout': '로그아웃',
        // Login Modal
        'login.title': 'Nostr로 로그인', 'login.extensionButton': 'Nostr 확장 프로그램으로 로그인', 'login.extensionDesc': '서명 확장 프로그램 사용 (Alby, nos2x 등)', 'login.orDivider': '또는', 'login.nsecLabel': '개인 키로 로그인 (nsec)', 'login.nsecPlaceholder': 'nsec 입력...', 'login.nsecButton': 'nsec로 로그인', 'login.nsecWarning': '경고: nsec 직접 입력은 확장 프로그램 사용보다 보안이 낮습니다. 더 나은 보안을 위해 NIP-07 확장 프로그램을 고려하세요.', 'login.newToNostr': 'Nostr이 처음이신가요?', 'login.createAccount': '계정 만들기', 'login.learnMore': 'Nostr에 대해 자세히 알아보기',
        // Connect Modal
        'connect.title': 'Nostr에 연결', 'connect.or': '또는', 'connect.extensionButton': 'Nostr 확장 프로그램 연결', 'connect.extensionDesc': '확장 프로그램 사용 (Alby, nos2x 등)', 'connect.nsecLabel': '개인 키로 로그인', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'nsec로 연결', 'connect.nsecWarning': '경고: nsec 직접 입력은 보안이 낮습니다. 더 나은 보안을 위해 NIP-07 확장 프로그램을 사용하세요.', 'connect.newToNostr': 'Nostr이 처음이신가요?', 'connect.createAccount': '계정 만들기',
        // Private Key Modal
        'privateKey.title': '개인 키', 'privateKey.warning': '중요: 안전한 곳에 저장하세요. 이 키를 잃어버리면 계정에 접근할 수 없습니다. 절대 다른 사람과 공유하지 마세요!', 'privateKey.show': '개인 키 표시', 'privateKey.hide': '개인 키 숨기기', 'privateKey.copy': '복사', 'privateKey.saved': '키를 저장했습니다', 'privateKey.yourPublicKey': '공개 키 (npub):', 'privateKey.yourPrivateKey': '개인 키 (nsec):',
        // Signup Modal
        'signup.title': 'Nostr 계정 만들기', 'signup.whatIsNostr': 'Nostr란?', 'signup.nostrDescription': 'Nostr는 자신의 신원과 데이터를 제어할 수 있는 분산형 프로토콜입니다. 중앙 서버가 없으며 계정은 암호화 키 쌍입니다.', 'signup.whyNostr': '왜 Nostr인가?', 'signup.benefit1': '신원 소유권', 'signup.benefit2': '검열 없음', 'signup.benefit3': '플랫폼 간 이식성', 'signup.createNew': '새 계정 만들기', 'signup.haveAccount': '이미 계정이 있으신가요?', 'signup.login': '로그인', 'signup.createButton': '계정 만들기', 'signup.generating': '키 생성 중...', 'signup.displayName': '표시 이름', 'signup.displayNamePlaceholder': '표시 이름 입력', 'signup.username': '사용자 이름', 'signup.usernamePlaceholder': '사용자 이름 입력', 'signup.about': '소개 (선택사항)', 'signup.profilePicture': '프로필 사진 (선택사항)', 'signup.lightningAddress': 'Lightning 주소 (선택사항)', 'signup.nostrAddress': 'Nostr 주소', 'signup.nostrAddressPlaceholder': '사용자이름', 'signup.nostrAddressHint': 'Nostr 주소로 프로필을 더 쉽게 찾을 수 있습니다. 소문자, 숫자, _, -만 사용 가능.', 'signup.nostrAddressRequired': 'Nostr 주소를 입력해주세요', 'signup.nostrAddressAvailable': '사용 가능!', 'signup.nostrAddressUnavailable': '이미 사용 중', 'signup.nostrAddressChecking': '확인 중...', 'signup.nostrAddressInvalid': '잘못된 사용자 이름 형식', 'signup.nostrAddressRegistering': 'Nostr 주소 등록 중...', 'signup.nostrAddressSuccess': 'Nostr 주소가 등록되었습니다!', 'signup.nostrAddressFailed': 'Nostr 주소를 등록할 수 없습니다', 'signup.createAccountBtn': '계정 만들기', 'signup.termsAgree': '계정을 만들면 다음에 동의하게 됩니다', 'signup.and': '및', 'signup.success': '계정이 성공적으로 생성되었습니다!', 'signup.yourPrivateKey': '개인 키 (nsec)', 'signup.keyWarning': '이것이 계정에 접근하는 유일한 방법입니다. 안전하게 보관하세요!', 'signup.copyPrivateKey': '개인 키 복사', 'signup.howToUseKey': '개인 키 사용 방법', 'signup.continueToPlebs': 'Plebs로 계속', 'signup.step1': '안전하게 저장:', 'signup.step1Desc': 'nsec를 비밀번호 관리자에 저장하거나, 적어두거나, 암호화된 파일에 저장하세요. 절대 공개하지 마세요!', 'signup.step2': '다시 로그인:', 'signup.step2Desc': '로그인 화면에서 "개인 키"를 클릭하고 nsec를 붙여넣으세요. 비밀번호처럼 작동합니다.', 'signup.step3': '다른 앱에서 사용:', 'signup.step3Desc': 'nsec는 모든 Nostr 앱에서 사용할 수 있습니다 - Damus, Primal, Amethyst 등!', 'signup.step4': '서명 앱 고려:', 'signup.step4Desc': '더 나은 보안을 위해 Amber (Android) 또는 Alby와 같은 브라우저 확장 프로그램을 사용하세요.',
        // Notifications
        'notifications.title': '알림', 'notifications.empty': '알림이 없습니다', 'notifications.viewAll': '모든 알림 보기', 'notifications.markAllRead': '모두 읽음으로 표시', 'notifications.settings': '알림 설정', 'notifications.loading': '알림 로딩 중...', 'notifications.zap': 'Zap을 보냈습니다', 'notifications.like': '좋아요를 눌렀습니다', 'notifications.comment': '댓글을 달았습니다', 'notifications.follow': '팔로우했습니다', 'notifications.repost': '리포스트했습니다', 'notifications.mention': '멘션했습니다',
        // Settings Modal
        'settings.title': '설정', 'settings.language': '언어', 'settings.languageDesc': '언어 선택', 'settings.saveToNostr': 'Nostr에 저장', 'settings.darkMode': '다크 모드', 'settings.darkModeDesc': '다크/라이트 테마 전환', 'settings.autoplay': '자동 재생', 'settings.autoplayDesc': '동영상 자동 재생', 'settings.saveSettings': '설정 저장', 'settings.resetDefaults': '초기화', 'settings.notificationSettings': '알림 설정', 'settings.notifications': '알림', 'settings.notificationsDesc': '푸시 알림 받기', 'settings.quality': '기본 화질', 'settings.qualityDesc': '동영상 재생 화질', 'settings.contentWarning': '콘텐츠 경고 설정', 'settings.showNsfwWarnings': 'NSFW 경고 표시', 'settings.showNsfwWarningsDesc': 'NSFW 콘텐츠에 연령 확인 표시', 'settings.showCommunityWarnings': '커뮤니티 경고 표시', 'settings.showCommunityWarningsDesc': '신고되거나 비추천이 많은 콘텐츠에 경고 표시', 'settings.showFollowsReportWarnings': '팔로우 신고 경고 표시', 'settings.showFollowsReportWarningsDesc': '팔로우하는 5명 이상이 콘텐츠를 신고하면 경고 표시', 'settings.filterPacks': '콘텐츠 필터 팩', 'settings.filterPacksDesc': '필터 팩을 활성화하여 특정 키워드와 일치하는 콘텐츠를 자동으로 숨깁니다.', 'settings.customKeywordFilter': '사용자 지정 키워드 필터', 'settings.customKeywordFilterPlaceholder': '키워드 또는 구문을 쉼표로 구분하여 입력\n예: 스팸, 원치 않는 콘텐츠, 특정 구문', 'settings.customKeywordFilterDesc': '필터링할 고유 키워드 추가 (쉼표로 구분)',
        // Upload Modal
        'upload.title': '동영상 업로드', 'upload.dragDrop': '여기에 동영상 파일을 드롭하세요', 'upload.or': '또는', 'upload.browse': '파일 찾아보기', 'upload.supportedFormats': '지원 형식: MP4, WebM, MOV', 'upload.maxSize': '최대 파일 크기: 2GB', 'upload.videoTitle': '제목', 'upload.titlePlaceholder': '동영상 제목 입력', 'upload.description': '설명', 'upload.descriptionPlaceholder': '동영상 설명...', 'upload.tags': '태그', 'upload.tagsPlaceholder': '쉼표로 구분하여 태그 추가', 'upload.visibility': '공개 설정', 'upload.public': '공개', 'upload.unlisted': '미등록', 'upload.uploadButton': '동영상 업로드', 'upload.uploading': '업로드 중...', 'upload.processing': '처리 중...', 'upload.complete': '완료!', 'upload.error': '업로드 실패', 'upload.nsfw': 'NSFW 콘텐츠', 'upload.nsfwDesc': '성인 콘텐츠로 표시', 'upload.thumbnail': '썸네일', 'upload.thumbnailDesc': '썸네일 업로드', 'upload.preparing': '준비 중...', 'upload.cancel': '취소', 'upload.progress': '업로드 진행률', 'upload.transcoding': '트랜스코딩 중', 'upload.status.preparing': '업로드 준비 중...', 'upload.status.uploading': '동영상 업로드 중...', 'upload.status.transcoding': '동영상 트랜스코딩 중...', 'upload.status.complete': '업로드 완료!', 'upload.qualityHigh': '높음', 'upload.qualityMedium': '중간', 'upload.qualityLow': '낮음',
        // Create Modal
        'create.title': '만들기', 'create.uploadVideo': '동영상 업로드', 'create.uploadDesc': '동영상 공유', 'create.goLive': '라이브 시작', 'create.goLiveDesc': '라이브 스트리밍 시작', 'create.createPost': '게시물 작성', 'create.createPostDesc': '텍스트 게시물 공유',
        // Go Live Modal
        'goLive.title': '라이브 시작', 'goLive.streamTitle': '스트림 제목', 'goLive.streamTitlePlaceholder': '스트림 제목 입력', 'goLive.description': '설명', 'goLive.descriptionPlaceholder': '스트림 설명...', 'goLive.category': '카테고리', 'goLive.selectCategory': '카테고리 선택', 'goLive.tags': '태그', 'goLive.tagsPlaceholder': '쉼표로 구분하여 태그 추가', 'goLive.startStream': '스트림 시작', 'goLive.streamKey': '스트림 키', 'goLive.streamUrl': '스트림 URL', 'goLive.copy': '복사', 'goLive.hideKey': '키 숨기기', 'goLive.showKey': '키 표시', 'goLive.connecting': '연결 중...', 'goLive.live': '라이브', 'goLive.offline': '오프라인', 'goLive.viewers': '시청자', 'goLive.endStream': '스트림 종료', 'goLive.nsfw': 'NSFW 콘텐츠', 'goLive.nsfwDesc': '성인 콘텐츠로 표시', 'goLive.thumbnail': '스트림 썸네일', 'goLive.thumbnailDesc': '썸네일 업로드', 'goLive.zapGoal': 'Zap 목표 (선택 사항)', 'goLive.zapGoalLabel': 'Zap 목표',
        // Video/Live No Description
        'video.noDescription': '이 동영상에 설명이 추가되지 않았습니다.', 'live.noDescription': '이 라이브 스트림에 설명이 추가되지 않았습니다.',
        // Edit Stream Modal
        'editStream.title': '스트림 편집', 'editStream.save': '변경 사항 저장',
        // Live Stream
        'live.live': '라이브', 'live.scheduled': '예정', 'live.ended': '스트림 종료', 'live.viewers': '시청자', 'live.viewer': '시청자', 'live.chat': '라이브 채팅', 'live.sendMessage': '메시지 보내기...', 'live.send': '보내기', 'live.goalReached': '목표 달성!', 'live.goalProgress': '목표의 {percent}%',
        // NSFW Warning Modal
        'nsfw.title': '성인 콘텐츠 경고', 'nsfw.warning': '이 콘텐츠는 NSFW(직장에서 보기 부적절)로 표시되어 있으며 성인 콘텐츠가 포함될 수 있습니다.', 'nsfw.confirm': '나이 확인', 'nsfw.confirmAge': '18세 이상입니다', 'nsfw.cancel': '돌아가기', 'nsfw.continue': '계속', 'nsfw.dontShowAgain': '이 경고 다시 표시 안 함',
        // Community Warning Modal
        'community.title': '커뮤니티 가이드라인', 'community.warning': '계속하기 전에 커뮤니티 가이드라인을 검토하세요.', 'community.guidelines': '다른 사람을 존중하고 커뮤니티 기준을 따르세요.', 'community.accept': '동의', 'community.decline': '거절',
        'communityWarning.title': '커뮤니티 경고', 'communityWarning.description': '이 동영상은 커뮤니티에서 신고되었거나 많은 비추천을 받았습니다. 다음과 같은 이유일 수 있습니다:', 'communityWarning.reason1': 'NSFW로 적절히 표시되지 않은 부적절한 콘텐츠', 'communityWarning.reason2': '신규 또는 의심스러운 사용자 정보', 'communityWarning.reason3': '오해의 소지가 있거나 허위 정보', 'communityWarning.reason4': '스팸 또는 저품질 콘텐츠', 'communityWarning.reason5': '잠재적으로 해로운 또는 불법 콘텐츠', 'communityWarning.proceed': '주의하여 진행하세요.', 'communityWarning.goBack': '돌아가기', 'communityWarning.viewAnyway': '그래도 보기',
        // Report Modal
        'report.title': '콘텐츠 신고', 'report.reason': '신고 사유', 'report.selectReason': '사유 선택', 'report.spam': '스팸 또는 오해의 소지', 'report.inappropriate': '부적절한 콘텐츠', 'report.violence': '폭력적이거나 위험한 콘텐츠', 'report.copyright': '저작권 침해', 'report.other': '기타', 'report.details': '세부 정보', 'report.detailsPlaceholder': '세부 정보 입력...', 'report.submit': '신고 제출', 'report.cancel': '취소',
        // Share Modal
        'share.title': '공유', 'share.copyLink': '링크 복사', 'share.embed': '임베드 코드', 'share.copyEmbed': '임베드 코드 복사', 'share.social': '소셜 미디어에 공유', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': '이메일', 'share.copied': '복사됨!', 'share.nostr': 'Nostr에 공유', 'share.generateImage': '이미지 생성', 'share.downloadImage': '다운로드', 'share.shareImage': '공유', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (정사각형)', 'share.size1080x1920': '1080 × 1920 (스토리)',
        // Edit Video Modal
        'editVideo.title': '동영상 편집', 'editVideo.videoTitle': '제목', 'editVideo.description': '설명', 'editVideo.tags': '태그', 'editVideo.thumbnail': '썸네일', 'editVideo.changeThumbnail': '썸네일 변경', 'editVideo.visibility': '공개 설정', 'editVideo.nsfw': 'NSFW 콘텐츠', 'editVideo.save': '변경 사항 저장', 'editVideo.delete': '동영상 삭제', 'editVideo.confirmDelete': '이 동영상을 삭제하시겠습니까?',
        // Edit Profile Modal
        'editProfile.title': '프로필 편집', 'editProfile.displayName': '표시 이름', 'editProfile.displayNamePlaceholder': '표시 이름 입력', 'editProfile.username': '사용자 이름', 'editProfile.usernamePlaceholder': '사용자 이름 입력', 'editProfile.about': '소개', 'editProfile.aboutPlaceholder': '자기 소개...', 'editProfile.website': '웹사이트', 'editProfile.websitePlaceholder': 'https://yourwebsite.com', 'editProfile.lightning': 'Lightning 주소', 'editProfile.lightningPlaceholder': 'you@getalby.com', 'editProfile.nip05': 'NIP-05 인증', 'editProfile.nip05Placeholder': 'you@domain.com', 'editProfile.avatar': '아바타', 'editProfile.changeAvatar': '아바타 변경', 'editProfile.banner': '배너', 'editProfile.changeBanner': '배너 변경', 'editProfile.save': '프로필 저장',
        // Confirmation Modal
        'confirm.title': '작업 확인', 'confirm.message': '계속하시겠습니까?', 'confirm.confirm': '확인', 'confirm.cancel': '취소',
        // Video Page
        'video.views': '조회', 'video.like': '좋아요', 'video.dislike': '싫어요', 'video.share': '공유', 'video.save': '저장', 'video.report': '신고', 'video.follow': '팔로우', 'video.unfollow': '언팔로우', 'video.subscribe': '구독', 'video.subscribed': '구독 중', 'video.comments': '댓글', 'video.addComment': '댓글 추가...', 'video.reply': '답글', 'video.replies': '개의 답글', 'video.loadMore': '더 보기', 'video.noComments': '댓글이 없습니다. 첫 번째로 댓글을 달아보세요!', 'video.zap': 'Zap', 'video.zapAmount': 'Zap 금액 (sats)', 'video.sendZap': 'Zap 보내기', 'video.boost': '부스트', 'video.description': '설명', 'video.showMore': '더 보기', 'video.showLess': '접기', 'video.publishedOn': '게시일',
        // Toast Messages
        'toast.loggedIn': '로그인 성공!', 'toast.settingsSaved': '설정 저장됨!', 'toast.settingsLocal': '설정이 로컬에 저장됨. Nostr에 저장 실패.', 'toast.settingsLocalOnly': '설정이 로컬에 저장됨!', 'toast.settingsReset': '설정이 기본값으로 초기화됨!', 'toast.avatarUploaded': '아바타 업로드 성공!', 'toast.profileUpdated': '프로필 업데이트 성공!', 'toast.copied': '클립보드에 복사됨!', 'toast.copyFailed': '복사 실패. 수동으로 복사하세요.', 'toast.installExtension': 'Alby 또는 nos2x와 같은 Nostr 브라우저 확장 프로그램을 설치하세요', 'toast.loginFailed': '확장 프로그램으로 로그인 실패. 다시 시도하세요.', 'toast.invalidKey': '잘못된 개인 키입니다. 확인 후 다시 시도하세요.', 'toast.enterKey': '개인 키를 입력하세요', 'toast.enterUsername': '사용자 이름을 입력하세요', 'toast.accountCreated': 'Plebs에 오신 것을 환영합니다! 로그인되었습니다.', 'toast.keyCopied': '개인 키가 클립보드에 복사됨!', 'toast.unmuted': '사용자 음소거 해제됨', 'toast.unmuteFailed': '음소거 해제 실패', 'toast.selectImage': '이미지 파일을 선택하세요', 'toast.imageTooLarge': '이미지는 5MB 미만이어야 합니다', 'toast.avatarFailed': '아바타 업로드 실패. 다시 시도하세요.', 'toast.mustBeLoggedIn': '프로필을 편집하려면 로그인이 필요합니다', 'toast.enterDisplayName': '표시 이름을 입력하세요', 'toast.profileFailed': '프로필 저장 실패. 다시 시도하세요.', 'toast.invalidBunker': '유효한 벙커 URL을 입력하세요', 'toast.connectFailed': '연결 실패', 'toast.showingFiltered': '필터링된 콘텐츠 표시 중', 'toast.reportSubmitted': '신고가 성공적으로 제출됨', 'toast.draftSaved': '임시 저장됨! 내 동영상에서 계속할 수 있습니다.', 'toast.draftLoaded': '임시 저장 불러옴. 업로드를 완료하고 게시하세요.', 'toast.draftDeleted': '임시 저장 삭제됨', 'toast.languageChanged': '언어가 변경됨', 'toast.videoBlocked': '동영상이 차단되고 Nostr에 게시됨', 'toast.waitForUpload': '동영상 업로드가 완료될 때까지 기다려주세요', 'toast.enterTitle': '제목을 입력하세요', 'toast.publishing': '동영상을 Nostr에 게시 중...',
        // Time
        'time.justNow': '방금 전', 'time.secondAgo': '1초 전', 'time.secondsAgo': '{n}초 전', 'time.minuteAgo': '1분 전', 'time.minutesAgo': '{n}분 전', 'time.hourAgo': '1시간 전', 'time.hoursAgo': '{n}시간 전', 'time.dayAgo': '1일 전', 'time.daysAgo': '{n}일 전', 'time.weekAgo': '1주 전', 'time.weeksAgo': '{n}주 전', 'time.monthAgo': '1개월 전', 'time.monthsAgo': '{n}개월 전', 'time.yearAgo': '1년 전', 'time.yearsAgo': '{n}년 전',
        // Empty States
        'empty.noVideos': '동영상을 찾을 수 없습니다', 'empty.noVideosDesc': '다른 검색어를 시도하세요', 'empty.noFollowing': '아직 팔로우하는 사람이 없습니다', 'empty.noFollowingDesc': '크리에이터를 팔로우하여 동영상을 보세요', 'empty.noHistory': '시청 기록이 없습니다', 'empty.noHistoryDesc': '시청한 동영상이 여기에 표시됩니다', 'empty.noLiked': '좋아요한 동영상이 없습니다', 'empty.noLikedDesc': '좋아요한 동영상이 여기에 표시됩니다', 'empty.noResults': '결과를 찾을 수 없습니다', 'empty.noResultsDesc': '다른 키워드를 시도하세요',
        // Misc
        'misc.loading': '로딩 중...', 'misc.loadingMore': '더 로딩 중...', 'misc.refresh': '새로고침', 'misc.retry': '다시 시도', 'misc.close': '닫기', 'misc.back': '뒤로', 'misc.next': '다음', 'misc.previous': '이전', 'misc.search': '검색', 'misc.filter': '필터', 'misc.sort': '정렬', 'misc.newest': '최신순', 'misc.oldest': '오래된순', 'misc.popular': '인기', 'misc.trending': '트렌딩', 'misc.sats': 'sats', 'misc.all': '전체', 'misc.copiedToClipboard': '클립보드에 복사됨!',
        // Common
        'common.submit': '제출', 'common.cancel': '취소', 'common.save': '저장', 'common.delete': '삭제', 'common.edit': '편집', 'common.close': '닫기', 'common.confirm': '확인', 'common.yes': '예', 'common.no': '아니오', 'common.ok': '확인', 'common.loading': '로딩 중...', 'common.uploading': '업로드 중...', 'common.error': '오류', 'common.success': '성공',
        // Aria Labels
        'aria.toggleMenu': '메뉴 전환', 'aria.mainNavigation': '메인 내비게이션', 'aria.videoContent': '동영상 콘텐츠', 'aria.loadingContent': '콘텐츠 로딩 중', 'aria.closeModal': '모달 닫기', 'aria.playVideo': '동영상 재생', 'aria.pauseVideo': '동영상 일시정지', 'aria.muteVideo': '음소거', 'aria.unmuteVideo': '음소거 해제', 'aria.fullscreen': '전체 화면', 'aria.exitFullscreen': '전체 화면 종료', 'aria.settings': '설정', 'aria.notifications': '알림', 'aria.userMenu': '사용자 메뉴', 'aria.searchInput': '동영상 검색', 'aria.videoPlayer': '동영상 플레이어',
        // Dynamic JavaScript text
        'button.hideQR': 'QR 코드 숨기기', 'button.showQR': 'QR 코드 보기', 'button.copied': '복사됨!', 'button.showLess': '간략히 보기', 'button.showMore': '더 보기', 'button.creatingAccount': '계정 생성 중...', 'button.submitting': '제출 중...', 'button.scheduleStream': '스트림 예약', 'button.goLive': '라이브 시작', 'button.creatingStream': '스트림 생성 중...', 'button.continueCustomAmount': '맞춤 금액으로 계속', 'button.recordFromCamera': '카메라로 녹화', 'button.requestingCamera': '카메라 요청 중...', 'button.recording': '녹화 중...',
        'status.saving': '저장 중...', 'status.saved': '저장됨!', 'status.uploading': '업로드 중...', 'status.uploadComplete': '업로드 완료!', 'status.uploadingToNostrBuild': 'nostr.build에 업로드 중...', 'status.publishingChanges': '변경 사항 게시 중...', 'status.removingOldVersion': '이전 버전 제거 중...', 'status.validatingThumbnail': '썸네일 검증 중...', 'status.uploadingThumbnail': '썸네일 업로드 중...', 'status.thumbnailUploaded': '썸네일 업로드됨!', 'status.processingVideo': '동영상 처리 중...', 'status.compressingVideo': '동영상 압축 중...', 'status.uploadingVideo': '동영상 업로드 중...', 'status.videoUploaded': '동영상 업로드 성공!', 'status.processing': '처리 중...', 'status.generatingThumbnail': '썸네일 생성 중...', 'status.generatingPreview': '미리보기 생성 중...', 'status.uploadingPreview': '미리보기 업로드 중...', 'status.publishing': '게시 중...', 'status.publishingToNostr': 'Nostr에 게시 중...', 'status.publishingVideoToNostr': 'Nostr에 동영상 게시 중...', 'status.generatingPoW': '작업 증명 생성 중...', 'status.posting': '게시 중...', 'status.processingVideoAndThumbnail': '동영상과 썸네일 처리 중...', 'status.uploadFailed': '업로드 실패 - 다시 시도하세요', 'status.selectVideoToUpload': '업로드할 동영상 선택', 'status.waitingForVideoUpload': '동영상 업로드 대기 중...', 'status.selectVideoAndThumbnail': '게시할 동영상과 썸네일 선택', 'status.ready': '준비 완료 ✓', 'status.failed': '실패 ✗', 'status.fromDraft': '임시저장에서', 'status.startingNow': '곧 시작!', 'status.ended': '종료됨', 'status.thumbnailReady': '준비됨', 'status.thumbnailFailed': '실패', 'status.uploadFailedRetry': '업로드 실패. 다시 시도하세요.',
        'publish.video': '동영상 게시', 'publish.autoThumbnail': '동영상 게시 (자동 썸네일)',
        'report.titleComment': '댓글 신고', 'report.titleUser': '사용자 신고', 'report.titleVideo': '동영상 신고', 'report.descComment': '댓글을 신고하는 이유를 선택하세요:', 'report.descUser': '사용자를 신고하는 이유를 선택하세요:', 'report.descVideo': '콘텐츠를 신고하는 이유를 선택하세요:',
        'empty.noMutedUsers': '뮤트된 사용자가 없습니다.', 'empty.noVideosToMonitor': '모니터링할 동영상이 없습니다.', 'empty.noRecentActivity': '최근 활동이 없습니다.', 'empty.failedLoadNotifications': '알림 로드 실패', 'empty.loginToViewLiked': '좋아요한 동영상을 보려면 <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">로그인</a>하세요.', 'empty.loginToViewFollowing': '팔로잉을 보려면 <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">로그인</a>하세요.', 'empty.loginToViewVideos': '동영상을 보려면 <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">로그인</a>하세요.', 'empty.loginToViewAnalytics': '통계를 보려면 <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">로그인</a>하세요.', 'empty.noLikedVideosYet': '아직 좋아요한 동영상이 없습니다.', 'empty.noLikedVideosFound': '좋아요한 동영상을 찾을 수 없습니다.', 'empty.noFullLengthLikedVideos': '좋아요한 긴 동영상을 찾을 수 없습니다.', 'empty.noWatchHistory': '시청 기록이 없습니다. 동영상을 시청해보세요.', 'empty.noVideosInHistory': '기록에 동영상이 없습니다.', 'empty.noFullLengthHistory': '기록에 긴 동영상이 없습니다.', 'empty.noMatchingVideos': '일치하는 동영상을 찾을 수 없습니다.', 'empty.noFullLengthVideos': '긴 동영상을 찾을 수 없습니다.', 'empty.failedLoadTrending': '트렌딩 로드 실패.', 'empty.noTrendingVideos': '트렌딩 동영상을 찾을 수 없습니다.', 'empty.noMatchingUsers': '일치하는 사용자를 찾을 수 없습니다.', 'empty.unableLoadProfiles': '프로필을 로드할 수 없습니다.', 'empty.noFollowingVideos': '팔로우하는 사용자의 동영상이 없습니다.', 'empty.noFullLengthFollowing': '팔로우하는 사용자의 긴 동영상이 없습니다.', 'empty.failedLoadFollowing': '로드 실패. 다시 시도하세요.', 'empty.noVideosUploadFirst': '동영상이 없습니다. 첫 동영상을 업로드하세요!', 'empty.noFullLengthUploaded': '긴 동영상을 찾을 수 없습니다.', 'empty.noMatchingLiveStreams': '일치하는 라이브 스트림을 찾을 수 없습니다.', 'empty.noMatchingShorts': '일치하는 쇼츠를 찾을 수 없습니다.', 'empty.noVideosForTag': '이 태그의 동영상이 없습니다.', 'empty.noFullLengthForTag': '이 태그의 긴 동영상이 없습니다.', 'empty.noUploadedVideos': '아직 업로드된 동영상이 없습니다.', 'empty.noVideosFound': '동영상을 찾을 수 없습니다.', 'empty.failedLoadProfile': '프로필 로드 실패. 다시 시도하세요.', 'empty.noComments': '아직 댓글이 없습니다. 첫 댓글을 달아보세요!', 'empty.failedLoadComments': '댓글 로드 실패', 'empty.noLiveNow': '현재 라이브 중인 사람이 없습니다. 첫 번째가 되어보세요!',
        'error.videoNotFound': '동영상을 찾을 수 없습니다.', 'error.contentNotAvailable': '이 콘텐츠를 사용할 수 없습니다.', 'error.invalidVideoData': '잘못된 동영상 데이터입니다.', 'error.videoNotAvailable': '동영상을 사용할 수 없습니다. 파일이 삭제되었을 수 있습니다.', 'error.failedLoadVideo': '동영상 로드 실패. 다시 시도하세요.', 'error.failedLoadVideoShort': '로드 실패. 파일이 삭제되었을 수 있습니다.', 'error.liveStreamNotFound': '라이브 스트림을 찾을 수 없습니다.', 'error.invalidLiveStreamData': '잘못된 라이브 스트림 데이터입니다.', 'error.failedLoadLiveStream': '라이브 스트림 로드 실패.',
        // New Button & Action Labels
        'button.follow': '팔로우', 'button.unfollow': '언팔로우', 'button.mute': '음소거', 'button.unmute': '음소거 해제', 'button.muteUser': '사용자 음소거', 'button.unmuteUser': '음소거 해제', 'button.confirm': '확인', 'button.cancel': '취소', 'button.close': '닫기', 'button.boost': '부스트', 'button.zap': 'Zap', 'button.viewMore': '더 보기', 'button.viewAnalytics': '통계 보기', 'button.backToMyVideos': '내 동영상으로 돌아가기', 'button.editDraft': '초안 편집', 'button.deleteDraft': '초안 삭제', 'button.editVideo': '동영상 편집', 'button.deleteVideo': '동영상 삭제', 'button.editShort': '쇼츠 편집', 'button.deleteShort': '쇼츠 삭제', 'button.editStream': '방송 편집', 'button.endStream': '방송 종료', 'button.reset': '초기화', 'button.download': '다운로드', 'button.watchRecording': '녹화 보기', 'button.show': '표시', 'button.login': '로그인', 'button.toggleChat': '채팅 전환', 'button.blockVideo': '동영상 차단', 'button.blockUser': '사용자 차단', 'button.unblock': '차단 해제', 'button.removeFromHistory': '기록에서 삭제',
        // New Stats & Counts
        'stat.views': '조회', 'stat.viewsCount': '{count}회 조회', 'stat.videos': '개 동영상', 'stat.video': '개 동영상', 'stat.followers': '팔로워', 'stat.follower': '팔로워', 'stat.following': '팔로잉', 'stat.subscribers': '구독자', 'stat.comments': '댓글', 'stat.liveCount': '{count}개 라이브', 'stat.percentOfGoal': '목표의 {percent}%', 'stat.netGrowth': '순증가', 'stat.newFollowers': '신규 팔로워', 'stat.unfollowed': '언팔로우', 'stat.lastUpdated': '최종 업데이트: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': '라이브', 'badge.ended': '종료됨', 'badge.scheduled': '예정됨', 'badge.warning': '경고', 'badge.communityWarning': '커뮤니티 경고', 'badge.verifiedNip05': 'NIP-05 인증됨', 'badge.streamer': '스트리머', 'badge.clickToView': '클릭하여 보기',
        // New Actions
        'action.report': '신고', 'action.reportComment': '댓글 신고', 'action.reportVideo': '이 동영상 신고', 'action.reportStream': '이 방송 신고', 'action.like': '좋아요', 'action.dislike': '싫어요', 'action.reply': '답글',
        // New Placeholders
        'placeholder.searchHistory': '기록 검색...', 'placeholder.searchUsers': '사용자 검색...', 'placeholder.searchMyVideos': '내 동영상 검색...', 'placeholder.eventId': '이벤트 ID 입력 (hex 또는 nevent/note)', 'placeholder.pubkey': 'pubkey 입력 (hex 또는 npub)', 'placeholder.customAmount': '사용자 지정 금액', 'placeholder.chatEnded': '채팅 종료 - 방송이 종료되었습니다', 'placeholder.addComment': '댓글 추가...', 'placeholder.setNewGoal': '새 목표 설정 (sats)',
        // New Video & Content
        'video.untitledVideo': '제목 없는 동영상', 'video.untitledShort': '제목 없는 쇼츠', 'video.upNext': '다음 동영상', 'video.noVideosYet': '아직 동영상이 없습니다', 'video.noShortsYet': '아직 쇼츠가 없습니다', 'video.noLiveStreamsYet': '아직 라이브 방송이 없습니다', 'video.noBlockedVideos': '차단된 동영상 없음', 'video.noBlockedUsers': '차단된 사용자 없음',
        // New Stream Messages
        'stream.ended': '이 방송이 종료되었습니다. 채팅이 닫혔습니다.', 'stream.welcomeChat': '라이브 채팅에 오신 것을 환영합니다!', 'stream.goalReached': '목표 달성!', 'stream.zapGoalReached': 'Zap 목표 달성! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': '음소거된 사용자의 메시지', 'muted.commentFromMutedUserHidden': '음소거된 사용자의 댓글이 숨겨짐', 'muted.commentHidden': '댓글이 숨겨짐 ({packs})', 'muted.messageHidden': '메시지가 숨겨짐 ({packs})', 'muted.commentReportedByFollows': '팔로우하는 사람들이 신고한 댓글', 'muted.messageReportedByFollows': '팔로우하는 사람들이 신고한 메시지', 'muted.commentHeavilyDownvoted': '커뮤니티에서 많이 비추천된 댓글', 'muted.messageHeavilyDownvoted': '많이 비추천된 메시지',
        // New Admin & Lists
        'list.blockedVideos': '차단된 동영상', 'list.blockedUsers': '차단된 사용자',
        // New Alerts
        'alert.cameraNotSupported': '이 브라우저에서는 카메라 액세스가 지원되지 않습니다. Chrome, Firefox, Safari 등 최신 브라우저를 사용하세요.', 'alert.noCameraFound': '카메라를 찾을 수 없습니다. 카메라를 연결하거나 파일 업로드 옵션을 사용하세요.', 'alert.cameraAccessDenied': '카메라 액세스가 거부되었습니다. 브라우저 설정에서 카메라를 허용하세요.', 'alert.cameraInUse': '카메라가 다른 애플리케이션에서 사용 중입니다. 다른 앱을 닫아주세요.', 'alert.cameraUnableAccess': '카메라에 액세스할 수 없습니다. 파일 업로드 옵션을 시도하세요.', 'alert.cameraUnableAccessWithError': '카메라에 액세스할 수 없습니다: {error}\n\n파일 업로드 옵션을 사용하세요.', 'alert.fillRequiredFields': '모든 필수 필드를 입력하세요', 'alert.uploadThumbnail': '방송 썸네일을 업로드하세요', 'alert.failedCreateStream': '라이브 방송 생성 실패. 다시 시도하세요.', 'alert.failedUpdateStream': '업데이트 실패. 다시 시도하세요.', 'alert.streamNotFound': '방송을 찾을 수 없습니다', 'alert.canOnlyEditOwnStreams': '자신의 방송만 편집할 수 있습니다', 'alert.invalidStreamData': '잘못된 방송 데이터', 'alert.enterValidGoalAmount': '유효한 목표 금액을 입력하세요', 'alert.canOnlyResetOwnGoals': '자신의 목표만 초기화할 수 있습니다', 'alert.streamEventNotFound': '방송 이벤트를 찾을 수 없습니다', 'alert.failedResetZapGoal': 'Zap 목표 초기화 실패. 다시 시도하세요.', 'alert.cannotBlockAdmin': '관리자 계정은 차단할 수 없습니다', 'alert.analyticsLoadFailed': '통계 로드 실패. 다시 시도하세요.', 'alert.cannotReplaceShortWithVideo': '쇼츠를 일반 동영상으로 대체할 수 없습니다. 세로 동영상(60초 이하)을 업로드하세요.', 'alert.cannotReplaceVideoWithShort': '일반 동영상을 쇼츠로 대체할 수 없습니다. 가로 동영상을 업로드하세요.', 'alert.shortsRequireVertical': '이 동영상은 가로 동영상인 것 같습니다. 쇼츠는 세로 동영상이어야 합니다. 가로 동영상은 "동영상 업로드"를 사용하세요.',
        // New Zap Messages
        'zap.cannotZapYourself': '자신에게 Zap을 보낼 수 없습니다', 'zap.cannotZapOwnContent': '자신의 콘텐츠에 Zap을 보낼 수 없습니다', 'zap.cannotZapOwnComment': '자신의 댓글에 Zap을 보낼 수 없습니다', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': '동영상 로딩 중...', 'status.loading': '로딩 중...', 'status.compressingProgress': '압축 중... {progress}%', 'status.uploadingProgress': '업로드 중... {progress}%', 'status.uploadingServers': '업로드 중... ({completed}/{total} 서버)', 'status.publishedSuccess': '{type}이(가) 성공적으로 게시되었습니다!',
        // New Warnings
        'warning.webmFormat': '참고: 브라우저는 WebM 형식을 출력합니다(iOS에서 재생되지 않을 수 있음). iOS 호환 MP4의 경우 Windows/Mac의 Chrome을 사용하세요.',
        // New Footer
        'footer.lastUpdated': '최종 업데이트: 2024년 12월',
        // DMCA Page
        'dmca.title': 'DMCA 및 콘텐츠 정책',
        'dmca.lastUpdated': '최종 업데이트: 2024년 12월',
        'dmca.architectureTitle': 'Plebs 아키텍처 이해하기',
        'dmca.architectureDesc': 'Plebs는 기존 동영상 호스팅 서비스와 다르게 운영되는 분산형 비디오 플랫폼 인터페이스입니다. 플랫폼에서 콘텐츠가 어떻게 배포되는지 이해하는 것이 중요합니다:',
        'dmca.architectureItem1': 'Plebs는 동영상이나 이미지 콘텐츠를 호스팅하지 않습니다.',
        'dmca.architectureItem1Desc': '우리는 다른 곳에 저장된 콘텐츠를 표시하는 클라이언트/인터페이스입니다.',
        'dmca.architectureItem2': '모든 미디어 파일(동영상, 이미지, 썸네일)은 제3자가 운영하는 독립적인 Blossom 서버에 저장됩니다.',
        'dmca.architectureItem3': '동영상 메타데이터(제목, 설명 등)는 독립적으로 운영되는 Nostr 릴레이에 게시됩니다.',
        'dmca.architectureItem4': 'Plebs는 단순히 이러한 분산 콘텐츠를 사용자 친화적인 인터페이스를 통해 집계하고 표시합니다.',
        'dmca.filingTitle': 'DMCA 신고 제출',
        'dmca.filingDesc': 'Plebs는 콘텐츠를 호스팅하지 않으므로 침해 자료를 직접 삭제할 수 없습니다. 저작권 침해에 대응하려면 적절한 당사자에게 연락해야 합니다:',
        'dmca.forVideoTitle': '1. 동영상/이미지 콘텐츠의 경우',
        'dmca.forVideoDesc': '미디어 파일은 Blossom 서버에 저장됩니다. 다음이 필요합니다:',
        'dmca.forVideoItem1': '콘텐츠를 호스팅하는 Blossom 서버 식별(URL에 표시됨)',
        'dmca.forVideoItem2': 'Blossom 서버 운영자에게 직접 DMCA 삭제 요청 연락',
        'dmca.forVideoItem3': '각 Blossom 서버는 독립적으로 운영되며 자체 정책이 있습니다',
        'dmca.forMetadataTitle': '2. 메타데이터/설명의 경우',
        'dmca.forMetadataDesc': '침해 콘텐츠가 동영상 제목, 설명 또는 기타 메타데이터에 있는 경우:',
        'dmca.forMetadataItem1': '이 정보는 Nostr 릴레이에 저장됩니다',
        'dmca.forMetadataItem2': '콘텐츠가 표시되는 특정 Nostr 릴레이 운영자에게 연락하세요',
        'dmca.forMetadataItem3': 'Nostr의 분산 특성으로 인해 여러 릴레이가 동일한 데이터를 저장할 수 있습니다',
        'dmca.whatWeCanDoTitle': 'Plebs가 할 수 있는 것',
        'dmca.whatWeCanDoDesc': '콘텐츠를 호스팅하지 않지만 다음을 할 수 있습니다:',
        'dmca.whatWeCanDoItem1': '특정 콘텐츠를 호스팅하는 Blossom 서버 또는 릴레이 식별 지원',
        'dmca.whatWeCanDoItem2': '콘텐츠를 로컬 차단 목록에 추가하여 인터페이스에 표시되지 않도록 함(참고: plebs.app에만 영향을 미치며 다른 Nostr 클라이언트에는 영향을 미치지 않음)',
        'dmca.whatWeCanDoItem3': '적절한 서비스 운영자에게 연락하는 방법에 대한 안내 제공',
        'dmca.toRequestAssistance': '지원을 요청하려면 다음과 함께 연락하세요:',
        'dmca.assistanceItem1': '침해 콘텐츠의 URL 또는 식별자',
        'dmca.assistanceItem2': '저작권 소유권 증명',
        'dmca.assistanceItem3': '저작권 보호 작품 설명',
        'dmca.blossomOperatorsTitle': 'Blossom 서버 운영자',
        'dmca.blossomOperatorsDesc': 'Blossom 서버를 운영하고 DMCA 삭제 요청을 받은 경우 관할 지역 법률에 따라 처리할 책임이 있습니다.',
        'dmca.blossomOperatorsLink': '알려진 Blossom 서버 목록은 Blossom 프로젝트 문서를 참조하세요.',
        'dmca.considerationsTitle': '중요 고려사항',
        'dmca.considerationsItem1': '분산화:',
        'dmca.considerationsItem1Desc': 'Nostr 및 Blossom의 분산 특성으로 인해 모든 소스에서 콘텐츠를 완전히 제거하는 것이 불가능할 수 있습니다.',
        'dmca.considerationsItem2': '여러 사본:',
        'dmca.considerationsItem2Desc': '콘텐츠가 여러 Blossom 서버와 릴레이에 존재할 수 있습니다. 여러 운영자에게 연락해야 할 수 있습니다.',
        'dmca.considerationsItem3': '해시 기반 저장:',
        'dmca.considerationsItem3Desc': 'Blossom은 콘텐츠 주소 저장을 사용합니다. 동일한 파일은 어느 서버에서나 동일한 해시를 갖습니다.',
        'dmca.considerationsItem4': '중앙 통제 없음:',
        'dmca.considerationsItem4Desc': 'Plebs나 다른 단일 조직 모두 전체 네트워크에서 콘텐츠를 제거할 수 있는 능력이 없습니다.',
        'dmca.counterNotificationTitle': '이의 신청',
        'dmca.counterNotificationDesc': '콘텐츠가 Blossom 서버에서 잘못 제거되었다고 생각되면 해당 서버 운영자에게 직접 연락하여 이의 신청을 제출해야 합니다.',
        'dmca.contactTitle': '연락처',
        'dmca.contactDesc': '이 정책에 대한 질문이나 콘텐츠 호스트 식별에 대한 지원이 필요하면',
        'dmca.contactLink': '문의하세요',

        // Analytics
        'analytics.title': '채널 분석',
        'analytics.description': '채널 성과 지표와 인사이트를 확인하세요.',
        'analytics.loading': '분석 데이터 로딩 중...',
        'analytics.error': '분석 데이터 로드 실패',
        'analytics.overview': '개요',
        'analytics.videos': '동영상',
        'analytics.engagement': '참여도',
        'analytics.totalViews': '총 조회수',
        'analytics.totalVideos': '총 동영상 수',
        'analytics.totalLikes': '총 좋아요 수',
        'analytics.totalZaps': '총 Zaps',
        'analytics.avgViews': '평균 조회수',
        'analytics.avgLikes': '평균 좋아요',
        'analytics.avgZaps': '평균 Zaps',
        'analytics.viewsOverTime': '시간별 조회수',
        'analytics.topVideos': '인기 동영상',
        'analytics.recentActivity': '최근 활동',
        'analytics.viewsLabel': '조회수',
        'analytics.likesLabel': '좋아요',
        'analytics.zapsLabel': 'Zaps',
        'analytics.dateLabel': '날짜',
        'analytics.videoTitle': '동영상 제목',
        'analytics.performance': '성과',
        'analytics.noData': '분석 데이터 없음',
        'analytics.noDataDesc': '분석을 보려면 동영상을 업로드하세요.',
        'analytics.last7Days': '최근 7일',
        'analytics.last30Days': '최근 30일',
        'analytics.last90Days': '최근 90일',
        'analytics.allTime': '전체 기간',
        'analytics.views': '조회',
        'analytics.likes': '좋아요',
        'analytics.zaps': 'Zaps',
        'analytics.rank': '순위',
        'analytics.noVideos': '동영상 없음',
        'analytics.noVideosDesc': '첫 번째 동영상을 업로드하여 성과 추적을 시작하세요.',

        // About Page
        'about.title': 'Plebs.place 소개',
        'about.subtitle': '탈중앙화 비디오 플랫폼',
        'about.welcome': 'Plebs.place에 오신 것을 환영합니다',
        'about.description': 'Plebs.place는 Nostr 프로토콜 기반의 탈중앙화 비디오 공유 플랫폼으로, 크리에이터가 콘텐츠와 시청자를 완전히 제어할 수 있습니다.',
        'about.feature1Title': '탈중앙화',
        'about.feature1Desc': 'Nostr 기반으로 검열 저항성과 진정한 콘텐츠 소유권을 보장합니다.',
        'about.feature2Title': '크리에이터 우선',
        'about.feature2Desc': '콘텐츠, 데이터, 시청자와의 관계를 완전히 제어합니다.',
        'about.feature3Title': '비트코인 수익화',
        'about.feature3Desc': '라이트닝 네트워크와 Zaps를 통해 시청자로부터 직접 지원을 받으세요.',
        'about.feature4Title': '오픈 소스',
        'about.feature4Desc': '탈중앙화 이념에 맞는 투명하고 커뮤니티 주도의 개발입니다.',
        'about.missionTitle': '우리의 미션',
        'about.missionDesc': '검열, 플랫폼 종속, 임의적인 규칙 변경 없는 비디오 플랫폼을 만드는 것입니다. 당신의 콘텐츠는 당신의 것입니다.',
        'about.techTitle': '기술',
        'about.techDesc': 'Nostr로 인증 및 소셜 기능, 라이트닝으로 즉시 소액 결제, 탈중앙화 스토리지 솔루션으로 구축되었습니다.',

        // Contact Page
        'contact.title': '연락처',
        'contact.subtitle': '연락 방법',
        'contact.description': '질문, 피드백, 제안이 있으시면 알려주세요.',
        'contact.nostrTitle': 'Nostr에서 팔로우',
        'contact.nostrDesc': 'Nostr에서 팔로우하여 업데이트와 커뮤니티 토론에 참여하세요.',
        'contact.githubTitle': 'GitHub',
        'contact.githubDesc': '소스 코드를 보고, 문제를 보고하고, 프로젝트에 기여하세요.',
        'contact.emailTitle': '이메일',
        'contact.emailDesc': '비즈니스 문의나 지원 관련 사항은 팀에 연락하세요.',

        // Terms Page
        'terms.title': '이용약관',
        'terms.lastUpdated': '최종 업데이트',
        'terms.section1Title': '1. 약관 동의',
        'terms.section1Content': 'Plebs.place를 사용함으로써 이 약관에 구속됨에 동의합니다. 동의하지 않으면 플랫폼을 사용하지 마세요.',
        'terms.section2Title': '2. 서비스 설명',
        'terms.section2Content': 'Plebs.place는 Nostr 프로토콜을 활용한 탈중앙화 비디오 공유 플랫폼입니다. 비디오 호스팅, 공유, 라이트닝 네트워크 수익화 도구를 제공합니다.',
        'terms.section3Title': '3. 사용자 책임',
        'terms.section3Content': '플랫폼을 통해 게시하는 모든 콘텐츠에 대한 책임은 사용자에게 있습니다. 불법적이거나 유해하거나 타인의 권리를 침해하는 콘텐츠를 업로드하지 않을 것에 동의합니다.',
        'terms.section4Title': '4. 콘텐츠 소유권',
        'terms.section4Content': '콘텐츠의 완전한 소유권은 사용자에게 있습니다. 업로드함으로써 Plebs.place에 비디오를 호스팅하고 제공할 수 있는 제한적 라이선스를 부여합니다.',
        'terms.section5Title': '5. 금지된 사용',
        'terms.section5Content': '불법 활동, 괴롭힘, 스팸, 유해 콘텐츠 배포에 플랫폼을 사용할 수 없습니다.',
        'terms.section6Title': '6. 계정 관리',
        'terms.section6Content': 'Nostr 키를 올바르게 관리하여 계정을 보호하는 것은 사용자의 책임입니다. 개인 키를 저장하지 않으며 분실된 계정은 복구할 수 없습니다.',
        'terms.section7Title': '7. 결제 조건',
        'terms.section7Content': '모든 결제는 라이트닝 네트워크를 통해 처리됩니다. 거래는 최종적이며 되돌릴 수 없습니다. 결제 전 모든 세부 사항을 확인하세요.',
        'terms.section8Title': '8. 책임 제한',
        'terms.section8Content': 'Plebs.place는 보증 없이 "있는 그대로" 제공됩니다. 손실, 손해 또는 서비스 중단에 대해 책임지지 않습니다.',
        'terms.section9Title': '9. 약관 변경',
        'terms.section9Content': '이 약관은 수시로 업데이트될 수 있습니다. 계속 사용하면 업데이트된 약관에 동의한 것으로 간주됩니다.',

        // Privacy Page
        'privacy.title': '개인정보 처리방침',
        'privacy.lastUpdated': '최종 업데이트',
        'privacy.section1Title': '1. 소개',
        'privacy.section1Content': '이 개인정보 처리방침은 Plebs.place의 탈중앙화 비디오 플랫폼 사용과 관련된 정보 처리 방법을 설명합니다.',
        'privacy.section2Title': '2. 수집하는 정보',
        'privacy.section2Content': '탈중앙화 플랫폼으로서 최소한의 데이터만 수집합니다. Nostr 공개 키는 인증에 사용되고, 비디오 메타데이터는 Nostr 릴레이에 저장됩니다.',
        'privacy.section3Title': '3. 데이터 저장',
        'privacy.section3Content': '콘텐츠는 탈중앙화 스토리지 솔루션에 저장됩니다. 중앙 서버에 개인 데이터를 저장하지 않습니다. 개인 키는 절대 공유되지 않습니다.',
        'privacy.section4Title': '4. 데이터 사용',
        'privacy.section4Content': '수집된 데이터는 플랫폼 서비스 제공 및 개선에만 사용됩니다. 데이터를 제3자에게 판매하지 않습니다.',
        'privacy.section5Title': '5. 쿠키 및 추적',
        'privacy.section5Content': '기본 기능을 위해 최소한의 쿠키를 사용합니다. 광고 추적이나 마케팅 목적의 데이터 수집은 하지 않습니다.',
        'privacy.section6Title': '6. 제3자 서비스',
        'privacy.section6Content': 'Nostr 릴레이 및 라이트닝 네트워크 노드와 통합됩니다. 이러한 서비스에는 자체 개인정보 처리방침이 있습니다.',
        'privacy.section7Title': '7. 데이터 보안',
        'privacy.section7Content': '탈중앙화 아키텍처를 통해 정보를 보호합니다. 그러나 개인 키를 보호하는 것은 사용자의 책임입니다.',
        'privacy.section8Title': '8. 사용자의 권리',
        'privacy.section8Content': '데이터를 완전히 제어합니다. 언제든지 콘텐츠를 삭제하거나 플랫폼 사용을 중단할 수 있습니다.',
        'privacy.section9Title': '9. 아동 개인정보',
        'privacy.section9Content': 'Plebs.place는 13세 미만 아동을 대상으로 하지 않습니다. 미성년자의 정보를 의도적으로 수집하지 않습니다.',
        'privacy.section10Title': '10. 정책 변경',
        'privacy.section10Content': '이 개인정보 처리방침을 업데이트할 수 있습니다. 변경 사항은 업데이트 날짜와 함께 이 페이지에 게시됩니다.',

        // FAQ Page
        'faq.title': '자주 묻는 질문',
        'faq.subtitle': '자주 묻는 질문과 답변',
        'faq.general': '일반',
        'faq.technical': '기술',
        'faq.monetization': '수익화',
        'faq.content': '콘텐츠',
        'faq.q1': 'Plebs.place란 무엇인가요?',
        'faq.a1': 'Plebs.place는 Nostr 프로토콜 기반의 탈중앙화 비디오 공유 플랫폼으로, 콘텐츠와 시청자를 완전히 소유할 수 있습니다.',
        'faq.q2': 'Plebs.place는 어떻게 작동하나요?',
        'faq.a2': '플랫폼은 Nostr로 인증 및 소셜, 탈중앙화 스토리지로 비디오 호스팅, 라이트닝 네트워크로 즉시 결제를 처리합니다.',
        'faq.q3': 'Plebs.place는 무료인가요?',
        'faq.a3': '네, 계정 생성, 업로드, 시청은 무료입니다. 시작하려면 Nostr 키만 있으면 됩니다.',
        'faq.q4': 'Nostr란 무엇인가요?',
        'faq.a4': 'Nostr는 중앙 플랫폼에 의존하지 않고 신원과 데이터를 제어할 수 있는 탈중앙화 통신 프로토콜입니다.',
        'faq.q5': '계정은 어떻게 만드나요?',
        'faq.a5': 'Alby나 nos2x 같은 Nostr 브라우저 확장 프로그램으로 로그인하거나 새 Nostr 키를 생성할 수 있습니다.',
        'faq.q6': '어떤 비디오 형식이 지원되나요?',
        'faq.a6': 'MP4, WebM, MOV 등 대부분의 일반적인 형식을 지원합니다. 비디오는 업로드 후 트랜스코딩됩니다.',
        'faq.q7': '비디오는 어디에 저장되나요?',
        'faq.a7': '비디오는 탈중앙화 스토리지 솔루션에 저장되어 콘텐츠가 단일 서버에 종속되지 않습니다.',
        'faq.q8': '라이트닝 네트워크란 무엇인가요?',
        'faq.a8': '라이트닝 네트워크는 비트코인의 레이어 2 결제 프로토콜로, 즉각적이고 저렴한 거래를 가능하게 합니다.',
        'faq.q9': 'Zaps란 무엇인가요?',
        'faq.a9': 'Zaps는 라이트닝 네트워크를 통해 전송되는 비트코인 소액 결제로, 크리에이터를 지원하는 데 사용됩니다.',
        'faq.q10': '콘텐츠로 어떻게 수익을 창출하나요?',
        'faq.a10': '크리에이터는 시청자 Zaps, 유료 콘텐츠, 라이트닝을 통한 직접 기부로 수익을 얻을 수 있습니다.',
        'faq.q11': '수익은 어떻게 인출하나요?',
        'faq.a11': '수익은 라이트닝 지갑으로 직접 도착합니다. 최소 인출 금액이나 대기 기간이 없습니다.',
        'faq.q12': '어떤 콘텐츠가 허용되나요?',
        'faq.a12': '합법적인 콘텐츠는 환영합니다. 이용약관을 따르고 유해하거나 불법적인 자료는 피해 주세요.',
        'faq.q13': '비디오를 삭제할 수 있나요?',
        'faq.a13': '네, 언제든지 비디오를 삭제할 수 있습니다. 탈중앙화 특성상 이미 배포된 사본은 다른 노드에 남아 있을 수 있습니다.',
        'faq.q14': '콘텐츠 중재가 있나요?',
        'faq.a14': '탈중앙화 플랫폼으로서 중재는 커뮤니티 주도 접근 방식과 사용자 제어를 통해 이루어집니다.',
        'faq.q15': '문제 있는 콘텐츠는 어떻게 신고하나요?',
        'faq.a15': '비디오의 신고 기능을 사용하거나 연락처 정보를 통해 알려주세요. 커뮤니티 피드백이 플랫폼 품질 유지에 도움이 됩니다.',
        // FAQ Self-Moderation Section
        'faq.selfModeration': '자체 조정',
        'faq.q16': '탈중앙화 플랫폼에서 조정은 어떻게 작동하나요?',
        'faq.a16': '중앙 집중식 조정자가 있는 기존 플랫폼과 달리, Plebs는 여러분이 보는 것을 제어합니다. 콘텐츠 필터 팩, 사용자 음소거, 커뮤니티 경고, 비율 동영상 표시기 등 강력한 자체 조정 도구를 제공합니다. 어떤 콘텐츠가 적절한지 결정하는 것은 여러분입니다 - 중앙 권한이 그 결정을 내리지 않습니다.',
        'faq.q17': '콘텐츠 필터 팩이란 무엇인가요?',
        'faq.a17Intro': '콘텐츠 필터 팩은 특정 유형의 콘텐츠를 숨기기 위해 활성화할 수 있는 사전 정의된 키워드 필터입니다. 사용 가능한 팩은 다음과 같습니다:',
        'faq.a17Pack1': '인종차별 및 혐오 발언:',
        'faq.a17Pack1Desc': '인종 비방 및 차별적 콘텐츠 필터링',
        'faq.a17Pack2': '성적으로 노골적인 콘텐츠:',
        'faq.a17Pack2Desc': '포르노 및 성인 콘텐츠 필터링',
        'faq.a17Pack3': '폭력 및 고어:',
        'faq.a17Pack3Desc': '그래픽 폭력 및 자해 콘텐츠 필터링',
        'faq.a17Pack4': '약물 및 물질:',
        'faq.a17Pack4Desc': '약물 관련 콘텐츠 필터링',
        'faq.a17Pack5': '스팸 및 사기:',
        'faq.a17Pack5Desc': '일반적인 스팸 및 사기 패턴 필터링',
        'faq.a17Pack6': '암호화폐:',
        'faq.a17Pack6Desc': '암호화폐 홍보 및 토큰 권유 필터링',
        'faq.a17Pack7': '정치 콘텐츠:',
        'faq.a17Pack7Desc': '당파적 정치 콘텐츠 필터링',
        'faq.a17Pack8': '심한 욕설:',
        'faq.a17Pack8Desc': '저속한 언어 필터링',
        'faq.a17Note': '설정 > 콘텐츠 필터에서 활성화할 수 있습니다. 사용자 정의 키워드도 추가할 수 있습니다. 필터링된 콘텐츠는 임시로 보고 싶은 경우 "어쨌든 보기" 버튼이 있는 자리 표시자를 표시합니다.',
        'faq.q18': '사용자를 음소거하려면 어떻게 하나요?',
        'faq.a18': '사용자를 음소거하려면 해당 사용자의 프로필을 방문하여 음소거 버튼을 클릭하세요. 음소거되면 해당 사용자의 모든 동영상이 피드에서 숨겨지고, 댓글은 "음소거된 사용자의 메시지"로 표시되며, 라이브 채팅 메시지도 숨겨집니다. 음소거 목록은 Nostr에 저장되므로 기기 간에 동기화됩니다. 프로필 설정의 "음소거된 사용자"에서 음소거된 사용자를 관리할 수 있습니다.',
        'faq.q19': '"비율"이란 무엇을 의미하나요?',
        'faq.a19': '동영상은 좋아요보다 싫어요가 훨씬 많으면 "비율"로 표시되어 부정적인 커뮤니티 반응을 나타냅니다. 구체적으로, 동영상에 최소 10개의 반응이 있고, 싫어요가 좋아요의 최소 두 배이고, 싫어요가 전체 반응의 70% 이상을 차지하면 비율이 됩니다. 비율 동영상에는 경고 배지가 표시되며 시청하기 전에 확인을 요청받습니다.',
        'faq.q20': '커뮤니티 경고는 어떻게 작동하나요?',
        'faq.a20': '사용자는 다양한 이유(스팸, 불법 콘텐츠, 학대, 오해의 소지 등)로 콘텐츠를 신고할 수 있습니다. 동영상이나 사용자가 팔로우하는 사람들로부터 5건 이상의 신고를 받으면 경고 표시가 나타납니다. 이것은 여러분의 소셜 그래프를 활용합니다 - 경고는 익명의 낯선 사람이 아닌 신뢰할 수 있는 네트워크에서 옵니다. 설정에서 "팔로우하는 계정의 경고 표시"를 전환할 수 있습니다.',
        'faq.q21': '콘텐츠를 신고하려면 어떻게 하나요?',
        'faq.a21': '동영상, 댓글 또는 사용자 프로필의 깃발 아이콘을 클릭하여 신고하세요. 이유(스팸, 불법, 학대, 오해의 소지, 사칭, 저작권, 기타)를 선택하고 선택적으로 세부 정보를 추가하세요. 신고는 이벤트로 Nostr에 게시되어 투명하고 분산화됩니다. 여러분의 신고는 네트워크의 다른 사람들이 문제가 있는 콘텐츠를 식별하는 데 도움이 됩니다.',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': '개인정보 보호 및 보안',
        'faq.q22': '내 활동은 비공개인가요?',
        'faq.a22': 'Nostr에서는 대부분의 활동이 설계상 공개입니다. 좋아요, 댓글, 팔로우, Zap은 공개 네트워크에서 볼 수 있습니다. 그러나 Plebs는 시청 기록을 브라우저에 로컬로 저장합니다 - 서버로 전송되지 않습니다. 언제든지 로컬 데이터를 지울 수 있습니다.',
        'faq.q23': '계정을 안전하게 유지하려면 어떻게 하나요?',
        'faq.a23': '개인 키(nsec)를 누구와도 공유하지 마세요. Alby, nos2x 또는 하드웨어 서명자와 같은 Nostr 브라우저 확장 프로그램을 사용하는 것을 강력히 권장합니다. 이들은 개인 키를 안전하게 보관하고 승인할 때만 이벤트에 서명합니다. 웹사이트에 직접 nsec를 저장하지 마세요.',
        'faq.q24': '콘텐츠를 삭제할 수 있나요?',
        'faq.a24': 'Nostr에 삭제 이벤트를 게시하여 삭제를 요청할 수 있습니다. 대부분의 잘 작동하는 릴레이 및 클라이언트는 이를 존중합니다. 그러나 네트워크의 분산 특성상 콘텐츠가 일부 릴레이나 Blossom 서버에 지속될 수 있습니다. 전체 네트워크에서 완전한 삭제를 강제할 수 있는 중앙 권한은 없습니다.',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': '문제 해결',
        'faq.q25': '동영상이 로드되지 않습니다 - 어떻게 해야 하나요?',
        'faq.a25Intro': '동영상이 로드되지 않으면 다음 단계를 시도하세요:',
        'faq.a25Item1': '페이지 새로 고침',
        'faq.a25Item2': '인터넷 연결 확인',
        'faq.a25Item3': '동영상을 호스팅하는 Blossom 서버가 다운되었을 수 있습니다 - 이것은 Plebs와 독립적입니다',
        'faq.a25Item4': '콘텐츠를 차단할 수 있는 브라우저 확장 프로그램을 비활성화해 보세요',
        'faq.a25Item5': '브라우저 캐시를 지우고 다시 시도',
        'faq.q26': '개인 키를 잃어버렸습니다 - 복구를 도와주실 수 있나요?',
        'faq.a26': '안타깝게도 아닙니다. Nostr 키는 암호화되어 있습니다 - 비밀번호 재설정이나 계정 복구는 없습니다. 중앙 권한이 없기 때문입니다. 그래서 키를 백업하고 안전한 키 관리 솔루션을 사용할 것을 강력히 권장합니다. nsec를 잃어버리면 새 신원을 만들어야 합니다.',
        'faq.q27': '버그를 신고하거나 기능을 요청하려면 어떻게 하나요?',
        'faq.a27': '<a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a> 페이지에서 버그를 신고하거나 기능을 요청할 수 있습니다. Nostr에서도 연락할 수 있습니다 - 자세한 내용은 <a href="#/contact">문의</a> 페이지를 참조하세요.',

        // Page Titles
        'pageTitle.following': '팔로잉',
        'pageTitle.myVideos': '내 동영상',
        'pageTitle.likedVideos': '좋아요한 동영상',
        'pageTitle.watchHistory': '시청 기록',
        'pageTitle.liveStreams': '라이브 스트림',
        'pageTitle.suffix': '- Plebs',
        'pageTitle.liveSuffix': '- Plebs 라이브',
        // Home Page Sections
        'section.trending': '인기 급상승',
        'section.recommended': '추천',
        'section.shorts': '쇼츠',
        'section.live': '라이브',
        'section.liveNow': '현재 라이브',
        'section.latestVideos': '최신 동영상',
        'section.videos': '동영상',
        'section.usersYouFollow': '팔로우한 사용자',
        // Trending Period
        'trending.thisWeek': '이번 주',
        'trending.today': '오늘',
        // Buttons
        'button.viewMore': '더보기',
        'button.clearAll': '모두 지우기',
        'button.showAnyway': '그래도 표시',
        // Confirmation Modals
        'confirm.logout': '로그아웃',
        'confirm.logoutMessage': '로그아웃하시겠습니까?',
        'confirm.resetSettings': '설정 초기화',
        'confirm.resetSettingsMessage': '모든 설정을 기본값으로 초기화하시겠습니까?',
        'confirm.reset': '초기화',
        'confirm.clearHistory': '기록 삭제',
        'confirm.clearHistoryMessage': '시청 기록을 모두 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.',
        'confirm.deleteDraft': '초안 삭제',
        'confirm.deleteDraftMessage': '이 초안을 삭제하시겠습니까?',
        'confirm.delete': '삭제',
        'confirm.deleteVideo': '동영상 삭제',
        'confirm.deleteVideoMessage': '이 동영상을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.',
        'confirm.endStream': '라이브 스트림 종료',
        'confirm.endStreamMessage': '이 라이브 스트림을 종료하시겠습니까? 이 작업은 되돌릴 수 없습니다.',
        'confirm.endStreamButton': '스트림 종료',
        // Content Filters
        'filter.hiddenByPack': '{pack}에 의해 숨김',
        'filter.showAnyway': '그래도 표시',
        'filter.contentHidden': '콘텐츠 필터로 인해 숨겨짐',
        // Filter Packs
        'filter.racism': '인종차별 및 혐오 발언', 'filter.racismDesc': '인종차별적 비방, 민족 혐오 발언 및 차별적 콘텐츠를 필터링', 'filter.sexualExplicit': '성적으로 노골적인 콘텐츠', 'filter.sexualExplicitDesc': '포르노 용어 및 성적으로 노골적인 콘텐츠를 필터링', 'filter.violence': '폭력 및 잔인함', 'filter.violenceDesc': '그래픽 폭력, 잔인한 콘텐츠 및 폭력 위협을 필터링', 'filter.drugs': '마약 및 약물', 'filter.drugsDesc': '마약 관련 콘텐츠 및 약물 남용을 필터링', 'filter.spam': '스팸 및 사기', 'filter.spamDesc': '일반적인 스팸, 사기 및 홍보 콘텐츠를 필터링', 'filter.crypto': '암호화폐', 'filter.cryptoDesc': '암호화폐 홍보, 거래 신호 및 토큰 홍보를 필터링', 'filter.politics': '정치적 콘텐츠', 'filter.politicsDesc': '당파적 정치 콘텐츠 및 분열적 수사를 필터링', 'filter.profanity': '강한 욕설', 'filter.profanityDesc': '강한 욕설 및 저속한 언어를 필터링', 'filter.customFilter': '사용자 정의 필터',
        // Following Page
        'following.noFollowingYet': '아직 팔로우한 사람이 없습니다. 팔로우할 크리에이터를 찾아보세요!',
    },
    ar: {
        // Navigation & Header
        'nav.home': 'الرئيسية', 'nav.following': 'المتابَعون', 'nav.myVideos': 'مقاطعي', 'nav.liked': 'الإعجابات', 'nav.history': 'السجل', 'nav.topics': 'المواضيع', 'nav.live': 'مباشر', 'nav.bitcoin': 'بتكوين', 'nav.nostr': 'Nostr', 'nav.technology': 'تقنية', 'nav.gaming': 'ألعاب', 'nav.tutorials': 'دروس', 'nav.podcasts': 'بودكاست', 'nav.music': 'موسيقى', 'nav.nsfw': 'NSFW', 'nav.about': 'حول', 'nav.contact': 'اتصل', 'nav.terms': 'الشروط', 'nav.privacy': 'الخصوصية', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': 'البث المباشر', 'nav.github': 'GitHub',
        'header.search': 'بحث عن مقاطع...', 'header.notifications': 'الإشعارات', 'header.settings': 'الإعدادات', 'header.create': 'إنشاء', 'header.viewProfile': 'عرض الملف', 'header.logout': 'تسجيل خروج',
        // Login Modal
        'login.title': 'تسجيل الدخول عبر Nostr', 'login.extensionButton': 'تسجيل الدخول بإضافة Nostr', 'login.extensionDesc': 'استخدم إضافة التوقيع (Alby, nos2x, إلخ)', 'login.orDivider': 'أو', 'login.nsecLabel': 'تسجيل الدخول بالمفتاح الخاص (nsec)', 'login.nsecPlaceholder': 'أدخل nsec...', 'login.nsecButton': 'تسجيل الدخول بـ nsec', 'login.nsecWarning': 'تحذير: إدخال nsec مباشرة أقل أماناً من استخدام الإضافة. يرجى استخدام إضافة NIP-07 للحصول على أمان أفضل.', 'login.newToNostr': 'جديد على Nostr؟', 'login.createAccount': 'إنشاء حساب', 'login.learnMore': 'تعرف على المزيد عن Nostr',
        // Connect Modal
        'connect.title': 'الاتصال بـ Nostr', 'connect.or': 'أو', 'connect.extensionButton': 'توصيل إضافة Nostr', 'connect.extensionDesc': 'استخدم إضافة (Alby, nos2x, إلخ)', 'connect.nsecLabel': 'تسجيل الدخول بالمفتاح الخاص', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'الاتصال بـ nsec', 'connect.nsecWarning': 'تحذير: إدخال nsec مباشرة أقل أماناً. استخدم إضافة NIP-07 للحصول على أمان أفضل.', 'connect.newToNostr': 'جديد على Nostr؟', 'connect.createAccount': 'إنشاء حساب',
        // Private Key Modal
        'privateKey.title': 'مفتاحك الخاص', 'privateKey.warning': 'مهم: احفظ هذا في مكان آمن. إذا فقدت هذا المفتاح، ستفقد الوصول إلى حسابك. لا تشاركه مع أي شخص!', 'privateKey.show': 'إظهار المفتاح الخاص', 'privateKey.hide': 'إخفاء المفتاح الخاص', 'privateKey.copy': 'نسخ', 'privateKey.saved': 'لقد حفظت مفتاحي', 'privateKey.yourPublicKey': 'مفتاحك العام (npub):', 'privateKey.yourPrivateKey': 'مفتاحك الخاص (nsec):',
        // Signup Modal
        'signup.title': 'إنشاء حساب Nostr', 'signup.whatIsNostr': 'ما هو Nostr؟', 'signup.nostrDescription': 'Nostr هو بروتوكول لامركزي يمنحك التحكم في هويتك وبياناتك. لا يوجد خادم مركزي - حسابك هو زوج من المفاتيح المشفرة.', 'signup.whyNostr': 'لماذا Nostr؟', 'signup.benefit1': 'امتلك هويتك', 'signup.benefit2': 'بدون رقابة', 'signup.benefit3': 'قابلية النقل عبر المنصات', 'signup.createNew': 'إنشاء حساب جديد', 'signup.haveAccount': 'لديك حساب؟', 'signup.login': 'تسجيل الدخول', 'signup.createButton': 'إنشاء حساب', 'signup.generating': 'جاري إنشاء المفاتيح...', 'signup.displayName': 'الاسم المعروض', 'signup.displayNamePlaceholder': 'أدخل الاسم المعروض', 'signup.username': 'اسم المستخدم', 'signup.usernamePlaceholder': 'أدخل اسم المستخدم', 'signup.about': 'نبذة (اختياري)', 'signup.profilePicture': 'صورة الملف الشخصي (اختياري)', 'signup.lightningAddress': 'عنوان Lightning (اختياري)', 'signup.nostrAddress': 'عنوان Nostr', 'signup.nostrAddressPlaceholder': 'اسم_المستخدم', 'signup.nostrAddressHint': 'عنوان Nostr يسهل العثور على ملفك الشخصي. أحرف صغيرة وأرقام و _ و - فقط.', 'signup.nostrAddressRequired': 'الرجاء إدخال عنوان Nostr', 'signup.nostrAddressAvailable': 'متاح!', 'signup.nostrAddressUnavailable': 'مستخدم بالفعل', 'signup.nostrAddressChecking': 'جاري التحقق...', 'signup.nostrAddressInvalid': 'تنسيق اسم المستخدم غير صالح', 'signup.nostrAddressRegistering': 'جاري تسجيل عنوان Nostr...', 'signup.nostrAddressSuccess': 'تم تسجيل عنوان Nostr!', 'signup.nostrAddressFailed': 'تعذر تسجيل عنوان Nostr', 'signup.createAccountBtn': 'إنشاء حساب', 'signup.termsAgree': 'بإنشاء حساب، أنت توافق على', 'signup.and': 'و', 'signup.success': 'تم إنشاء الحساب بنجاح!', 'signup.yourPrivateKey': 'مفتاحك الخاص (nsec)', 'signup.keyWarning': 'هذه هي الطريقة الوحيدة للوصول إلى حسابك. احفظها بأمان!', 'signup.copyPrivateKey': 'نسخ المفتاح الخاص', 'signup.howToUseKey': 'كيفية استخدام مفتاحك الخاص', 'signup.continueToPlebs': 'المتابعة إلى Plebs', 'signup.step1': 'احفظه بأمان:', 'signup.step1Desc': 'احفظ nsec في مدير كلمات المرور، أو اكتبه، أو احفظه في ملف مشفر. لا تشاركه علنياً!', 'signup.step2': 'لتسجيل الدخول مرة أخرى:', 'signup.step2Desc': 'انقر على "المفتاح الخاص" في شاشة تسجيل الدخول والصق nsec. يعمل مثل كلمة المرور.', 'signup.step3': 'استخدم في تطبيقات أخرى:', 'signup.step3Desc': 'nsec يعمل في جميع تطبيقات Nostr - Damus وPrimal وAmethyst والمئات غيرها!', 'signup.step4': 'فكر في تطبيق توقيع:', 'signup.step4Desc': 'لأمان أفضل، استخدم تطبيقات مثل Amber (Android) أو إضافة متصفح مثل Alby لإدارة مفاتيحك.',
        // Notifications
        'notifications.title': 'الإشعارات', 'notifications.empty': 'لا توجد إشعارات', 'notifications.viewAll': 'عرض جميع الإشعارات', 'notifications.markAllRead': 'تحديد الكل كمقروء', 'notifications.settings': 'إعدادات الإشعارات', 'notifications.loading': 'جاري تحميل الإشعارات...', 'notifications.zap': 'أرسل لك زاب', 'notifications.like': 'أعجب بالمحتوى', 'notifications.comment': 'علق', 'notifications.follow': 'تابعك', 'notifications.repost': 'أعاد النشر', 'notifications.mention': 'ذكرك',
        // Settings Modal
        'settings.title': 'الإعدادات', 'settings.language': 'اللغة', 'settings.languageDesc': 'اختر لغتك', 'settings.saveToNostr': 'حفظ في Nostr', 'settings.darkMode': 'الوضع الداكن', 'settings.darkModeDesc': 'تبديل السمة الداكنة/الفاتحة', 'settings.autoplay': 'التشغيل التلقائي', 'settings.autoplayDesc': 'تشغيل الفيديو تلقائياً', 'settings.saveSettings': 'حفظ الإعدادات', 'settings.resetDefaults': 'إعادة تعيين', 'settings.notificationSettings': 'إعدادات الإشعارات', 'settings.notifications': 'الإشعارات', 'settings.notificationsDesc': 'تلقي إشعارات الدفع', 'settings.quality': 'الجودة الافتراضية', 'settings.qualityDesc': 'جودة تشغيل الفيديو', 'settings.contentWarning': 'تفضيلات تحذير المحتوى', 'settings.showNsfwWarnings': 'إظهار تحذيرات NSFW', 'settings.showNsfwWarningsDesc': 'إظهار التحقق من العمر لمحتوى NSFW', 'settings.showCommunityWarnings': 'إظهار تحذيرات المجتمع', 'settings.showCommunityWarningsDesc': 'إظهار تحذيرات للمحتوى المبلغ عنه أو ذي التقييم السلبي', 'settings.showFollowsReportWarnings': 'إظهار تحذيرات بلاغات المتابعين', 'settings.showFollowsReportWarningsDesc': 'إظهار تحذيرات عندما يبلغ 5+ أشخاص تتابعهم عن محتوى', 'settings.filterPacks': 'حزم فلاتر المحتوى', 'settings.filterPacksDesc': 'تفعيل حزم الفلاتر لإخفاء المحتوى المطابق لكلمات مفتاحية محددة تلقائياً.', 'settings.customKeywordFilter': 'فلتر الكلمات المفتاحية المخصص', 'settings.customKeywordFilterPlaceholder': 'أدخل كلمات مفتاحية أو عبارات مفصولة بفواصل\nمثال: رسائل مزعجة، محتوى غير مرغوب، عبارة محددة', 'settings.customKeywordFilterDesc': 'أضف كلماتك المفتاحية للفلترة (مفصولة بفواصل)',
        // Upload Modal
        'upload.title': 'رفع فيديو', 'upload.dragDrop': 'اسحب وأفلت ملف الفيديو هنا', 'upload.or': 'أو', 'upload.browse': 'تصفح الملفات', 'upload.supportedFormats': 'الصيغ المدعومة: MP4, WebM, MOV', 'upload.maxSize': 'الحجم الأقصى: 2GB', 'upload.videoTitle': 'العنوان', 'upload.titlePlaceholder': 'أدخل عنوان الفيديو', 'upload.description': 'الوصف', 'upload.descriptionPlaceholder': 'صف الفيديو...', 'upload.tags': 'الوسوم', 'upload.tagsPlaceholder': 'أضف وسوماً مفصولة بفواصل', 'upload.visibility': 'الظهور', 'upload.public': 'عام', 'upload.unlisted': 'غير مدرج', 'upload.uploadButton': 'رفع الفيديو', 'upload.uploading': 'جاري الرفع...', 'upload.processing': 'جاري المعالجة...', 'upload.complete': 'اكتمل!', 'upload.error': 'فشل الرفع', 'upload.nsfw': 'محتوى للبالغين', 'upload.nsfwDesc': 'تحديد كمحتوى للبالغين', 'upload.thumbnail': 'الصورة المصغرة', 'upload.thumbnailDesc': 'رفع صورة مصغرة', 'upload.preparing': 'جاري التحضير...', 'upload.cancel': 'إلغاء', 'upload.progress': 'تقدم الرفع', 'upload.transcoding': 'التحويل', 'upload.status.preparing': 'جاري تحضير الرفع...', 'upload.status.uploading': 'جاري رفع الفيديو...', 'upload.status.transcoding': 'جاري تحويل الفيديو...', 'upload.status.complete': 'اكتمل الرفع!', 'upload.qualityHigh': 'عالية', 'upload.qualityMedium': 'متوسطة', 'upload.qualityLow': 'منخفضة',
        // Create Modal
        'create.title': 'إنشاء', 'create.uploadVideo': 'رفع فيديو', 'create.uploadDesc': 'مشاركة فيديو', 'create.goLive': 'بث مباشر', 'create.goLiveDesc': 'بدء بث مباشر', 'create.createPost': 'إنشاء منشور', 'create.createPostDesc': 'مشاركة نص',
        // Go Live Modal
        'goLive.title': 'بث مباشر', 'goLive.streamTitle': 'عنوان البث', 'goLive.streamTitlePlaceholder': 'أدخل عنوان البث', 'goLive.description': 'الوصف', 'goLive.descriptionPlaceholder': 'صف البث...', 'goLive.category': 'الفئة', 'goLive.selectCategory': 'اختر فئة', 'goLive.tags': 'الوسوم', 'goLive.tagsPlaceholder': 'أضف وسوماً مفصولة بفواصل', 'goLive.startStream': 'بدء البث', 'goLive.streamKey': 'مفتاح البث', 'goLive.streamUrl': 'رابط البث', 'goLive.copy': 'نسخ', 'goLive.hideKey': 'إخفاء المفتاح', 'goLive.showKey': 'إظهار المفتاح', 'goLive.connecting': 'جاري الاتصال...', 'goLive.live': 'مباشر', 'goLive.offline': 'غير متصل', 'goLive.viewers': 'مشاهدين', 'goLive.endStream': 'إنهاء البث', 'goLive.nsfw': 'محتوى للبالغين', 'goLive.nsfwDesc': 'تحديد كمحتوى للبالغين', 'goLive.thumbnail': 'صورة البث', 'goLive.thumbnailDesc': 'رفع صورة مصغرة', 'goLive.zapGoal': 'هدف Zap (اختياري)', 'goLive.zapGoalLabel': 'هدف Zap',
        // Video/Live No Description
        'video.noDescription': 'لم يتم إضافة وصف لهذا الفيديو.', 'live.noDescription': 'لم يتم إضافة وصف لهذا البث المباشر.',
        // Edit Stream Modal
        'editStream.title': 'تعديل البث', 'editStream.save': 'حفظ التغييرات',
        // NSFW Warning Modal
        'nsfw.title': 'تحذير: محتوى للبالغين', 'nsfw.warning': 'تم تحديد هذا المحتوى كـ NSFW وقد يحتوي على محتوى للبالغين.', 'nsfw.confirm': 'تأكيد عمرك', 'nsfw.confirmAge': 'عمري 18 سنة أو أكثر', 'nsfw.cancel': 'رجوع', 'nsfw.continue': 'متابعة', 'nsfw.dontShowAgain': 'عدم إظهار هذا التحذير مرة أخرى',
        // Community Warning Modal
        'community.title': 'إرشادات المجتمع', 'community.warning': 'يرجى مراجعة إرشادات المجتمع قبل المتابعة.', 'community.guidelines': 'كن محترماً واتبع معايير المجتمع.', 'community.accept': 'قبول', 'community.decline': 'رفض',
        'communityWarning.title': 'تحذير المجتمع', 'communityWarning.description': 'تم تمييز هذا الفيديو و/أو تلقى تقييمات سلبية كثيرة من المجتمع. قد يكون ذلك بسبب:', 'communityWarning.reason1': 'محتوى غير لائق لم يتم وضع علامة NSFW عليه بشكل صحيح', 'communityWarning.reason2': 'مستخدم جديد أو تفاصيل مستخدم مشبوهة', 'communityWarning.reason3': 'معلومات مضللة أو كاذبة', 'communityWarning.reason4': 'رسائل مزعجة أو محتوى منخفض الجودة', 'communityWarning.reason5': 'محتوى قد يكون ضارًا أو غير قانوني', 'communityWarning.proceed': 'تابع بحذر.', 'communityWarning.goBack': 'رجوع', 'communityWarning.viewAnyway': 'عرض على أي حال',
        // Report Modal
        'report.title': 'الإبلاغ عن محتوى', 'report.reason': 'سبب الإبلاغ', 'report.selectReason': 'اختر سبباً', 'report.spam': 'بريد مزعج أو مضلل', 'report.inappropriate': 'محتوى غير لائق', 'report.violence': 'محتوى عنيف أو خطير', 'report.copyright': 'انتهاك حقوق النشر', 'report.other': 'آخر', 'report.details': 'التفاصيل', 'report.detailsPlaceholder': 'قدم مزيداً من التفاصيل...', 'report.submit': 'إرسال البلاغ', 'report.cancel': 'إلغاء',
        // Share Modal
        'share.title': 'مشاركة', 'share.copyLink': 'نسخ الرابط', 'share.embed': 'كود التضمين', 'share.copyEmbed': 'نسخ كود التضمين', 'share.social': 'مشاركة على الشبكات الاجتماعية', 'share.twitter': 'تويتر', 'share.facebook': 'فيسبوك', 'share.reddit': 'ريديت', 'share.telegram': 'تيليجرام', 'share.whatsapp': 'واتساب', 'share.email': 'بريد إلكتروني', 'share.copied': 'تم النسخ!', 'share.nostr': 'مشاركة على Nostr', 'share.generateImage': 'إنشاء صورة', 'share.downloadImage': 'تحميل', 'share.shareImage': 'مشاركة', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (مربع)', 'share.size1080x1920': '1080 × 1920 (قصص)',
        // Edit Video Modal
        'editVideo.title': 'تعديل الفيديو', 'editVideo.videoTitle': 'العنوان', 'editVideo.description': 'الوصف', 'editVideo.tags': 'الوسوم', 'editVideo.thumbnail': 'الصورة المصغرة', 'editVideo.changeThumbnail': 'تغيير الصورة المصغرة', 'editVideo.visibility': 'الظهور', 'editVideo.nsfw': 'محتوى للبالغين', 'editVideo.save': 'حفظ التغييرات', 'editVideo.delete': 'حذف الفيديو', 'editVideo.confirmDelete': 'هل أنت متأكد من حذف هذا الفيديو؟',
        // Edit Profile Modal
        'editProfile.title': 'تعديل الملف الشخصي', 'editProfile.displayName': 'الاسم المعروض', 'editProfile.displayNamePlaceholder': 'أدخل الاسم المعروض', 'editProfile.username': 'اسم المستخدم', 'editProfile.usernamePlaceholder': 'أدخل اسم المستخدم', 'editProfile.about': 'نبذة', 'editProfile.aboutPlaceholder': 'أخبرنا عن نفسك...', 'editProfile.website': 'الموقع', 'editProfile.websitePlaceholder': 'https://yourwebsite.com', 'editProfile.lightning': 'عنوان Lightning', 'editProfile.lightningPlaceholder': 'you@getalby.com', 'editProfile.nip05': 'توثيق NIP-05', 'editProfile.nip05Placeholder': 'you@domain.com', 'editProfile.avatar': 'الصورة الرمزية', 'editProfile.changeAvatar': 'تغيير الصورة الرمزية', 'editProfile.banner': 'الغلاف', 'editProfile.changeBanner': 'تغيير الغلاف', 'editProfile.save': 'حفظ الملف الشخصي',
        // Confirmation Modal
        'confirm.title': 'تأكيد الإجراء', 'confirm.message': 'هل أنت متأكد من المتابعة؟', 'confirm.confirm': 'تأكيد', 'confirm.cancel': 'إلغاء',
        // Video Page
        'video.views': 'مشاهدات', 'video.like': 'إعجاب', 'video.dislike': 'عدم إعجاب', 'video.share': 'مشاركة', 'video.save': 'حفظ', 'video.report': 'إبلاغ', 'video.follow': 'متابعة', 'video.unfollow': 'إلغاء المتابعة', 'video.subscribe': 'اشتراك', 'video.subscribed': 'مشترك', 'video.comments': 'التعليقات', 'video.addComment': 'أضف تعليقاً...', 'video.reply': 'رد', 'video.replies': 'ردود', 'video.loadMore': 'تحميل المزيد', 'video.noComments': 'لا توجد تعليقات. كن أول من يعلق!', 'video.zap': 'زاب', 'video.zapAmount': 'مبلغ الزاب (ساتوشي)', 'video.sendZap': 'إرسال زاب', 'video.boost': 'تعزيز', 'video.description': 'الوصف', 'video.showMore': 'عرض المزيد', 'video.showLess': 'عرض أقل', 'video.publishedOn': 'نُشر في',
        // Toast Messages
        'toast.loggedIn': 'تم تسجيل الدخول بنجاح!', 'toast.settingsSaved': 'تم حفظ الإعدادات بنجاح!', 'toast.settingsLocal': 'تم حفظ الإعدادات محلياً. تعذر الحفظ على Nostr.', 'toast.settingsLocalOnly': 'تم حفظ الإعدادات محلياً!', 'toast.settingsReset': 'تم إعادة الإعدادات إلى الافتراضي!', 'toast.avatarUploaded': 'تم رفع الصورة الرمزية بنجاح!', 'toast.profileUpdated': 'تم تحديث الملف الشخصي بنجاح!', 'toast.copied': 'تم النسخ إلى الحافظة!', 'toast.copyFailed': 'فشل النسخ. يرجى النسخ يدوياً.', 'toast.installExtension': 'يرجى تثبيت إضافة Nostr للمتصفح مثل Alby أو nos2x', 'toast.loginFailed': 'فشل تسجيل الدخول بالإضافة. حاول مرة أخرى.', 'toast.invalidKey': 'مفتاح خاص غير صالح. تحقق وحاول مرة أخرى.', 'toast.enterKey': 'يرجى إدخال المفتاح الخاص', 'toast.enterUsername': 'يرجى إدخال اسم المستخدم', 'toast.accountCreated': 'مرحباً بك في Plebs! تم تسجيل دخولك.', 'toast.keyCopied': 'تم نسخ المفتاح الخاص إلى الحافظة!', 'toast.unmuted': 'تم إلغاء كتم المستخدم', 'toast.unmuteFailed': 'فشل إلغاء الكتم', 'toast.selectImage': 'يرجى اختيار ملف صورة', 'toast.imageTooLarge': 'يجب أن تكون الصورة أقل من 5 ميجابايت', 'toast.avatarFailed': 'فشل رفع الصورة الرمزية. حاول مرة أخرى.', 'toast.mustBeLoggedIn': 'يجب تسجيل الدخول لتعديل ملفك الشخصي', 'toast.enterDisplayName': 'يرجى إدخال الاسم المعروض', 'toast.profileFailed': 'فشل حفظ الملف الشخصي. حاول مرة أخرى.', 'toast.invalidBunker': 'يرجى إدخال رابط bunker صالح', 'toast.connectFailed': 'فشل الاتصال', 'toast.showingFiltered': 'عرض المحتوى المصفى', 'toast.reportSubmitted': 'تم إرسال البلاغ بنجاح', 'toast.draftSaved': 'تم حفظ المسودة! يمكنك المتابعة لاحقاً من فيديوهاتي.', 'toast.draftLoaded': 'تم تحميل المسودة. أكمل الرفع والنشر.', 'toast.draftDeleted': 'تم حذف المسودة', 'toast.languageChanged': 'تم تغيير اللغة', 'toast.videoBlocked': 'تم حظر الفيديو ونشره على Nostr', 'toast.waitForUpload': 'يرجى الانتظار حتى اكتمال رفع الفيديو', 'toast.enterTitle': 'يرجى إدخال العنوان', 'toast.publishing': 'جار نشر الفيديو على Nostr...',
        // Time
        'time.justNow': 'الآن', 'time.secondAgo': 'منذ ثانية', 'time.secondsAgo': 'منذ {n} ثانية', 'time.minuteAgo': 'منذ دقيقة', 'time.minutesAgo': 'منذ {n} دقيقة', 'time.hourAgo': 'منذ ساعة', 'time.hoursAgo': 'منذ {n} ساعة', 'time.dayAgo': 'منذ يوم', 'time.daysAgo': 'منذ {n} يوم', 'time.weekAgo': 'منذ أسبوع', 'time.weeksAgo': 'منذ {n} أسبوع', 'time.monthAgo': 'منذ شهر', 'time.monthsAgo': 'منذ {n} شهر', 'time.yearAgo': 'منذ سنة', 'time.yearsAgo': 'منذ {n} سنة',
        // Empty States
        'empty.noVideos': 'لم يتم العثور على فيديوهات', 'empty.noVideosDesc': 'جرب بحثاً آخر', 'empty.noFollowing': 'لم تتابع أي شخص بعد', 'empty.noFollowingDesc': 'تابع المبدعين لمشاهدة فيديوهاتهم', 'empty.noHistory': 'لا يوجد سجل مشاهدة', 'empty.noHistoryDesc': 'الفيديوهات التي تشاهدها ستظهر هنا', 'empty.noLiked': 'لا توجد فيديوهات أعجبتك', 'empty.noLikedDesc': 'الفيديوهات التي تعجبك ستظهر هنا', 'empty.noResults': 'لم يتم العثور على نتائج', 'empty.noResultsDesc': 'جرب كلمات مفتاحية أخرى',
        // Misc
        'misc.loading': 'جار التحميل...', 'misc.loadingMore': 'جار تحميل المزيد...', 'misc.refresh': 'تحديث', 'misc.retry': 'إعادة المحاولة', 'misc.close': 'إغلاق', 'misc.back': 'رجوع', 'misc.next': 'التالي', 'misc.previous': 'السابق', 'misc.search': 'بحث', 'misc.filter': 'تصفية', 'misc.sort': 'ترتيب', 'misc.newest': 'الأحدث', 'misc.oldest': 'الأقدم', 'misc.popular': 'الأكثر شعبية', 'misc.trending': 'الرائج', 'misc.sats': 'ساتوشي', 'misc.all': 'الكل', 'misc.copiedToClipboard': 'تم النسخ!',
        // Common
        'common.submit': 'إرسال', 'common.cancel': 'إلغاء', 'common.save': 'حفظ', 'common.delete': 'حذف', 'common.edit': 'تعديل', 'common.close': 'إغلاق', 'common.confirm': 'تأكيد', 'common.yes': 'نعم', 'common.no': 'لا', 'common.ok': 'حسناً', 'common.loading': 'جار التحميل...', 'common.uploading': 'جار الرفع...', 'common.error': 'خطأ', 'common.success': 'نجاح',
        // Aria Labels
        'aria.toggleMenu': 'تبديل القائمة', 'aria.mainNavigation': 'التنقل الرئيسي', 'aria.videoContent': 'محتوى الفيديو', 'aria.loadingContent': 'جار تحميل المحتوى', 'aria.closeModal': 'إغلاق النافذة', 'aria.playVideo': 'تشغيل الفيديو', 'aria.pauseVideo': 'إيقاف الفيديو', 'aria.muteVideo': 'كتم الصوت', 'aria.unmuteVideo': 'إلغاء الكتم', 'aria.fullscreen': 'ملء الشاشة', 'aria.exitFullscreen': 'الخروج من ملء الشاشة', 'aria.settings': 'الإعدادات', 'aria.notifications': 'الإشعارات', 'aria.userMenu': 'قائمة المستخدم', 'aria.searchInput': 'بحث عن فيديو', 'aria.videoPlayer': 'مشغل الفيديو',
        // Dynamic JavaScript text
        'button.hideQR': 'إخفاء رمز QR', 'button.showQR': 'إظهار رمز QR', 'button.copied': 'تم النسخ!', 'button.showLess': 'إظهار أقل', 'button.showMore': 'إظهار المزيد', 'button.creatingAccount': 'جار إنشاء الحساب...', 'button.submitting': 'جار الإرسال...', 'button.scheduleStream': 'جدولة البث', 'button.goLive': 'بدء البث', 'button.creatingStream': 'جار إنشاء البث...', 'button.continueCustomAmount': 'متابعة بمبلغ مخصص', 'button.recordFromCamera': 'تسجيل من الكاميرا', 'button.requestingCamera': 'جار طلب الكاميرا...', 'button.recording': 'جار التسجيل...',
        'status.saving': 'جار الحفظ...', 'status.saved': 'تم الحفظ!', 'status.uploading': 'جار الرفع...', 'status.uploadComplete': 'اكتمل الرفع!', 'status.uploadingToNostrBuild': 'جار الرفع إلى nostr.build...', 'status.publishingChanges': 'جار نشر التغييرات...', 'status.removingOldVersion': 'جار إزالة النسخة القديمة...', 'status.validatingThumbnail': 'جار التحقق من الصورة المصغرة...', 'status.uploadingThumbnail': 'جار رفع الصورة المصغرة...', 'status.thumbnailUploaded': 'تم رفع الصورة المصغرة!', 'status.processingVideo': 'جار معالجة الفيديو...', 'status.compressingVideo': 'جار ضغط الفيديو...', 'status.uploadingVideo': 'جار رفع الفيديو...', 'status.videoUploaded': 'تم رفع الفيديو بنجاح!', 'status.processing': 'جار المعالجة...', 'status.generatingThumbnail': 'جار إنشاء الصورة المصغرة...', 'status.generatingPreview': 'جار إنشاء المعاينة...', 'status.uploadingPreview': 'جار رفع المعاينة...', 'status.publishing': 'جار النشر...', 'status.publishingToNostr': 'جار النشر على Nostr...', 'status.publishingVideoToNostr': 'جار نشر الفيديو على Nostr...', 'status.generatingPoW': 'جار إنشاء إثبات العمل...', 'status.posting': 'جار النشر...', 'status.processingVideoAndThumbnail': 'جار معالجة الفيديو والصورة المصغرة...', 'status.uploadFailed': 'فشل الرفع - حاول مجدداً', 'status.selectVideoToUpload': 'اختر فيديو للرفع', 'status.waitingForVideoUpload': 'في انتظار رفع الفيديو...', 'status.selectVideoAndThumbnail': 'اختر الفيديو والصورة المصغرة للنشر', 'status.ready': 'جاهز ✓', 'status.failed': 'فشل ✗', 'status.fromDraft': 'من المسودة', 'status.startingNow': 'يبدأ الآن!', 'status.ended': 'انتهى', 'status.thumbnailReady': 'جاهز', 'status.thumbnailFailed': 'فشل', 'status.uploadFailedRetry': 'فشل الرفع. حاول مجدداً.',
        'publish.video': 'نشر الفيديو', 'publish.autoThumbnail': 'نشر الفيديو (صورة مصغرة تلقائية)',
        'report.titleComment': 'الإبلاغ عن تعليق', 'report.titleUser': 'الإبلاغ عن مستخدم', 'report.titleVideo': 'الإبلاغ عن فيديو', 'report.descComment': 'اختر سبب الإبلاغ عن هذا التعليق:', 'report.descUser': 'اختر سبب الإبلاغ عن هذا المستخدم:', 'report.descVideo': 'اختر سبب الإبلاغ عن هذا المحتوى:',
        'empty.noMutedUsers': 'لا يوجد مستخدمون مكتومون.', 'empty.noVideosToMonitor': 'لا توجد فيديوهات للمراقبة.', 'empty.noRecentActivity': 'لا يوجد نشاط حديث.', 'empty.failedLoadNotifications': 'فشل تحميل الإشعارات', 'empty.loginToViewLiked': 'يرجى <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">تسجيل الدخول</a> لعرض الفيديوهات المفضلة.', 'empty.loginToViewFollowing': 'يرجى <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">تسجيل الدخول</a> لعرض المتابَعين.', 'empty.loginToViewVideos': 'يرجى <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">تسجيل الدخول</a> لعرض فيديوهاتك.', 'empty.loginToViewAnalytics': 'يرجى <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">تسجيل الدخول</a> لعرض الإحصائيات.', 'empty.noLikedVideosYet': 'لم تعجب بأي فيديو بعد.', 'empty.noLikedVideosFound': 'لم يتم العثور على فيديوهات مفضلة.', 'empty.noFullLengthLikedVideos': 'لم يتم العثور على فيديوهات طويلة مفضلة.', 'empty.noWatchHistory': 'لا يوجد سجل مشاهدة. ابدأ مشاهدة الفيديوهات.', 'empty.noVideosInHistory': 'لا توجد فيديوهات في السجل.', 'empty.noFullLengthHistory': 'لا توجد فيديوهات طويلة في السجل.', 'empty.noMatchingVideos': 'لم يتم العثور على فيديوهات مطابقة.', 'empty.noFullLengthVideos': 'لم يتم العثور على فيديوهات طويلة.', 'empty.failedLoadTrending': 'فشل تحميل الرائج.', 'empty.noTrendingVideos': 'لم يتم العثور على فيديوهات رائجة.', 'empty.noMatchingUsers': 'لم يتم العثور على مستخدمين مطابقين.', 'empty.unableLoadProfiles': 'تعذر تحميل الملفات الشخصية.', 'empty.noFollowingVideos': 'لا توجد فيديوهات من المتابَعين.', 'empty.noFullLengthFollowing': 'لا توجد فيديوهات طويلة من المتابَعين.', 'empty.failedLoadFollowing': 'فشل التحميل. حاول مجدداً.', 'empty.noVideosUploadFirst': 'لا توجد فيديوهات. ارفع أول فيديو!', 'empty.noFullLengthUploaded': 'لم يتم العثور على فيديوهات طويلة.', 'empty.noMatchingLiveStreams': 'لم يتم العثور على بث مباشر مطابق.', 'empty.noMatchingShorts': 'لم يتم العثور على فيديوهات قصيرة مطابقة.', 'empty.noVideosForTag': 'لا توجد فيديوهات لهذا الوسم.', 'empty.noFullLengthForTag': 'لا توجد فيديوهات طويلة لهذا الوسم.', 'empty.noUploadedVideos': 'لم يتم رفع فيديوهات بعد.', 'empty.noVideosFound': 'لم يتم العثور على فيديوهات.', 'empty.failedLoadProfile': 'فشل تحميل الملف الشخصي. حاول مجدداً.', 'empty.noComments': 'لا توجد تعليقات بعد. كن أول من يعلق!', 'empty.failedLoadComments': 'فشل تحميل التعليقات', 'empty.noLiveNow': 'لا أحد يبث مباشرة الآن. كن الأول!',
        'error.videoNotFound': 'الفيديو غير موجود.', 'error.contentNotAvailable': 'هذا المحتوى غير متاح.', 'error.invalidVideoData': 'بيانات الفيديو غير صالحة.', 'error.videoNotAvailable': 'الفيديو غير متاح. ربما تم حذف الملف.', 'error.failedLoadVideo': 'فشل تحميل الفيديو. حاول مجدداً.', 'error.failedLoadVideoShort': 'فشل التحميل. ربما تم حذف الملف.', 'error.liveStreamNotFound': 'البث المباشر غير موجود.', 'error.invalidLiveStreamData': 'بيانات البث المباشر غير صالحة.', 'error.failedLoadLiveStream': 'فشل تحميل البث المباشر.',
        // New Button & Action Labels
        'button.follow': 'متابعة', 'button.unfollow': 'إلغاء المتابعة', 'button.mute': 'كتم', 'button.unmute': 'إلغاء الكتم', 'button.muteUser': 'كتم المستخدم', 'button.unmuteUser': 'إلغاء كتم المستخدم', 'button.confirm': 'تأكيد', 'button.cancel': 'إلغاء', 'button.close': 'إغلاق', 'button.boost': 'تعزيز', 'button.zap': 'Zap', 'button.viewMore': 'عرض المزيد', 'button.viewAnalytics': 'عرض الإحصائيات', 'button.backToMyVideos': 'العودة إلى فيديوهاتي', 'button.editDraft': 'تعديل المسودة', 'button.deleteDraft': 'حذف المسودة', 'button.editVideo': 'تعديل الفيديو', 'button.deleteVideo': 'حذف الفيديو', 'button.editShort': 'تعديل الشورت', 'button.deleteShort': 'حذف الشورت', 'button.editStream': 'تعديل البث', 'button.endStream': 'إنهاء البث', 'button.reset': 'إعادة تعيين', 'button.download': 'تحميل', 'button.watchRecording': 'مشاهدة التسجيل', 'button.show': 'عرض', 'button.login': 'تسجيل الدخول', 'button.toggleChat': 'تبديل الدردشة', 'button.blockVideo': 'حظر الفيديو', 'button.blockUser': 'حظر المستخدم', 'button.unblock': 'إلغاء الحظر', 'button.removeFromHistory': 'إزالة من السجل',
        // New Stats & Counts
        'stat.views': 'مشاهدات', 'stat.viewsCount': '{count} مشاهدة', 'stat.videos': 'فيديوهات', 'stat.video': 'فيديو', 'stat.followers': 'متابعين', 'stat.follower': 'متابع', 'stat.following': 'متابَعون', 'stat.subscribers': 'مشتركين', 'stat.comments': 'تعليقات', 'stat.liveCount': '{count} مباشر', 'stat.percentOfGoal': '{percent}% من الهدف', 'stat.netGrowth': 'النمو الصافي', 'stat.newFollowers': 'متابعون جدد', 'stat.unfollowed': 'إلغاء المتابعة', 'stat.lastUpdated': 'آخر تحديث: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'مباشر', 'badge.ended': 'انتهى', 'badge.scheduled': 'مجدول', 'badge.warning': 'تحذير', 'badge.communityWarning': 'تحذير المجتمع', 'badge.verifiedNip05': 'NIP-05 موثق', 'badge.streamer': 'مذيع', 'badge.clickToView': 'انقر للعرض',
        // New Actions
        'action.report': 'إبلاغ', 'action.reportComment': 'الإبلاغ عن التعليق', 'action.reportVideo': 'الإبلاغ عن الفيديو', 'action.reportStream': 'الإبلاغ عن البث', 'action.like': 'إعجاب', 'action.dislike': 'عدم إعجاب', 'action.reply': 'رد',
        // New Placeholders
        'placeholder.searchHistory': 'البحث في السجل...', 'placeholder.searchUsers': 'البحث عن مستخدمين...', 'placeholder.searchMyVideos': 'البحث في فيديوهاتي...', 'placeholder.eventId': 'أدخل معرف الحدث (hex أو nevent/note)', 'placeholder.pubkey': 'أدخل pubkey (hex أو npub)', 'placeholder.customAmount': 'مبلغ مخصص', 'placeholder.chatEnded': 'الدردشة مغلقة - انتهى البث', 'placeholder.addComment': 'أضف تعليقاً...', 'placeholder.setNewGoal': 'تعيين هدف جديد (sats)',
        // New Video & Content
        'video.untitledVideo': 'فيديو بدون عنوان', 'video.untitledShort': 'شورت بدون عنوان', 'video.upNext': 'التالي', 'video.noVideosYet': 'لا توجد فيديوهات بعد', 'video.noShortsYet': 'لا توجد شورتات بعد', 'video.noLiveStreamsYet': 'لا توجد بثوث مباشرة بعد', 'video.noBlockedVideos': 'لا توجد فيديوهات محظورة', 'video.noBlockedUsers': 'لا يوجد مستخدمون محظورون',
        // New Stream Messages
        'stream.ended': 'انتهى هذا البث. الدردشة مغلقة الآن.', 'stream.welcomeChat': 'مرحباً في الدردشة المباشرة!', 'stream.goalReached': 'تم تحقيق الهدف!', 'stream.zapGoalReached': 'تم تحقيق هدف Zap! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'رسالة من مستخدم مكتوم', 'muted.commentFromMutedUserHidden': 'تعليق من مستخدم مكتوم مخفي', 'muted.commentHidden': 'تعليق مخفي ({packs})', 'muted.messageHidden': 'رسالة مخفية ({packs})', 'muted.commentReportedByFollows': 'تعليق أبلغ عنه أشخاص تتابعهم', 'muted.messageReportedByFollows': 'رسالة أبلغ عنها أشخاص تتابعهم', 'muted.commentHeavilyDownvoted': 'تعليق حصل على تصويتات سلبية كثيرة', 'muted.messageHeavilyDownvoted': 'رسالة حصلت على تصويتات سلبية كثيرة',
        // New Admin & Lists
        'list.blockedVideos': 'فيديوهات محظورة', 'list.blockedUsers': 'مستخدمون محظورون',
        // New Alerts
        'alert.cameraNotSupported': 'الوصول إلى الكاميرا غير مدعوم في هذا المتصفح. يرجى استخدام متصفح حديث مثل Chrome أو Firefox أو Safari.', 'alert.noCameraFound': 'لم يتم العثور على كاميرا. يرجى توصيل كاميرا أو استخدام خيار رفع الملفات.', 'alert.cameraAccessDenied': 'تم رفض الوصول إلى الكاميرا. يرجى السماح بأذونات الكاميرا في إعدادات المتصفح.', 'alert.cameraInUse': 'الكاميرا قيد الاستخدام بواسطة تطبيق آخر. يرجى إغلاق التطبيقات الأخرى.', 'alert.cameraUnableAccess': 'لا يمكن الوصول إلى الكاميرا. يرجى استخدام خيار الرفع.', 'alert.cameraUnableAccessWithError': 'لا يمكن الوصول إلى الكاميرا: {error}\n\nيرجى استخدام خيار الرفع.', 'alert.fillRequiredFields': 'يرجى ملء جميع الحقول المطلوبة', 'alert.uploadThumbnail': 'يرجى رفع صورة مصغرة للبث', 'alert.failedCreateStream': 'فشل إنشاء البث المباشر. يرجى المحاولة مرة أخرى.', 'alert.failedUpdateStream': 'فشل التحديث. يرجى المحاولة مرة أخرى.', 'alert.streamNotFound': 'لم يتم العثور على البث', 'alert.canOnlyEditOwnStreams': 'يمكنك فقط تعديل بثوثك', 'alert.invalidStreamData': 'بيانات البث غير صالحة', 'alert.enterValidGoalAmount': 'يرجى إدخال مبلغ هدف صالح', 'alert.canOnlyResetOwnGoals': 'يمكنك فقط إعادة تعيين أهدافك', 'alert.streamEventNotFound': 'لم يتم العثور على حدث البث', 'alert.failedResetZapGoal': 'فشل إعادة تعيين هدف Zap. يرجى المحاولة مرة أخرى.', 'alert.cannotBlockAdmin': 'لا يمكن حظر حساب المشرف', 'alert.analyticsLoadFailed': 'فشل تحميل الإحصائيات. يرجى المحاولة مرة أخرى.', 'alert.cannotReplaceShortWithVideo': 'لا يمكن استبدال شورت بفيديو عادي. يرجى رفع فيديو عمودي (60 ثانية أو أقل).', 'alert.cannotReplaceVideoWithShort': 'لا يمكن استبدال فيديو عادي بشورت. يرجى رفع فيديو أفقي.', 'alert.shortsRequireVertical': 'يبدو أن هذا الفيديو أفقي. يجب أن تكون الشورتات فيديوهات عمودية. يرجى استخدام "رفع فيديو" للفيديوهات الأفقية.',
        // New Zap Messages
        'zap.cannotZapYourself': 'لا يمكنك إرسال Zap لنفسك', 'zap.cannotZapOwnContent': 'لا يمكنك إرسال Zap للمحتوى الخاص بك', 'zap.cannotZapOwnComment': 'لا يمكنك إرسال Zap لتعليقك', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'جاري تحميل الفيديو...', 'status.loading': 'جاري التحميل...', 'status.compressingProgress': 'جاري الضغط... {progress}%', 'status.uploadingProgress': 'جاري الرفع... {progress}%', 'status.uploadingServers': 'جاري الرفع... ({completed}/{total} خوادم)', 'status.publishedSuccess': 'تم نشر {type} بنجاح!',
        // New Warnings
        'warning.webmFormat': 'ملاحظة: سيخرج متصفحك بتنسيق WebM (قد لا يعمل على iOS). للحصول على MP4 متوافق مع iOS، استخدم Chrome على Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'آخر تحديث: ديسمبر 2024',
        // DMCA Page
        'dmca.title': 'DMCA وسياسة المحتوى',
        'dmca.lastUpdated': 'آخر تحديث: ديسمبر 2024',
        'dmca.architectureTitle': 'فهم بنية Plebs',
        'dmca.architectureDesc': 'Plebs هي واجهة منصة فيديو لامركزية تعمل بشكل مختلف عن خدمات استضافة الفيديو التقليدية.',
        'dmca.architectureItem1': 'Plebs لا تستضيف أي محتوى فيديو أو صور.',
        'dmca.architectureItem1Desc': 'نحن عميل/واجهة تعرض المحتوى المخزن في مكان آخر.',
        'dmca.architectureItem2': 'جميع ملفات الوسائط مخزنة على خوادم Blossom مستقلة.',
        'dmca.architectureItem3': 'بيانات الفيديو الوصفية تُنشر على مرحلات Nostr.',
        'dmca.architectureItem4': 'Plebs تجمع وتعرض هذا المحتوى الموزع فقط.',
        'dmca.filingTitle': 'تقديم مطالبة DMCA',
        'dmca.filingDesc': 'لأن Plebs لا تستضيف المحتوى، لا يمكننا إزالة المواد المخالفة مباشرة.',
        'dmca.forVideoTitle': '1. لمحتوى الفيديو/الصور',
        'dmca.forVideoDesc': 'ملفات الوسائط مخزنة على خوادم Blossom.',
        'dmca.forVideoItem1': 'تحديد أي خادم Blossom يستضيف المحتوى',
        'dmca.forVideoItem2': 'الاتصال مباشرة بمشغل خادم Blossom',
        'dmca.forVideoItem3': 'كل خادم Blossom يعمل بشكل مستقل',
        'dmca.forMetadataTitle': '2. للبيانات الوصفية/الأوصاف',
        'dmca.forMetadataDesc': 'إذا كان المحتوى المخالف في العنوان أو الوصف:',
        'dmca.forMetadataItem1': 'هذه المعلومات مخزنة على مرحلات Nostr',
        'dmca.forMetadataItem2': 'اتصل بمشغلي مرحلات Nostr المحددين',
        'dmca.forMetadataItem3': 'قد تخزن عدة مرحلات نفس البيانات',
        'dmca.whatWeCanDoTitle': 'ما يمكن لـ Plebs فعله',
        'dmca.whatWeCanDoDesc': 'على الرغم من أننا لا نستضيف المحتوى، يمكننا:',
        'dmca.whatWeCanDoItem1': 'مساعدتك في تحديد الخوادم التي تستضيف محتوى محدد',
        'dmca.whatWeCanDoItem2': 'إضافة المحتوى إلى قائمة حظر محلية',
        'dmca.whatWeCanDoItem3': 'تقديم إرشادات حول كيفية الاتصال بالمشغلين المناسبين',
        'dmca.toRequestAssistance': 'لطلب المساعدة، يرجى الاتصال بنا مع:',
        'dmca.assistanceItem1': 'رابط أو معرف المحتوى المخالف',
        'dmca.assistanceItem2': 'إثبات ملكية حقوق النشر الخاصة بك',
        'dmca.assistanceItem3': 'وصف للعمل المحمي',
        'dmca.blossomOperatorsTitle': 'مشغلو خوادم Blossom',
        'dmca.blossomOperatorsDesc': 'إذا كنت تدير خادم Blossom، فأنت مسؤول عن التعامل مع طلبات DMCA.',
        'dmca.blossomOperatorsLink': 'للحصول على قائمة بخوادم Blossom المعروفة، راجع الوثائق.',
        'dmca.considerationsTitle': 'اعتبارات مهمة',
        'dmca.considerationsItem1': 'اللامركزية:',
        'dmca.considerationsItem1Desc': 'قد لا يكون من الممكن إزالة المحتوى بالكامل من جميع المصادر.',
        'dmca.considerationsItem2': 'نسخ متعددة:',
        'dmca.considerationsItem2Desc': 'قد يتم نسخ المحتوى على خوادم متعددة.',
        'dmca.considerationsItem3': 'استمرار البيانات الوصفية:',
        'dmca.considerationsItem3Desc': 'قد تستمر البيانات الوصفية حتى بعد إزالة ملفات الوسائط.',
        'dmca.considerationsItem4': 'لا سيطرة مركزية:',
        'dmca.considerationsItem4Desc': 'لا يوجد كيان واحد يمكنه إزالة المحتوى من الشبكة بأكملها.',
        'dmca.counterNotificationTitle': 'إخطار مضاد',
        'dmca.counterNotificationDesc': 'إذا كنت تعتقد أن محتواك أُزيل بالخطأ، اتصل بمشغل الخادم.',
        'dmca.contactTitle': 'اتصل بنا',
        'dmca.contactDesc': 'للأسئلة، يرجى',
        'dmca.contactLink': 'الاتصال بنا',
        // Admin Dashboard
        'admin.title': 'لوحة تحكم المسؤول',
        'admin.loading': 'جاري تحميل تحليلات المنصة...',
        'admin.platformOverview': 'نظرة عامة على المنصة',
        'admin.totalVideos': 'إجمالي الفيديوهات',
        'admin.videos7Days': 'فيديوهات (7 أيام)',
        'admin.videos30Days': 'فيديوهات (30 يومًا)',
        'admin.uniqueCreators': 'منشئون فريدون',
        'admin.likes30Days': 'إعجابات (30 يومًا)',
        'admin.dislikes30Days': 'عدم إعجاب (30 يومًا)',
        'admin.monthlyActiveUsers': 'المستخدمون النشطون شهريًا',
        'admin.mauDesc': 'المستخدمون الفريدون الذين رفعوا أو تفاعلوا أو علقوا (آخر 6 أشهر)',
        'admin.boostRevenue': 'إيرادات Boost (آخر 30 يومًا)',
        'admin.totalBoostRevenue': 'إجمالي إيرادات Boost',
        'admin.totalBoosts': 'إجمالي Boosts',
        'admin.blocklistManagement': 'إدارة قائمة الحظر',
        'admin.blocklistDesc': 'حظر فيديوهات أو مستخدمين محددين.',
        'admin.blockedVideos': 'الفيديوهات المحظورة',
        'admin.blockedUsers': 'المستخدمون المحظورون',
        'admin.blockByEventId': 'حظر فيديو حسب المعرف',
        'admin.blockByPubkey': 'حظر مستخدم حسب المفتاح العام',
        'admin.blockVideo': 'حظر الفيديو',
        'admin.blockUser': 'حظر المستخدم',
        'admin.noBlockedVideos': 'لا توجد فيديوهات محظورة',
        'admin.noBlockedUsers': 'لا يوجد مستخدمون محظورون',
        'admin.unblock': 'إلغاء الحظر',
        'admin.accessDenied': 'تم رفض الوصول. للمسؤول فقط.',
        // Search/Trending/Channel/Buttons/Common
        'search.noVideosFound': 'لا توجد فيديوهات مطابقة لـ "{query}".',
        'search.noFullLengthVideos': 'لا توجد فيديوهات طويلة مطابقة لـ "{query}".',
        'trending.noVideosToday': 'لا توجد فيديوهات رائجة اليوم.',
        'trending.noVideosThisWeek': 'لا توجد فيديوهات رائجة هذا الأسبوع.',
        'channel.video': 'فيديو',
        'channel.videos': 'فيديوهات',
        'channel.follower': 'متابع',
        'channel.followers': 'متابعين',
        'button.follow': 'متابعة',
        'button.following': 'متابَع',
        'button.unfollow': 'إلغاء المتابعة',
        'button.mute': 'كتم',
        'button.unmute': 'إلغاء الكتم',
        'button.report': 'إبلاغ',
        'button.muteUser': 'كتم المستخدم',
        'button.unmuteUser': 'إلغاء كتم المستخدم',
        'button.reportComment': 'الإبلاغ عن التعليق',
        'button.reportUser': 'الإبلاغ عن هذا المستخدم',
        'live.goalReached': 'تم تحقيق الهدف!',
        'live.goalProgress': '{percent}% من الهدف',
        'common.loading': 'جاري التحميل...',
        'common.sats': 'sats',
        // Analytics
        'analytics.title': 'تحليلات القناة',
        'analytics.description': 'عرض مقاييس أداء قناتك والرؤى.',
        'analytics.loading': 'جاري تحميل التحليلات...',
        'analytics.error': 'فشل تحميل التحليلات',
        'analytics.overview': 'نظرة عامة',
        'analytics.videos': 'الفيديوهات',
        'analytics.engagement': 'التفاعل',
        'analytics.totalViews': 'إجمالي المشاهدات',
        'analytics.totalVideos': 'إجمالي الفيديوهات',
        'analytics.totalLikes': 'إجمالي الإعجابات',
        'analytics.totalZaps': 'إجمالي الـ Zaps',
        'analytics.avgViews': 'متوسط المشاهدات',
        'analytics.avgLikes': 'متوسط الإعجابات',
        'analytics.avgZaps': 'متوسط الـ Zaps',
        'analytics.viewsOverTime': 'المشاهدات عبر الزمن',
        'analytics.topVideos': 'أفضل الفيديوهات',
        'analytics.recentActivity': 'النشاط الأخير',
        'analytics.viewsLabel': 'المشاهدات',
        'analytics.likesLabel': 'الإعجابات',
        'analytics.zapsLabel': 'Zaps',
        'analytics.dateLabel': 'التاريخ',
        'analytics.videoTitle': 'عنوان الفيديو',
        'analytics.performance': 'الأداء',
        'analytics.noData': 'لا توجد بيانات تحليلية',
        'analytics.noDataDesc': 'ابدأ بتحميل الفيديوهات لرؤية تحليلاتك.',
        'analytics.last7Days': 'آخر 7 أيام',
        'analytics.last30Days': 'آخر 30 يوماً',
        'analytics.last90Days': 'آخر 90 يوماً',
        'analytics.allTime': 'كل الأوقات',
        'analytics.views': 'مشاهدات',
        'analytics.likes': 'إعجابات',
        'analytics.zaps': 'Zaps',
        'analytics.rank': 'الترتيب',
        'analytics.noVideos': 'لا توجد فيديوهات',
        'analytics.noVideosDesc': 'حمّل أول فيديو لك لبدء تتبع الأداء.',

        // About Page
        'about.title': 'حول Plebs.place',
        'about.subtitle': 'منصة فيديو لامركزية',
        'about.welcome': 'مرحباً بك في Plebs.place',
        'about.description': 'Plebs.place هي منصة مشاركة فيديو لامركزية مبنية على بروتوكول Nostr، تمنح المبدعين السيطرة الكاملة على محتواهم وجمهورهم.',
        'about.feature1Title': 'لامركزية',
        'about.feature1Desc': 'مبنية على Nostr، تضمن مقاومة الرقابة والملكية الحقيقية للمحتوى.',
        'about.feature2Title': 'الأولوية للمبدعين',
        'about.feature2Desc': 'احتفظ بالسيطرة الكاملة على محتواك وبياناتك وعلاقتك بجمهورك.',
        'about.feature3Title': 'تحقيق الدخل بالبيتكوين',
        'about.feature3Desc': 'احصل على الدعم مباشرة من المشاهدين عبر شبكة Lightning والـ Zaps.',
        'about.feature4Title': 'مفتوح المصدر',
        'about.feature4Desc': 'تطوير شفاف يقوده المجتمع ويتوافق مع روح اللامركزية.',
        'about.missionTitle': 'مهمتنا',
        'about.missionDesc': 'إنشاء منصة فيديو خالية من الرقابة، والحبس في المنصات، والتغييرات التعسفية للقواعد. محتواك ملكك.',
        'about.techTitle': 'التقنية',
        'about.techDesc': 'مبنية باستخدام Nostr للهوية والميزات الاجتماعية، وLightning للمدفوعات الصغيرة الفورية، وحلول التخزين اللامركزية.',

        // Contact Page
        'contact.title': 'اتصل بنا',
        'contact.subtitle': 'تواصل معنا',
        'contact.description': 'لديك أسئلة أو ملاحظات أو اقتراحات؟ نحب أن نسمع منك.',
        'contact.nostrTitle': 'تابعنا على Nostr',
        'contact.nostrDesc': 'تابعنا على Nostr للحصول على التحديثات والمشاركة في نقاشات المجتمع.',
        'contact.githubTitle': 'GitHub',
        'contact.githubDesc': 'اطلع على الكود المصدري، أبلغ عن المشكلات، أو ساهم في المشروع.',
        'contact.emailTitle': 'البريد الإلكتروني',
        'contact.emailDesc': 'للاستفسارات التجارية أو أسئلة الدعم، تواصل مع فريقنا.',

        // Terms Page
        'terms.title': 'شروط الخدمة',
        'terms.lastUpdated': 'آخر تحديث',
        'terms.section1Title': '1. قبول الشروط',
        'terms.section1Content': 'باستخدام Plebs.place، فإنك توافق على الالتزام بهذه الشروط. إذا كنت لا توافق، يرجى عدم استخدام المنصة.',
        'terms.section2Title': '2. وصف الخدمة',
        'terms.section2Content': 'Plebs.place هي منصة مشاركة فيديو لامركزية تستخدم بروتوكول Nostr. نوفر أدوات لاستضافة الفيديو ومشاركته وتحقيق الدخل عبر Lightning.',
        'terms.section3Title': '3. مسؤوليات المستخدم',
        'terms.section3Content': 'أنت مسؤول عن كل المحتوى الذي تنشره عبر المنصة. توافق على عدم تحميل أي محتوى غير قانوني أو ضار أو ينتهك حقوق الآخرين.',
        'terms.section4Title': '4. ملكية المحتوى',
        'terms.section4Content': 'تحتفظ بالملكية الكاملة لمحتواك. بالتحميل، تمنح Plebs.place ترخيصاً محدوداً لاستضافة وتقديم فيديوهاتك.',
        'terms.section5Title': '5. الاستخدام المحظور',
        'terms.section5Content': 'لا يجوز استخدام المنصة لأي أنشطة غير قانونية أو مضايقات أو رسائل مزعجة أو توزيع محتوى ضار.',
        'terms.section6Title': '6. إدارة الحساب',
        'terms.section6Content': 'أنت مسؤول عن تأمين حسابك من خلال إدارة مفاتيح Nostr بشكل صحيح. نحن لا نخزن مفتاحك الخاص ولا يمكننا استعادة الحسابات المفقودة.',
        'terms.section7Title': '7. شروط الدفع',
        'terms.section7Content': 'تتم جميع المدفوعات عبر شبكة Lightning. المعاملات نهائية ولا يمكن التراجع عنها. تأكد من التحقق من جميع تفاصيل الدفع قبل المعاملات.',
        'terms.section8Title': '8. حدود المسؤولية',
        'terms.section8Content': 'يتم توفير Plebs.place "كما هي" بدون ضمانات. لسنا مسؤولين عن أي خسائر أو أضرار أو انقطاعات في الخدمة.',
        'terms.section9Title': '9. تغييرات الشروط',
        'terms.section9Content': 'قد يتم تحديث هذه الشروط من وقت لآخر. الاستمرار في الاستخدام يعني قبول الشروط المحدثة.',

        // Privacy Page
        'privacy.title': 'سياسة الخصوصية',
        'privacy.lastUpdated': 'آخر تحديث',
        'privacy.section1Title': '1. مقدمة',
        'privacy.section1Content': 'توضح سياسة الخصوصية هذه كيفية تعامل Plebs.place مع المعلومات المتعلقة باستخدامك لمنصة الفيديو اللامركزية.',
        'privacy.section2Title': '2. المعلومات التي نجمعها',
        'privacy.section2Content': 'كمنصة لامركزية، نجمع الحد الأدنى من البيانات. يُستخدم مفتاحك العام على Nostr للمصادقة، وتُخزَّن بيانات الفيديو الوصفية على مرحلات Nostr.',
        'privacy.section3Title': '3. تخزين البيانات',
        'privacy.section3Content': 'يُخزَّن محتواك على حلول تخزين لامركزية. لا نخزن بيانات شخصية على خوادم مركزية. مفتاحك الخاص لا يُشارَك معنا أبداً.',
        'privacy.section4Title': '4. استخدام البيانات',
        'privacy.section4Content': 'تُستخدم أي بيانات نجمعها فقط لتوفير خدمات المنصة وتحسينها. لا نبيع بياناتك لأطراف ثالثة أبداً.',
        'privacy.section5Title': '5. ملفات تعريف الارتباط والتتبع',
        'privacy.section5Content': 'نستخدم الحد الأدنى من ملفات تعريف الارتباط للوظائف الأساسية. لا نقوم بتتبع الإعلانات أو جمع البيانات لأغراض التسويق.',
        'privacy.section6Title': '6. خدمات الطرف الثالث',
        'privacy.section6Content': 'نتكامل مع مرحلات Nostr وعقد شبكة Lightning. هذه الخدمات لها سياسات خصوصية خاصة بها.',
        'privacy.section7Title': '7. أمان البيانات',
        'privacy.section7Content': 'نحمي معلوماتك من خلال بنيتنا اللامركزية. ومع ذلك، أنت مسؤول عن حماية مفتاحك الخاص.',
        'privacy.section8Title': '8. حقوقك',
        'privacy.section8Content': 'لديك السيطرة الكاملة على بياناتك. يمكنك حذف محتواك أو التوقف عن استخدام المنصة في أي وقت.',
        'privacy.section9Title': '9. خصوصية الأطفال',
        'privacy.section9Content': 'Plebs.place ليست مخصصة للأطفال دون سن 13 عاماً. نحن لا نجمع معلومات من القاصرين عن قصد.',
        'privacy.section10Title': '10. تغييرات السياسة',
        'privacy.section10Content': 'قد نقوم بتحديث سياسة الخصوصية هذه. ستُنشر التغييرات على هذه الصفحة مع تاريخ التحديث.',

        // FAQ Page
        'faq.title': 'الأسئلة الشائعة',
        'faq.subtitle': 'الأسئلة المتكررة والإجابات',
        'faq.general': 'عام',
        'faq.technical': 'تقني',
        'faq.monetization': 'تحقيق الدخل',
        'faq.content': 'المحتوى',
        'faq.q1': 'ما هو Plebs.place؟',
        'faq.a1': 'Plebs.place هي منصة مشاركة فيديو لامركزية مبنية على بروتوكول Nostr، تمنحك الملكية الكاملة لمحتواك وجمهورك.',
        'faq.q2': 'كيف يعمل Plebs.place؟',
        'faq.a2': 'تستخدم المنصة Nostr للمصادقة والميزات الاجتماعية، والتخزين اللامركزي لاستضافة الفيديو، وشبكة Lightning للمدفوعات الفورية.',
        'faq.q3': 'هل Plebs.place مجاني؟',
        'faq.a3': 'نعم، إنشاء الحساب والتحميل والمشاهدة مجاني. تحتاج فقط إلى مفتاح Nostr للبدء.',
        'faq.q4': 'ما هو Nostr؟',
        'faq.a4': 'Nostr هو بروتوكول اتصالات لامركزي يتيح لك التحكم في هويتك وبياناتك دون الاعتماد على منصات مركزية.',
        'faq.q5': 'كيف أنشئ حساباً؟',
        'faq.a5': 'يمكنك تسجيل الدخول باستخدام إضافة متصفح Nostr مثل Alby أو nos2x، أو إنشاء مفتاح Nostr جديد.',
        'faq.q6': 'ما هي صيغ الفيديو المدعومة؟',
        'faq.a6': 'ندعم معظم الصيغ الشائعة بما في ذلك MP4 وWebM وMOV. يتم تحويل الفيديوهات بعد التحميل للحصول على أفضل تشغيل.',
        'faq.q7': 'أين تُخزَّن فيديوهاتي؟',
        'faq.a7': 'تُخزَّن الفيديوهات على حلول تخزين لامركزية، مما يضمن عدم سيطرة خادم واحد على محتواك.',
        'faq.q8': 'ما هي شبكة Lightning؟',
        'faq.a8': 'شبكة Lightning هي بروتوكول دفع من الطبقة الثانية للبيتكوين يتيح معاملات فورية ومنخفضة الرسوم.',
        'faq.q9': 'ما هي الـ Zaps؟',
        'faq.a9': 'الـ Zaps هي مدفوعات صغيرة بالبيتكوين تُرسَل عبر شبكة Lightning لدعم المبدعين.',
        'faq.q10': 'كيف أحقق الدخل من محتواي؟',
        'faq.a10': 'يمكن للمبدعين كسب الدخل من خلال Zaps المشاهدين، والمحتوى المدفوع، والتبرعات المباشرة عبر Lightning.',
        'faq.q11': 'كيف أسحب أرباحي؟',
        'faq.a11': 'تصل الأرباح مباشرة إلى محفظة Lightning الخاصة بك. لا يوجد حد أدنى للسحب أو فترات انتظار.',
        'faq.q12': 'ما المحتوى المسموح به؟',
        'faq.a12': 'المحتوى القانوني مرحب به. يرجى اتباع شروط الخدمة وتجنب المواد الضارة أو غير القانونية.',
        'faq.q13': 'هل يمكنني حذف فيديوهاتي؟',
        'faq.a13': 'نعم، يمكنك حذف الفيديوهات في أي وقت. بسبب الطبيعة اللامركزية، قد تبقى النسخ الموزعة على عقد أخرى.',
        'faq.q14': 'هل هناك إشراف على المحتوى؟',
        'faq.a14': 'كمنصة لامركزية، يتم الإشراف من خلال نهج يقوده المجتمع وتحكم المستخدمين.',
        'faq.q15': 'كيف أبلغ عن محتوى مسيء؟',
        'faq.a15': 'استخدم ميزة الإبلاغ على الفيديو أو أخبرنا من خلال معلومات الاتصال. تساعد ملاحظات المجتمع في الحفاظ على جودة المنصة.',
        // FAQ Self-Moderation Section
        'faq.selfModeration': 'الإشراف الذاتي',
        'faq.q16': 'كيف يعمل الإشراف على منصة لامركزية؟',
        'faq.a16': 'على عكس المنصات التقليدية ذات المشرفين المركزيين، يمنحك Plebs التحكم فيما تراه. نوفر أدوات إشراف ذاتي قوية بما في ذلك حزم فلاتر المحتوى، وكتم المستخدمين، وتحذيرات المجتمع، ومؤشرات الفيديوهات المنتقدة. أنت من يقرر ما هو المحتوى المناسب لك - لا توجد سلطة مركزية تتخذ هذه القرارات.',
        'faq.q17': 'ما هي حزم فلاتر المحتوى؟',
        'faq.a17Intro': 'حزم فلاتر المحتوى هي فلاتر كلمات رئيسية محددة مسبقاً يمكنك تفعيلها لإخفاء أنواع معينة من المحتوى. تشمل الحزم المتاحة:',
        'faq.a17Pack1': 'العنصرية وخطاب الكراهية:',
        'faq.a17Pack1Desc': 'تصفية الإهانات العنصرية والمحتوى التمييزي',
        'faq.a17Pack2': 'محتوى جنسي صريح:',
        'faq.a17Pack2Desc': 'تصفية المحتوى الإباحي والمحتوى للبالغين',
        'faq.a17Pack3': 'العنف والدموية:',
        'faq.a17Pack3Desc': 'تصفية العنف الصريح ومحتوى إيذاء النفس',
        'faq.a17Pack4': 'المخدرات والمواد:',
        'faq.a17Pack4Desc': 'تصفية المحتوى المتعلق بالمخدرات',
        'faq.a17Pack5': 'البريد المزعج والاحتيال:',
        'faq.a17Pack5Desc': 'تصفية أنماط البريد المزعج والاحتيال الشائعة',
        'faq.a17Pack6': 'العملات المشفرة:',
        'faq.a17Pack6Desc': 'تصفية الترويج للعملات المشفرة والرموز',
        'faq.a17Pack7': 'المحتوى السياسي:',
        'faq.a17Pack7Desc': 'تصفية المحتوى السياسي الحزبي',
        'faq.a17Pack8': 'لغة بذيئة قوية:',
        'faq.a17Pack8Desc': 'تصفية اللغة البذيئة',
        'faq.a17Note': 'قم بتفعيلها في الإعدادات > فلاتر المحتوى. يمكنك أيضاً إضافة كلمات رئيسية مخصصة. يعرض المحتوى المصفى عنصراً نائباً مع زر "عرض على أي حال" إذا أردت مشاهدته مؤقتاً.',
        'faq.q18': 'كيف أكتم مستخدماً؟',
        'faq.a18': 'لكتم مستخدم، قم بزيارة ملفه الشخصي وانقر على زر الكتم. بمجرد الكتم، سيتم إخفاء جميع مقاطع الفيديو الخاصة به من موجزك، وستظهر تعليقاته كـ "رسالة من مستخدم مكتوم"، وسيتم إخفاء رسائل الدردشة المباشرة الخاصة به. يتم تخزين قائمة الكتم الخاصة بك على Nostr، لذا تتزامن عبر الأجهزة. يمكنك إدارة المستخدمين المكتومين في إعدادات الملف الشخصي ضمن "المستخدمون المكتومون".',
        'faq.q19': 'ماذا يعني "منتقد"؟',
        'faq.a19': 'يتم تحديد الفيديو على أنه "منتقد" عندما يحصل على عدد كبير من عدم الإعجاب مقارنة بالإعجابات، مما يشير إلى استقبال سلبي من المجتمع. على وجه التحديد، يكون الفيديو منتقداً عندما يحتوي على 10 ردود فعل على الأقل، وعدم الإعجاب ضعف الإعجاب على الأقل، وعدم الإعجاب يشكل 70% أو أكثر من إجمالي ردود الفعل. تعرض مقاطع الفيديو المنتقدة شارة تحذير، وسيُطلب منك التأكيد قبل المشاهدة.',
        'faq.q20': 'كيف تعمل تحذيرات المجتمع؟',
        'faq.a20': 'يمكن للمستخدمين الإبلاغ عن المحتوى لأسباب مختلفة (بريد مزعج، محتوى غير قانوني، إساءة، مضلل، إلخ). عندما يتلقى فيديو أو مستخدم 5 بلاغات أو أكثر من أشخاص تتابعهم، يظهر مؤشر تحذير. يستفيد هذا من رسم التواصل الاجتماعي الخاص بك - تأتي التحذيرات من شبكتك الموثوقة، وليس من غرباء مجهولين. يمكنك تبديل "إظهار التحذيرات من الحسابات التي أتابعها" في الإعدادات.',
        'faq.q21': 'كيف أبلغ عن محتوى؟',
        'faq.a21': 'انقر على أيقونة العلم على أي فيديو أو تعليق أو ملف تعريف مستخدم للإبلاغ عنه. حدد سبباً (بريد مزعج، غير قانوني، إساءة، مضلل، انتحال شخصية، حقوق نشر، أو آخر) وأضف تفاصيل اختيارياً. يتم نشر البلاغات على Nostr كأحداث، مما يجعلها شفافة ولامركزية. تساعد بلاغاتك الآخرين في شبكتك على تحديد المحتوى الإشكالي.',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': 'الخصوصية والأمان',
        'faq.q22': 'هل نشاطي خاص؟',
        'faq.a22': 'على Nostr، معظم الأنشطة عامة بالتصميم. إعجاباتك وتعليقاتك ومتابعاتك وزاباتك مرئية على الشبكة العامة. ومع ذلك، يخزن Plebs سجل المشاهدة محلياً في متصفحك - لا يتم إرساله إلى أي خادم أبداً. يمكنك مسح بياناتك المحلية في أي وقت.',
        'faq.q23': 'كيف أحافظ على أمان حسابي؟',
        'faq.a23': 'لا تشارك مفتاحك الخاص (nsec) مع أي شخص أبداً. نوصي بشدة باستخدام إضافة متصفح Nostr مثل Alby أو nos2x أو موقِّع أجهزة. هذه تحافظ على مفتاحك الخاص آمناً وتوقع الأحداث فقط عند الموافقة عليها. تجنب تخزين nsec الخاص بك مباشرة في المواقع.',
        'faq.q24': 'هل يمكنني حذف المحتوى الخاص بي؟',
        'faq.a24': 'يمكنك طلب الحذف من خلال نشر حدث حذف على Nostr. ستحترم معظم المرحلات والعملاء الذين يعملون بشكل جيد هذا. ومع ذلك، بسبب الطبيعة اللامركزية للشبكة، قد يستمر المحتوى على بعض المرحلات أو خوادم Blossom. لا توجد سلطة مركزية يمكنها فرض الحذف الكامل عبر الشبكة بأكملها.',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': 'استكشاف الأخطاء وإصلاحها',
        'faq.q25': 'لا يتم تحميل مقاطع الفيديو - ماذا أفعل؟',
        'faq.a25Intro': 'إذا لم يتم تحميل مقاطع الفيديو، جرب هذه الخطوات:',
        'faq.a25Item1': 'أعد تحميل الصفحة',
        'faq.a25Item2': 'تحقق من اتصالك بالإنترنت',
        'faq.a25Item3': 'قد يكون خادم Blossom الذي يستضيف الفيديو معطلاً - هذا مستقل عن Plebs',
        'faq.a25Item4': 'حاول تعطيل إضافات المتصفح التي قد تحظر المحتوى',
        'faq.a25Item5': 'امسح ذاكرة التخزين المؤقت لمتصفحك وحاول مرة أخرى',
        'faq.q26': 'فقدت مفتاحي الخاص - هل يمكنك مساعدتي في استرداده؟',
        'faq.a26': 'للأسف، لا. مفاتيح Nostr مشفرة - لا يوجد إعادة تعيين كلمة المرور أو استرداد للحساب لأنه لا توجد سلطة مركزية. لهذا السبب نوصي بشدة بعمل نسخة احتياطية من مفاتيحك واستخدام حل إدارة مفاتيح آمن. إذا فقدت nsec الخاص بك، ستحتاج إلى إنشاء هوية جديدة.',
        'faq.q27': 'كيف أبلغ عن خطأ أو أطلب ميزة؟',
        'faq.a27': 'يمكنك الإبلاغ عن الأخطاء أو طلب الميزات على صفحة <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a> الخاصة بنا. يمكنك أيضاً التواصل معنا على Nostr - تفضل بزيارة صفحة <a href="#/contact">اتصل بنا</a> للحصول على التفاصيل.',

        // Page Titles
        'pageTitle.following': 'المتابعون',
        'pageTitle.myVideos': 'مقاطعي',
        'pageTitle.likedVideos': 'المقاطع المعجب بها',
        'pageTitle.watchHistory': 'سجل المشاهدة',
        'pageTitle.liveStreams': 'البث المباشر',
        'pageTitle.suffix': '- Plebs',
        'pageTitle.liveSuffix': '- مباشر على Plebs',
        // Home Page Sections
        'section.trending': 'الرائج',
        'section.recommended': 'موصى به لك',
        'section.shorts': 'المقاطع القصيرة',
        'section.live': 'مباشر',
        'section.liveNow': 'مباشر الآن',
        'section.latestVideos': 'أحدث المقاطع',
        'section.videos': 'المقاطع',
        'section.usersYouFollow': 'المستخدمون المتابَعون',
        // Trending Period
        'trending.thisWeek': 'هذا الأسبوع',
        'trending.today': 'اليوم',
        // Buttons
        'button.viewMore': 'عرض المزيد',
        'button.clearAll': 'مسح الكل',
        'button.showAnyway': 'إظهار على أي حال',
        // Confirmation Modals
        'confirm.logout': 'تسجيل الخروج',
        'confirm.logoutMessage': 'هل أنت متأكد من تسجيل الخروج؟',
        'confirm.resetSettings': 'إعادة تعيين الإعدادات',
        'confirm.resetSettingsMessage': 'هل أنت متأكد من إعادة تعيين جميع الإعدادات إلى القيم الافتراضية؟',
        'confirm.reset': 'إعادة تعيين',
        'confirm.clearHistory': 'مسح السجل',
        'confirm.clearHistoryMessage': 'هل أنت متأكد من مسح سجل المشاهدة بالكامل؟ لا يمكن التراجع عن هذا الإجراء.',
        'confirm.deleteDraft': 'حذف المسودة',
        'confirm.deleteDraftMessage': 'هل أنت متأكد من حذف هذه المسودة؟',
        'confirm.delete': 'حذف',
        'confirm.deleteVideo': 'حذف المقطع',
        'confirm.deleteVideoMessage': 'هل أنت متأكد من حذف هذا المقطع؟ لا يمكن التراجع عن هذا الإجراء.',
        'confirm.endStream': 'إنهاء البث المباشر',
        'confirm.endStreamMessage': 'هل أنت متأكد من إنهاء هذا البث المباشر؟ لا يمكن التراجع عن هذا الإجراء.',
        'confirm.endStreamButton': 'إنهاء البث',
        // Content Filters
        'filter.hiddenByPack': 'مخفي بواسطة {pack}',
        'filter.showAnyway': 'إظهار على أي حال',
        'filter.contentHidden': 'المحتوى مخفي بواسطة مرشح المحتوى',
        // Filter Packs
        'filter.racism': 'العنصرية وخطاب الكراهية', 'filter.racismDesc': 'يرشح الإهانات العنصرية وخطاب الكراهية العرقية والمحتوى التمييزي', 'filter.sexualExplicit': 'محتوى جنسي صريح', 'filter.sexualExplicitDesc': 'يرشح المصطلحات الإباحية والمحتوى الجنسي الصريح', 'filter.violence': 'العنف والدموية', 'filter.violenceDesc': 'يرشح العنف الرسومي والدموية والتهديدات العنيفة', 'filter.drugs': 'المخدرات والمواد', 'filter.drugsDesc': 'يرشح المحتوى المتعلق بالمخدرات وإساءة استخدام المواد', 'filter.spam': 'الرسائل المزعجة والاحتيال', 'filter.spamDesc': 'يرشح الرسائل المزعجة الشائعة والاحتيال والمحتوى الترويجي', 'filter.crypto': 'العملات المشفرة', 'filter.cryptoDesc': 'يرشح ترويج العملات المشفرة وإشارات التداول والترويج للرموز', 'filter.politics': 'المحتوى السياسي', 'filter.politicsDesc': 'يرشح المحتوى السياسي الحزبي والخطاب المنقسم', 'filter.profanity': 'الألفاظ البذيئة', 'filter.profanityDesc': 'يرشح الألفاظ البذيئة القوية واللغة الفجة', 'filter.customFilter': 'مرشح مخصص',
        // Following Page
        'following.noFollowingYet': 'لا تتابع أحداً بعد. ابحث عن منشئي محتوى لمتابعتهم!',

    },
    hi: {
        // Navigation & Header
        'nav.home': 'होम', 'nav.following': 'फॉलोइंग', 'nav.myVideos': 'मेरे वीडियो', 'nav.liked': 'पसंद किए', 'nav.history': 'इतिहास', 'nav.topics': 'विषय', 'nav.live': 'लाइव', 'nav.bitcoin': 'बिटकॉइन', 'nav.nostr': 'Nostr', 'nav.technology': 'तकनीक', 'nav.gaming': 'गेमिंग', 'nav.tutorials': 'ट्यूटोरियल', 'nav.podcasts': 'पॉडकास्ट', 'nav.music': 'संगीत', 'nav.nsfw': 'NSFW', 'nav.about': 'के बारे में', 'nav.contact': 'संपर्क', 'nav.terms': 'शर्तें', 'nav.privacy': 'गोपनीयता', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': 'लाइव स्ट्रीम', 'nav.github': 'GitHub',
        'header.search': 'वीडियो खोजें...', 'header.notifications': 'सूचनाएं', 'header.settings': 'सेटिंग्स', 'header.create': 'बनाएं', 'header.viewProfile': 'प्रोफ़ाइल देखें', 'header.logout': 'लॉग आउट',
        // Login Modal
        'login.title': 'Nostr से लॉग इन करें', 'login.extensionButton': 'Nostr एक्सटेंशन से लॉग इन करें', 'login.extensionDesc': 'साइनिंग एक्सटेंशन का उपयोग करें (Alby, nos2x, आदि)', 'login.orDivider': 'या', 'login.nsecLabel': 'प्राइवेट की से लॉग इन करें (nsec)', 'login.nsecPlaceholder': 'nsec दर्ज करें...', 'login.nsecButton': 'nsec से लॉग इन करें', 'login.nsecWarning': 'चेतावनी: nsec सीधे दर्ज करना एक्सटेंशन की तुलना में कम सुरक्षित है। बेहतर सुरक्षा के लिए NIP-07 एक्सटेंशन का उपयोग करें।', 'login.newToNostr': 'Nostr पर नए हैं?', 'login.createAccount': 'खाता बनाएं', 'login.learnMore': 'Nostr के बारे में और जानें',
        // Connect Modal
        'connect.title': 'Nostr से कनेक्ट करें', 'connect.or': 'या', 'connect.extensionButton': 'Nostr एक्सटेंशन कनेक्ट करें', 'connect.extensionDesc': 'एक्सटेंशन का उपयोग करें (Alby, nos2x, आदि)', 'connect.nsecLabel': 'प्राइवेट की से लॉग इन करें', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'nsec से कनेक्ट करें', 'connect.nsecWarning': 'चेतावनी: nsec सीधे दर्ज करना कम सुरक्षित है। बेहतर सुरक्षा के लिए NIP-07 एक्सटेंशन का उपयोग करें।', 'connect.newToNostr': 'Nostr पर नए हैं?', 'connect.createAccount': 'खाता बनाएं',
        // Private Key Modal
        'privateKey.title': 'आपकी प्राइवेट की', 'privateKey.warning': 'महत्वपूर्ण: इसे सुरक्षित जगह पर सहेजें। यदि आप यह की खो देते हैं, तो आप अपने खाते तक पहुंच खो देंगे। इसे किसी के साथ साझा न करें!', 'privateKey.show': 'प्राइवेट की दिखाएं', 'privateKey.hide': 'प्राइवेट की छुपाएं', 'privateKey.copy': 'कॉपी करें', 'privateKey.saved': 'मैंने अपनी की सहेज ली है', 'privateKey.yourPublicKey': 'आपकी पब्लिक की (npub):', 'privateKey.yourPrivateKey': 'आपकी प्राइवेट की (nsec):',
        // Signup Modal
        'signup.title': 'Nostr खाता बनाएं', 'signup.whatIsNostr': 'Nostr क्या है?', 'signup.nostrDescription': 'Nostr एक विकेंद्रीकृत प्रोटोकॉल है जो आपको अपनी पहचान और डेटा पर नियंत्रण देता है। कोई केंद्रीय सर्वर नहीं - आपका खाता एक क्रिप्टोग्राफिक की पेयर है।', 'signup.whyNostr': 'Nostr क्यों?', 'signup.benefit1': 'अपनी पहचान के मालिक बनें', 'signup.benefit2': 'कोई सेंसरशिप नहीं', 'signup.benefit3': 'प्लेटफॉर्म के बीच पोर्टेबिलिटी', 'signup.createNew': 'नया खाता बनाएं', 'signup.haveAccount': 'पहले से खाता है?', 'signup.login': 'लॉग इन करें', 'signup.createButton': 'खाता बनाएं', 'signup.generating': 'कीज़ जनरेट हो रही हैं...', 'signup.displayName': 'प्रदर्शित नाम', 'signup.displayNamePlaceholder': 'प्रदर्शित नाम दर्ज करें', 'signup.username': 'उपयोगकर्ता नाम', 'signup.usernamePlaceholder': 'उपयोगकर्ता नाम दर्ज करें', 'signup.about': 'परिचय (वैकल्पिक)', 'signup.profilePicture': 'प्रोफाइल फोटो (वैकल्पिक)', 'signup.lightningAddress': 'Lightning पता (वैकल्पिक)', 'signup.nostrAddress': 'Nostr पता', 'signup.nostrAddressPlaceholder': 'उपयोगकर्तानाम', 'signup.nostrAddressHint': 'आपका Nostr पता आपकी प्रोफाइल को खोजना आसान बनाता है। केवल छोटे अक्षर, अंक, _ और -।', 'signup.nostrAddressRequired': 'कृपया Nostr पता दर्ज करें', 'signup.nostrAddressAvailable': 'उपलब्ध!', 'signup.nostrAddressUnavailable': 'पहले से उपयोग में है', 'signup.nostrAddressChecking': 'जांच हो रही है...', 'signup.nostrAddressInvalid': 'अमान्य उपयोगकर्ता नाम प्रारूप', 'signup.nostrAddressRegistering': 'आपका Nostr पता पंजीकृत हो रहा है...', 'signup.nostrAddressSuccess': 'Nostr पता पंजीकृत हो गया!', 'signup.nostrAddressFailed': 'Nostr पता पंजीकृत नहीं हो सका', 'signup.createAccountBtn': 'खाता बनाएं', 'signup.termsAgree': 'खाता बनाकर, आप सहमत हैं', 'signup.and': 'और', 'signup.success': 'खाता सफलतापूर्वक बना!', 'signup.yourPrivateKey': 'आपकी प्राइवेट की (nsec)', 'signup.keyWarning': 'यह आपके खाते तक पहुंचने का एकमात्र तरीका है। इसे सुरक्षित रखें!', 'signup.copyPrivateKey': 'प्राइवेट की कॉपी करें', 'signup.howToUseKey': 'अपनी प्राइवेट की का उपयोग कैसे करें', 'signup.continueToPlebs': 'Plebs पर जारी रखें', 'signup.step1': 'सुरक्षित रूप से सहेजें:', 'signup.step1Desc': 'nsec को पासवर्ड मैनेजर में सहेजें, लिख लें, या एन्क्रिप्टेड फाइल में सहेजें। सार्वजनिक रूप से साझा न करें!', 'signup.step2': 'फिर से लॉग इन करने के लिए:', 'signup.step2Desc': 'लॉगिन स्क्रीन पर "प्राइवेट की" पर क्लिक करें और nsec पेस्ट करें। यह पासवर्ड की तरह काम करता है।', 'signup.step3': 'अन्य ऐप्स में उपयोग करें:', 'signup.step3Desc': 'आपका nsec सभी Nostr ऐप्स में काम करता है - Damus, Primal, Amethyst और सैकड़ों अन्य!', 'signup.step4': 'साइनर ऐप पर विचार करें:', 'signup.step4Desc': 'बेहतर सुरक्षा के लिए, Amber (Android) या Alby जैसे ब्राउज़र एक्सटेंशन का उपयोग करें।',
        // Notifications
        'notifications.title': 'सूचनाएं', 'notifications.empty': 'कोई सूचना नहीं', 'notifications.viewAll': 'सभी सूचनाएं देखें', 'notifications.markAllRead': 'सभी को पढ़ा हुआ चिह्नित करें', 'notifications.settings': 'सूचना सेटिंग्स', 'notifications.loading': 'सूचनाएं लोड हो रही हैं...', 'notifications.zap': 'ने आपको ज़ैप भेजा', 'notifications.like': 'ने आपकी सामग्री पसंद की', 'notifications.comment': 'ने टिप्पणी की', 'notifications.follow': 'ने आपको फॉलो किया', 'notifications.repost': 'ने रीपोस्ट किया', 'notifications.mention': 'ने आपका उल्लेख किया',
        // Settings Modal
        'settings.title': 'सेटिंग्स', 'settings.language': 'भाषा', 'settings.languageDesc': 'भाषा चुनें', 'settings.saveToNostr': 'Nostr पर सहेजें', 'settings.darkMode': 'डार्क मोड', 'settings.darkModeDesc': 'डार्क/लाइट थीम टॉगल करें', 'settings.autoplay': 'ऑटोप्ले', 'settings.autoplayDesc': 'वीडियो ऑटो-प्ले करें', 'settings.saveSettings': 'सेटिंग्स सहेजें', 'settings.resetDefaults': 'रीसेट', 'settings.notificationSettings': 'सूचना सेटिंग्स', 'settings.notifications': 'सूचनाएं', 'settings.notificationsDesc': 'पुश सूचनाएं प्राप्त करें', 'settings.quality': 'डिफ़ॉल्ट गुणवत्ता', 'settings.qualityDesc': 'वीडियो प्लेबैक गुणवत्ता', 'settings.contentWarning': 'सामग्री चेतावनी प्राथमिकताएं', 'settings.showNsfwWarnings': 'NSFW चेतावनियां दिखाएं', 'settings.showNsfwWarningsDesc': 'NSFW सामग्री के लिए आयु सत्यापन दिखाएं', 'settings.showCommunityWarnings': 'समुदाय चेतावनियां दिखाएं', 'settings.showCommunityWarningsDesc': 'फ़्लैग की गई या अधिक डाउनवोट वाली सामग्री के लिए चेतावनियां दिखाएं', 'settings.showFollowsReportWarnings': 'फॉलो रिपोर्ट चेतावनियां दिखाएं', 'settings.showFollowsReportWarningsDesc': 'जब आपके 5+ फॉलो किए गए लोग सामग्री की रिपोर्ट करें तो चेतावनियां दिखाएं', 'settings.filterPacks': 'सामग्री फ़िल्टर पैक', 'settings.filterPacksDesc': 'विशिष्ट कीवर्ड से मेल खाने वाली सामग्री को स्वचालित रूप से छुपाने के लिए फ़िल्टर पैक सक्षम करें।', 'settings.customKeywordFilter': 'कस्टम कीवर्ड फ़िल्टर', 'settings.customKeywordFilterPlaceholder': 'कीवर्ड या वाक्यांश अल्पविराम से अलग करके दर्ज करें\nउदाहरण: स्पैम, अवांछित सामग्री, विशिष्ट वाक्यांश', 'settings.customKeywordFilterDesc': 'फ़िल्टर करने के लिए अपने कीवर्ड जोड़ें (अल्पविराम से अलग)',
        // Upload Modal
        'upload.title': 'वीडियो अपलोड करें', 'upload.dragDrop': 'वीडियो फ़ाइल यहाँ ड्रैग और ड्रॉप करें', 'upload.or': 'या', 'upload.browse': 'फ़ाइलें ब्राउज़ करें', 'upload.supportedFormats': 'समर्थित प्रारूप: MP4, WebM, MOV', 'upload.maxSize': 'अधिकतम आकार: 2GB', 'upload.videoTitle': 'शीर्षक', 'upload.titlePlaceholder': 'वीडियो शीर्षक दर्ज करें', 'upload.description': 'विवरण', 'upload.descriptionPlaceholder': 'अपने वीडियो का वर्णन करें...', 'upload.tags': 'टैग्स', 'upload.tagsPlaceholder': 'अल्पविराम से अलग टैग जोड़ें', 'upload.visibility': 'दृश्यता', 'upload.public': 'सार्वजनिक', 'upload.unlisted': 'असूचीबद्ध', 'upload.uploadButton': 'वीडियो अपलोड करें', 'upload.uploading': 'अपलोड हो रहा है...', 'upload.processing': 'प्रोसेस हो रहा है...', 'upload.complete': 'पूर्ण!', 'upload.error': 'अपलोड विफल', 'upload.nsfw': 'NSFW सामग्री', 'upload.nsfwDesc': 'वयस्क सामग्री के रूप में चिह्नित करें', 'upload.thumbnail': 'थंबनेल', 'upload.thumbnailDesc': 'थंबनेल अपलोड करें', 'upload.preparing': 'तैयारी हो रही है...', 'upload.cancel': 'रद्द करें', 'upload.progress': 'अपलोड प्रगति', 'upload.transcoding': 'ट्रांसकोडिंग', 'upload.status.preparing': 'अपलोड की तैयारी...', 'upload.status.uploading': 'वीडियो अपलोड हो रहा है...', 'upload.status.transcoding': 'वीडियो ट्रांसकोड हो रहा है...', 'upload.status.complete': 'अपलोड पूर्ण!', 'upload.qualityHigh': 'उच्च', 'upload.qualityMedium': 'मध्यम', 'upload.qualityLow': 'निम्न',
        // Create Modal
        'create.title': 'बनाएं', 'create.uploadVideo': 'वीडियो अपलोड करें', 'create.uploadDesc': 'वीडियो साझा करें', 'create.goLive': 'लाइव जाएं', 'create.goLiveDesc': 'लाइव स्ट्रीम शुरू करें', 'create.createPost': 'पोस्ट बनाएं', 'create.createPostDesc': 'टेक्स्ट पोस्ट साझा करें',
        // Go Live Modal
        'goLive.title': 'लाइव जाएं', 'goLive.streamTitle': 'स्ट्रीम शीर्षक', 'goLive.streamTitlePlaceholder': 'स्ट्रीम शीर्षक दर्ज करें', 'goLive.description': 'विवरण', 'goLive.descriptionPlaceholder': 'अपनी स्ट्रीम का वर्णन करें...', 'goLive.category': 'श्रेणी', 'goLive.selectCategory': 'श्रेणी चुनें', 'goLive.tags': 'टैग्स', 'goLive.tagsPlaceholder': 'अल्पविराम से अलग टैग जोड़ें', 'goLive.startStream': 'स्ट्रीम शुरू करें', 'goLive.streamKey': 'स्ट्रीम की', 'goLive.streamUrl': 'स्ट्रीम URL', 'goLive.copy': 'कॉपी करें', 'goLive.hideKey': 'की छुपाएं', 'goLive.showKey': 'की दिखाएं', 'goLive.connecting': 'कनेक्ट हो रहा है...', 'goLive.live': 'लाइव', 'goLive.offline': 'ऑफलाइन', 'goLive.viewers': 'दर्शक', 'goLive.endStream': 'स्ट्रीम समाप्त करें', 'goLive.nsfw': 'NSFW सामग्री', 'goLive.nsfwDesc': 'वयस्क सामग्री के रूप में चिह्नित करें', 'goLive.thumbnail': 'स्ट्रीम थंबनेल', 'goLive.thumbnailDesc': 'थंबनेल अपलोड करें', 'goLive.zapGoal': 'Zap लक्ष्य (वैकल्पिक)', 'goLive.zapGoalLabel': 'Zap लक्ष्य',
        // Video/Live No Description
        'video.noDescription': 'इस वीडियो में कोई विवरण नहीं जोड़ा गया है।', 'live.noDescription': 'इस लाइव स्ट्रीम में कोई विवरण नहीं जोड़ा गया है।',
        // Edit Stream Modal
        'editStream.title': 'स्ट्रीम संपादित करें', 'editStream.save': 'परिवर्तन सहेजें',
        // NSFW Warning Modal
        'nsfw.title': 'वयस्क सामग्री चेतावनी', 'nsfw.warning': 'यह सामग्री NSFW के रूप में चिह्नित है और इसमें वयस्क सामग्री हो सकती है।', 'nsfw.confirm': 'अपनी आयु पुष्टि करें', 'nsfw.confirmAge': 'मेरी आयु 18 वर्ष या उससे अधिक है', 'nsfw.cancel': 'वापस जाएं', 'nsfw.continue': 'जारी रखें', 'nsfw.dontShowAgain': 'यह चेतावनी फिर न दिखाएं',
        // Community Warning Modal
        'community.title': 'समुदाय दिशानिर्देश', 'community.warning': 'कृपया जारी रखने से पहले हमारे समुदाय दिशानिर्देशों की समीक्षा करें।', 'community.guidelines': 'सम्मानजनक रहें और समुदाय मानकों का पालन करें।', 'community.accept': 'स्वीकार करें', 'community.decline': 'अस्वीकार करें',
        'communityWarning.title': 'समुदाय चेतावनी', 'communityWarning.description': 'इस वीडियो को समुदाय द्वारा फ़्लैग किया गया है और/या भारी मात्रा में नकारात्मक वोट मिले हैं। यह इसके कारण हो सकता है:', 'communityWarning.reason1': 'अनुचित सामग्री जिसे NSFW के रूप में सही ढंग से चिह्नित नहीं किया गया', 'communityWarning.reason2': 'नया या संदिग्ध उपयोगकर्ता विवरण', 'communityWarning.reason3': 'भ्रामक या झूठी जानकारी', 'communityWarning.reason4': 'स्पैम या निम्न गुणवत्ता वाली सामग्री', 'communityWarning.reason5': 'संभावित हानिकारक या अवैध सामग्री', 'communityWarning.proceed': 'सावधानी से आगे बढ़ें।', 'communityWarning.goBack': 'वापस जाएं', 'communityWarning.viewAnyway': 'फिर भी देखें',
        // Report Modal
        'report.title': 'सामग्री की रिपोर्ट करें', 'report.reason': 'रिपोर्ट का कारण', 'report.selectReason': 'कारण चुनें', 'report.spam': 'स्पैम या भ्रामक', 'report.inappropriate': 'अनुचित सामग्री', 'report.violence': 'हिंसक या खतरनाक सामग्री', 'report.copyright': 'कॉपीराइट उल्लंघन', 'report.other': 'अन्य', 'report.details': 'विवरण', 'report.detailsPlaceholder': 'अधिक विवरण प्रदान करें...', 'report.submit': 'रिपोर्ट सबमिट करें', 'report.cancel': 'रद्द करें',
        // Share Modal
        'share.title': 'साझा करें', 'share.copyLink': 'लिंक कॉपी करें', 'share.embed': 'एम्बेड कोड', 'share.copyEmbed': 'एम्बेड कोड कॉपी करें', 'share.social': 'सोशल मीडिया पर साझा करें', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': 'ईमेल', 'share.copied': 'कॉपी हो गया!', 'share.nostr': 'Nostr पर साझा करें', 'share.generateImage': 'इमेज जनरेट करें', 'share.downloadImage': 'डाउनलोड', 'share.shareImage': 'साझा करें', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (वर्गाकार)', 'share.size1080x1920': '1080 × 1920 (स्टोरी)',
        // Edit Video Modal
        'editVideo.title': 'वीडियो संपादित करें', 'editVideo.videoTitle': 'शीर्षक', 'editVideo.description': 'विवरण', 'editVideo.tags': 'टैग्स', 'editVideo.thumbnail': 'थंबनेल', 'editVideo.changeThumbnail': 'थंबनेल बदलें', 'editVideo.visibility': 'दृश्यता', 'editVideo.nsfw': 'NSFW सामग्री', 'editVideo.save': 'परिवर्तन सहेजें', 'editVideo.delete': 'वीडियो हटाएं', 'editVideo.confirmDelete': 'क्या आप वाकई इस वीडियो को हटाना चाहते हैं?',
        // Edit Profile Modal
        'editProfile.title': 'प्रोफ़ाइल संपादित करें', 'editProfile.displayName': 'प्रदर्शित नाम', 'editProfile.displayNamePlaceholder': 'प्रदर्शित नाम दर्ज करें', 'editProfile.username': 'उपयोगकर्ता नाम', 'editProfile.usernamePlaceholder': 'उपयोगकर्ता नाम दर्ज करें', 'editProfile.about': 'परिचय', 'editProfile.aboutPlaceholder': 'अपने बारे में बताएं...', 'editProfile.website': 'वेबसाइट', 'editProfile.websitePlaceholder': 'https://yourwebsite.com', 'editProfile.lightning': 'Lightning पता', 'editProfile.lightningPlaceholder': 'you@getalby.com', 'editProfile.nip05': 'NIP-05 सत्यापन', 'editProfile.nip05Placeholder': 'you@domain.com', 'editProfile.avatar': 'अवतार', 'editProfile.changeAvatar': 'अवतार बदलें', 'editProfile.banner': 'बैनर', 'editProfile.changeBanner': 'बैनर बदलें', 'editProfile.save': 'प्रोफ़ाइल सहेजें',
        // Confirmation Modal
        'confirm.title': 'कार्रवाई पुष्टि करें', 'confirm.message': 'क्या आप वाकई जारी रखना चाहते हैं?', 'confirm.confirm': 'पुष्टि करें', 'confirm.cancel': 'रद्द करें',
        // Video Page
        'video.views': 'बार देखा गया', 'video.like': 'पसंद', 'video.dislike': 'नापसंद', 'video.share': 'साझा करें', 'video.save': 'सहेजें', 'video.report': 'रिपोर्ट करें', 'video.follow': 'फॉलो करें', 'video.unfollow': 'अनफॉलो', 'video.subscribe': 'सब्सक्राइब', 'video.subscribed': 'सब्सक्राइब्ड', 'video.comments': 'टिप्पणियाँ', 'video.addComment': 'टिप्पणी जोड़ें...', 'video.reply': 'जवाब दें', 'video.replies': 'जवाब', 'video.loadMore': 'और लोड करें', 'video.noComments': 'कोई टिप्पणी नहीं। पहले टिप्पणी करें!', 'video.zap': 'ज़ैप', 'video.zapAmount': 'ज़ैप राशि (सैट्स)', 'video.sendZap': 'ज़ैप भेजें', 'video.boost': 'बूस्ट', 'video.description': 'विवरण', 'video.showMore': 'और दिखाएं', 'video.showLess': 'कम दिखाएं', 'video.publishedOn': 'प्रकाशित',
        // Toast Messages
        'toast.loggedIn': 'सफलतापूर्वक लॉग इन हो गए!', 'toast.settingsSaved': 'सेटिंग्स सफलतापूर्वक सहेजी गईं!', 'toast.settingsLocal': 'सेटिंग्स स्थानीय रूप से सहेजी गईं। Nostr पर सहेजने में विफल।', 'toast.settingsLocalOnly': 'सेटिंग्स स्थानीय रूप से सहेजी गईं!', 'toast.settingsReset': 'सेटिंग्स डिफ़ॉल्ट पर रीसेट हो गईं!', 'toast.avatarUploaded': 'अवतार सफलतापूर्वक अपलोड हो गया!', 'toast.profileUpdated': 'प्रोफ़ाइल सफलतापूर्वक अपडेट हो गई!', 'toast.copied': 'क्लिपबोर्ड पर कॉपी हो गया!', 'toast.copyFailed': 'कॉपी करने में विफल। कृपया मैन्युअल रूप से कॉपी करें।', 'toast.installExtension': 'कृपया Alby या nos2x जैसा Nostr ब्राउज़र एक्सटेंशन इंस्टॉल करें', 'toast.loginFailed': 'एक्सटेंशन से लॉगिन विफल। पुनः प्रयास करें।', 'toast.invalidKey': 'अमान्य प्राइवेट की। जाँच करें और पुनः प्रयास करें।', 'toast.enterKey': 'कृपया अपनी प्राइवेट की दर्ज करें', 'toast.enterUsername': 'कृपया उपयोगकर्ता नाम दर्ज करें', 'toast.accountCreated': 'Plebs में आपका स्वागत है! आप अब लॉग इन हैं।', 'toast.keyCopied': 'प्राइवेट की क्लिपबोर्ड पर कॉपी हो गई!', 'toast.unmuted': 'उपयोगकर्ता अनम्यूट हो गया', 'toast.unmuteFailed': 'अनम्यूट करने में विफल', 'toast.selectImage': 'कृपया एक इमेज फ़ाइल चुनें', 'toast.imageTooLarge': 'इमेज 5MB से कम होनी चाहिए', 'toast.avatarFailed': 'अवतार अपलोड करने में विफल। पुनः प्रयास करें।', 'toast.mustBeLoggedIn': 'प्रोफ़ाइल संपादित करने के लिए लॉग इन होना ज़रूरी है', 'toast.enterDisplayName': 'कृपया प्रदर्शित नाम दर्ज करें', 'toast.profileFailed': 'प्रोफ़ाइल सहेजने में विफल। पुनः प्रयास करें।', 'toast.invalidBunker': 'कृपया वैध bunker URL दर्ज करें', 'toast.connectFailed': 'कनेक्ट करने में विफल', 'toast.showingFiltered': 'फ़िल्टर की गई सामग्री दिखा रहे हैं', 'toast.reportSubmitted': 'रिपोर्ट सफलतापूर्वक सबमिट हो गई', 'toast.draftSaved': 'ड्राफ्ट सहेजा गया! आप मेरे वीडियो से बाद में जारी रख सकते हैं।', 'toast.draftLoaded': 'ड्राफ्ट लोड हो गया। अपलोड पूरा करें और प्रकाशित करें।', 'toast.draftDeleted': 'ड्राफ्ट हटा दिया गया', 'toast.languageChanged': 'भाषा बदली गई', 'toast.videoBlocked': 'वीडियो ब्लॉक किया गया और Nostr पर प्रकाशित हुआ', 'toast.waitForUpload': 'कृपया वीडियो अपलोड पूरा होने की प्रतीक्षा करें', 'toast.enterTitle': 'कृपया शीर्षक दर्ज करें', 'toast.publishing': 'Nostr पर वीडियो प्रकाशित हो रहा है...',
        // Time
        'time.justNow': 'अभी', 'time.secondAgo': '1 सेकंड पहले', 'time.secondsAgo': '{n} सेकंड पहले', 'time.minuteAgo': '1 मिनट पहले', 'time.minutesAgo': '{n} मिनट पहले', 'time.hourAgo': '1 घंटा पहले', 'time.hoursAgo': '{n} घंटे पहले', 'time.dayAgo': '1 दिन पहले', 'time.daysAgo': '{n} दिन पहले', 'time.weekAgo': '1 सप्ताह पहले', 'time.weeksAgo': '{n} सप्ताह पहले', 'time.monthAgo': '1 महीना पहले', 'time.monthsAgo': '{n} महीने पहले', 'time.yearAgo': '1 साल पहले', 'time.yearsAgo': '{n} साल पहले',
        // Empty States
        'empty.noVideos': 'कोई वीडियो नहीं मिला', 'empty.noVideosDesc': 'अलग खोज करके देखें', 'empty.noFollowing': 'आप किसी को फॉलो नहीं कर रहे', 'empty.noFollowingDesc': 'क्रिएटर्स को फॉलो करें उनके वीडियो देखने के लिए', 'empty.noHistory': 'कोई देखने का इतिहास नहीं', 'empty.noHistoryDesc': 'जो वीडियो आप देखते हैं वे यहाँ दिखाई देंगे', 'empty.noLiked': 'कोई पसंद किए गए वीडियो नहीं', 'empty.noLikedDesc': 'जो वीडियो आप पसंद करते हैं वे यहाँ दिखाई देंगे', 'empty.noResults': 'कोई परिणाम नहीं मिला', 'empty.noResultsDesc': 'अलग कीवर्ड आज़माएं',
        // Misc
        'misc.loading': 'लोड हो रहा है...', 'misc.loadingMore': 'और लोड हो रहा है...', 'misc.refresh': 'रिफ्रेश', 'misc.retry': 'पुनः प्रयास', 'misc.close': 'बंद करें', 'misc.back': 'वापस', 'misc.next': 'अगला', 'misc.previous': 'पिछला', 'misc.search': 'खोजें', 'misc.filter': 'फ़िल्टर', 'misc.sort': 'क्रमबद्ध करें', 'misc.newest': 'नवीनतम', 'misc.oldest': 'पुराने', 'misc.popular': 'लोकप्रिय', 'misc.trending': 'ट्रेंडिंग', 'misc.sats': 'सैट्स', 'misc.all': 'सभी', 'misc.copiedToClipboard': 'क्लिपबोर्ड पर कॉपी हो गया!',
        // Common
        'common.submit': 'सबमिट', 'common.cancel': 'रद्द करें', 'common.save': 'सहेजें', 'common.delete': 'हटाएं', 'common.edit': 'संपादित करें', 'common.close': 'बंद करें', 'common.confirm': 'पुष्टि करें', 'common.yes': 'हाँ', 'common.no': 'नहीं', 'common.ok': 'ठीक है', 'common.loading': 'लोड हो रहा है...', 'common.uploading': 'अपलोड हो रहा है...', 'common.error': 'त्रुटि', 'common.success': 'सफल',
        // Aria Labels
        'aria.toggleMenu': 'मेनू टॉगल करें', 'aria.mainNavigation': 'मुख्य नेविगेशन', 'aria.videoContent': 'वीडियो सामग्री', 'aria.loadingContent': 'सामग्री लोड हो रही है', 'aria.closeModal': 'मोडल बंद करें', 'aria.playVideo': 'वीडियो चलाएं', 'aria.pauseVideo': 'वीडियो रोकें', 'aria.muteVideo': 'म्यूट करें', 'aria.unmuteVideo': 'अनम्यूट करें', 'aria.fullscreen': 'फुल स्क्रीन', 'aria.exitFullscreen': 'फुल स्क्रीन से बाहर', 'aria.settings': 'सेटिंग्स', 'aria.notifications': 'सूचनाएं', 'aria.userMenu': 'उपयोगकर्ता मेनू', 'aria.searchInput': 'वीडियो खोजें', 'aria.videoPlayer': 'वीडियो प्लेयर',
        // Dynamic JavaScript text
        'button.hideQR': 'QR कोड छुपाएं', 'button.showQR': 'QR कोड दिखाएं', 'button.copied': 'कॉपी हो गया!', 'button.showLess': 'कम दिखाएं', 'button.showMore': 'और दिखाएं', 'button.creatingAccount': 'खाता बनाया जा रहा है...', 'button.submitting': 'सबमिट हो रहा है...', 'button.scheduleStream': 'स्ट्रीम शेड्यूल करें', 'button.goLive': 'लाइव जाएं', 'button.creatingStream': 'स्ट्रीम बनाई जा रही है...', 'button.continueCustomAmount': 'कस्टम राशि के साथ जारी रखें', 'button.recordFromCamera': 'कैमरे से रिकॉर्ड करें', 'button.requestingCamera': 'कैमरा मांगा जा रहा है...', 'button.recording': 'रिकॉर्ड हो रहा है...',
        'status.saving': 'सहेजा जा रहा है...', 'status.saved': 'सहेज लिया गया!', 'status.uploading': 'अपलोड हो रहा है...', 'status.uploadComplete': 'अपलोड पूर्ण!', 'status.uploadingToNostrBuild': 'nostr.build पर अपलोड हो रहा है...', 'status.publishingChanges': 'परिवर्तन प्रकाशित हो रहे हैं...', 'status.removingOldVersion': 'पुराना संस्करण हटाया जा रहा है...', 'status.validatingThumbnail': 'थंबनेल सत्यापित हो रहा है...', 'status.uploadingThumbnail': 'थंबनेल अपलोड हो रहा है...', 'status.thumbnailUploaded': 'थंबनेल अपलोड हो गया!', 'status.processingVideo': 'वीडियो प्रोसेस हो रहा है...', 'status.compressingVideo': 'वीडियो कंप्रेस हो रहा है...', 'status.uploadingVideo': 'वीडियो अपलोड हो रहा है...', 'status.videoUploaded': 'वीडियो सफलतापूर्वक अपलोड हो गया!', 'status.processing': 'प्रोसेस हो रहा है...', 'status.generatingThumbnail': 'थंबनेल बनाया जा रहा है...', 'status.generatingPreview': 'प्रीव्यू बनाया जा रहा है...', 'status.uploadingPreview': 'प्रीव्यू अपलोड हो रहा है...', 'status.publishing': 'प्रकाशित हो रहा है...', 'status.publishingToNostr': 'Nostr पर प्रकाशित हो रहा है...', 'status.publishingVideoToNostr': 'Nostr पर वीडियो प्रकाशित हो रहा है...', 'status.generatingPoW': 'प्रूफ ऑफ वर्क बनाया जा रहा है...', 'status.posting': 'पोस्ट हो रहा है...', 'status.processingVideoAndThumbnail': 'वीडियो और थंबनेल प्रोसेस हो रहे हैं...', 'status.uploadFailed': 'अपलोड विफल - फिर से प्रयास करें', 'status.selectVideoToUpload': 'अपलोड करने के लिए वीडियो चुनें', 'status.waitingForVideoUpload': 'वीडियो अपलोड की प्रतीक्षा...', 'status.selectVideoAndThumbnail': 'प्रकाशित करने के लिए वीडियो और थंबनेल चुनें', 'status.ready': 'तैयार ✓', 'status.failed': 'विफल ✗', 'status.fromDraft': 'ड्राफ्ट से', 'status.startingNow': 'अभी शुरू हो रहा है!', 'status.ended': 'समाप्त', 'status.thumbnailReady': 'तैयार', 'status.thumbnailFailed': 'विफल', 'status.uploadFailedRetry': 'अपलोड विफल। फिर से प्रयास करें।',
        'publish.video': 'वीडियो प्रकाशित करें', 'publish.autoThumbnail': 'वीडियो प्रकाशित करें (ऑटो थंबनेल)',
        'report.titleComment': 'टिप्पणी की रिपोर्ट करें', 'report.titleUser': 'उपयोगकर्ता की रिपोर्ट करें', 'report.titleVideo': 'वीडियो की रिपोर्ट करें', 'report.descComment': 'इस टिप्पणी की रिपोर्ट करने का कारण चुनें:', 'report.descUser': 'इस उपयोगकर्ता की रिपोर्ट करने का कारण चुनें:', 'report.descVideo': 'इस सामग्री की रिपोर्ट करने का कारण चुनें:',
        'empty.noMutedUsers': 'कोई म्यूट किए गए उपयोगकर्ता नहीं।', 'empty.noVideosToMonitor': 'मॉनिटर करने के लिए कोई वीडियो नहीं।', 'empty.noRecentActivity': 'कोई हाल की गतिविधि नहीं।', 'empty.failedLoadNotifications': 'सूचनाएं लोड करने में विफल', 'empty.loginToViewLiked': 'पसंद किए गए वीडियो देखने के लिए कृपया <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">लॉग इन करें</a>।', 'empty.loginToViewFollowing': 'फॉलोइंग देखने के लिए कृपया <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">लॉग इन करें</a>।', 'empty.loginToViewVideos': 'अपने वीडियो देखने के लिए कृपया <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">लॉग इन करें</a>।', 'empty.loginToViewAnalytics': 'आंकड़े देखने के लिए कृपया <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">लॉग इन करें</a>।', 'empty.noLikedVideosYet': 'आपने अभी तक कोई वीडियो पसंद नहीं किया।', 'empty.noLikedVideosFound': 'पसंद किए गए वीडियो नहीं मिले।', 'empty.noFullLengthLikedVideos': 'पसंद किए गए लंबे वीडियो नहीं मिले।', 'empty.noWatchHistory': 'कोई देखने का इतिहास नहीं। वीडियो देखना शुरू करें।', 'empty.noVideosInHistory': 'इतिहास में कोई वीडियो नहीं।', 'empty.noFullLengthHistory': 'इतिहास में लंबे वीडियो नहीं।', 'empty.noMatchingVideos': 'मिलते-जुलते वीडियो नहीं मिले।', 'empty.noFullLengthVideos': 'लंबे वीडियो नहीं मिले।', 'empty.failedLoadTrending': 'ट्रेंडिंग लोड करने में विफल।', 'empty.noTrendingVideos': 'ट्रेंडिंग वीडियो नहीं मिले।', 'empty.noMatchingUsers': 'मिलते-जुलते उपयोगकर्ता नहीं मिले।', 'empty.unableLoadProfiles': 'प्रोफाइल लोड करने में असमर्थ।', 'empty.noFollowingVideos': 'फॉलो किए गए लोगों के वीडियो अभी नहीं।', 'empty.noFullLengthFollowing': 'फॉलो किए गए लोगों के लंबे वीडियो नहीं।', 'empty.failedLoadFollowing': 'लोड करने में विफल। फिर से प्रयास करें।', 'empty.noVideosUploadFirst': 'कोई वीडियो नहीं। पहला वीडियो अपलोड करें!', 'empty.noFullLengthUploaded': 'लंबे वीडियो नहीं मिले।', 'empty.noMatchingLiveStreams': 'मिलती-जुलती लाइव स्ट्रीम नहीं मिली।', 'empty.noMatchingShorts': 'मिलते-जुलते शॉर्ट्स नहीं मिले।', 'empty.noVideosForTag': 'इस टैग के लिए कोई वीडियो नहीं।', 'empty.noFullLengthForTag': 'इस टैग के लिए लंबे वीडियो नहीं।', 'empty.noUploadedVideos': 'अभी तक कोई वीडियो अपलोड नहीं।', 'empty.noVideosFound': 'कोई वीडियो नहीं मिला।', 'empty.failedLoadProfile': 'प्रोफाइल लोड करने में विफल। फिर से प्रयास करें।', 'empty.noComments': 'अभी कोई टिप्पणी नहीं। पहले टिप्पणी करें!', 'empty.failedLoadComments': 'टिप्पणियां लोड करने में विफल', 'empty.noLiveNow': 'अभी कोई लाइव नहीं। पहले बनें!',
        'error.videoNotFound': 'वीडियो नहीं मिला।', 'error.contentNotAvailable': 'यह सामग्री उपलब्ध नहीं है।', 'error.invalidVideoData': 'अमान्य वीडियो डेटा।', 'error.videoNotAvailable': 'वीडियो उपलब्ध नहीं। फाइल हटाई जा सकती है।', 'error.failedLoadVideo': 'वीडियो लोड करने में विफल। फिर से प्रयास करें।', 'error.failedLoadVideoShort': 'लोड करने में विफल। फाइल हटाई जा सकती है।', 'error.liveStreamNotFound': 'लाइव स्ट्रीम नहीं मिली।', 'error.invalidLiveStreamData': 'अमान्य लाइव स्ट्रीम डेटा।', 'error.failedLoadLiveStream': 'लाइव स्ट्रीम लोड करने में विफल।',
        // New Button & Action Labels
        'button.follow': 'फॉलो करें', 'button.unfollow': 'अनफॉलो करें', 'button.mute': 'म्यूट करें', 'button.unmute': 'अनम्यूट करें', 'button.muteUser': 'उपयोगकर्ता को म्यूट करें', 'button.unmuteUser': 'उपयोगकर्ता को अनम्यूट करें', 'button.confirm': 'पुष्टि करें', 'button.cancel': 'रद्द करें', 'button.close': 'बंद करें', 'button.boost': 'बूस्ट', 'button.zap': 'Zap', 'button.viewMore': 'और देखें', 'button.viewAnalytics': 'विश्लेषण देखें', 'button.backToMyVideos': 'मेरे वीडियो पर वापस जाएं', 'button.editDraft': 'ड्राफ्ट संपादित करें', 'button.deleteDraft': 'ड्राफ्ट हटाएं', 'button.editVideo': 'वीडियो संपादित करें', 'button.deleteVideo': 'वीडियो हटाएं', 'button.editShort': 'शॉर्ट संपादित करें', 'button.deleteShort': 'शॉर्ट हटाएं', 'button.editStream': 'स्ट्रीम संपादित करें', 'button.endStream': 'स्ट्रीम समाप्त करें', 'button.reset': 'रीसेट करें', 'button.download': 'डाउनलोड करें', 'button.watchRecording': 'रिकॉर्डिंग देखें', 'button.show': 'दिखाएं', 'button.login': 'लॉगिन करें', 'button.toggleChat': 'चैट टॉगल करें', 'button.blockVideo': 'वीडियो ब्लॉक करें', 'button.blockUser': 'उपयोगकर्ता ब्लॉक करें', 'button.unblock': 'अनब्लॉक करें', 'button.removeFromHistory': 'इतिहास से हटाएं',
        // New Stats & Counts
        'stat.views': 'बार देखा गया', 'stat.viewsCount': '{count} बार देखा गया', 'stat.videos': 'वीडियो', 'stat.video': 'वीडियो', 'stat.followers': 'फॉलोअर्स', 'stat.follower': 'फॉलोअर', 'stat.following': 'फॉलो कर रहे हैं', 'stat.subscribers': 'सब्सक्राइबर्स', 'stat.comments': 'टिप्पणियां', 'stat.liveCount': '{count} लाइव', 'stat.percentOfGoal': 'लक्ष्य का {percent}%', 'stat.netGrowth': 'शुद्ध वृद्धि', 'stat.newFollowers': 'नए फॉलोअर्स', 'stat.unfollowed': 'अनफॉलो', 'stat.lastUpdated': 'अंतिम अपडेट: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'लाइव', 'badge.ended': 'समाप्त', 'badge.scheduled': 'निर्धारित', 'badge.warning': 'चेतावनी', 'badge.communityWarning': 'समुदाय चेतावनी', 'badge.verifiedNip05': 'NIP-05 सत्यापित', 'badge.streamer': 'स्ट्रीमर', 'badge.clickToView': 'देखने के लिए क्लिक करें',
        // New Actions
        'action.report': 'रिपोर्ट करें', 'action.reportComment': 'टिप्पणी की रिपोर्ट करें', 'action.reportVideo': 'इस वीडियो की रिपोर्ट करें', 'action.reportStream': 'इस स्ट्रीम की रिपोर्ट करें', 'action.like': 'पसंद', 'action.dislike': 'नापसंद', 'action.reply': 'जवाब दें',
        // New Placeholders
        'placeholder.searchHistory': 'इतिहास खोजें...', 'placeholder.searchUsers': 'उपयोगकर्ता खोजें...', 'placeholder.searchMyVideos': 'मेरे वीडियो खोजें...', 'placeholder.eventId': 'इवेंट ID दर्ज करें (hex या nevent/note)', 'placeholder.pubkey': 'pubkey दर्ज करें (hex या npub)', 'placeholder.customAmount': 'कस्टम राशि', 'placeholder.chatEnded': 'चैट बंद - स्ट्रीम समाप्त', 'placeholder.addComment': 'टिप्पणी जोड़ें...', 'placeholder.setNewGoal': 'नया लक्ष्य सेट करें (sats)',
        // New Video & Content
        'video.untitledVideo': 'शीर्षकहीन वीडियो', 'video.untitledShort': 'शीर्षकहीन शॉर्ट', 'video.upNext': 'अगला', 'video.noVideosYet': 'अभी तक कोई वीडियो नहीं', 'video.noShortsYet': 'अभी तक कोई शॉर्ट्स नहीं', 'video.noLiveStreamsYet': 'अभी तक कोई लाइव स्ट्रीम नहीं', 'video.noBlockedVideos': 'कोई ब्लॉक वीडियो नहीं', 'video.noBlockedUsers': 'कोई ब्लॉक उपयोगकर्ता नहीं',
        // New Stream Messages
        'stream.ended': 'यह स्ट्रीम समाप्त हो गई है। चैट अब बंद है।', 'stream.welcomeChat': 'लाइव चैट में आपका स्वागत है!', 'stream.goalReached': 'लक्ष्य प्राप्त!', 'stream.zapGoalReached': 'Zap लक्ष्य प्राप्त! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'म्यूट उपयोगकर्ता का संदेश', 'muted.commentFromMutedUserHidden': 'म्यूट उपयोगकर्ता की टिप्पणी छिपी', 'muted.commentHidden': 'टिप्पणी छिपी ({packs})', 'muted.messageHidden': 'संदेश छिपा ({packs})', 'muted.commentReportedByFollows': 'आप जिन्हें फॉलो करते हैं उनने रिपोर्ट की गई टिप्पणी', 'muted.messageReportedByFollows': 'आप जिन्हें फॉलो करते हैं उनने रिपोर्ट किया संदेश', 'muted.commentHeavilyDownvoted': 'समुदाय द्वारा भारी डाउनवोट टिप्पणी', 'muted.messageHeavilyDownvoted': 'भारी डाउनवोट संदेश',
        // New Admin & Lists
        'list.blockedVideos': 'ब्लॉक वीडियो', 'list.blockedUsers': 'ब्लॉक उपयोगकर्ता',
        // New Alerts
        'alert.cameraNotSupported': 'इस ब्राउज़र में कैमरा एक्सेस समर्थित नहीं है। कृपया Chrome, Firefox, या Safari जैसा आधुनिक ब्राउज़र उपयोग करें।', 'alert.noCameraFound': 'कोई कैमरा नहीं मिला। कृपया कैमरा कनेक्ट करें या फ़ाइल अपलोड विकल्प का उपयोग करें।', 'alert.cameraAccessDenied': 'कैमरा एक्सेस अस्वीकृत। कृपया ब्राउज़र सेटिंग्स में कैमरा अनुमति दें।', 'alert.cameraInUse': 'कैमरा किसी अन्य एप्लिकेशन द्वारा उपयोग में है। कृपया अन्य ऐप्स बंद करें।', 'alert.cameraUnableAccess': 'कैमरा एक्सेस नहीं हो पा रहा। कृपया अपलोड विकल्प का उपयोग करें।', 'alert.cameraUnableAccessWithError': 'कैमरा एक्सेस नहीं हो पा रहा: {error}\n\nकृपया अपलोड विकल्प का उपयोग करें।', 'alert.fillRequiredFields': 'कृपया सभी आवश्यक फ़ील्ड भरें', 'alert.uploadThumbnail': 'कृपया अपनी स्ट्रीम के लिए थंबनेल अपलोड करें', 'alert.failedCreateStream': 'लाइव स्ट्रीम बनाने में विफल। कृपया पुनः प्रयास करें।', 'alert.failedUpdateStream': 'अपडेट विफल। कृपया पुनः प्रयास करें।', 'alert.streamNotFound': 'स्ट्रीम नहीं मिली', 'alert.canOnlyEditOwnStreams': 'आप केवल अपनी स्ट्रीम्स संपादित कर सकते हैं', 'alert.invalidStreamData': 'अमान्य स्ट्रीम डेटा', 'alert.enterValidGoalAmount': 'कृपया वैध लक्ष्य राशि दर्ज करें', 'alert.canOnlyResetOwnGoals': 'आप केवल अपने लक्ष्य रीसेट कर सकते हैं', 'alert.streamEventNotFound': 'स्ट्रीम इवेंट नहीं मिला', 'alert.failedResetZapGoal': 'Zap लक्ष्य रीसेट करने में विफल। कृपया पुनः प्रयास करें।', 'alert.cannotBlockAdmin': 'एडमिन अकाउंट ब्लॉक नहीं किया जा सकता', 'alert.analyticsLoadFailed': 'विश्लेषण लोड करने में विफल। कृपया पुनः प्रयास करें।', 'alert.cannotReplaceShortWithVideo': 'शॉर्ट को सामान्य वीडियो से नहीं बदल सकते। कृपया वर्टिकल वीडियो (60 सेकंड या कम) अपलोड करें।', 'alert.cannotReplaceVideoWithShort': 'सामान्य वीडियो को शॉर्ट से नहीं बदल सकते। कृपया हॉरिज़ॉन्टल वीडियो अपलोड करें।', 'alert.shortsRequireVertical': 'यह वीडियो हॉरिज़ॉन्टल लगता है। शॉर्ट्स वर्टिकल वीडियो होने चाहिए। हॉरिज़ॉन्टल वीडियो के लिए "वीडियो अपलोड करें" का उपयोग करें।',
        // New Zap Messages
        'zap.cannotZapYourself': 'आप खुद को Zap नहीं कर सकते', 'zap.cannotZapOwnContent': 'आप अपनी सामग्री को Zap नहीं कर सकते', 'zap.cannotZapOwnComment': 'आप अपनी टिप्पणी को Zap नहीं कर सकते', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'वीडियो लोड हो रहा है...', 'status.loading': 'लोड हो रहा है...', 'status.compressingProgress': 'कंप्रेस हो रहा है... {progress}%', 'status.uploadingProgress': 'अपलोड हो रहा है... {progress}%', 'status.uploadingServers': 'अपलोड हो रहा है... ({completed}/{total} सर्वर)', 'status.publishedSuccess': '{type} सफलतापूर्वक प्रकाशित!',
        // New Warnings
        'warning.webmFormat': 'नोट: आपका ब्राउज़र WebM फॉर्मेट आउटपुट करेगा (iOS पर काम नहीं कर सकता)। iOS-संगत MP4 के लिए Windows/Mac पर Chrome का उपयोग करें।',
        // New Footer
        'footer.lastUpdated': 'अंतिम अपडेट: दिसंबर 2024',
        // DMCA Page
        'dmca.title': 'DMCA और सामग्री नीति',
        'dmca.lastUpdated': 'अंतिम अपडेट: दिसंबर 2024',
        'dmca.architectureTitle': 'Plebs आर्किटेक्चर को समझना',
        'dmca.architectureDesc': 'Plebs एक विकेंद्रीकृत वीडियो प्लेटफॉर्म फ्रंटएंड है जो पारंपरिक वीडियो होस्टिंग सेवाओं से अलग तरीके से काम करता है।',
        'dmca.architectureItem1': 'Plebs कोई वीडियो या छवि सामग्री होस्ट नहीं करता।',
        'dmca.architectureItem1Desc': 'हम एक क्लाइंट/फ्रंटएंड हैं जो कहीं और संग्रहीत सामग्री प्रदर्शित करता है।',
        'dmca.architectureItem2': 'सभी मीडिया फाइलें स्वतंत्र Blossom सर्वरों पर संग्रहीत हैं।',
        'dmca.architectureItem3': 'वीडियो मेटाडेटा Nostr रिले पर प्रकाशित है।',
        'dmca.architectureItem4': 'Plebs केवल इस वितरित सामग्री को एकत्र और प्रदर्शित करता है।',
        'dmca.filingTitle': 'DMCA दावा दायर करना',
        'dmca.filingDesc': 'क्योंकि Plebs सामग्री होस्ट नहीं करता, हम सीधे उल्लंघनकारी सामग्री को हटा नहीं सकते।',
        'dmca.forVideoTitle': '1. वीडियो/छवि सामग्री के लिए',
        'dmca.forVideoDesc': 'मीडिया फाइलें Blossom सर्वरों पर संग्रहीत हैं।',
        'dmca.forVideoItem1': 'पहचानें कि कौन सा Blossom सर्वर सामग्री होस्ट कर रहा है',
        'dmca.forVideoItem2': 'Blossom सर्वर ऑपरेटर से सीधे संपर्क करें',
        'dmca.forVideoItem3': 'प्रत्येक Blossom सर्वर स्वतंत्र रूप से संचालित होता है',
        'dmca.forMetadataTitle': '2. मेटाडेटा/विवरण के लिए',
        'dmca.forMetadataDesc': 'यदि उल्लंघनकारी सामग्री शीर्षक या विवरण में है:',
        'dmca.forMetadataItem1': 'यह जानकारी Nostr रिले पर संग्रहीत है',
        'dmca.forMetadataItem2': 'विशिष्ट Nostr रिले ऑपरेटरों से संपर्क करें',
        'dmca.forMetadataItem3': 'कई रिले समान डेटा संग्रहीत कर सकते हैं',
        'dmca.whatWeCanDoTitle': 'Plebs क्या कर सकता है',
        'dmca.whatWeCanDoDesc': 'हालांकि हम सामग्री होस्ट नहीं करते, हम कर सकते हैं:',
        'dmca.whatWeCanDoItem1': 'विशिष्ट सामग्री होस्ट करने वाले सर्वरों की पहचान में सहायता करें',
        'dmca.whatWeCanDoItem2': 'स्थानीय ब्लॉकलिस्ट में सामग्री जोड़ें',
        'dmca.whatWeCanDoItem3': 'उपयुक्त ऑपरेटरों से संपर्क करने के बारे में मार्गदर्शन प्रदान करें',
        'dmca.toRequestAssistance': 'सहायता का अनुरोध करने के लिए, कृपया हमसे संपर्क करें:',
        'dmca.assistanceItem1': 'उल्लंघनकारी सामग्री का लिंक या पहचानकर्ता',
        'dmca.assistanceItem2': 'आपके कॉपीराइट स्वामित्व का प्रमाण',
        'dmca.assistanceItem3': 'संरक्षित कार्य का विवरण',
        'dmca.blossomOperatorsTitle': 'Blossom सर्वर ऑपरेटरों के लिए',
        'dmca.blossomOperatorsDesc': 'यदि आप Blossom सर्वर संचालित करते हैं, तो आप DMCA अनुरोधों को संभालने के लिए जिम्मेदार हैं।',
        'dmca.blossomOperatorsLink': 'ज्ञात Blossom सर्वरों की सूची के लिए, दस्तावेज़ देखें।',
        'dmca.considerationsTitle': 'महत्वपूर्ण विचार',
        'dmca.considerationsItem1': 'विकेंद्रीकरण:',
        'dmca.considerationsItem1Desc': 'सभी स्रोतों से सामग्री को पूरी तरह से हटाना संभव नहीं हो सकता।',
        'dmca.considerationsItem2': 'एकाधिक प्रतियां:',
        'dmca.considerationsItem2Desc': 'सामग्री कई सर्वरों पर दोहराई जा सकती है।',
        'dmca.considerationsItem3': 'मेटाडेटा दृढ़ता:',
        'dmca.considerationsItem3Desc': 'मीडिया फाइलें हटाने के बाद भी मेटाडेटा बना रह सकता है।',
        'dmca.considerationsItem4': 'कोई केंद्रीय नियंत्रण नहीं:',
        'dmca.considerationsItem4Desc': 'कोई एकल इकाई पूरे नेटवर्क से सामग्री नहीं हटा सकती।',
        'dmca.counterNotificationTitle': 'काउंटर नोटिफिकेशन',
        'dmca.counterNotificationDesc': 'यदि आपको लगता है कि आपकी सामग्री गलती से हटा दी गई, तो सर्वर ऑपरेटर से संपर्क करें।',
        'dmca.contactTitle': 'हमसे संपर्क करें',
        'dmca.contactDesc': 'प्रश्नों के लिए, कृपया',
        'dmca.contactLink': 'हमसे संपर्क करें',
        // Admin Dashboard
        'admin.title': 'एडमिन डैशबोर्ड',
        'admin.loading': 'प्लेटफॉर्म एनालिटिक्स लोड हो रहा है...',
        'admin.platformOverview': 'प्लेटफॉर्म अवलोकन',
        'admin.totalVideos': 'कुल वीडियो',
        'admin.videos7Days': 'वीडियो (7 दिन)',
        'admin.videos30Days': 'वीडियो (30 दिन)',
        'admin.uniqueCreators': 'अद्वितीय क्रिएटर्स',
        'admin.likes30Days': 'लाइक्स (30 दिन)',
        'admin.dislikes30Days': 'डिसलाइक्स (30 दिन)',
        'admin.monthlyActiveUsers': 'मासिक सक्रिय उपयोगकर्ता',
        'admin.mauDesc': 'अद्वितीय उपयोगकर्ता जिन्होंने अपलोड किया, प्रतिक्रिया दी या टिप्पणी की (पिछले 6 महीने)',
        'admin.boostRevenue': 'Boost राजस्व (पिछले 30 दिन)',
        'admin.totalBoostRevenue': 'कुल Boost राजस्व',
        'admin.totalBoosts': 'कुल Boosts',
        'admin.blocklistManagement': 'ब्लॉकलिस्ट प्रबंधन',
        'admin.blocklistDesc': 'विशिष्ट वीडियो या उपयोगकर्ताओं को ब्लॉक करें।',
        'admin.blockedVideos': 'ब्लॉक वीडियो',
        'admin.blockedUsers': 'ब्लॉक उपयोगकर्ता',
        'admin.blockByEventId': 'इवेंट ID द्वारा वीडियो ब्लॉक करें',
        'admin.blockByPubkey': 'Pubkey द्वारा उपयोगकर्ता ब्लॉक करें',
        'admin.blockVideo': 'वीडियो ब्लॉक करें',
        'admin.blockUser': 'उपयोगकर्ता ब्लॉक करें',
        'admin.noBlockedVideos': 'कोई ब्लॉक वीडियो नहीं',
        'admin.noBlockedUsers': 'कोई ब्लॉक उपयोगकर्ता नहीं',
        'admin.unblock': 'अनब्लॉक करें',
        'admin.accessDenied': 'एक्सेस अस्वीकृत। केवल एडमिन के लिए।',
        // Search/Trending/Channel/Buttons/Common
        'search.noVideosFound': '"{query}" के लिए कोई वीडियो नहीं मिला।',
        'search.noFullLengthVideos': '"{query}" के लिए कोई पूर्ण-लंबाई वीडियो नहीं मिला।',
        'trending.noVideosToday': 'आज कोई ट्रेंडिंग वीडियो नहीं।',
        'trending.noVideosThisWeek': 'इस सप्ताह कोई ट्रेंडिंग वीडियो नहीं।',
        'channel.video': 'वीडियो',
        'channel.videos': 'वीडियो',
        'channel.follower': 'फॉलोअर',
        'channel.followers': 'फॉलोअर्स',
        'button.follow': 'फॉलो करें',
        'button.following': 'फॉलो किया',
        'button.unfollow': 'अनफॉलो करें',
        'button.mute': 'म्यूट करें',
        'button.unmute': 'अनम्यूट करें',
        'button.report': 'रिपोर्ट करें',
        'button.muteUser': 'उपयोगकर्ता को म्यूट करें',
        'button.unmuteUser': 'उपयोगकर्ता को अनम्यूट करें',
        'button.reportComment': 'टिप्पणी की रिपोर्ट करें',
        'button.reportUser': 'इस उपयोगकर्ता की रिपोर्ट करें',
        'live.goalReached': 'लक्ष्य प्राप्त!',
        'live.goalProgress': 'लक्ष्य का {percent}%',
        'common.loading': 'लोड हो रहा है...',
        'common.sats': 'sats',

        // Analytics
        'analytics.title': 'चैनल एनालिटिक्स',
        'analytics.description': 'अपने चैनल के प्रदर्शन मेट्रिक्स और इनसाइट्स देखें।',
        'analytics.loading': 'एनालिटिक्स लोड हो रहा है...',
        'analytics.error': 'एनालिटिक्स लोड करने में विफल',
        'analytics.overview': 'अवलोकन',
        'analytics.videos': 'वीडियो',
        'analytics.engagement': 'एंगेजमेंट',
        'analytics.totalViews': 'कुल व्यूज',
        'analytics.totalVideos': 'कुल वीडियो',
        'analytics.totalLikes': 'कुल लाइक्स',
        'analytics.totalZaps': 'कुल Zaps',
        'analytics.avgViews': 'औसत व्यूज',
        'analytics.avgLikes': 'औसत लाइक्स',
        'analytics.avgZaps': 'औसत Zaps',
        'analytics.viewsOverTime': 'समय के साथ व्यूज',
        'analytics.topVideos': 'टॉप वीडियो',
        'analytics.recentActivity': 'हाल की गतिविधि',
        'analytics.viewsLabel': 'व्यूज',
        'analytics.likesLabel': 'लाइक्स',
        'analytics.zapsLabel': 'Zaps',
        'analytics.dateLabel': 'तारीख',
        'analytics.videoTitle': 'वीडियो शीर्षक',
        'analytics.performance': 'प्रदर्शन',
        'analytics.noData': 'कोई एनालिटिक्स डेटा नहीं',
        'analytics.noDataDesc': 'अपनी एनालिटिक्स देखने के लिए वीडियो अपलोड करना शुरू करें।',
        'analytics.last7Days': 'पिछले 7 दिन',
        'analytics.last30Days': 'पिछले 30 दिन',
        'analytics.last90Days': 'पिछले 90 दिन',
        'analytics.allTime': 'सभी समय',
        'analytics.views': 'व्यूज',
        'analytics.likes': 'लाइक्स',
        'analytics.zaps': 'Zaps',
        'analytics.rank': 'रैंक',
        'analytics.noVideos': 'कोई वीडियो नहीं',
        'analytics.noVideosDesc': 'प्रदर्शन ट्रैकिंग शुरू करने के लिए अपना पहला वीडियो अपलोड करें।',

        // About Page
        'about.title': 'Plebs.place के बारे में',
        'about.subtitle': 'विकेंद्रीकृत वीडियो प्लेटफॉर्म',
        'about.welcome': 'Plebs.place में आपका स्वागत है',
        'about.description': 'Plebs.place एक विकेंद्रीकृत वीडियो शेयरिंग प्लेटफॉर्म है जो Nostr प्रोटोकॉल पर बना है, जो क्रिएटर्स को उनकी सामग्री और दर्शकों पर पूर्ण नियंत्रण देता है।',
        'about.feature1Title': 'विकेंद्रीकृत',
        'about.feature1Desc': 'Nostr पर निर्मित, सेंसरशिप प्रतिरोध और सामग्री का सच्चा स्वामित्व सुनिश्चित करता है।',
        'about.feature2Title': 'क्रिएटर-प्रथम',
        'about.feature2Desc': 'अपनी सामग्री, डेटा और दर्शकों के साथ संबंध पर पूर्ण नियंत्रण रखें।',
        'about.feature3Title': 'बिटकॉइन मोनेटाइजेशन',
        'about.feature3Desc': 'Lightning Network और Zaps के माध्यम से सीधे दर्शकों से समर्थन प्राप्त करें।',
        'about.feature4Title': 'ओपन सोर्स',
        'about.feature4Desc': 'विकेंद्रीकरण की भावना के अनुरूप पारदर्शी, समुदाय-संचालित विकास।',
        'about.missionTitle': 'हमारा मिशन',
        'about.missionDesc': 'सेंसरशिप, प्लेटफॉर्म लॉक-इन और मनमाने नियम परिवर्तनों से मुक्त वीडियो प्लेटफॉर्म बनाना। आपकी सामग्री आपकी है।',
        'about.techTitle': 'तकनीक',
        'about.techDesc': 'Nostr से पहचान और सामाजिक सुविधाएं, Lightning से तत्काल माइक्रोपेमेंट और विकेंद्रीकृत स्टोरेज समाधानों से निर्मित।',

        // Contact Page
        'contact.title': 'संपर्क करें',
        'contact.subtitle': 'संपर्क में रहें',
        'contact.description': 'प्रश्न, प्रतिक्रिया या सुझाव हैं? हम आपसे सुनना पसंद करेंगे।',
        'contact.nostrTitle': 'Nostr पर फॉलो करें',
        'contact.nostrDesc': 'अपडेट और समुदाय चर्चाओं के लिए हमें Nostr पर फॉलो करें।',
        'contact.githubTitle': 'GitHub',
        'contact.githubDesc': 'सोर्स कोड देखें, समस्याएं रिपोर्ट करें, या प्रोजेक्ट में योगदान दें।',
        'contact.emailTitle': 'ईमेल',
        'contact.emailDesc': 'व्यावसायिक पूछताछ या सहायता प्रश्नों के लिए हमारी टीम से संपर्क करें।',

        // Terms Page
        'terms.title': 'सेवा की शर्तें',
        'terms.lastUpdated': 'अंतिम अपडेट',
        'terms.section1Title': '1. शर्तों की स्वीकृति',
        'terms.section1Content': 'Plebs.place का उपयोग करके, आप इन शर्तों से बंधे होने के लिए सहमत हैं। यदि आप सहमत नहीं हैं, तो कृपया प्लेटफॉर्म का उपयोग न करें।',
        'terms.section2Title': '2. सेवा विवरण',
        'terms.section2Content': 'Plebs.place एक विकेंद्रीकृत वीडियो शेयरिंग प्लेटफॉर्म है जो Nostr प्रोटोकॉल का उपयोग करता है। हम वीडियो होस्टिंग, शेयरिंग और Lightning मोनेटाइजेशन के लिए टूल प्रदान करते हैं।',
        'terms.section3Title': '3. उपयोगकर्ता जिम्मेदारियां',
        'terms.section3Content': 'आप प्लेटफॉर्म के माध्यम से पोस्ट की गई सभी सामग्री के लिए जिम्मेदार हैं। आप अवैध, हानिकारक, या दूसरों के अधिकारों का उल्लंघन करने वाली सामग्री अपलोड न करने के लिए सहमत हैं।',
        'terms.section4Title': '4. सामग्री स्वामित्व',
        'terms.section4Content': 'आप अपनी सामग्री का पूर्ण स्वामित्व रखते हैं। अपलोड करके, आप Plebs.place को अपने वीडियो होस्ट करने और प्रदान करने के लिए सीमित लाइसेंस देते हैं।',
        'terms.section5Title': '5. निषिद्ध उपयोग',
        'terms.section5Content': 'आप किसी भी अवैध गतिविधियों, उत्पीड़न, स्पैम, या हानिकारक सामग्री के वितरण के लिए प्लेटफॉर्म का उपयोग नहीं कर सकते।',
        'terms.section6Title': '6. खाता प्रबंधन',
        'terms.section6Content': 'आप अपनी Nostr कुंजियों को ठीक से प्रबंधित करके अपने खाते को सुरक्षित करने के लिए जिम्मेदार हैं। हम आपकी निजी कुंजी संग्रहीत नहीं करते और खोए हुए खाते पुनर्प्राप्त नहीं कर सकते।',
        'terms.section7Title': '7. भुगतान शर्तें',
        'terms.section7Content': 'सभी भुगतान Lightning Network के माध्यम से संसाधित होते हैं। लेनदेन अंतिम और अपरिवर्तनीय हैं। कृपया लेनदेन से पहले सभी भुगतान विवरण सत्यापित करें।',
        'terms.section8Title': '8. दायित्व की सीमा',
        'terms.section8Content': 'Plebs.place बिना किसी वारंटी के "जैसा है" प्रदान किया जाता है। हम किसी भी हानि, क्षति, या सेवा रुकावट के लिए जिम्मेदार नहीं हैं।',
        'terms.section9Title': '9. शर्तों में परिवर्तन',
        'terms.section9Content': 'ये शर्तें समय-समय पर अपडेट हो सकती हैं। निरंतर उपयोग अपडेटेड शर्तों की स्वीकृति का संकेत देता है।',

        // Privacy Page
        'privacy.title': 'गोपनीयता नीति',
        'privacy.lastUpdated': 'अंतिम अपडेट',
        'privacy.section1Title': '1. परिचय',
        'privacy.section1Content': 'यह गोपनीयता नीति बताती है कि Plebs.place हमारे विकेंद्रीकृत वीडियो प्लेटफॉर्म के आपके उपयोग से संबंधित जानकारी को कैसे संभालता है।',
        'privacy.section2Title': '2. हम कौन सी जानकारी एकत्र करते हैं',
        'privacy.section2Content': 'विकेंद्रीकृत प्लेटफॉर्म के रूप में, हम न्यूनतम डेटा एकत्र करते हैं। आपकी Nostr सार्वजनिक कुंजी प्रमाणीकरण के लिए उपयोग की जाती है, और वीडियो मेटाडेटा Nostr रिले पर संग्रहीत होता है।',
        'privacy.section3Title': '3. डेटा भंडारण',
        'privacy.section3Content': 'आपकी सामग्री विकेंद्रीकृत स्टोरेज समाधानों पर संग्रहीत है। हम केंद्रीकृत सर्वरों पर व्यक्तिगत डेटा संग्रहीत नहीं करते। आपकी निजी कुंजी कभी भी हमारे साथ साझा नहीं की जाती।',
        'privacy.section4Title': '4. डेटा उपयोग',
        'privacy.section4Content': 'हम जो भी डेटा एकत्र करते हैं वह केवल प्लेटफॉर्म सेवाएं प्रदान करने और सुधारने के लिए उपयोग किया जाता है। हम कभी भी आपका डेटा तीसरे पक्षों को नहीं बेचते।',
        'privacy.section5Title': '5. कुकीज़ और ट्रैकिंग',
        'privacy.section5Content': 'हम बुनियादी कार्यक्षमता के लिए न्यूनतम कुकीज़ का उपयोग करते हैं। हम विज्ञापन ट्रैकिंग नहीं करते या मार्केटिंग उद्देश्यों के लिए डेटा एकत्र नहीं करते।',
        'privacy.section6Title': '6. तृतीय-पक्ष सेवाएं',
        'privacy.section6Content': 'हम Nostr रिले और Lightning Network नोड्स के साथ एकीकृत करते हैं। इन सेवाओं की अपनी गोपनीयता नीतियां हैं।',
        'privacy.section7Title': '7. डेटा सुरक्षा',
        'privacy.section7Content': 'हम अपनी विकेंद्रीकृत वास्तुकला के माध्यम से आपकी जानकारी की रक्षा करते हैं। हालांकि, आप अपनी निजी कुंजी की सुरक्षा के लिए जिम्मेदार हैं।',
        'privacy.section8Title': '8. आपके अधिकार',
        'privacy.section8Content': 'आपके पास अपने डेटा पर पूर्ण नियंत्रण है। आप किसी भी समय अपनी सामग्री हटा सकते हैं या प्लेटफॉर्म का उपयोग बंद कर सकते हैं।',
        'privacy.section9Title': '9. बच्चों की गोपनीयता',
        'privacy.section9Content': 'Plebs.place 13 वर्ष से कम उम्र के बच्चों के लिए नहीं है। हम जानबूझकर नाबालिगों से जानकारी एकत्र नहीं करते।',
        'privacy.section10Title': '10. नीति परिवर्तन',
        'privacy.section10Content': 'हम इस गोपनीयता नीति को अपडेट कर सकते हैं। परिवर्तन इस पेज पर अपडेट तिथि के साथ पोस्ट किए जाएंगे।',

        // FAQ Page
        'faq.title': 'अक्सर पूछे जाने वाले प्रश्न',
        'faq.subtitle': 'सामान्य प्रश्न और उत्तर',
        'faq.general': 'सामान्य',
        'faq.technical': 'तकनीकी',
        'faq.monetization': 'मोनेटाइजेशन',
        'faq.content': 'सामग्री',
        'faq.q1': 'Plebs.place क्या है?',
        'faq.a1': 'Plebs.place एक विकेंद्रीकृत वीडियो शेयरिंग प्लेटफॉर्म है जो Nostr प्रोटोकॉल पर बना है, जो आपको अपनी सामग्री और दर्शकों का पूर्ण स्वामित्व देता है।',
        'faq.q2': 'Plebs.place कैसे काम करता है?',
        'faq.a2': 'प्लेटफॉर्म Nostr का उपयोग प्रमाणीकरण और सामाजिक के लिए, विकेंद्रीकृत स्टोरेज का वीडियो होस्टिंग के लिए, और Lightning Network का तत्काल भुगतान के लिए करता है।',
        'faq.q3': 'क्या Plebs.place मुफ्त है?',
        'faq.a3': 'हां, खाता बनाना, अपलोड करना और देखना मुफ्त है। शुरू करने के लिए आपको बस एक Nostr कुंजी चाहिए।',
        'faq.q4': 'Nostr क्या है?',
        'faq.a4': 'Nostr एक विकेंद्रीकृत संचार प्रोटोकॉल है जो आपको केंद्रीकृत प्लेटफॉर्म पर निर्भर किए बिना अपनी पहचान और डेटा को नियंत्रित करने देता है।',
        'faq.q5': 'मैं खाता कैसे बनाऊं?',
        'faq.a5': 'आप Alby या nos2x जैसे Nostr ब्राउज़र एक्सटेंशन से साइन इन कर सकते हैं, या एक नई Nostr कुंजी बना सकते हैं।',
        'faq.q6': 'कौन से वीडियो फॉर्मेट समर्थित हैं?',
        'faq.a6': 'हम MP4, WebM और MOV सहित अधिकांश सामान्य फॉर्मेट का समर्थन करते हैं। वीडियो अपलोड के बाद ट्रांसकोड किए जाते हैं।',
        'faq.q7': 'मेरे वीडियो कहां संग्रहीत हैं?',
        'faq.a7': 'वीडियो विकेंद्रीकृत स्टोरेज समाधानों पर संग्रहीत हैं, जो सुनिश्चित करते हैं कि आपकी सामग्री किसी एक सर्वर के नियंत्रण में नहीं है।',
        'faq.q8': 'Lightning Network क्या है?',
        'faq.a8': 'Lightning Network बिटकॉइन के लिए एक लेयर 2 भुगतान प्रोटोकॉल है जो तत्काल, कम शुल्क वाले लेनदेन को सक्षम करता है।',
        'faq.q9': 'Zaps क्या हैं?',
        'faq.a9': 'Zaps Lightning Network के माध्यम से भेजे गए बिटकॉइन माइक्रोपेमेंट हैं जो क्रिएटर्स का समर्थन करने के लिए उपयोग किए जाते हैं।',
        'faq.q10': 'मैं अपनी सामग्री का मोनेटाइजेशन कैसे करूं?',
        'faq.a10': 'क्रिएटर्स दर्शक Zaps, सशुल्क सामग्री और Lightning के माध्यम से सीधे दान से आय अर्जित कर सकते हैं।',
        'faq.q11': 'मैं अपनी कमाई कैसे निकालूं?',
        'faq.a11': 'कमाई सीधे आपके Lightning वॉलेट में आती है। कोई न्यूनतम निकासी या प्रतीक्षा अवधि नहीं है।',
        'faq.q12': 'कौन सी सामग्री अनुमत है?',
        'faq.a12': 'वैध सामग्री का स्वागत है। कृपया हमारी सेवा शर्तों का पालन करें और हानिकारक या अवैध सामग्री से बचें।',
        'faq.q13': 'क्या मैं अपने वीडियो हटा सकता हूं?',
        'faq.a13': 'हां, आप किसी भी समय वीडियो हटा सकते हैं। विकेंद्रीकृत प्रकृति के कारण, वितरित प्रतियां अन्य नोड्स पर रह सकती हैं।',
        'faq.q14': 'क्या सामग्री मॉडरेशन है?',
        'faq.a14': 'विकेंद्रीकृत प्लेटफॉर्म के रूप में, मॉडरेशन समुदाय-संचालित दृष्टिकोण और उपयोगकर्ता नियंत्रण के माध्यम से होता है।',
        'faq.q15': 'मैं समस्याग्रस्त सामग्री की रिपोर्ट कैसे करूं?',
        'faq.a15': 'वीडियो पर रिपोर्ट सुविधा का उपयोग करें या हमारी संपर्क जानकारी के माध्यम से हमें बताएं। समुदाय प्रतिक्रिया प्लेटफॉर्म गुणवत्ता बनाए रखने में मदद करती है।',
        // FAQ Self-Moderation Section
        'faq.selfModeration': 'स्व-मॉडरेशन',
        'faq.q16': 'विकेंद्रीकृत प्लेटफ़ॉर्म पर मॉडरेशन कैसे काम करता है?',
        'faq.a16': 'केंद्रीकृत मॉडरेटर वाले पारंपरिक प्लेटफार्मों के विपरीत, Plebs आपको इस बात पर नियंत्रण देता है कि आप क्या देखते हैं। हम शक्तिशाली स्व-मॉडरेशन टूल प्रदान करते हैं जिसमें सामग्री फ़िल्टर पैक, उपयोगकर्ता म्यूटिंग, सामुदायिक चेतावनियां और रेश्यो किए गए वीडियो संकेतक शामिल हैं। आप तय करते हैं कि कौन सी सामग्री आपके लिए उपयुक्त है - कोई केंद्रीय प्राधिकरण उन निर्णयों को नहीं ले रहा है।',
        'faq.q17': 'सामग्री फ़िल्टर पैक क्या हैं?',
        'faq.a17Intro': 'सामग्री फ़िल्टर पैक पूर्वनिर्धारित कीवर्ड फ़िल्टर हैं जिन्हें आप विशिष्ट प्रकार की सामग्री छिपाने के लिए सक्षम कर सकते हैं। उपलब्ध पैक में शामिल हैं:',
        'faq.a17Pack1': 'नस्लवाद और घृणास्पद भाषण:',
        'faq.a17Pack1Desc': 'नस्लीय अपमान और भेदभावपूर्ण सामग्री को फ़िल्टर करता है',
        'faq.a17Pack2': 'यौन स्पष्ट सामग्री:',
        'faq.a17Pack2Desc': 'अश्लील और वयस्क सामग्री को फ़िल्टर करता है',
        'faq.a17Pack3': 'हिंसा और रक्तपात:',
        'faq.a17Pack3Desc': 'ग्राफिक हिंसा और आत्म-हानि सामग्री को फ़िल्टर करता है',
        'faq.a17Pack4': 'ड्रग्स और पदार्थ:',
        'faq.a17Pack4Desc': 'ड्रग-संबंधित सामग्री को फ़िल्टर करता है',
        'faq.a17Pack5': 'स्पैम और घोटाले:',
        'faq.a17Pack5Desc': 'सामान्य स्पैम और घोटाले के पैटर्न को फ़िल्टर करता है',
        'faq.a17Pack6': 'क्रिप्टोकरेंसी:',
        'faq.a17Pack6Desc': 'क्रिप्टो प्रचार और टोकन शिलिंग को फ़िल्टर करता है',
        'faq.a17Pack7': 'राजनीतिक सामग्री:',
        'faq.a17Pack7Desc': 'पक्षपातपूर्ण राजनीतिक सामग्री को फ़िल्टर करता है',
        'faq.a17Pack8': 'मजबूत अपशब्द:',
        'faq.a17Pack8Desc': 'अश्लील भाषा को फ़िल्टर करता है',
        'faq.a17Note': 'सेटिंग्स > सामग्री फ़िल्टर में इन्हें सक्षम करें। आप कस्टम कीवर्ड भी जोड़ सकते हैं। फ़िल्टर की गई सामग्री एक प्लेसहोल्डर दिखाती है जिसमें "वैसे भी दिखाएं" बटन होता है यदि आप इसे अस्थायी रूप से देखना चाहते हैं।',
        'faq.q18': 'मैं किसी उपयोगकर्ता को म्यूट कैसे करूं?',

        // Page Titles
        'pageTitle.following': 'फॉलोइंग',
        'pageTitle.myVideos': 'मेरे वीडियो',
        'pageTitle.likedVideos': 'पसंद किए गए वीडियो',
        'pageTitle.watchHistory': 'देखने का इतिहास',
        'pageTitle.liveStreams': 'लाइव स्ट्रीम',
        'pageTitle.suffix': '- Plebs',
        'pageTitle.liveSuffix': '- Plebs पर लाइव',
        // Home Page Sections
        'section.trending': 'ट्रेंडिंग',
        'section.recommended': 'आपके लिए सुझाव',
        'section.shorts': 'शॉर्ट्स',
        'section.live': 'लाइव',
        'section.liveNow': 'अभी लाइव',
        'section.latestVideos': 'नवीनतम वीडियो',
        'section.videos': 'वीडियो',
        'section.usersYouFollow': 'आपके द्वारा फॉलो किए गए उपयोगकर्ता',
        // Trending Period
        'trending.thisWeek': 'इस सप्ताह',
        'trending.today': 'आज',
        // Buttons
        'button.viewMore': 'और देखें',
        'button.clearAll': 'सभी साफ़ करें',
        'button.showAnyway': 'वैसे भी दिखाएं',
        // Confirmation Modals
        'confirm.logout': 'लॉग आउट',
        'confirm.logoutMessage': 'क्या आप वाकई लॉग आउट करना चाहते हैं?',
        'confirm.resetSettings': 'सेटिंग्स रीसेट करें',
        'confirm.resetSettingsMessage': 'क्या आप वाकई सभी सेटिंग्स को डिफ़ॉल्ट पर रीसेट करना चाहते हैं?',
        'confirm.reset': 'रीसेट',
        'confirm.clearHistory': 'इतिहास साफ़ करें',
        'confirm.clearHistoryMessage': 'क्या आप वाकई अपना पूरा देखने का इतिहास साफ़ करना चाहते हैं? इसे पूर्ववत नहीं किया जा सकता।',
        'confirm.deleteDraft': 'ड्राफ्ट हटाएं',
        'confirm.deleteDraftMessage': 'क्या आप वाकई इस ड्राफ्ट को हटाना चाहते हैं?',
        'confirm.delete': 'हटाएं',
        'confirm.deleteVideo': 'वीडियो हटाएं',
        'confirm.deleteVideoMessage': 'क्या आप वाकई इस वीडियो को हटाना चाहते हैं? यह कार्रवाई पूर्ववत नहीं की जा सकती।',
        'confirm.endStream': 'लाइव स्ट्रीम समाप्त करें',
        'confirm.endStreamMessage': 'क्या आप वाकई इस लाइव स्ट्रीम को समाप्त करना चाहते हैं? यह कार्रवाई पूर्ववत नहीं की जा सकती।',
        'confirm.endStreamButton': 'स्ट्रीम समाप्त करें',
        // Content Filters
        'filter.hiddenByPack': '{pack} द्वारा छिपाया गया',
        'filter.showAnyway': 'वैसे भी दिखाएं',
        'filter.contentHidden': 'सामग्री फ़िल्टर द्वारा सामग्री छिपाई गई',
        // Filter Packs
        'filter.racism': 'नस्लवाद और घृणा भाषण', 'filter.racismDesc': 'नस्लीय गालियां, जातीय घृणा भाषण और भेदभावपूर्ण सामग्री को फ़िल्टर करता है', 'filter.sexualExplicit': 'यौन स्पष्ट', 'filter.sexualExplicitDesc': 'अश्लील शब्दों और यौन स्पष्ट सामग्री को फ़िल्टर करता है', 'filter.violence': 'हिंसा और गोर', 'filter.violenceDesc': 'ग्राफिक हिंसा, गोर और हिंसक धमकियों को फ़िल्टर करता है', 'filter.drugs': 'ड्रग्स और पदार्थ', 'filter.drugsDesc': 'ड्रग-संबंधित सामग्री और पदार्थ दुरुपयोग को फ़िल्टर करता है', 'filter.spam': 'स्पैम और घोटाले', 'filter.spamDesc': 'सामान्य स्पैम, घोटाले और प्रचार सामग्री को फ़िल्टर करता है', 'filter.crypto': 'क्रिप्टोकरेंसी', 'filter.cryptoDesc': 'क्रिप्टोकरेंसी प्रचार, ट्रेडिंग सिग्नल और टोकन प्रचार को फ़िल्टर करता है', 'filter.politics': 'राजनीतिक सामग्री', 'filter.politicsDesc': 'पक्षपातपूर्ण राजनीतिक सामग्री और विभाजनकारी बयानबाजी को फ़िल्टर करता है', 'filter.profanity': 'कड़ी अपशब्द', 'filter.profanityDesc': 'कड़ी अपशब्द और अश्लील भाषा को फ़िल्टर करता है', 'filter.customFilter': 'कस्टम फ़िल्टर',
        // Following Page
        'following.noFollowingYet': 'आप अभी तक किसी को फॉलो नहीं कर रहे हैं। क्रिएटर्स खोजें और फॉलो करें!',
        'faq.a18': 'किसी उपयोगकर्ता को म्यूट करने के लिए, उनकी प्रोफ़ाइल पर जाएं और म्यूट बटन पर क्लिक करें। एक बार म्यूट करने के बाद, उनके सभी वीडियो आपके फ़ीड से छिपा दिए जाएंगे, उनकी टिप्पणियां "म्यूट किए गए उपयोगकर्ता से संदेश" के रूप में दिखाई देंगी, और उनके लाइव चैट संदेश छिपाए जाएंगे। आपकी म्यूट सूची Nostr पर संग्रहीत है, इसलिए यह उपकरणों में सिंक होती है। आप "म्यूट किए गए उपयोगकर्ता" के तहत अपनी प्रोफ़ाइल सेटिंग्स में म्यूट किए गए उपयोगकर्ताओं को प्रबंधित कर सकते हैं।',
        'faq.q19': '"रेश्यो" का क्या मतलब है?',
        'faq.a19': 'जब किसी वीडियो में लाइक्स की तुलना में काफी अधिक डिसलाइक होते हैं, तो उसे "रेश्यो" के रूप में चिह्नित किया जाता है, जो नकारात्मक सामुदायिक प्रतिक्रिया को दर्शाता है। विशेष रूप से, एक वीडियो को रेश्यो माना जाता है जब इसमें कम से कम 10 प्रतिक्रियाएं हों, डिसलाइक लाइक्स से कम से कम दोगुने हों, और डिसलाइक कुल प्रतिक्रियाओं का 70% या उससे अधिक हों। रेश्यो किए गए वीडियो एक चेतावनी बैज प्रदर्शित करते हैं, और देखने से पहले आपसे पुष्टि करने के लिए कहा जाएगा।',
        'faq.q20': 'सामुदायिक चेतावनियां कैसे काम करती हैं?',
        'faq.a20': 'उपयोगकर्ता विभिन्न कारणों से सामग्री की रिपोर्ट कर सकते हैं (स्पैम, अवैध सामग्री, दुरुपयोग, भ्रामक, आदि)। जब किसी वीडियो या उपयोगकर्ता को आपके द्वारा फॉलो किए जाने वाले लोगों से 5 या अधिक रिपोर्ट मिलती हैं, तो एक चेतावनी संकेतक दिखाई देता है। यह आपके सामाजिक ग्राफ़ का लाभ उठाता है - चेतावनियां आपके विश्वसनीय नेटवर्क से आती हैं, अनाम अजनबियों से नहीं। आप सेटिंग्स में "मेरे द्वारा फॉलो किए गए खातों से चेतावनियां दिखाएं" टॉगल कर सकते हैं।',
        'faq.q21': 'मैं सामग्री की रिपोर्ट कैसे करूं?',
        'faq.a21': 'किसी भी वीडियो, टिप्पणी या उपयोगकर्ता प्रोफ़ाइल पर फ़्लैग आइकन पर क्लिक करके उसकी रिपोर्ट करें। एक कारण चुनें (स्पैम, अवैध, दुरुपयोग, भ्रामक, प्रतिरूपण, कॉपीराइट, या अन्य) और वैकल्पिक रूप से विवरण जोड़ें। रिपोर्ट को Nostr पर इवेंट के रूप में प्रकाशित किया जाता है, जिससे वे पारदर्शी और विकेंद्रीकृत होते हैं। आपकी रिपोर्ट आपके नेटवर्क में दूसरों को समस्याग्रस्त सामग्री की पहचान करने में मदद करती है।',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': 'गोपनीयता और सुरक्षा',
        'faq.q22': 'क्या मेरी गतिविधि निजी है?',
        'faq.a22': 'Nostr पर, अधिकांश गतिविधि डिज़ाइन द्वारा सार्वजनिक होती है। आपके लाइक्स, टिप्पणियां, फॉलो और zaps सार्वजनिक नेटवर्क पर दिखाई देते हैं। हालाँकि, Plebs आपके ब्राउज़र में आपके वॉच हिस्ट्री को स्थानीय रूप से संग्रहीत करता है - इसे कभी भी किसी सर्वर पर नहीं भेजा जाता है। आप किसी भी समय अपना स्थानीय डेटा साफ़ कर सकते हैं।',
        'faq.q23': 'मैं अपने खाते को सुरक्षित कैसे रखूं?',
        'faq.a23': 'अपनी निजी कुंजी (nsec) को कभी भी किसी के साथ साझा न करें। हम दृढ़ता से Alby, nos2x, या हार्डवेयर साइनर जैसे Nostr ब्राउज़र एक्सटेंशन का उपयोग करने की सिफारिश करते हैं। ये आपकी निजी कुंजी को सुरक्षित रखते हैं और केवल तब इवेंट पर हस्ताक्षर करते हैं जब आप उन्हें मंजूरी देते हैं। वेबसाइटों में अपने nsec को सीधे संग्रहीत करने से बचें।',
        'faq.q24': 'क्या मैं अपनी सामग्री हटा सकता हूं?',
        'faq.a24': 'आप Nostr पर डिलीट इवेंट प्रकाशित करके हटाने का अनुरोध कर सकते हैं। अधिकांश अच्छे व्यवहार वाले रिले और क्लाइंट इसका सम्मान करेंगे। हालाँकि, नेटवर्क की विकेंद्रीकृत प्रकृति के कारण, सामग्री कुछ रिले या Blossom सर्वरों पर बनी रह सकती है। कोई केंद्रीय प्राधिकरण नहीं है जो पूरे नेटवर्क में पूर्ण विलोपन को मजबूर कर सके।',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': 'समस्या निवारण',
        'faq.q25': 'वीडियो लोड नहीं हो रहे हैं - मुझे क्या करना चाहिए?',
        'faq.a25Intro': 'यदि वीडियो लोड नहीं हो रहे हैं, तो इन चरणों को आज़माएं:',
        'faq.a25Item1': 'पेज को रिफ्रेश करें',
        'faq.a25Item2': 'अपना इंटरनेट कनेक्शन जांचें',
        'faq.a25Item3': 'वीडियो को होस्ट करने वाला Blossom सर्वर डाउन हो सकता है - यह Plebs से स्वतंत्र है',
        'faq.a25Item4': 'ब्राउज़र एक्सटेंशन को अक्षम करने का प्रयास करें जो सामग्री को ब्लॉक कर सकते हैं',
        'faq.a25Item5': 'अपना ब्राउज़र कैश साफ़ करें और फिर से प्रयास करें',
        'faq.q26': 'मैंने अपनी निजी कुंजी खो दी है - क्या आप इसे पुनर्प्राप्त करने में मेरी सहायता कर सकते हैं?',
        'faq.a26': 'दुर्भाग्य से, नहीं। Nostr कुंजियां क्रिप्टोग्राफिक हैं - कोई पासवर्ड रीसेट या खाता पुनर्प्राप्ति नहीं है क्योंकि कोई केंद्रीय प्राधिकरण नहीं है। यही कारण है कि हम दृढ़ता से अपनी कुंजियों का बैकअप लेने और एक सुरक्षित कुंजी प्रबंधन समाधान का उपयोग करने की सिफारिश करते हैं। यदि आप अपना nsec खो देते हैं, तो आपको एक नई पहचान बनानी होगी।',
        'faq.q27': 'मैं बग की रिपोर्ट कैसे करूं या सुविधा का अनुरोध कैसे करूं?',
        'faq.a27': 'आप हमारे <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a> पेज पर बग की रिपोर्ट कर सकते हैं या सुविधाओं का अनुरोध कर सकते हैं। आप Nostr पर भी हमसे संपर्क कर सकते हैं - विवरण के लिए हमारे <a href="#/contact">संपर्क</a> पेज पर जाएं।',
    },
    it: {
        // Navigation & Header
        'nav.home': 'Home', 'nav.following': 'Seguiti', 'nav.myVideos': 'I Miei Video', 'nav.liked': 'Piaciuti', 'nav.history': 'Cronologia', 'nav.topics': 'ARGOMENTI', 'nav.live': 'In Diretta', 'nav.bitcoin': 'Bitcoin', 'nav.nostr': 'Nostr', 'nav.technology': 'Tecnologia', 'nav.gaming': 'Gaming', 'nav.tutorials': 'Tutorial', 'nav.podcasts': 'Podcast', 'nav.music': 'Musica', 'nav.nsfw': 'NSFW', 'nav.about': 'Info', 'nav.contact': 'Contatti', 'nav.terms': 'Termini', 'nav.privacy': 'Privacy', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': 'Live Stream', 'nav.github': 'GitHub',
        'header.search': 'Cerca video...', 'header.notifications': 'Notifiche', 'header.settings': 'Impostazioni', 'header.create': 'Crea', 'header.viewProfile': 'Vedi Profilo', 'header.logout': 'Esci',
        // Login Modal
        'login.title': 'Accedi con Nostr', 'login.extensionButton': 'Accedi con Estensione Nostr', 'login.extensionDesc': 'Usa estensione di firma (Alby, nos2x, ecc.)', 'login.orDivider': 'OPPURE', 'login.nsecLabel': 'Accedi con Chiave Privata (nsec)', 'login.nsecPlaceholder': 'Inserisci il tuo nsec...', 'login.nsecButton': 'Accedi con nsec', 'login.nsecWarning': 'Attenzione: Inserire nsec direttamente è meno sicuro rispetto all\'uso di un\'estensione. Considera un\'estensione NIP-07 per maggiore sicurezza.', 'login.newToNostr': 'Nuovo su Nostr?', 'login.createAccount': 'Crea Account', 'login.learnMore': 'Scopri di più su Nostr',
        // Connect Modal
        'connect.title': 'Connetti a Nostr', 'connect.or': 'OPPURE', 'connect.extensionButton': 'Connetti Estensione Nostr', 'connect.extensionDesc': 'Usa estensione (Alby, nos2x, ecc.)', 'connect.nsecLabel': 'Accedi con Chiave Privata', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'Connetti con nsec', 'connect.nsecWarning': 'Attenzione: Inserire nsec direttamente è meno sicuro. Usa un\'estensione NIP-07 per maggiore sicurezza.', 'connect.newToNostr': 'Nuovo su Nostr?', 'connect.createAccount': 'Crea Account',
        // Private Key Modal
        'privateKey.title': 'La Tua Chiave Privata', 'privateKey.warning': 'IMPORTANTE: Salva questo in un posto sicuro. Se perdi questa chiave, perderai l\'accesso al tuo account. Non condividerla mai con nessuno!', 'privateKey.show': 'Mostra Chiave Privata', 'privateKey.hide': 'Nascondi Chiave Privata', 'privateKey.copy': 'Copia', 'privateKey.saved': 'Ho salvato la mia chiave', 'privateKey.yourPublicKey': 'La tua Chiave Pubblica (npub):', 'privateKey.yourPrivateKey': 'La tua Chiave Privata (nsec):',
        // Signup Modal
        'signup.title': 'Crea Account Nostr', 'signup.whatIsNostr': 'Cos\'è Nostr?', 'signup.nostrDescription': 'Nostr è un protocollo decentralizzato che ti dà il controllo sulla tua identità e i tuoi dati. Nessun server centrale - il tuo account è una coppia di chiavi crittografiche.', 'signup.whyNostr': 'Perché Nostr?', 'signup.benefit1': 'Possiedi la tua identità', 'signup.benefit2': 'Nessuna censura', 'signup.benefit3': 'Portabilità tra piattaforme', 'signup.createNew': 'Crea Nuovo Account', 'signup.haveAccount': 'Hai già un account?', 'signup.login': 'Accedi', 'signup.createButton': 'Crea Account', 'signup.generating': 'Generazione chiavi...', 'signup.displayName': 'Nome Visualizzato', 'signup.displayNamePlaceholder': 'Inserisci nome visualizzato', 'signup.username': 'Nome Utente', 'signup.usernamePlaceholder': 'Inserisci nome utente', 'signup.about': 'Descrizione (opzionale)', 'signup.profilePicture': 'Foto Profilo (opzionale)', 'signup.lightningAddress': 'Indirizzo Lightning (opzionale)', 'signup.nostrAddress': 'Indirizzo Nostr', 'signup.nostrAddressPlaceholder': 'nomeutente', 'signup.nostrAddressHint': 'Il tuo indirizzo Nostr rende il tuo profilo più facile da trovare. Solo lettere minuscole, numeri, _ e -.', 'signup.nostrAddressRequired': 'Inserisci un indirizzo Nostr', 'signup.nostrAddressAvailable': 'Disponibile!', 'signup.nostrAddressUnavailable': 'Già in uso', 'signup.nostrAddressChecking': 'Verifica in corso...', 'signup.nostrAddressInvalid': 'Formato nome utente non valido', 'signup.nostrAddressRegistering': 'Registrazione indirizzo Nostr...', 'signup.nostrAddressSuccess': 'Indirizzo Nostr registrato!', 'signup.nostrAddressFailed': 'Impossibile registrare indirizzo Nostr', 'signup.createAccountBtn': 'Crea Account', 'signup.termsAgree': 'Creando un account, accetti i nostri', 'signup.and': 'e', 'signup.success': 'Account Creato con Successo!', 'signup.yourPrivateKey': 'La Tua Chiave Privata (nsec)', 'signup.keyWarning': 'Questo è l\'UNICO modo per accedere al tuo account. Conservala in un posto sicuro!', 'signup.copyPrivateKey': 'Copia Chiave Privata', 'signup.howToUseKey': 'Come usare la tua chiave privata', 'signup.continueToPlebs': 'Continua su Plebs', 'signup.step1': 'Salva in modo sicuro:', 'signup.step1Desc': 'Salva il tuo nsec in un gestore di password, scrivilo o salvalo in un file crittografato. Non condividerlo mai pubblicamente!', 'signup.step2': 'Per accedere di nuovo:', 'signup.step2Desc': 'Clicca su "Chiave Privata" nella schermata di accesso e incolla il tuo nsec. Funziona come una password.', 'signup.step3': 'Usa in altre app:', 'signup.step3Desc': 'Il tuo nsec funziona in tutte le app Nostr - Damus, Primal, Amethyst e centinaia di altre!', 'signup.step4': 'Considera un\'app di firma:', 'signup.step4Desc': 'Per maggiore sicurezza, usa app come Amber (Android) o un\'estensione del browser come Alby per gestire le tue chiavi.',
        // Notifications
        'notifications.title': 'Notifiche', 'notifications.empty': 'Nessuna notifica', 'notifications.viewAll': 'Vedi tutte le notifiche', 'notifications.markAllRead': 'Segna tutto come letto', 'notifications.settings': 'Impostazioni notifiche', 'notifications.loading': 'Caricamento notifiche...', 'notifications.zap': 'ti ha inviato uno zap', 'notifications.like': 'ha apprezzato il tuo contenuto', 'notifications.comment': 'ha commentato', 'notifications.follow': 'ti ha seguito', 'notifications.repost': 'ha ripostato', 'notifications.mention': 'ti ha menzionato',
        // Settings Modal
        'settings.title': 'Impostazioni', 'settings.language': 'Lingua', 'settings.languageDesc': 'Scegli la lingua', 'settings.saveToNostr': 'Salva su Nostr', 'settings.darkMode': 'Modalità Scura', 'settings.darkModeDesc': 'Attiva/disattiva tema scuro', 'settings.autoplay': 'Riproduzione Auto', 'settings.autoplayDesc': 'Riproduci video automaticamente', 'settings.saveSettings': 'Salva Impostazioni', 'settings.resetDefaults': 'Ripristina', 'settings.notificationSettings': 'Impostazioni Notifiche', 'settings.notifications': 'Notifiche', 'settings.notificationsDesc': 'Ricevi notifiche push', 'settings.quality': 'Qualità Predefinita', 'settings.qualityDesc': 'Qualità riproduzione video', 'settings.contentWarning': 'Preferenze Avvisi Contenuto', 'settings.showNsfwWarnings': 'Mostra avvisi NSFW', 'settings.showNsfwWarningsDesc': 'Mostra verifica età per contenuti NSFW', 'settings.showCommunityWarnings': 'Mostra avvisi della community', 'settings.showCommunityWarningsDesc': 'Mostra avvisi per contenuti segnalati o con molti voti negativi', 'settings.showFollowsReportWarnings': 'Mostra avvisi segnalazioni seguiti', 'settings.showFollowsReportWarningsDesc': 'Mostra avvisi quando 5+ persone che segui segnalano contenuti', 'settings.filterPacks': 'Pacchetti Filtri Contenuto', 'settings.filterPacksDesc': 'Abilita pacchetti filtri per nascondere automaticamente contenuti con parole chiave specifiche.', 'settings.customKeywordFilter': 'Filtro Parole Chiave Personalizzato', 'settings.customKeywordFilterPlaceholder': 'Inserisci parole chiave o frasi separate da virgola\nEsempio: spam, contenuto indesiderato, frase specifica', 'settings.customKeywordFilterDesc': 'Aggiungi le tue parole chiave da filtrare (separate da virgola)',
        // Upload Modal
        'upload.title': 'Carica Video', 'upload.dragDrop': 'Trascina e rilascia il file video qui', 'upload.or': 'oppure', 'upload.browse': 'Sfoglia File', 'upload.supportedFormats': 'Formati supportati: MP4, WebM, MOV', 'upload.maxSize': 'Dimensione massima: 2GB', 'upload.videoTitle': 'Titolo', 'upload.titlePlaceholder': 'Inserisci titolo video', 'upload.description': 'Descrizione', 'upload.descriptionPlaceholder': 'Descrivi il tuo video...', 'upload.tags': 'Tag', 'upload.tagsPlaceholder': 'Aggiungi tag separati da virgola', 'upload.visibility': 'Visibilità', 'upload.public': 'Pubblico', 'upload.unlisted': 'Non elencato', 'upload.uploadButton': 'Carica Video', 'upload.uploading': 'Caricamento...', 'upload.processing': 'Elaborazione...', 'upload.complete': 'Completato!', 'upload.error': 'Caricamento fallito', 'upload.nsfw': 'Contenuto NSFW', 'upload.nsfwDesc': 'Contrassegna come contenuto per adulti', 'upload.thumbnail': 'Miniatura', 'upload.thumbnailDesc': 'Carica miniatura video', 'upload.preparing': 'Preparazione...', 'upload.cancel': 'Annulla', 'upload.progress': 'Progresso caricamento', 'upload.transcoding': 'Transcodifica', 'upload.status.preparing': 'Preparazione caricamento...', 'upload.status.uploading': 'Caricamento video...', 'upload.status.transcoding': 'Transcodifica video...', 'upload.status.complete': 'Caricamento completato!', 'upload.qualityHigh': 'Alta', 'upload.qualityMedium': 'Media', 'upload.qualityLow': 'Bassa',
        // Create Modal
        'create.title': 'Crea', 'create.uploadVideo': 'Carica Video', 'create.uploadDesc': 'Condividi un video', 'create.goLive': 'Vai in Diretta', 'create.goLiveDesc': 'Avvia streaming live', 'create.createPost': 'Crea Post', 'create.createPostDesc': 'Condividi un post testuale',
        // Go Live Modal
        'goLive.title': 'Vai in Diretta', 'goLive.streamTitle': 'Titolo Stream', 'goLive.streamTitlePlaceholder': 'Inserisci titolo stream', 'goLive.description': 'Descrizione', 'goLive.descriptionPlaceholder': 'Descrivi il tuo stream...', 'goLive.category': 'Categoria', 'goLive.selectCategory': 'Seleziona categoria', 'goLive.tags': 'Tag', 'goLive.tagsPlaceholder': 'Aggiungi tag separati da virgola', 'goLive.startStream': 'Avvia Stream', 'goLive.streamKey': 'Chiave Stream', 'goLive.streamUrl': 'URL Stream', 'goLive.copy': 'Copia', 'goLive.hideKey': 'Nascondi Chiave', 'goLive.showKey': 'Mostra Chiave', 'goLive.connecting': 'Connessione...', 'goLive.live': 'IN DIRETTA', 'goLive.offline': 'Offline', 'goLive.viewers': 'spettatori', 'goLive.endStream': 'Termina Stream', 'goLive.nsfw': 'Contenuto NSFW', 'goLive.nsfwDesc': 'Contrassegna come contenuto per adulti', 'goLive.thumbnail': 'Miniatura Stream', 'goLive.thumbnailDesc': 'Carica miniatura', 'goLive.zapGoal': 'Obiettivo Zap (opzionale)', 'goLive.zapGoalLabel': 'Obiettivo Zap',
        // Video/Live No Description
        'video.noDescription': 'Nessuna descrizione aggiunta a questo video.', 'live.noDescription': 'Nessuna descrizione aggiunta a questa diretta.',
        // Edit Stream Modal
        'editStream.title': 'Modifica Stream', 'editStream.save': 'Salva Modifiche',
        // NSFW Warning Modal
        'nsfw.title': 'Avviso Contenuto Adulti', 'nsfw.warning': 'Questo contenuto è contrassegnato come NSFW (Non Sicuro per il Lavoro) e potrebbe contenere materiale per adulti.', 'nsfw.confirm': 'Conferma la tua età', 'nsfw.confirmAge': 'Ho 18 anni o più', 'nsfw.cancel': 'Torna Indietro', 'nsfw.continue': 'Continua', 'nsfw.dontShowAgain': 'Non mostrare più questo avviso',
        // Community Warning Modal
        'community.title': 'Linee Guida Community', 'community.warning': 'Rivedi le nostre linee guida della community prima di continuare.', 'community.guidelines': 'Sii rispettoso e segui gli standard della community.', 'community.accept': 'Accetto', 'community.decline': 'Rifiuto',
        'communityWarning.title': 'Avviso della Community', 'communityWarning.description': 'Questo video è stato segnalato e/o ha ricevuto molti voti negativi dalla community. Questo potrebbe essere dovuto a:', 'communityWarning.reason1': 'Contenuto inappropriato non correttamente contrassegnato come NSFW', 'communityWarning.reason2': 'Dettagli utente nuovi o sospetti', 'communityWarning.reason3': 'Informazioni fuorvianti o false', 'communityWarning.reason4': 'Spam o contenuto di bassa qualità', 'communityWarning.reason5': 'Contenuto potenzialmente dannoso o illegale', 'communityWarning.proceed': 'Procedere con cautela.', 'communityWarning.goBack': 'Torna Indietro', 'communityWarning.viewAnyway': 'Visualizza Comunque',
        // Report Modal
        'report.title': 'Segnala Contenuto', 'report.reason': 'Motivo della Segnalazione', 'report.selectReason': 'Seleziona motivo', 'report.spam': 'Spam o fuorviante', 'report.inappropriate': 'Contenuto inappropriato', 'report.violence': 'Contenuto violento o pericoloso', 'report.copyright': 'Violazione copyright', 'report.other': 'Altro', 'report.details': 'Dettagli', 'report.detailsPlaceholder': 'Fornisci maggiori dettagli...', 'report.submit': 'Invia Segnalazione', 'report.cancel': 'Annulla',
        // Share Modal
        'share.title': 'Condividi', 'share.copyLink': 'Copia Link', 'share.embed': 'Codice Embed', 'share.copyEmbed': 'Copia Codice Embed', 'share.social': 'Condividi sui Social', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': 'Email', 'share.copied': 'Copiato!', 'share.nostr': 'Condividi su Nostr', 'share.generateImage': 'Genera Immagine', 'share.downloadImage': 'Scarica', 'share.shareImage': 'Condividi', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (quadrato)', 'share.size1080x1920': '1080 × 1920 (storia)',
        // Edit Video Modal
        'editVideo.title': 'Modifica Video', 'editVideo.videoTitle': 'Titolo', 'editVideo.description': 'Descrizione', 'editVideo.tags': 'Tag', 'editVideo.thumbnail': 'Miniatura', 'editVideo.changeThumbnail': 'Cambia Miniatura', 'editVideo.visibility': 'Visibilità', 'editVideo.nsfw': 'Contenuto NSFW', 'editVideo.save': 'Salva Modifiche', 'editVideo.delete': 'Elimina Video', 'editVideo.confirmDelete': 'Sei sicuro di voler eliminare questo video?',
        // Edit Profile Modal
        'editProfile.title': 'Modifica Profilo', 'editProfile.displayName': 'Nome Visualizzato', 'editProfile.displayNamePlaceholder': 'Inserisci nome visualizzato', 'editProfile.username': 'Nome Utente', 'editProfile.usernamePlaceholder': 'Inserisci nome utente', 'editProfile.about': 'Bio', 'editProfile.aboutPlaceholder': 'Raccontaci di te...', 'editProfile.website': 'Sito Web', 'editProfile.websitePlaceholder': 'https://tuosito.com', 'editProfile.lightning': 'Indirizzo Lightning', 'editProfile.lightningPlaceholder': 'tu@getalby.com', 'editProfile.nip05': 'Verifica NIP-05', 'editProfile.nip05Placeholder': 'tu@dominio.com', 'editProfile.avatar': 'Avatar', 'editProfile.changeAvatar': 'Cambia Avatar', 'editProfile.banner': 'Banner', 'editProfile.changeBanner': 'Cambia Banner', 'editProfile.save': 'Salva Profilo',
        // Confirmation Modal
        'confirm.title': 'Conferma Azione', 'confirm.message': 'Sei sicuro di voler continuare?', 'confirm.confirm': 'Conferma', 'confirm.cancel': 'Annulla',
        // Video Page
        'video.views': 'visualizzazioni', 'video.like': 'Mi Piace', 'video.dislike': 'Non Mi Piace', 'video.share': 'Condividi', 'video.save': 'Salva', 'video.report': 'Segnala', 'video.follow': 'Segui', 'video.unfollow': 'Non Seguire', 'video.subscribe': 'Iscriviti', 'video.subscribed': 'Iscritto', 'video.comments': 'Commenti', 'video.addComment': 'Aggiungi commento...', 'video.reply': 'Rispondi', 'video.replies': 'risposte', 'video.loadMore': 'Carica Altri', 'video.noComments': 'Nessun commento. Sii il primo!', 'video.zap': 'Zap', 'video.zapAmount': 'Importo Zap (sats)', 'video.sendZap': 'Invia Zap', 'video.boost': 'Boost', 'video.description': 'Descrizione', 'video.showMore': 'Mostra di più', 'video.showLess': 'Mostra meno', 'video.publishedOn': 'Pubblicato il',
        // Toast Messages
        'toast.loggedIn': 'Accesso effettuato con successo!', 'toast.settingsSaved': 'Impostazioni salvate con successo!', 'toast.settingsLocal': 'Impostazioni salvate localmente. Impossibile salvare su Nostr.', 'toast.settingsLocalOnly': 'Impostazioni salvate localmente!', 'toast.settingsReset': 'Impostazioni ripristinate ai valori predefiniti!', 'toast.avatarUploaded': 'Avatar caricato con successo!', 'toast.profileUpdated': 'Profilo aggiornato con successo!', 'toast.copied': 'Copiato negli appunti!', 'toast.copyFailed': 'Copia fallita. Si prega di copiare manualmente.', 'toast.installExtension': 'Si prega di installare un\'estensione Nostr come Alby o nos2x', 'toast.loginFailed': 'Accesso con estensione fallito. Riprova.', 'toast.invalidKey': 'Chiave privata non valida. Controlla e riprova.', 'toast.enterKey': 'Si prega di inserire la chiave privata', 'toast.enterUsername': 'Si prega di inserire un nome utente', 'toast.accountCreated': 'Benvenuto su Plebs! Sei ora connesso.', 'toast.keyCopied': 'Chiave privata copiata negli appunti!', 'toast.unmuted': 'Utente riattivato', 'toast.unmuteFailed': 'Impossibile riattivare utente', 'toast.selectImage': 'Si prega di selezionare un file immagine', 'toast.imageTooLarge': 'L\'immagine deve essere inferiore a 5MB', 'toast.avatarFailed': 'Caricamento avatar fallito. Riprova.', 'toast.mustBeLoggedIn': 'Devi essere connesso per modificare il profilo', 'toast.enterDisplayName': 'Si prega di inserire un nome visualizzato', 'toast.profileFailed': 'Salvataggio profilo fallito. Riprova.', 'toast.invalidBunker': 'Si prega di inserire un URL bunker valido', 'toast.connectFailed': 'Connessione fallita', 'toast.showingFiltered': 'Visualizzazione contenuti filtrati', 'toast.reportSubmitted': 'Segnalazione inviata con successo', 'toast.draftSaved': 'Bozza salvata! Puoi continuare dopo da I Miei Video.', 'toast.draftLoaded': 'Bozza caricata. Completa il caricamento e pubblica.', 'toast.draftDeleted': 'Bozza eliminata', 'toast.languageChanged': 'Lingua cambiata', 'toast.videoBlocked': 'Video bloccato e pubblicato su Nostr', 'toast.waitForUpload': 'Attendere il completamento del caricamento video', 'toast.enterTitle': 'Si prega di inserire un titolo', 'toast.publishing': 'Pubblicazione video su Nostr...',
        // Time
        'time.justNow': 'adesso', 'time.secondAgo': '1 secondo fa', 'time.secondsAgo': '{n} secondi fa', 'time.minuteAgo': '1 minuto fa', 'time.minutesAgo': '{n} minuti fa', 'time.hourAgo': '1 ora fa', 'time.hoursAgo': '{n} ore fa', 'time.dayAgo': '1 giorno fa', 'time.daysAgo': '{n} giorni fa', 'time.weekAgo': '1 settimana fa', 'time.weeksAgo': '{n} settimane fa', 'time.monthAgo': '1 mese fa', 'time.monthsAgo': '{n} mesi fa', 'time.yearAgo': '1 anno fa', 'time.yearsAgo': '{n} anni fa',
        // Empty States
        'empty.noVideos': 'Nessun video trovato', 'empty.noVideosDesc': 'Prova una ricerca diversa', 'empty.noFollowing': 'Non segui ancora nessuno', 'empty.noFollowingDesc': 'Segui i creator per vedere i loro video', 'empty.noHistory': 'Nessuna cronologia', 'empty.noHistoryDesc': 'I video che guardi appariranno qui', 'empty.noLiked': 'Nessun video piaciuto', 'empty.noLikedDesc': 'I video che ti piacciono appariranno qui', 'empty.noResults': 'Nessun risultato trovato', 'empty.noResultsDesc': 'Prova parole chiave diverse',
        // Misc
        'misc.loading': 'Caricamento...', 'misc.loadingMore': 'Caricamento altri...', 'misc.refresh': 'Aggiorna', 'misc.retry': 'Riprova', 'misc.close': 'Chiudi', 'misc.back': 'Indietro', 'misc.next': 'Avanti', 'misc.previous': 'Precedente', 'misc.search': 'Cerca', 'misc.filter': 'Filtra', 'misc.sort': 'Ordina', 'misc.newest': 'Più Recenti', 'misc.oldest': 'Più Vecchi', 'misc.popular': 'Popolari', 'misc.trending': 'Di Tendenza', 'misc.sats': 'sats', 'misc.all': 'Tutti', 'misc.copiedToClipboard': 'Copiato negli appunti!',
        // Common
        'common.submit': 'Invia', 'common.cancel': 'Annulla', 'common.save': 'Salva', 'common.delete': 'Elimina', 'common.edit': 'Modifica', 'common.close': 'Chiudi', 'common.confirm': 'Conferma', 'common.yes': 'Sì', 'common.no': 'No', 'common.ok': 'OK', 'common.loading': 'Caricamento...', 'common.uploading': 'Caricamento...', 'common.error': 'Errore', 'common.success': 'Successo',
        // Aria Labels
        'aria.toggleMenu': 'Attiva/disattiva menu', 'aria.mainNavigation': 'Navigazione principale', 'aria.videoContent': 'Contenuto video', 'aria.loadingContent': 'Caricamento contenuto', 'aria.closeModal': 'Chiudi modale', 'aria.playVideo': 'Riproduci video', 'aria.pauseVideo': 'Pausa video', 'aria.muteVideo': 'Disattiva audio', 'aria.unmuteVideo': 'Attiva audio', 'aria.fullscreen': 'Schermo intero', 'aria.exitFullscreen': 'Esci da schermo intero', 'aria.settings': 'Impostazioni', 'aria.notifications': 'Notifiche', 'aria.userMenu': 'Menu utente', 'aria.searchInput': 'Cerca video', 'aria.videoPlayer': 'Lettore video',
        // Dynamic JavaScript text
        'button.hideQR': 'Nascondi QR Code', 'button.showQR': 'Mostra QR Code', 'button.copied': 'Copiato!', 'button.showLess': 'Mostra Meno', 'button.showMore': 'Mostra Altro', 'button.creatingAccount': 'Creazione account...', 'button.submitting': 'Invio in corso...', 'button.scheduleStream': 'Programma Streaming', 'button.goLive': 'Vai in Diretta', 'button.creatingStream': 'Creazione streaming...', 'button.continueCustomAmount': 'Continua con Importo Personalizzato', 'button.recordFromCamera': 'Registra dalla Fotocamera', 'button.requestingCamera': 'Richiesta fotocamera...', 'button.recording': 'Registrazione...',
        'status.saving': 'Salvataggio...', 'status.saved': 'Salvato!', 'status.uploading': 'Caricamento...', 'status.uploadComplete': 'Caricamento completato!', 'status.uploadingToNostrBuild': 'Caricamento su nostr.build...', 'status.publishingChanges': 'Pubblicazione modifiche...', 'status.removingOldVersion': 'Rimozione vecchia versione...', 'status.validatingThumbnail': 'Validazione miniatura...', 'status.uploadingThumbnail': 'Caricamento miniatura...', 'status.thumbnailUploaded': 'Miniatura caricata!', 'status.processingVideo': 'Elaborazione video...', 'status.compressingVideo': 'Compressione video...', 'status.uploadingVideo': 'Caricamento video...', 'status.videoUploaded': 'Video caricato con successo!', 'status.processing': 'Elaborazione...', 'status.generatingThumbnail': 'Generazione miniatura...', 'status.generatingPreview': 'Generazione anteprima...', 'status.uploadingPreview': 'Caricamento anteprima...', 'status.publishing': 'Pubblicazione...', 'status.publishingToNostr': 'Pubblicazione su Nostr...', 'status.publishingVideoToNostr': 'Pubblicazione video su Nostr...', 'status.generatingPoW': 'Generazione proof of work...', 'status.posting': 'Pubblicazione...', 'status.processingVideoAndThumbnail': 'Elaborazione video e miniatura...', 'status.uploadFailed': 'Caricamento fallito - riprova', 'status.selectVideoToUpload': 'Seleziona video da caricare', 'status.waitingForVideoUpload': 'In attesa del caricamento video...', 'status.selectVideoAndThumbnail': 'Seleziona video e miniatura per pubblicare', 'status.ready': 'Pronto ✓', 'status.failed': 'Fallito ✗', 'status.fromDraft': 'Da bozza', 'status.startingNow': 'Inizia ora!', 'status.ended': 'TERMINATO', 'status.thumbnailReady': 'Pronto', 'status.thumbnailFailed': 'Fallito', 'status.uploadFailedRetry': 'Caricamento fallito. Riprova.',
        'publish.video': 'Pubblica Video', 'publish.autoThumbnail': 'Pubblica Video (miniatura auto)',
        'report.titleComment': 'Segnala Commento', 'report.titleUser': 'Segnala Utente', 'report.titleVideo': 'Segnala Video', 'report.descComment': 'Seleziona un motivo per segnalare questo commento:', 'report.descUser': 'Seleziona un motivo per segnalare questo utente:', 'report.descVideo': 'Seleziona un motivo per segnalare questo contenuto:',
        'empty.noMutedUsers': 'Nessun utente silenziato.', 'empty.noVideosToMonitor': 'Nessun video da monitorare.', 'empty.noRecentActivity': 'Nessuna attività recente.', 'empty.failedLoadNotifications': 'Impossibile caricare le notifiche', 'empty.loginToViewLiked': 'Per favore <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">accedi</a> per vedere i video che ti piacciono.', 'empty.loginToViewFollowing': 'Per favore <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">accedi</a> per vedere chi segui.', 'empty.loginToViewVideos': 'Per favore <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">accedi</a> per vedere i tuoi video.', 'empty.loginToViewAnalytics': 'Per favore <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">accedi</a> per vedere le tue statistiche.', 'empty.noLikedVideosYet': 'Non hai ancora messo mi piace a nessun video.', 'empty.noLikedVideosFound': 'Nessun video piaciuto trovato.', 'empty.noFullLengthLikedVideos': 'Nessun video lungo piaciuto trovato.', 'empty.noWatchHistory': 'Nessuna cronologia. Inizia a guardare video.', 'empty.noVideosInHistory': 'Nessun video nella cronologia.', 'empty.noFullLengthHistory': 'Nessun video lungo nella cronologia.', 'empty.noMatchingVideos': 'Nessun video corrispondente trovato.', 'empty.noFullLengthVideos': 'Nessun video lungo trovato.', 'empty.failedLoadTrending': 'Impossibile caricare le tendenze.', 'empty.noTrendingVideos': 'Nessun video di tendenza trovato.', 'empty.noMatchingUsers': 'Nessun utente corrispondente trovato.', 'empty.unableLoadProfiles': 'Impossibile caricare i profili.', 'empty.noFollowingVideos': 'Nessun video dagli utenti che segui.', 'empty.noFullLengthFollowing': 'Nessun video lungo dagli utenti che segui.', 'empty.failedLoadFollowing': 'Caricamento fallito. Riprova.', 'empty.noVideosUploadFirst': 'Nessun video. Carica il tuo primo video!', 'empty.noFullLengthUploaded': 'Nessun video lungo trovato.', 'empty.noMatchingLiveStreams': 'Nessun live stream corrispondente trovato.', 'empty.noMatchingShorts': 'Nessun short corrispondente trovato.', 'empty.noVideosForTag': 'Nessun video per questo tag.', 'empty.noFullLengthForTag': 'Nessun video lungo per questo tag.', 'empty.noUploadedVideos': 'Nessun video caricato ancora.', 'empty.noVideosFound': 'Nessun video trovato.', 'empty.failedLoadProfile': 'Impossibile caricare il profilo. Riprova.', 'empty.noComments': 'Nessun commento ancora. Sii il primo!', 'empty.failedLoadComments': 'Impossibile caricare i commenti', 'empty.noLiveNow': 'Nessuno in diretta ora. Sii il primo!',
        'error.videoNotFound': 'Video non trovato.', 'error.contentNotAvailable': 'Questo contenuto non è disponibile.', 'error.invalidVideoData': 'Dati video non validi.', 'error.videoNotAvailable': 'Video non disponibile. Il file potrebbe essere stato rimosso.', 'error.failedLoadVideo': 'Impossibile caricare il video. Riprova.', 'error.failedLoadVideoShort': 'Caricamento fallito. File potrebbe essere rimosso.', 'error.liveStreamNotFound': 'Live stream non trovato.', 'error.invalidLiveStreamData': 'Dati live stream non validi.', 'error.failedLoadLiveStream': 'Impossibile caricare il live stream.',
        // New Button & Action Labels
        'button.follow': 'Segui', 'button.unfollow': 'Non seguire', 'button.mute': 'Silenzia', 'button.unmute': 'Riattiva audio', 'button.muteUser': 'Silenzia utente', 'button.unmuteUser': 'Riattiva utente', 'button.confirm': 'Conferma', 'button.cancel': 'Annulla', 'button.close': 'Chiudi', 'button.boost': 'Potenzia', 'button.zap': 'Zap', 'button.viewMore': 'Mostra altro', 'button.viewAnalytics': 'Visualizza statistiche', 'button.backToMyVideos': 'Torna ai Miei Video', 'button.editDraft': 'Modifica bozza', 'button.deleteDraft': 'Elimina bozza', 'button.editVideo': 'Modifica video', 'button.deleteVideo': 'Elimina video', 'button.editShort': 'Modifica short', 'button.deleteShort': 'Elimina short', 'button.editStream': 'Modifica diretta', 'button.endStream': 'Termina diretta', 'button.reset': 'Reimposta', 'button.download': 'Scarica', 'button.watchRecording': 'Guarda registrazione', 'button.show': 'Mostra', 'button.login': 'Accedi', 'button.toggleChat': 'Attiva/disattiva chat', 'button.blockVideo': 'Blocca video', 'button.blockUser': 'Blocca utente', 'button.unblock': 'Sblocca', 'button.removeFromHistory': 'Rimuovi dalla cronologia',
        // New Stats & Counts
        'stat.views': 'visualizzazioni', 'stat.viewsCount': '{count} visualizzazioni', 'stat.videos': 'video', 'stat.video': 'video', 'stat.followers': 'follower', 'stat.follower': 'follower', 'stat.following': 'Seguiti', 'stat.subscribers': 'iscritti', 'stat.comments': 'Commenti', 'stat.liveCount': '{count} in diretta', 'stat.percentOfGoal': '{percent}% dell\'obiettivo', 'stat.netGrowth': 'Crescita netta', 'stat.newFollowers': 'Nuovi follower', 'stat.unfollowed': 'Non seguono più', 'stat.lastUpdated': 'Ultimo aggiornamento: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'IN DIRETTA', 'badge.ended': 'TERMINATA', 'badge.scheduled': 'PROGRAMMATA', 'badge.warning': 'AVVISO', 'badge.communityWarning': 'AVVISO DELLA COMUNITÀ', 'badge.verifiedNip05': 'NIP-05 verificato', 'badge.streamer': 'Streamer', 'badge.clickToView': 'Clicca per vedere',
        // New Actions
        'action.report': 'Segnala', 'action.reportComment': 'Segnala commento', 'action.reportVideo': 'Segnala questo video', 'action.reportStream': 'Segnala questa diretta', 'action.like': 'Mi piace', 'action.dislike': 'Non mi piace', 'action.reply': 'Rispondi',
        // New Placeholders
        'placeholder.searchHistory': 'Cerca nella cronologia...', 'placeholder.searchUsers': 'Cerca utenti...', 'placeholder.searchMyVideos': 'Cerca nei miei video...', 'placeholder.eventId': 'Inserisci ID evento (hex o nevent/note)', 'placeholder.pubkey': 'Inserisci pubkey (hex o npub)', 'placeholder.customAmount': 'Importo personalizzato', 'placeholder.chatEnded': 'Chat chiusa - diretta terminata', 'placeholder.addComment': 'Aggiungi un commento...', 'placeholder.setNewGoal': 'Imposta nuovo obiettivo (sats)',
        // New Video & Content
        'video.untitledVideo': 'Video senza titolo', 'video.untitledShort': 'Short senza titolo', 'video.upNext': 'Prossimo', 'video.noVideosYet': 'Ancora nessun video', 'video.noShortsYet': 'Ancora nessun short', 'video.noLiveStreamsYet': 'Ancora nessuna diretta', 'video.noBlockedVideos': 'Nessun video bloccato', 'video.noBlockedUsers': 'Nessun utente bloccato',
        // New Stream Messages
        'stream.ended': 'Questa diretta è terminata. La chat è ora chiusa.', 'stream.welcomeChat': 'Benvenuto nella chat dal vivo!', 'stream.goalReached': 'Obiettivo raggiunto!', 'stream.zapGoalReached': 'Obiettivo Zap raggiunto! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Messaggio da utente silenziato', 'muted.commentFromMutedUserHidden': 'Commento da utente silenziato nascosto', 'muted.commentHidden': 'Commento nascosto ({packs})', 'muted.messageHidden': 'Messaggio nascosto ({packs})', 'muted.commentReportedByFollows': 'Commento segnalato da persone che segui', 'muted.messageReportedByFollows': 'Messaggio segnalato da persone che segui', 'muted.commentHeavilyDownvoted': 'Commento molto criticato dalla comunità', 'muted.messageHeavilyDownvoted': 'Messaggio molto criticato',
        // New Admin & Lists
        'list.blockedVideos': 'Video bloccati', 'list.blockedUsers': 'Utenti bloccati',
        // New Alerts
        'alert.cameraNotSupported': 'L\'accesso alla fotocamera non è supportato in questo browser. Utilizza un browser moderno come Chrome, Firefox o Safari.', 'alert.noCameraFound': 'Nessuna fotocamera trovata. Collega una fotocamera o usa l\'opzione di caricamento file.', 'alert.cameraAccessDenied': 'Accesso alla fotocamera negato. Consenti i permessi della fotocamera nelle impostazioni del browser.', 'alert.cameraInUse': 'La fotocamera è in uso da un\'altra applicazione. Chiudi le altre app.', 'alert.cameraUnableAccess': 'Impossibile accedere alla fotocamera. Prova l\'opzione di caricamento.', 'alert.cameraUnableAccessWithError': 'Impossibile accedere alla fotocamera: {error}\n\nUsa l\'opzione di caricamento.', 'alert.fillRequiredFields': 'Compila tutti i campi obbligatori', 'alert.uploadThumbnail': 'Carica una miniatura per la tua diretta', 'alert.failedCreateStream': 'Impossibile creare la diretta. Riprova.', 'alert.failedUpdateStream': 'Aggiornamento fallito. Riprova.', 'alert.streamNotFound': 'Diretta non trovata', 'alert.canOnlyEditOwnStreams': 'Puoi modificare solo le tue dirette', 'alert.invalidStreamData': 'Dati diretta non validi', 'alert.enterValidGoalAmount': 'Inserisci un importo obiettivo valido', 'alert.canOnlyResetOwnGoals': 'Puoi reimpostare solo i tuoi obiettivi', 'alert.streamEventNotFound': 'Evento diretta non trovato', 'alert.failedResetZapGoal': 'Impossibile reimpostare l\'obiettivo Zap. Riprova.', 'alert.cannotBlockAdmin': 'Non è possibile bloccare l\'account admin', 'alert.analyticsLoadFailed': 'Impossibile caricare le statistiche. Riprova.', 'alert.cannotReplaceShortWithVideo': 'Non è possibile sostituire uno Short con un video normale. Carica un video verticale (60 secondi o meno).', 'alert.cannotReplaceVideoWithShort': 'Non è possibile sostituire un video normale con uno Short. Carica un video orizzontale.', 'alert.shortsRequireVertical': 'Questo video sembra essere orizzontale. Gli Short devono essere video verticali. Usa "Carica Video" per i video orizzontali.',
        // New Zap Messages
        'zap.cannotZapYourself': 'Non puoi inviare Zap a te stesso', 'zap.cannotZapOwnContent': 'Non puoi inviare Zap al tuo contenuto', 'zap.cannotZapOwnComment': 'Non puoi inviare Zap al tuo commento', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'Caricamento video...', 'status.loading': 'Caricamento...', 'status.compressingProgress': 'Compressione... {progress}%', 'status.uploadingProgress': 'Caricamento... {progress}%', 'status.uploadingServers': 'Caricamento... ({completed}/{total} server)', 'status.publishedSuccess': '{type} pubblicato con successo!',
        // New Warnings
        'warning.webmFormat': 'Nota: Il tuo browser produrrà formato WebM (potrebbe non funzionare su iOS). Per MP4 compatibile con iOS, usa Chrome su Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Ultimo aggiornamento: Dicembre 2024',
        // DMCA Page
        'dmca.title': 'DMCA e Politica sui Contenuti',
        'dmca.lastUpdated': 'Ultimo aggiornamento: Dicembre 2024',
        'dmca.architectureTitle': 'Comprendere l\'Architettura di Plebs',
        'dmca.architectureDesc': 'Plebs è un\'interfaccia di piattaforma video decentralizzata che opera in modo diverso dai servizi tradizionali.',
        'dmca.architectureItem1': 'Plebs non ospita alcun contenuto video o immagine.',
        'dmca.architectureItem1Desc': 'Siamo un client/interfaccia che visualizza contenuti archiviati altrove.',
        'dmca.architectureItem2': 'Tutti i file multimediali sono archiviati su server Blossom indipendenti.',
        'dmca.architectureItem3': 'I metadati video sono pubblicati sui relay Nostr.',
        'dmca.architectureItem4': 'Plebs aggrega e visualizza semplicemente questo contenuto distribuito.',
        'dmca.filingTitle': 'Presentare un Reclamo DMCA',
        'dmca.filingDesc': 'Poiché Plebs non ospita contenuti, non possiamo rimuovere direttamente materiale violativo.',
        'dmca.forVideoTitle': '1. Per Contenuti Video/Immagine',
        'dmca.forVideoDesc': 'I file multimediali sono archiviati sui server Blossom.',
        'dmca.forVideoItem1': 'Identificare quale server Blossom ospita il contenuto',
        'dmca.forVideoItem2': 'Contattare direttamente l\'operatore del server Blossom',
        'dmca.forVideoItem3': 'Ogni server Blossom opera in modo indipendente',
        'dmca.forMetadataTitle': '2. Per Metadati/Descrizioni',
        'dmca.forMetadataDesc': 'Se il contenuto violativo è nel titolo o nella descrizione:',
        'dmca.forMetadataItem1': 'Queste informazioni sono archiviate sui relay Nostr',
        'dmca.forMetadataItem2': 'Contattare gli operatori specifici dei relay Nostr',
        'dmca.forMetadataItem3': 'Più relay possono archiviare gli stessi dati',
        'dmca.whatWeCanDoTitle': 'Cosa Può Fare Plebs',
        'dmca.whatWeCanDoDesc': 'Sebbene non ospitiamo contenuti, possiamo:',
        'dmca.whatWeCanDoItem1': 'Aiutarti a identificare quali server ospitano contenuti specifici',
        'dmca.whatWeCanDoItem2': 'Aggiungere contenuti a una lista di blocco locale',
        'dmca.whatWeCanDoItem3': 'Fornire indicazioni su come contattare gli operatori appropriati',
        'dmca.toRequestAssistance': 'Per richiedere assistenza, contattaci con:',
        'dmca.assistanceItem1': 'L\'URL o l\'identificatore del contenuto violativo',
        'dmca.assistanceItem2': 'Prova della tua proprietà del copyright',
        'dmca.assistanceItem3': 'Una descrizione dell\'opera protetta',
        'dmca.blossomOperatorsTitle': 'Operatori di Server Blossom',
        'dmca.blossomOperatorsDesc': 'Se gestisci un server Blossom, sei responsabile della gestione delle richieste DMCA.',
        'dmca.blossomOperatorsLink': 'Per un elenco di server Blossom noti, consulta la documentazione.',
        'dmca.considerationsTitle': 'Considerazioni Importanti',
        'dmca.considerationsItem1': 'Decentralizzazione:',
        'dmca.considerationsItem1Desc': 'La rimozione completa del contenuto potrebbe non essere possibile.',
        'dmca.considerationsItem2': 'Copie Multiple:',
        'dmca.considerationsItem2Desc': 'Il contenuto può essere replicato su più server.',
        'dmca.considerationsItem3': 'Persistenza dei Metadati:',
        'dmca.considerationsItem3Desc': 'I metadati possono persistere anche dopo la rimozione.',
        'dmca.considerationsItem4': 'Nessun Controllo Centrale:',
        'dmca.considerationsItem4Desc': 'Nessuna entità singola può rimuovere contenuti dall\'intera rete.',
        'dmca.counterNotificationTitle': 'Contro-Notifica',
        'dmca.counterNotificationDesc': 'Se ritieni che il tuo contenuto sia stato rimosso per errore, contatta l\'operatore del server.',
        'dmca.contactTitle': 'Contatto',
        'dmca.contactDesc': 'Per domande,',
        'dmca.contactLink': 'contattaci',
        // Admin Dashboard
        'admin.title': 'Dashboard Amministratore',
        'admin.loading': 'Caricamento analisi della piattaforma...',
        'admin.platformOverview': 'Panoramica della Piattaforma',
        'admin.totalVideos': 'Video Totali',
        'admin.videos7Days': 'Video (7 giorni)',
        'admin.videos30Days': 'Video (30 giorni)',
        'admin.uniqueCreators': 'Creatori Unici',
        'admin.likes30Days': 'Mi Piace (30 giorni)',
        'admin.dislikes30Days': 'Non Mi Piace (30 giorni)',
        'admin.monthlyActiveUsers': 'Utenti Attivi Mensili',
        'admin.mauDesc': 'Utenti unici che hanno caricato video, reagito o commentato (ultimi 6 mesi)',
        'admin.boostRevenue': 'Entrate da Boost (Ultimi 30 Giorni)',
        'admin.totalBoostRevenue': 'Entrate Totali da Boost',
        'admin.totalBoosts': 'Boost Totali',
        'admin.blocklistManagement': 'Gestione Lista di Blocco',
        'admin.blocklistDesc': 'Blocca video o utenti specifici.',
        'admin.blockedVideos': 'Video Bloccati',
        'admin.blockedUsers': 'Utenti Bloccati',
        'admin.blockByEventId': 'Blocca Video per ID',
        'admin.blockByPubkey': 'Blocca Utente per Pubkey',
        'admin.blockVideo': 'Blocca Video',
        'admin.blockUser': 'Blocca Utente',
        'admin.noBlockedVideos': 'Nessun video bloccato',
        'admin.noBlockedUsers': 'Nessun utente bloccato',
        'admin.unblock': 'Sblocca',
        'admin.accessDenied': 'Accesso negato. Solo amministratore.',
        // Search/Trending/Channel/Buttons/Common
        'search.noVideosFound': 'Nessun video trovato per "{query}".',
        'search.noFullLengthVideos': 'Nessun video completo trovato per "{query}".',
        'trending.noVideosToday': 'Nessun video di tendenza oggi.',
        'trending.noVideosThisWeek': 'Nessun video di tendenza questa settimana.',
        'channel.video': 'video',
        'channel.videos': 'video',
        'channel.follower': 'follower',
        'channel.followers': 'follower',
        'button.follow': 'Segui',
        'button.following': 'Seguito',
        'button.unfollow': 'Smetti di seguire',
        'button.mute': 'Silenzia',
        'button.unmute': 'Riattiva audio',
        'button.report': 'Segnala',
        'button.muteUser': 'Silenzia utente',
        'button.unmuteUser': 'Riattiva audio utente',
        'button.reportComment': 'Segnala commento',
        'button.reportUser': 'Segnala questo utente',
        'live.goalReached': 'Obiettivo Raggiunto!',
        'live.goalProgress': '{percent}% dell\'obiettivo',
        'common.loading': 'Caricamento...',
        'common.sats': 'sats',

        // Analytics
        'analytics.title': 'Analisi del Canale',
        'analytics.description': 'Visualizza le metriche di performance e gli insight del tuo canale.',
        'analytics.loading': 'Caricamento analisi...',
        'analytics.error': 'Impossibile caricare le analisi',
        'analytics.overview': 'Panoramica',
        'analytics.videos': 'Video',
        'analytics.engagement': 'Coinvolgimento',
        'analytics.totalViews': 'Visualizzazioni totali',
        'analytics.totalVideos': 'Video totali',
        'analytics.totalLikes': 'Mi piace totali',
        'analytics.totalZaps': 'Zaps totali',
        'analytics.avgViews': 'Media visualizzazioni',
        'analytics.avgLikes': 'Media mi piace',
        'analytics.avgZaps': 'Media Zaps',
        'analytics.viewsOverTime': 'Visualizzazioni nel tempo',
        'analytics.topVideos': 'Video più popolari',
        'analytics.recentActivity': 'Attività recente',
        'analytics.viewsLabel': 'Visualizzazioni',
        'analytics.likesLabel': 'Mi piace',
        'analytics.zapsLabel': 'Zaps',
        'analytics.dateLabel': 'Data',
        'analytics.videoTitle': 'Titolo video',
        'analytics.performance': 'Performance',
        'analytics.noData': 'Nessun dato analitico',
        'analytics.noDataDesc': 'Inizia a caricare video per vedere le tue analisi.',
        'analytics.last7Days': 'Ultimi 7 giorni',
        'analytics.last30Days': 'Ultimi 30 giorni',
        'analytics.last90Days': 'Ultimi 90 giorni',
        'analytics.allTime': 'Tutto il tempo',
        'analytics.views': 'Visualizzazioni',
        'analytics.likes': 'Mi piace',
        'analytics.zaps': 'Zaps',
        'analytics.rank': 'Posizione',
        'analytics.noVideos': 'Nessun video',
        'analytics.noVideosDesc': 'Carica il tuo primo video per iniziare a monitorare le performance.',

        // About Page
        'about.title': 'Informazioni su Plebs.place',
        'about.subtitle': 'Piattaforma video decentralizzata',
        'about.welcome': 'Benvenuto su Plebs.place',
        'about.description': 'Plebs.place è una piattaforma di condivisione video decentralizzata costruita sul protocollo Nostr, che offre ai creatori il pieno controllo sui propri contenuti e sul proprio pubblico.',
        'about.feature1Title': 'Decentralizzato',
        'about.feature1Desc': 'Costruito su Nostr, garantisce resistenza alla censura e vera proprietà dei contenuti.',
        'about.feature2Title': 'Prima i creatori',
        'about.feature2Desc': 'Mantieni il pieno controllo sui tuoi contenuti, dati e relazione con il pubblico.',
        'about.feature3Title': 'Monetizzazione Bitcoin',
        'about.feature3Desc': 'Ricevi supporto direttamente dagli spettatori tramite Lightning Network e Zaps.',
        'about.feature4Title': 'Open Source',
        'about.feature4Desc': 'Sviluppo trasparente e guidato dalla comunità, in linea con lo spirito della decentralizzazione.',
        'about.missionTitle': 'La nostra missione',
        'about.missionDesc': 'Creare una piattaforma video libera da censura, lock-in e cambiamenti arbitrari delle regole. I tuoi contenuti sono tuoi.',
        'about.techTitle': 'Tecnologia',
        'about.techDesc': 'Costruito con Nostr per identità e funzionalità social, Lightning per micropagamenti istantanei e soluzioni di storage decentralizzate.',

        // Contact Page
        'contact.title': 'Contattaci',
        'contact.subtitle': 'Resta in contatto',
        'contact.description': 'Hai domande, feedback o suggerimenti? Saremo felici di sentirti.',
        'contact.nostrTitle': 'Seguici su Nostr',
        'contact.nostrDesc': 'Seguici su Nostr per aggiornamenti e discussioni della comunità.',
        'contact.githubTitle': 'GitHub',
        'contact.githubDesc': 'Visualizza il codice sorgente, segnala problemi o contribuisci al progetto.',
        'contact.emailTitle': 'Email',
        'contact.emailDesc': 'Per richieste commerciali o domande di supporto, contatta il nostro team.',

        // Terms Page
        'terms.title': 'Termini di Servizio',
        'terms.lastUpdated': 'Ultimo aggiornamento',
        'terms.section1Title': '1. Accettazione dei termini',
        'terms.section1Content': 'Utilizzando Plebs.place, accetti di essere vincolato da questi termini. Se non sei d\'accordo, ti preghiamo di non utilizzare la piattaforma.',
        'terms.section2Title': '2. Descrizione del servizio',
        'terms.section2Content': 'Plebs.place è una piattaforma di condivisione video decentralizzata che utilizza il protocollo Nostr. Forniamo strumenti per hosting video, condivisione e monetizzazione tramite Lightning.',
        'terms.section3Title': '3. Responsabilità dell\'utente',
        'terms.section3Content': 'Sei responsabile di tutti i contenuti che pubblichi attraverso la piattaforma. Accetti di non caricare contenuti illegali, dannosi o che violano i diritti altrui.',
        'terms.section4Title': '4. Proprietà dei contenuti',
        'terms.section4Content': 'Mantieni la piena proprietà dei tuoi contenuti. Caricando, concedi a Plebs.place una licenza limitata per ospitare e fornire i tuoi video.',
        'terms.section5Title': '5. Uso vietato',
        'terms.section5Content': 'Non puoi utilizzare la piattaforma per attività illegali, molestie, spam o distribuzione di contenuti dannosi.',
        'terms.section6Title': '6. Gestione dell\'account',
        'terms.section6Content': 'Sei responsabile della sicurezza del tuo account gestendo correttamente le tue chiavi Nostr. Non conserviamo la tua chiave privata e non possiamo recuperare account persi.',
        'terms.section7Title': '7. Termini di pagamento',
        'terms.section7Content': 'Tutti i pagamenti sono elaborati tramite Lightning Network. Le transazioni sono definitive e irreversibili. Verifica tutti i dettagli di pagamento prima delle transazioni.',
        'terms.section8Title': '8. Limitazione di responsabilità',
        'terms.section8Content': 'Plebs.place è fornito "così com\'è" senza garanzie. Non siamo responsabili per perdite, danni o interruzioni del servizio.',
        'terms.section9Title': '9. Modifiche ai termini',
        'terms.section9Content': 'Questi termini possono essere aggiornati periodicamente. L\'uso continuato indica l\'accettazione dei termini aggiornati.',

        // Privacy Page
        'privacy.title': 'Informativa sulla Privacy',
        'privacy.lastUpdated': 'Ultimo aggiornamento',
        'privacy.section1Title': '1. Introduzione',
        'privacy.section1Content': 'Questa informativa sulla privacy spiega come Plebs.place gestisce le informazioni relative al tuo utilizzo della nostra piattaforma video decentralizzata.',
        'privacy.section2Title': '2. Informazioni che raccogliamo',
        'privacy.section2Content': 'Come piattaforma decentralizzata, raccogliamo dati minimi. La tua chiave pubblica Nostr è usata per l\'autenticazione e i metadati video sono memorizzati sui relay Nostr.',
        'privacy.section3Title': '3. Archiviazione dei dati',
        'privacy.section3Content': 'I tuoi contenuti sono memorizzati su soluzioni di storage decentralizzate. Non memorizziamo dati personali su server centralizzati. La tua chiave privata non viene mai condivisa con noi.',
        'privacy.section4Title': '4. Utilizzo dei dati',
        'privacy.section4Content': 'Tutti i dati che raccogliamo sono utilizzati esclusivamente per fornire e migliorare i servizi della piattaforma. Non vendiamo mai i tuoi dati a terzi.',
        'privacy.section5Title': '5. Cookie e tracciamento',
        'privacy.section5Content': 'Utilizziamo cookie minimi per le funzionalità di base. Non effettuiamo tracciamento pubblicitario né raccogliamo dati per scopi di marketing.',
        'privacy.section6Title': '6. Servizi di terze parti',
        'privacy.section6Content': 'Ci integriamo con relay Nostr e nodi Lightning Network. Questi servizi hanno le proprie informative sulla privacy.',
        'privacy.section7Title': '7. Sicurezza dei dati',
        'privacy.section7Content': 'Proteggiamo le tue informazioni attraverso la nostra architettura decentralizzata. Tuttavia, sei responsabile della protezione della tua chiave privata.',
        'privacy.section8Title': '8. I tuoi diritti',
        'privacy.section8Content': 'Hai il pieno controllo sui tuoi dati. Puoi eliminare i tuoi contenuti o smettere di usare la piattaforma in qualsiasi momento.',
        'privacy.section9Title': '9. Privacy dei minori',
        'privacy.section9Content': 'Plebs.place non è destinato ai minori di 13 anni. Non raccogliamo intenzionalmente informazioni da minori.',
        'privacy.section10Title': '10. Modifiche all\'informativa',
        'privacy.section10Content': 'Potremmo aggiornare questa informativa sulla privacy. Le modifiche saranno pubblicate su questa pagina con la data di aggiornamento.',

        // FAQ Page
        'faq.title': 'Domande Frequenti',
        'faq.subtitle': 'Domande e risposte comuni',
        'faq.general': 'Generale',
        'faq.technical': 'Tecnico',
        'faq.monetization': 'Monetizzazione',
        'faq.content': 'Contenuti',
        'faq.q1': 'Cos\'è Plebs.place?',
        'faq.a1': 'Plebs.place è una piattaforma di condivisione video decentralizzata costruita sul protocollo Nostr, che ti offre la piena proprietà dei tuoi contenuti e del tuo pubblico.',
        'faq.q2': 'Come funziona Plebs.place?',
        'faq.a2': 'La piattaforma utilizza Nostr per autenticazione e social, storage decentralizzato per hosting video e Lightning Network per pagamenti istantanei.',
        'faq.q3': 'Plebs.place è gratuito?',
        'faq.a3': 'Sì, creare un account, caricare e guardare video è gratuito. Hai solo bisogno di una chiave Nostr per iniziare.',
        'faq.q4': 'Cos\'è Nostr?',
        'faq.a4': 'Nostr è un protocollo di comunicazione decentralizzato che ti permette di controllare la tua identità e i tuoi dati senza dipendere da piattaforme centralizzate.',
        'faq.q5': 'Come creo un account?',
        'faq.a5': 'Puoi accedere con un\'estensione browser Nostr come Alby o nos2x, oppure generare una nuova chiave Nostr.',
        'faq.q6': 'Quali formati video sono supportati?',
        'faq.a6': 'Supportiamo la maggior parte dei formati comuni tra cui MP4, WebM e MOV. I video vengono transcodificati dopo il caricamento.',
        'faq.q7': 'Dove sono memorizzati i miei video?',
        'faq.a7': 'I video sono memorizzati su soluzioni di storage decentralizzate, garantendo che i tuoi contenuti non siano controllati da un singolo server.',
        'faq.q8': 'Cos\'è Lightning Network?',
        'faq.a8': 'Lightning Network è un protocollo di pagamento di secondo livello per Bitcoin che permette transazioni istantanee e a basso costo.',
        'faq.q9': 'Cosa sono gli Zaps?',
        'faq.a9': 'Gli Zaps sono micropagamenti in Bitcoin inviati tramite Lightning Network per supportare i creatori.',
        'faq.q10': 'Come posso monetizzare i miei contenuti?',
        'faq.a10': 'I creatori possono guadagnare attraverso Zaps degli spettatori, contenuti a pagamento e donazioni dirette tramite Lightning.',
        'faq.q11': 'Come prelevo i miei guadagni?',
        'faq.a11': 'I guadagni arrivano direttamente nel tuo wallet Lightning. Non ci sono minimi di prelievo o periodi di attesa.',
        'faq.q12': 'Quali contenuti sono consentiti?',
        'faq.a12': 'I contenuti legali sono benvenuti. Si prega di seguire i nostri termini di servizio ed evitare materiale dannoso o illegale.',
        'faq.q13': 'Posso eliminare i miei video?',
        'faq.a13': 'Sì, puoi eliminare i video in qualsiasi momento. A causa della natura decentralizzata, le copie già distribuite potrebbero rimanere su altri nodi.',
        'faq.q14': 'C\'è moderazione dei contenuti?',
        'faq.a14': 'Come piattaforma decentralizzata, la moderazione avviene attraverso approcci guidati dalla comunità e controlli degli utenti.',
        'faq.q15': 'Come segnalo contenuti problematici?',
        'faq.a15': 'Usa la funzione di segnalazione sui video o contattaci attraverso le nostre informazioni di contatto. Il feedback della comunità aiuta a mantenere la qualità della piattaforma.',
        // FAQ Self-Moderation Section
        'faq.selfModeration': 'Auto-moderazione',
        'faq.q16': 'Come funziona la moderazione su una piattaforma decentralizzata?',
        'faq.a16': 'A differenza delle piattaforme tradizionali con moderatori centralizzati, Plebs ti mette in controllo di ciò che vedi. Forniamo potenti strumenti di auto-moderazione tra cui pacchetti di filtri per contenuti, silenziamento utenti, avvisi della comunità e indicatori di video "ratioed". Tu decidi quale contenuto è appropriato per te - non c\'è un\'autorità centrale che prende queste decisioni.',
        'faq.q17': 'Cosa sono i Pacchetti di Filtri per Contenuti?',

        // Page Titles
        'pageTitle.following': 'Seguiti',
        'pageTitle.myVideos': 'I Miei Video',
        'pageTitle.likedVideos': 'Video Piaciuti',
        'pageTitle.watchHistory': 'Cronologia Visualizzazioni',
        'pageTitle.liveStreams': 'Live Stream',
        'pageTitle.suffix': '- Plebs',
        'pageTitle.liveSuffix': '- Live su Plebs',
        // Home Page Sections
        'section.trending': 'Di Tendenza',
        'section.recommended': 'Consigliati per Te',
        'section.shorts': 'Shorts',
        'section.live': 'Live',
        'section.liveNow': 'In Diretta Ora',
        'section.latestVideos': 'Video Recenti',
        'section.videos': 'Video',
        'section.usersYouFollow': 'Utenti che Segui',
        // Trending Period
        'trending.thisWeek': 'Questa Settimana',
        'trending.today': 'Oggi',
        // Buttons
        'button.viewMore': 'Mostra Altro',
        'button.clearAll': 'Cancella Tutto',
        'button.showAnyway': 'Mostra comunque',
        // Confirmation Modals
        'confirm.logout': 'Esci',
        'confirm.logoutMessage': 'Sei sicuro di voler uscire?',
        'confirm.resetSettings': 'Ripristina Impostazioni',
        'confirm.resetSettingsMessage': 'Sei sicuro di voler ripristinare tutte le impostazioni ai valori predefiniti?',
        'confirm.reset': 'Ripristina',
        'confirm.clearHistory': 'Cancella Cronologia',
        'confirm.clearHistoryMessage': 'Sei sicuro di voler cancellare l\'intera cronologia visualizzazioni? Questa azione non può essere annullata.',
        'confirm.deleteDraft': 'Elimina Bozza',
        'confirm.deleteDraftMessage': 'Sei sicuro di voler eliminare questa bozza?',
        'confirm.delete': 'Elimina',
        'confirm.deleteVideo': 'Elimina Video',
        'confirm.deleteVideoMessage': 'Sei sicuro di voler eliminare questo video? Questa azione non può essere annullata.',
        'confirm.endStream': 'Termina Live Stream',
        'confirm.endStreamMessage': 'Sei sicuro di voler terminare questo live stream? Questa azione non può essere annullata.',
        'confirm.endStreamButton': 'Termina Stream',
        // Content Filters
        'filter.hiddenByPack': 'Nascosto da {pack}',
        'filter.showAnyway': 'Mostra comunque',
        'filter.contentHidden': 'Contenuto nascosto dal filtro contenuti',
        // Filter Packs
        'filter.racism': 'Razzismo e Incitamento all\'Odio', 'filter.racismDesc': 'Filtra insulti razziali, incitamento all\'odio etnico e contenuti discriminatori', 'filter.sexualExplicit': 'Sessualmente Esplicito', 'filter.sexualExplicitDesc': 'Filtra termini pornografici e contenuti sessualmente espliciti', 'filter.violence': 'Violenza e Gore', 'filter.violenceDesc': 'Filtra violenza grafica, gore e minacce violente', 'filter.drugs': 'Droghe e Sostanze', 'filter.drugsDesc': 'Filtra contenuti relativi alle droghe e abuso di sostanze', 'filter.spam': 'Spam e Truffe', 'filter.spamDesc': 'Filtra spam comune, truffe e contenuti promozionali', 'filter.crypto': 'Criptovalute', 'filter.cryptoDesc': 'Filtra promozione di criptovalute, segnali di trading e promozione di token', 'filter.politics': 'Contenuto Politico', 'filter.politicsDesc': 'Filtra contenuti politici di parte e retorica divisiva', 'filter.profanity': 'Parolacce Forti', 'filter.profanityDesc': 'Filtra parolacce forti e linguaggio volgare', 'filter.customFilter': 'Filtro Personalizzato',
        // Following Page
        'following.noFollowingYet': 'Non segui ancora nessuno. Trova i creatori da seguire!',
        'faq.a17Intro': 'I Pacchetti di Filtri per Contenuti sono filtri di parole chiave predefiniti che puoi abilitare per nascondere specifici tipi di contenuto. I pacchetti disponibili includono:',
        'faq.a17Pack1': 'Razzismo e Incitamento all\'Odio:',
        'faq.a17Pack1Desc': 'Filtra insulti razziali e contenuti discriminatori',
        'faq.a17Pack2': 'Contenuti Sessualmente Espliciti:',
        'faq.a17Pack2Desc': 'Filtra contenuti pornografici e per adulti',
        'faq.a17Pack3': 'Violenza e Gore:',
        'faq.a17Pack3Desc': 'Filtra violenza grafica e contenuti di autolesionismo',
        'faq.a17Pack4': 'Droghe e Sostanze:',
        'faq.a17Pack4Desc': 'Filtra contenuti relativi alle droghe',
        'faq.a17Pack5': 'Spam e Truffe:',
        'faq.a17Pack5Desc': 'Filtra pattern comuni di spam e truffe',
        'faq.a17Pack6': 'Criptovalute:',
        'faq.a17Pack6Desc': 'Filtra promozione crypto e shilling di token',
        'faq.a17Pack7': 'Contenuti Politici:',
        'faq.a17Pack7Desc': 'Filtra contenuti politici di parte',
        'faq.a17Pack8': 'Linguaggio Volgare:',
        'faq.a17Pack8Desc': 'Filtra linguaggio volgare',
        'faq.a17Note': 'Abilita questi in Impostazioni > Filtri Contenuti. Puoi anche aggiungere parole chiave personalizzate. I contenuti filtrati mostrano un segnaposto con un pulsante "Mostra comunque" se vuoi visualizzarlo temporaneamente.',
        'faq.q18': 'Come silenziare un utente?',
        'faq.a18': 'Per silenziare un utente, visita il suo profilo e clicca il pulsante silenzia. Una volta silenziato, tutti i suoi video saranno nascosti dal tuo feed, i loro commenti appariranno come "Messaggio da utente silenziato" e i loro messaggi nella chat live saranno nascosti. La tua lista silenziati è archiviata su Nostr, quindi si sincronizza tra i dispositivi. Puoi gestire gli utenti silenziati nelle Impostazioni Profilo sotto "Utenti Silenziati".',
        'faq.q19': 'Cosa significa "Ratioed"?',
        'faq.a19': 'Un video è contrassegnato come "ratioed" quando ha significativamente più dislike che like, indicando una ricezione negativa dalla comunità. Specificamente, un video è ratioed quando ha almeno 10 reazioni, i dislike sono almeno il doppio dei like e i dislike costituiscono il 70% o più delle reazioni totali. I video ratioed mostrano un badge di avviso e ti verrà chiesto di confermare prima di visualizzare.',
        'faq.q20': 'Come funzionano gli avvisi della comunità?',
        'faq.a20': 'Gli utenti possono segnalare contenuti per varie ragioni (spam, contenuti illegali, abusi, fuorvianti, ecc.). Quando un video o un utente riceve 5 o più segnalazioni da persone che segui, appare un indicatore di avviso. Questo sfrutta il tuo grafo sociale - gli avvisi provengono dalla tua rete fidata, non da sconosciuti anonimi. Puoi attivare "Mostra avvisi da account che seguo" nelle Impostazioni.',
        'faq.q21': 'Come segnalare contenuti?',
        'faq.a21': 'Clicca l\'icona della bandiera su qualsiasi video, commento o profilo utente per segnalarlo. Seleziona una ragione (Spam, Illegale, Abuso, Fuorviante, Impersonificazione, Copyright, o Altro) e opzionalmente aggiungi dettagli. Le segnalazioni sono pubblicate su Nostr come eventi, rendendole trasparenti e decentralizzate. Le tue segnalazioni aiutano altri nella tua rete a identificare contenuti problematici.',
        // FAQ Privacy & Security Section
        'faq.privacySecurity': 'Privacy e Sicurezza',
        'faq.q22': 'La mia attività è privata?',
        'faq.a22': 'Su Nostr, la maggior parte dell\'attività è pubblica per design. I tuoi like, commenti, follow e zap sono visibili sulla rete pubblica. Tuttavia, Plebs memorizza la tua cronologia di visualizzazione localmente nel tuo browser - non viene mai inviata a nessun server. Puoi cancellare i tuoi dati locali in qualsiasi momento.',
        'faq.q23': 'Come mantenere sicuro il mio account?',
        'faq.a23': 'Non condividere mai la tua chiave privata (nsec) con nessuno. Raccomandiamo fortemente di usare un\'estensione browser Nostr come Alby, nos2x, o un hardware signer. Questi mantengono la tua chiave privata sicura e firmano solo gli eventi quando li approvi. Evita di memorizzare il tuo nsec direttamente nei siti web.',
        'faq.q24': 'Posso eliminare i miei contenuti?',
        'faq.a24': 'Puoi richiedere l\'eliminazione pubblicando un evento di cancellazione su Nostr. La maggior parte dei relay e client ben comportati lo rispetteranno. Tuttavia, a causa della natura decentralizzata della rete, i contenuti potrebbero persistere su alcuni relay o server Blossom. Non c\'è un\'autorità centrale che possa forzare l\'eliminazione completa su tutta la rete.',
        // FAQ Troubleshooting Section
        'faq.troubleshooting': 'Risoluzione Problemi',
        'faq.q25': 'I video non si caricano - cosa devo fare?',
        'faq.a25Intro': 'Se i video non si caricano, prova questi passaggi:',
        'faq.a25Item1': 'Aggiorna la pagina',
        'faq.a25Item2': 'Controlla la tua connessione internet',
        'faq.a25Item3': 'Il server Blossom che ospita il video potrebbe essere offline - questo è indipendente da Plebs',
        'faq.a25Item4': 'Prova a disabilitare le estensioni del browser che potrebbero bloccare i contenuti',
        'faq.a25Item5': 'Cancella la cache del browser e riprova',
        'faq.q26': 'Ho perso la mia chiave privata - puoi aiutarmi a recuperarla?',
        'faq.a26': 'Sfortunatamente no. Le chiavi Nostr sono crittografiche - non c\'è reset della password o recupero dell\'account perché non c\'è un\'autorità centrale. Questo è il motivo per cui raccomandiamo fortemente di fare il backup delle tue chiavi e usare una soluzione di gestione chiavi sicura. Se perdi il tuo nsec, dovrai creare una nuova identità.',
        'faq.q27': 'Come segnalare un bug o richiedere una funzionalità?',
        'faq.a27': 'Puoi segnalare bug o richiedere funzionalità sulla nostra pagina <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a>. Puoi anche contattarci su Nostr - visita la nostra pagina <a href="#/contact">Contatti</a> per i dettagli.',
    }
};

// Get translation for a key
function t(key, params = {}) {
    let text = translations[currentLanguage]?.[key] || translations.en[key] || key;
    Object.keys(params).forEach(param => {
        text = text.replace(new RegExp(`\\{${param}\\}`, 'g'), params[param]);
    });
    return text;
}

// Detect browser language and return best match
function detectBrowserLanguage() {
    const browserLang = navigator.language || navigator.userLanguage || 'en';
    const langCode = browserLang.split('-')[0].toLowerCase();
    return SUPPORTED_LANGUAGES[langCode] ? langCode : 'en';
}

// Initialize language from storage or browser
function initializeLanguage() {
    const savedLang = localStorage.getItem('plebsLanguage');
    if (savedLang && SUPPORTED_LANGUAGES[savedLang]) {
        currentLanguage = savedLang;
    } else {
        currentLanguage = detectBrowserLanguage();
        localStorage.setItem('plebsLanguage', currentLanguage);
    }
    document.documentElement.setAttribute('lang', currentLanguage);
    document.documentElement.setAttribute('dir', currentLanguage === 'ar' ? 'rtl' : 'ltr');
}

// Change language and update UI
function changeLanguage(langCode) {
    if (!SUPPORTED_LANGUAGES[langCode]) return;
    currentLanguage = langCode;
    localStorage.setItem('plebsLanguage', langCode);
    document.documentElement.setAttribute('lang', langCode);
    document.documentElement.setAttribute('dir', langCode === 'ar' ? 'rtl' : 'ltr');
    if (typeof userSettings !== 'undefined') {
        userSettings.language = langCode;
    }
    applyTranslations();
    const langSelect = document.getElementById('languageSelect');
    if (langSelect) langSelect.value = langCode;
}

// Apply translations to all elements with data-i18n attribute
function applyTranslations() {
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        el.textContent = t(key);
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        el.placeholder = t(key);
    });
    document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const key = el.getAttribute('data-i18n-title');
        el.title = t(key);
    });
    document.querySelectorAll('[data-i18n-html]').forEach(el => {
        const key = el.getAttribute('data-i18n-html');
        el.innerHTML = t(key);
    });
    document.querySelectorAll('[data-i18n-aria-label]').forEach(el => {
        const key = el.getAttribute('data-i18n-aria-label');
        el.setAttribute('aria-label', t(key));
    });
}

// Generate language selector HTML options
function generateLanguageSelector() {
    let options = '';
    Object.entries(SUPPORTED_LANGUAGES).forEach(([code, name]) => {
        options += `<option value="${code}" ${code === currentLanguage ? 'selected' : ''}>${name}</option>`;
    });
    return options;
}

// ===== END i18n SYSTEM =====

// Global state
let currentUser = null;
let loginCheckPromise = null; // Promise that resolves when initial login check is complete
let relayConnections = {};
let currentView = 'home';
let uploadedVideoHash = null;

// Upload state tracking for immediate uploads
const uploadState = {
    video: {
        file: null,
        status: 'pending', // pending, compressing, uploading, complete, error
        progress: 0,
        url: null,
        hash: null,
        error: null,
        size: 0,
        type: null,
        duration: null,
        dimensions: null,
        mirrors: [] // All successful blossom upload URLs for NIP-71 fallbacks
    },
    thumbnail: {
        file: null,
        status: 'pending', // pending, uploading, complete, error
        progress: 0,
        url: null,
        error: null
    },
    preview: {
        file: null,
        status: 'pending', // pending, generating, uploading, complete, error
        progress: 0,
        url: null,
        error: null
    },
    draftId: null // Track if this is an existing draft being edited
};

// Next video auto-play state
let nextVideoData = null;
let autoPlayCountdownTimer = null;
const AUTO_PLAY_COUNTDOWN_SECONDS = 5;

let allEvents = new Map();
let profileCache = new Map();
let reactionsCache = new Map();
let nip05ValidationCache = new Map();
let imageValidationCache = new Map();
// Cache profile validation results per pubkey: { isSuspicious: boolean, avatarValid: boolean, nip05Valid: boolean }
let profileValidationCache = new Map();
let pendingNSFWAction = null;
let pendingRatioedAction = null;
let sessionNSFWAllowed = false;
let sessionRatioedAllowed = new Set();
let currentTrendingPeriod = 'week';
let isInitializingSettings = false;
let boostsCache = new Map();

// Image asset cache for thumbnails and preview GIFs
// Stores loaded images as blob URLs to avoid refetching when same video appears in multiple grids
// Structure: Map<url, { blobUrl: string, size: number, lastAccessed: number }>
const imageAssetCache = new Map();
const IMAGE_CACHE_MAX_SIZE = 100 * 1024 * 1024; // 100MB max cache size
const IMAGE_CACHE_MAX_ENTRIES = 500; // Max number of cached images
let imageCacheTotalSize = 0;
// Track URLs that failed due to CORS - don't retry fetching these
const corsFailedUrls = new Set();

// Mute list cache (NIP-51 kind 10000)
let mutedUsersCache = new Set();
let muteListLoaded = false;
// Session-based "temporarily show" for muted user content
let sessionUnhiddenMutedUsers = new Set();

// User's follows cache (kind 3) - Set of pubkeys user follows
let userFollowsCache = new Set();
let userFollowsLoaded = false;

// Reports cache (NIP-56 kind 1984) - Maps event/pubkey to Set of reporter pubkeys
// Structure: { eventReports: Map<eventId, Set<reporterPubkey>>, pubkeyReports: Map<pubkey, Set<reporterPubkey>> }
let reportsCache = {
    eventReports: new Map(),
    pubkeyReports: new Map(),
    loadedEvents: new Set(),
    loadedPubkeys: new Set()
};

// Admin configuration
const ADMIN_PUBKEY = 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df';
const ADMIN_BLOCKLIST_KIND = 30000; // NIP-51 parameterized replaceable list
const ADMIN_BLOCKLIST_D_TAG = 'plebs-blocklist';

// Admin blocklist cache (fetched from Nostr, cached in localStorage)
let adminBlocklist = {
    events: new Set(),    // Blocked event IDs (videos)
    pubkeys: new Set()    // Blocked user pubkeys
};
const ADMIN_BLOCKLIST_CACHE_KEY = 'plebsAdminBlocklistCache';
let adminBlocklistLoaded = false;

// Check if current user is admin
function isAdmin() {
    return currentUser && currentUser.pubkey === ADMIN_PUBKEY;
}

// Load admin blocklist - first from cache, then fetch from Nostr
function loadAdminBlocklist() {
    // Load from localStorage cache first for immediate availability
    try {
        const cached = localStorage.getItem(ADMIN_BLOCKLIST_CACHE_KEY);
        if (cached) {
            const data = JSON.parse(cached);
            adminBlocklist.events = new Set(data.events || []);
            adminBlocklist.pubkeys = new Set(data.pubkeys || []);
        }
    } catch (e) {
        console.error('Failed to load blocklist cache:', e);
    }

    // Then fetch latest from Nostr (non-blocking)
    fetchAdminBlocklistFromNostr();
}

// Fetch admin blocklist from Nostr relays
async function fetchAdminBlocklistFromNostr() {
    try {
        const filter = {
            kinds: [ADMIN_BLOCKLIST_KIND],
            authors: [ADMIN_PUBKEY],
            '#d': [ADMIN_BLOCKLIST_D_TAG],
            limit: 1
        };

        let blocklistEvent = null;
        await requestEventsStream(
            filter,
            event => {
                // Keep the most recent event
                if (!blocklistEvent || event.created_at > blocklistEvent.created_at) {
                    blocklistEvent = event;
                }
            },
            { timeout: 10000 }
        );

        if (blocklistEvent) {
            // Parse blocked events and pubkeys from tags
            const blockedEvents = new Set();
            const blockedPubkeys = new Set();

            for (const tag of blocklistEvent.tags) {
                if (tag[0] === 'e' && tag[1]) {
                    blockedEvents.add(tag[1].toLowerCase());
                } else if (tag[0] === 'p' && tag[1]) {
                    blockedPubkeys.add(tag[1].toLowerCase());
                }
            }

            adminBlocklist.events = blockedEvents;
            adminBlocklist.pubkeys = blockedPubkeys;

            // Update localStorage cache
            saveAdminBlocklistCache();
        }

        adminBlocklistLoaded = true;
    } catch (e) {
        console.error('Failed to fetch admin blocklist from Nostr:', e);
        adminBlocklistLoaded = true; // Mark as loaded even on error to not block app
    }
}

// Save blocklist to localStorage cache (for faster startup)
function saveAdminBlocklistCache() {
    try {
        const data = {
            events: Array.from(adminBlocklist.events),
            pubkeys: Array.from(adminBlocklist.pubkeys)
        };
        localStorage.setItem(ADMIN_BLOCKLIST_CACHE_KEY, JSON.stringify(data));
    } catch (e) {
        console.error('Failed to save blocklist cache:', e);
    }
}

// Publish admin blocklist to Nostr (admin only)
async function publishAdminBlocklist() {
    if (!isAdmin()) {
        console.error('Only admin can publish blocklist');
        return false;
    }

    try {
        // Build tags array
        const tags = [
            ['d', ADMIN_BLOCKLIST_D_TAG]
        ];

        // Add blocked events
        for (const eventId of adminBlocklist.events) {
            tags.push(['e', eventId]);
        }

        // Add blocked pubkeys
        for (const pubkey of adminBlocklist.pubkeys) {
            tags.push(['p', pubkey]);
        }

        // Create the event
        const event = {
            kind: ADMIN_BLOCKLIST_KIND,
            created_at: Math.floor(Date.now() / 1000),
            tags: tags,
            content: '' // Content is empty, data is in tags
        };

        // Sign the event
        const signedEvent = await signEvent(event);
        if (!signedEvent) {
            throw new Error('Failed to sign blocklist event');
        }

        // Publish to relays
        const published = await publishEvent(signedEvent);
        if (!published) {
            throw new Error('Failed to publish to any relay');
        }

        // Update local cache
        saveAdminBlocklistCache();

        return true;
    } catch (e) {
        console.error('Failed to publish admin blocklist:', e);
        return false;
    }
}

// Check if content is blocked by admin
function isBlockedByAdmin(eventId, pubkey) {
    return adminBlocklist.events.has(eventId) || adminBlocklist.pubkeys.has(pubkey);
}

// Check if a pubkey is blocked (for action restrictions)
function isPubkeyBlocked(pubkey) {
    return adminBlocklist.pubkeys.has(pubkey);
}

// Comments state for sorting
let currentCommentsState = {
    comments: [],
    eventIds: [],
    reactions: new Map(),
    zaps: new Map(),
    sortBy: 'newest'
};

// Track pubkeys currently being loaded to avoid duplicate requests
const pendingProfileLoads = new Set();

// Author stats cache (video count, follower count) with expiry
const authorStatsCache = new Map();
const AUTHOR_STATS_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

// NIP-46 connection state
let nip46Connection = null;
let nip46Secret = null;

// Local storage keys
const STORAGE_KEYS = {
    privateKey: 'plebsPrivateKey',
    publicKey: 'plebsPublicKey',
    profile: 'plebsProfile',
    loginMethod: 'plebsLoginMethod',
    relays: 'plebsRelays',
    bunkerURL: 'plebsBunkerURL',
    nip46Secret: 'plebsNip46Secret',
    lastNotificationView: 'plebsLastNotificationView'
};

// Blossom servers
const BLOSSOM_SERVERS = [
    'https://blossom.primal.net',
    'https://blossom.band',
    'https://24242.io',
    'https://nostr.media'
];

// Premium Blossom server
const PREMIUM_BLOSSOM_SERVER = 'https://nostrmedia.com';

// Default relay URLs
const RELAY_URLS = [
    'wss://relay.damus.io',
    'wss://relay.coinos.io',
    'wss://nos.lol',
    'wss://relay.primal.net'
];

// WoT relay URLs
const WOT_RELAY_URLS = [
    'wss://wot.utxo.one',
    'wss://nostrelites.org',
    'wss://wot.nostr.party',
    'wss://wot.nostr.net'
];

// Additional relay for publishing only
const PUBLISH_ONLY_RELAYS = [
    'wss://sendit.nosflare.com'
];

// NIP-71 Video Event Kinds (Addressable/Parameterized Replaceable)
// Using kinds 34235/34236 for addressable events that can be updated
const NIP71_VIDEO_KIND = 34235;   // Addressable normal/horizontal videos
const NIP71_SHORT_KIND = 34236;   // Addressable vertical/short videos (like Reels/Shorts)

// Legacy NIP-71 kinds (regular events, for backwards compatibility)
const NIP71_VIDEO_KIND_LEGACY = 21;
const NIP71_SHORT_KIND_LEGACY = 22;

// All video kinds for querying (includes legacy kind 1, legacy NIP-71, and addressable NIP-71)
const ALL_VIDEO_KINDS = [1, NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY];

// NIP-53 Live Activities
const NIP53_LIVE_EVENT_KIND = 30311;  // Live activity (streaming)
const NIP53_LIVE_CHAT_KIND = 1311;    // Live chat messages

// All content kinds including live
const ALL_CONTENT_KINDS = [...ALL_VIDEO_KINDS, NIP53_LIVE_EVENT_KIND];

// Live stream state
let currentLiveChat = {
    streamId: null,        // Current stream ID being viewed
    messages: [],          // Chat messages
    subscriptionId: null,  // Relay subscription ID for chat
    lastMessageTime: 0,    // For deduplication
    viewers: new Set(),    // Track unique viewers
    chatParticipants: new Map(), // Track chat participants: pubkey -> lastActivityTime
    viewerCount: 0,        // Current viewer count from live event
    eventId: null          // Current live event ID
};

// Live stream thumbnail upload state
const liveStreamState = {
    thumbnailUrl: null,
    thumbnailFile: null,
    isScheduled: false,
    scheduledTime: null
};

// Draft storage key
const DRAFTS_STORAGE_KEY = 'plebsVideoDrafts';

// Map to link kind 1 events to their NIP-71 counterparts
let videoEventLinks = new Map(); // Maps kind 1 event ID to kind 21/22 event ID and vice versa

// ===== NIP-13 Proof of Work =====
// Minimum PoW difficulty for reactions and comments to count in trending
const MIN_POW_DIFFICULTY = 16; // Require 16 leading zero bits (about 65k hash attempts average)

// ===== NIP-78 View Tracking =====
// Kind 30078 for aggregated view counts (replaceable by d-tag)
const VIEW_TRACKING_APP_ID = 'plebs/video-views';
const LIVE_VIEWER_TRACKING_APP_ID = 'plebs/live-viewers';
const VIEW_EVENT_KIND = 30078;
const LIVE_VIEWER_TIMEOUT = 5 * 60; // 5 minutes in seconds - viewers must update within this window
const LIVE_VIEWER_UPDATE_INTERVAL = 4 * 60 * 1000; // 4 minutes in ms - send updates before timeout

// Cache for video view counts with TTL
const videoViewsCache = new Map(); // eventId -> { count, timestamp }
const VIEW_CACHE_TTL = 5 * 60 * 1000; // 5 minute TTL for view counts
const pendingViewRequests = new Map(); // eventId -> Promise (track in-flight requests)

// Helper to get cached view count (respects TTL)
function getCachedViewCount(eventId) {
    const cached = videoViewsCache.get(eventId);
    if (!cached) return null;
    if (Date.now() - cached.timestamp > VIEW_CACHE_TTL) {
        videoViewsCache.delete(eventId);
        return null;
    }
    return cached.count;
}

// Helper to set cached view count with timestamp
function setCachedViewCount(eventId, count) {
    videoViewsCache.set(eventId, { count, timestamp: Date.now() });
}

// Settings management
let userSettings = {
    useWotRelays: false,
    usePremiumBlossom: false,
    customBlossomServers: [],
    saveToNostr: true,
    showNSFWWarnings: true,
    showCommunityWarnings: true,
    showFollowsReportWarnings: true,
    enabledFilterPacks: [],
    customKeywordFilter: [],
    // Notification settings
    notifications: {
        reactions: true,
        replies: true,
        zaps: true,
        chatMentions: true,
        newFollowers: true
    }
};

// ===== CONTENT FILTER PACKS =====
// Each pack contains keywords that will hide content matching them
// Icons are SVG strings for consistent rendering
const FILTER_PACK_ICONS = {
    // No/prohibited symbol - hate not allowed
    racism: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z"/></svg>',
    // Eye with slash - hidden/adult content
    sexualExplicit: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>',
    // Warning triangle - danger/violence
    violence: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>',
    // Pill/capsule - drugs
    drugs: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M19 8H5c-2.21 0-4 1.79-4 4s1.79 4 4 4h14c2.21 0 4-1.79 4-4s-1.79-4-4-4zM5 14c-1.1 0-2-.9-2-2s.9-2 2-2h6v4H5z"/></svg>',
    // Email warning - spam
    spam: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>',
    // Capitol/government building - politics
    politics: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L3 8v2h2v8H3v2h18v-2h-2v-8h2V8l-9-6zM7 18v-8h2v8H7zm4 0v-8h2v8h-2zm4 0v-8h2v8h-2z"/></svg>',
    // Chat bubble with asterisks - profanity/censored
    profanity: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-9 11H9V7h2v6zm4 0h-2V7h2v6z"/></svg>',
    // Coin with C symbol (like Bitcoin ₿ but C) - cryptocurrency
    crypto: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/><path d="M15 9.5c-.8-1.1-2-1.5-3-1.5-2.2 0-4 1.8-4 4s1.8 4 4 4c1 0 2.2-.4 3-1.5"/><line x1="12" y1="5" x2="12" y2="8"/><line x1="12" y1="16" x2="12" y2="19"/></svg>'
};

const FILTER_PACKS = {
    racism: {
        nameKey: 'filter.racism',
        descKey: 'filter.racismDesc',
        icon: FILTER_PACK_ICONS.racism,
        keywords: [
            'nigger', 'nigga', 'n1gger', 'n1gga', 'nigg3r', 'nig nog', 'spic', 'sp1c', 'wetback', 'beaner',
            'chink', 'ch1nk', 'gook', 'g00k', 'zipperhead', 'slant eye', 'kike', 'k1ke', 'kyke', 'heeb',
            'raghead', 'towelhead', 'sand nigger', 'camel jockey', 'paki', 'curry muncher', 'dot head',
            'cracker', 'honky', 'white trash', 'redneck trash', 'coon', 'c00n', 'darkie', 'jungle bunny',
            'porch monkey', 'moon cricket', 'tar baby', 'negro', 'colored people', 'redskin', 'injun',
            'prairie nigger', 'wagon burner', 'squaw', 'wop', 'dago', 'guinea', 'greaseball', 'polack',
            'mick', 'paddy', 'white power', 'heil hitler', '1488', 'gas the', 'race war', 'ethnic cleansing',
            'white genocide', 'great replacement', 'jew world order', 'zog', 'dindu', 'we wuz', 'jogger',
            'despite being 13', 'crime statistics'
        ]
    },
    sexualExplicit: {
        nameKey: 'filter.sexualExplicit',
        descKey: 'filter.sexualExplicitDesc',
        icon: FILTER_PACK_ICONS.sexualExplicit,
        keywords: [
            'porn', 'p0rn', 'pron', 'xxx', 'xxxx', 'hardcore sex', 'anal sex', 'blowjob', 'blow job',
            'handjob', 'hand job', 'cumshot', 'cum shot', 'facial cumshot', 'creampie', 'cream pie',
            'gangbang', 'gang bang', 'bukkake', 'deepthroat', 'deep throat', 'milf', 'm1lf', 'dilf',
            'pussy', 'p*ssy', 'cock', 'c0ck', 'dick pic', 'd1ck', 'tits', 't1ts',
            'boobs', 'b00bs', 'naked', 'nude', 'nudes', 'onlyfans', 'only fans', 'fansly', 'chaturbate',
            'pornhub', 'xvideos', 'xhamster', 'brazzers', 'bangbros', 'realitykings', 'naughtyamerica',
            'hentai', 'h3ntai', 'rule34', 'rule 34', 'r34', 'ecchi', 'ahegao', 'futanari', 'futa',
            'masturbat', 'masterbat', 'jerk off', 'jack off', 'fap', 'orgasm', '0rgasm', 'ejaculat',
            'squirt', 'fetish', 'bondage', 'bdsm', 'dominatrix', 'femdom', 'pegging', 'cuckold',
            'swinger', 'threesome', 'foursome', 'orgy', '0rgy', 'sex tape', 'sextape', 'leaked nudes',
            'nip slip', 'upskirt', 'downblouse', 'camgirl', 'cam girl', 'stripper', 'escort',
            'prostitut', 'hooker', 'whore', 'wh0re', 'slut', 'sl*t', 'lolita', 'loli', 'cuck', 'cuckold', 'cucking'
        ]
    },
    violence: {
        nameKey: 'filter.violence',
        descKey: 'filter.violenceDesc',
        icon: FILTER_PACK_ICONS.violence,
        keywords: [
            'gore', 'g0re', 'gory', 'beheading', 'decapitat', 'dismember', 'mutilat', 'disembowel',
            'execution video', 'snuff', 'snuff film', 'real death', 'actual death', 'watch him die',
            'watch her die', 'brutal murder', 'torture video', 't0rture', 'cartel video', 'cartel execution',
            'isis execution', 'terrorist execution', 'mass shooting', 'school shooting', 'shoot up',
            'bomb threat', 'kill everyone', 'murder everyone', 'massacre', 'bloodbath', 'blood bath',
            'self harm', 'self-harm', 'cutting myself', 'slit wrist', 'suicide video', 'kms', 'kys',
            'kill myself', 'kill yourself', 'neck rope', 'an hero', 'livestream shooting',
            'manifesto', 'going postal', 'rampage'
        ]
    },
    drugs: {
        nameKey: 'filter.drugs',
        descKey: 'filter.drugsDesc',
        icon: FILTER_PACK_ICONS.drugs,
        keywords: [
            'cocaine', 'c0caine', 'coke dealer', 'crack cocaine', 'heroin', 'her0in', 'h3roin',
            'fentanyl', 'fent', 'meth', 'm3th', 'methamphetamine', 'crystal meth', 'ice drug',
            'mdma', 'ecstasy', 'molly drug', 'lsd', 'acid trip', 'shrooms', 'magic mushrooms',
            'psilocybin', 'dmt', 'ayahuasca', 'ketamine', 'k hole', 'pcp', 'angel dust',
            'xanax', 'xans', 'bars drug', 'percocet', 'percs', 'oxy', 'oxycontin', 'oxycodone',
            'vicodin', 'codeine', 'lean drug', 'purple drank', 'sizzurp', 'drug dealer',
            'plug drug', 'trap house', 'cook meth', 'drug cartel', 'smuggling drugs',
            'inject heroin', 'shooting up', 'overdose', '0verdose', 'od\'d', 'nodding off'
        ]
    },
    spam: {
        nameKey: 'filter.spam',
        descKey: 'filter.spamDesc',
        icon: FILTER_PACK_ICONS.spam,
        keywords: [
            'free bitcoin', 'free btc', 'free crypto', 'double your bitcoin', 'double your btc',
            'send btc get', '2x return', '10x return', 'guaranteed profit', 'guaranteed returns',
            'investment opportunity', 'get rich quick', 'make money fast', 'passive income secret',
            'work from home scam', 'mlm opportunity', 'pyramid scheme', 'ponzi', 'rug pull',
            'pump and dump', 'to the moon', '100x gains', '1000x', 'next bitcoin', 'next ethereum',
            'presale token', 'airdrop claim', 'claim your tokens', 'connect wallet', 'mint now',
            'limited spots', 'act now', 'dm for details', 'dm me for', 'link in bio', 'check bio',
            'follow for follow', 'f4f', 'sub4sub', 'like4like', 'giveaway winner', 'you won',
            'congratulations you', 'claim your prize', 'click here now', 'sign up now',
            'telegram group', 'join our discord', 'whatsapp group', 'hot singles', 'date tonight',
            'viagra', 'v1agra', 'cialis', 'c1alis', 'weight loss', 'diet pill', 'enhancement pill'
        ]
    },
    crypto: {
        nameKey: 'filter.crypto',
        descKey: 'filter.cryptoDesc',
        icon: FILTER_PACK_ICONS.crypto,
        keywords: [
            'bitcoin', 'btc', 'ethereum', 'eth', 'crypto', 'cryptocurrency', 'altcoin', 'altcoins',
            'blockchain', 'defi', 'nft', 'nfts', 'web3', 'hodl', 'hodling', 'fomo', 'fud',
            'bullish', 'bearish', 'mooning', 'lambo', 'wen lambo', 'wagmi', 'ngmi',
            'diamond hands', 'paper hands', 'whale', 'whales', 'pump', 'dump', 'dyor',
            'shill', 'shilling', 'shitcoin', 'memecoin', 'meme coin', 'dogecoin', 'doge',
            'shiba', 'shib', 'pepe coin', 'solana', 'sol', 'cardano', 'ada', 'xrp', 'ripple',
            'binance', 'bnb', 'coinbase', 'kraken', 'kucoin', 'ftx', 'dex', 'cex',
            'staking', 'yield farming', 'liquidity pool', 'airdrop', 'ico', 'ido', 'ieo',
            'token sale', 'presale', 'whitelist', 'mint', 'minting', 'gas fee', 'gas fees',
            'metamask', 'wallet connect', 'seed phrase', 'private key', 'cold wallet', 'hot wallet',
            'ledger', 'trezor', 'uniswap', 'pancakeswap', 'opensea', 'rarible',
            'trading signal', 'buy signal', 'sell signal', 'technical analysis', 'ta',
            'market cap', 'mcap', 'volume', 'candle', 'candlestick', 'resistance', 'support',
            'breakout', 'breakdown', 'rsi', 'macd', 'fibonacci', 'elliot wave'
        ]
    },
    politics: {
        nameKey: 'filter.politics',
        descKey: 'filter.politicsDesc',
        icon: FILTER_PACK_ICONS.politics,
        keywords: [
            'maga', 'make america great', 'trump', 'biden', 'lets go brandon', 'fjb',
            'trump supporter', 'biden supporter', 'libtard', 'l1btard', 'conservatard', 'republicunt',
            'demonrat', 'demoncrat', 'republikkkan', 'snowflake lib', 'triggered lib', 'own the libs',
            'woke mob', 'cancel culture', 'sjw', 'social justice warrior', 'antifa', 'ant1fa',
            'proud boys', 'proud boy', 'qanon', 'q anon', 'deep state', 'globalist', 'nwo',
            'new world order', 'great reset', 'build back better', 'stolen election', 'stop the steal',
            'election fraud', 'voter fraud', 'dominion machines', 'rigged election', 'plandemic',
            'scamdemic', 'covid hoax', 'vaccine injury', 'vaxxed', 'antivaxx', 'anti-vaxx',
            'big pharma', 'bill gates microchip', 'george soros', 'koch brothers', 'mainstream media',
            'fake news media', 'lamestream', 'sheeple', 'wake up sheeple'
        ]
    },
    profanity: {
        nameKey: 'filter.profanity',
        descKey: 'filter.profanityDesc',
        icon: FILTER_PACK_ICONS.profanity,
        keywords: [
            'fuck', 'f*ck', 'fuk', 'fck', 'f u c k', 'fucking', 'fuckin', 'fucker', 'motherfuck',
            'motherfucker', 'mf', 'mfer', 'shit', 'sh1t', 'sh*t', 'bullshit', 'bullsh1t', 'horseshit',
            'shithead', 'shitface', 'asshole', 'assh0le', 'a**hole', 'ass hole', 'arsehole', 'arse',
            'bitch', 'b1tch', 'b*tch', 'bitches', 'son of a bitch', 'bastard', 'b4stard', 'dumbass',
            'dumb ass', 'jackass', 'jack ass', 'dipshit', 'dip shit', 'douchebag', 'douche bag',
            'douche', 'd-bag', 'scumbag', 'scum bag', 'piss off', 'pissed off', 'damn', 'goddamn',
            'god damn', 'bloody hell', 'bollocks', 'wanker', 'twat', 'bellend', 'cunt'
        ]
    }
};

// Enabled filter packs (stored in localStorage)
let enabledFilterPacks = new Set();
// Session-allowed filtered content (user clicked "show anyway")
let sessionFilteredAllowed = new Set();

// Initialize filter packs from localStorage
function initFilterPacks() {
    const stored = localStorage.getItem('plebsFilterPacks');
    if (stored) {
        try {
            const parsed = JSON.parse(stored);
            enabledFilterPacks = new Set(parsed);
        } catch (e) {
            console.error('Failed to parse filter packs:', e);
            enabledFilterPacks = new Set();
        }
    }
    // Update sidebar visibility based on saved filter packs
    updateSidebarFilterVisibility();
}

// Save filter packs to localStorage
function saveFilterPacks() {
    localStorage.setItem('plebsFilterPacks', JSON.stringify([...enabledFilterPacks]));
}

// Toggle a filter pack
function toggleFilterPack(packId) {
    if (enabledFilterPacks.has(packId)) {
        enabledFilterPacks.delete(packId);
    } else {
        enabledFilterPacks.add(packId);
    }
    saveFilterPacks();

    // Update UI checkbox
    const checkbox = document.getElementById(`filterPack_${packId}`);
    if (checkbox) {
        checkbox.checked = enabledFilterPacks.has(packId);
    }

    // Update sidebar visibility based on filter packs
    updateSidebarFilterVisibility();
}

// Update sidebar menu visibility based on enabled filter packs
function updateSidebarFilterVisibility() {
    // Hide NSFW link if Sexually Explicit filter is enabled
    const nsfwLink = document.getElementById('sidebar-nsfw-link');
    if (nsfwLink) {
        nsfwLink.style.display = enabledFilterPacks.has('sexualExplicit') ? 'none' : '';
    }

    // Hide Bitcoin link if Cryptocurrency filter is enabled
    const bitcoinLink = document.getElementById('sidebar-bitcoin-link');
    if (bitcoinLink) {
        bitcoinLink.style.display = enabledFilterPacks.has('crypto') ? 'none' : '';
    }

    // Hide Bitcoin featured topic section if on homepage and Crypto filter is enabled
    const bitcoinFeaturedSection = document.getElementById('featuredTopic3Section');
    if (bitcoinFeaturedSection) {
        bitcoinFeaturedSection.style.display = enabledFilterPacks.has('crypto') ? 'none' : '';
    }
}

// Check if text matches any enabled filter pack keywords or custom keywords
function matchesFilterPacks(text) {
    const hasFilterPacks = enabledFilterPacks.size > 0;
    const hasCustomKeywords = userSettings.customKeywordFilter && userSettings.customKeywordFilter.length > 0;

    if (!text || (!hasFilterPacks && !hasCustomKeywords)) return { matches: false, packs: [] };

    const lowerText = text.toLowerCase();
    const matchedPacks = [];

    // Check filter packs
    for (const packId of enabledFilterPacks) {
        const pack = FILTER_PACKS[packId];
        if (!pack) continue;

        for (const keyword of pack.keywords) {
            // Use word boundary matching to avoid false positives
            // But also check for intentional obfuscation patterns
            const escaped = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(^|[^a-z0-9])${escaped}([^a-z0-9]|$)`, 'i');

            if (regex.test(lowerText)) {
                matchedPacks.push({ packId, packName: t(pack.nameKey), keyword });
                break; // One match per pack is enough
            }
        }
    }

    // Check custom keywords
    if (hasCustomKeywords) {
        for (const keyword of userSettings.customKeywordFilter) {
            const escaped = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(^|[^a-z0-9])${escaped}([^a-z0-9]|$)`, 'i');

            if (regex.test(lowerText)) {
                matchedPacks.push({ packId: 'custom', packName: t('filter.customFilter'), keyword });
                break; // One match is enough for custom keywords
            }
        }
    }

    return {
        matches: matchedPacks.length > 0,
        packs: matchedPacks
    };
}

// Check if video content should be filtered
function shouldFilterVideoContent(event, videoData) {
    const hasFilters = enabledFilterPacks.size > 0 ||
        (userSettings.customKeywordFilter && userSettings.customKeywordFilter.length > 0);
    if (!hasFilters) return { filtered: false };

    // Check if user already allowed this content this session
    if (sessionFilteredAllowed.has(event.id)) {
        return { filtered: false };
    }

    // Filter NSFW videos when Sexually Explicit filter is enabled
    if (enabledFilterPacks.has('sexualExplicit')) {
        // Check for NSFW content-warning tag
        if (isVideoNSFW(event)) {
            return {
                filtered: true,
                packs: [{ packId: 'sexualExplicit', packName: 'Sexually Explicit' }],
                reason: 'Sexually Explicit'
            };
        }
        // Check for nsfw tag
        const tags = event.tags || [];
        if (tags.some(t => t[0] === 't' && t[1]?.toLowerCase() === 'nsfw')) {
            return {
                filtered: true,
                packs: [{ packId: 'sexualExplicit', packName: 'Sexually Explicit' }],
                reason: 'Sexually Explicit'
            };
        }
    }

    // Combine all text content to check
    const textToCheck = [
        videoData?.title || '',
        videoData?.description || '',
        ...(videoData?.tags || [])
    ].join(' ');

    const result = matchesFilterPacks(textToCheck);

    if (result.matches) {
        return {
            filtered: true,
            packs: result.packs,
            reason: result.packs.map(p => p.packName).join(', ')
        };
    }

    return { filtered: false };
}

// Check if comment should be filtered
function shouldFilterComment(commentText) {
    const hasFilters = enabledFilterPacks.size > 0 ||
        (userSettings.customKeywordFilter && userSettings.customKeywordFilter.length > 0);
    if (!hasFilters) return { filtered: false };

    const result = matchesFilterPacks(commentText);

    if (result.matches) {
        return {
            filtered: true,
            packs: result.packs,
            reason: result.packs.map(p => p.packName).join(', ')
        };
    }

    return { filtered: false };
}

// Allow filtered content for this session
function allowFilteredContent(eventId) {
    sessionFilteredAllowed.add(eventId);
}

// Create filtered content placeholder for videos
function createFilteredContentPlaceholder(event, filterResult, type = 'video') {
    const packNames = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.name || p.packName).join(', ');
    const packIcons = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.icon || '🚫').join(' ');

    if (type === 'video') {
        return `
            <div class="video-card filtered-content-placeholder" data-event-id="${event.id}">
                <div class="filtered-placeholder-content">
                    <div class="filtered-icon">${packIcons}</div>
                    <p>Content hidden by filter</p>
                    <p class="filtered-reason">${escapeHtml(packNames)}</p>
                    <button class="unhide-filtered-btn" onclick="handleUnhideFilteredContent('${event.id}')">
                        Show anyway
                    </button>
                </div>
            </div>
        `;
    } else if (type === 'comment') {
        return `
            <div class="comment filtered-comment-placeholder" data-event-id="${event.id}">
                <div class="filtered-placeholder-content filtered-comment">
                    <span class="filtered-icon-small">${packIcons}</span>
                    <span>Comment hidden (${escapeHtml(packNames)})</span>
                    <button class="unhide-filtered-btn-small" onclick="handleUnhideFilteredContent('${event.id}')">
                        Show
                    </button>
                </div>
            </div>
        `;
    }
    return '';
}

// Handle unhide filtered content
function handleUnhideFilteredContent(eventId) {
    allowFilteredContent(eventId);
    showToast('Showing filtered content', 'info');

    // Find and replace the placeholder
    const placeholder = document.querySelector(`.filtered-content-placeholder[data-event-id="${eventId}"], .filtered-comment-placeholder[data-event-id="${eventId}"]`);
    if (placeholder) {
        // Trigger a re-render by refreshing the current view
        const event = allEvents.get(eventId);
        if (event) {
            if (placeholder.classList.contains('video-card')) {
                // Re-render video card
                const profile = profileCache.get(event.pubkey);
                const reactions = reactionsCache.get(eventId);
                const isShort = isNip71ShortKind(event.kind);
                const newCard = isShort
                    ? createShortCard(event, profile, reactions)
                    : createVideoCard(event, profile, reactions);
                placeholder.outerHTML = newCard;
            } else {
                // For comments, re-render just this comment without reloading all
                const comment = currentCommentsState.comments.find(c => c.id === eventId);
                if (comment) {
                    // Get depth from placeholder data attribute
                    const depth = parseInt(placeholder.dataset.depth || '0', 10);
                    const commentWithDepth = { ...comment, depth, children: [] };

                    // Create the comment element
                    const commentElement = createCommentElement(
                        commentWithDepth,
                        profileCache,
                        currentCommentsState.reactions,
                        currentCommentsState.zaps
                    );

                    // Replace placeholder with the actual comment
                    placeholder.replaceWith(commentElement);
                }
            }
        }
    }
}

// ===== PERFORMANCE OPTIMIZATIONS =====

// Relay latency tracking
const relayLatency = new Map();

// LRU Cache implementation for memory management
class LRUCache {
    constructor(maxSize = 500) {
        this.maxSize = maxSize;
        this.cache = new Map();
    }

    get(key) {
        if (!this.cache.has(key)) return undefined;
        const value = this.cache.get(key);
        // Move to end (most recently used)
        this.cache.delete(key);
        this.cache.set(key, value);
        return value;
    }

    set(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.maxSize) {
            // Delete oldest (first) entry
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }

    has(key) {
        return this.cache.has(key);
    }

    delete(key) {
        return this.cache.delete(key);
    }

    clear() {
        this.cache.clear();
    }

    get size() {
        return this.cache.size;
    }
}

// Replace standard Maps with LRU caches for better memory management
const profileCacheLRU = new LRUCache(1000);
const reactionsCacheLRU = new LRUCache(2000);

// Debounce utility function
function debounce(func, wait, immediate = false) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            timeout = null;
            if (!immediate) func.apply(this, args);
        };
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(this, args);
    };
}

// Throttle utility function
function throttle(func, limit) {
    let inThrottle;
    return function executedFunction(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// ===== NIP-71 VIDEO EVENT HELPERS =====

// Generate a unique d-tag identifier for parameterized replaceable events
function generateVideoDTag() {
    // Create a unique identifier using timestamp and random string
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 10);
    return `video-${timestamp}-${random}`;
}

// Get image dimensions from a file
function getImageDimensions(file) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = () => {
            URL.revokeObjectURL(url);
            resolve({ width: img.naturalWidth, height: img.naturalHeight });
        };

        img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to load image'));
        };

        img.src = url;
    });
}

// Check if an image orientation matches the video type (vertical for Shorts, horizontal for regular)
function isThumbnailOrientationValid(thumbnailWidth, thumbnailHeight, isShortVideo) {
    const thumbnailIsVertical = thumbnailHeight > thumbnailWidth;
    // For Shorts, thumbnail should be vertical; for regular videos, thumbnail should be horizontal
    return isShortVideo === thumbnailIsVertical;
}

// Capture a frame from the video preview player and return as a File object
// Uses the existing video preview player to avoid CORS/tainted canvas issues
function captureVideoFrame(unusedUrl, captureTimeSeconds = 2) {
    return new Promise((resolve, reject) => {
        const video = document.getElementById('videoPreviewPlayer');
        if (!video || !video.src) {
            reject(new Error('Video preview player not found'));
            return;
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        const captureCurrentFrame = () => {
            try {
                // Set canvas to video dimensions
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                // Draw the video frame to canvas
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                // Convert canvas to blob
                canvas.toBlob((blob) => {
                    if (blob) {
                        const file = new File([blob], 'auto-thumbnail.jpg', { type: 'image/jpeg' });
                        resolve({
                            file: file,
                            width: canvas.width,
                            height: canvas.height
                        });
                    } else {
                        reject(new Error('Failed to create thumbnail blob'));
                    }
                }, 'image/jpeg', 0.85);
            } catch (error) {
                reject(error);
            }
        };

        // If video is ready, seek to the capture time
        if (video.readyState >= 2) {
            const seekTime = Math.min(captureTimeSeconds, video.duration * 0.1, video.duration - 0.5);
            const targetTime = Math.max(0, seekTime);

            if (Math.abs(video.currentTime - targetTime) < 0.5) {
                // Already at the right time, capture immediately
                captureCurrentFrame();
            } else {
                // Seek to the target time
                video.onseeked = () => {
                    video.onseeked = null;
                    captureCurrentFrame();
                };
                video.currentTime = targetTime;
            }
        } else {
            // Wait for video to load
            video.onloadeddata = () => {
                video.onloadeddata = null;
                const seekTime = Math.min(captureTimeSeconds, video.duration * 0.1, video.duration - 0.5);
                video.onseeked = () => {
                    video.onseeked = null;
                    captureCurrentFrame();
                };
                video.currentTime = Math.max(0, seekTime);
            };
        }
    });
}

// GIF Encoder - Creates animated GIFs from canvas frames
// Based on NeuQuant algorithm and LZW compression
const GIFEncoder = {
    // LZW encoding
    encode: function (width, height, frames, delay = 100) {
        const stream = [];

        // GIF Header
        this.writeString(stream, 'GIF89a');

        // Logical Screen Descriptor
        this.writeShort(stream, width);
        this.writeShort(stream, height);
        stream.push(0xF7); // Global Color Table Flag + Color Resolution + Sort Flag + Size (256 colors)
        stream.push(0x00); // Background Color Index
        stream.push(0x00); // Pixel Aspect Ratio

        // Global Color Table (256 colors)
        const colorTable = this.buildColorTable(frames);
        for (let i = 0; i < 256; i++) {
            stream.push(colorTable[i * 3] || 0);
            stream.push(colorTable[i * 3 + 1] || 0);
            stream.push(colorTable[i * 3 + 2] || 0);
        }

        // Netscape Application Extension (for looping)
        stream.push(0x21, 0xFF, 0x0B);
        this.writeString(stream, 'NETSCAPE2.0');
        stream.push(0x03, 0x01);
        this.writeShort(stream, 0); // Loop forever
        stream.push(0x00);

        // Process each frame
        for (const frameData of frames) {
            // Graphics Control Extension
            stream.push(0x21, 0xF9, 0x04);
            stream.push(0x04); // Disposal method: restore to background
            this.writeShort(stream, Math.round(delay / 10)); // Delay in 1/100ths of a second
            stream.push(0x00); // Transparent color index (none)
            stream.push(0x00);

            // Image Descriptor
            stream.push(0x2C);
            this.writeShort(stream, 0); // Left
            this.writeShort(stream, 0); // Top
            this.writeShort(stream, width);
            this.writeShort(stream, height);
            stream.push(0x00); // No local color table

            // Image Data
            const indexedPixels = this.quantizeFrame(frameData, colorTable, width, height);
            this.writeLZW(stream, indexedPixels, 8);
        }

        // GIF Trailer
        stream.push(0x3B);

        return new Uint8Array(stream);
    },

    writeString: function (stream, str) {
        for (let i = 0; i < str.length; i++) {
            stream.push(str.charCodeAt(i));
        }
    },

    writeShort: function (stream, val) {
        stream.push(val & 0xFF);
        stream.push((val >> 8) & 0xFF);
    },

    buildColorTable: function (frames) {
        // Simple color quantization - sample colors from all frames
        const colorCounts = new Map();

        for (const frame of frames) {
            for (let i = 0; i < frame.length; i += 4) {
                // Quantize to 5-bit color for grouping
                const r = frame[i] & 0xF8;
                const g = frame[i + 1] & 0xF8;
                const b = frame[i + 2] & 0xF8;
                const key = (r << 16) | (g << 8) | b;
                colorCounts.set(key, (colorCounts.get(key) || 0) + 1);
            }
        }

        // Sort by frequency and take top 256
        const sortedColors = [...colorCounts.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, 256);

        const table = new Uint8Array(768);
        for (let i = 0; i < sortedColors.length; i++) {
            const color = sortedColors[i][0];
            table[i * 3] = (color >> 16) & 0xFF;
            table[i * 3 + 1] = (color >> 8) & 0xFF;
            table[i * 3 + 2] = color & 0xFF;
        }

        return table;
    },

    quantizeFrame: function (frameData, colorTable, width, height) {
        const pixels = new Uint8Array(width * height);

        for (let i = 0; i < width * height; i++) {
            const r = frameData[i * 4];
            const g = frameData[i * 4 + 1];
            const b = frameData[i * 4 + 2];

            // Find closest color in palette
            let minDist = Infinity;
            let bestIndex = 0;

            for (let j = 0; j < 256; j++) {
                const dr = r - colorTable[j * 3];
                const dg = g - colorTable[j * 3 + 1];
                const db = b - colorTable[j * 3 + 2];
                const dist = dr * dr + dg * dg + db * db;

                if (dist < minDist) {
                    minDist = dist;
                    bestIndex = j;
                    if (dist === 0) break;
                }
            }

            pixels[i] = bestIndex;
        }

        return pixels;
    },

    writeLZW: function (stream, pixels, minCodeSize) {
        stream.push(minCodeSize);

        const clearCode = 1 << minCodeSize;
        const eoiCode = clearCode + 1;

        let codeSize = minCodeSize + 1;
        let nextCode = eoiCode + 1;
        const codeTable = new Map();

        // Initialize code table
        for (let i = 0; i < clearCode; i++) {
            codeTable.set(String.fromCharCode(i), i);
        }

        let buffer = 0;
        let bufferSize = 0;
        const subBlock = [];

        const writeCode = (code) => {
            buffer |= code << bufferSize;
            bufferSize += codeSize;

            while (bufferSize >= 8) {
                subBlock.push(buffer & 0xFF);
                buffer >>= 8;
                bufferSize -= 8;

                if (subBlock.length === 255) {
                    stream.push(255);
                    for (const b of subBlock) stream.push(b);
                    subBlock.length = 0;
                }
            }
        };

        writeCode(clearCode);

        let indexBuffer = String.fromCharCode(pixels[0]);

        for (let i = 1; i < pixels.length; i++) {
            const k = String.fromCharCode(pixels[i]);
            const combined = indexBuffer + k;

            if (codeTable.has(combined)) {
                indexBuffer = combined;
            } else {
                writeCode(codeTable.get(indexBuffer));

                if (nextCode < 4096) {
                    codeTable.set(combined, nextCode++);
                    if (nextCode > (1 << codeSize) && codeSize < 12) {
                        codeSize++;
                    }
                }

                indexBuffer = k;
            }
        }

        writeCode(codeTable.get(indexBuffer));
        writeCode(eoiCode);

        // Flush remaining bits
        if (bufferSize > 0) {
            subBlock.push(buffer & 0xFF);
        }

        // Write remaining sub-block
        if (subBlock.length > 0) {
            stream.push(subBlock.length);
            for (const b of subBlock) stream.push(b);
        }

        stream.push(0x00); // Block terminator
    }
};

// Detect iOS/Safari for optimized handling
function isIOSOrSafari() {
    const ua = navigator.userAgent;
    const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
    return isIOS || isSafari;
}

// Generate an animated GIF preview using the video preview player
// Captures frames from the first few seconds and creates a looping GIF
// Uses the existing video preview player to avoid CORS/tainted canvas issues
function generatePreviewGif(unusedUrl, options = {}) {
    const isMobileOrSafari = isIOSOrSafari();
    const defaultFrameCount = isMobileOrSafari ? 5 : 8;

    const {
        frameCount = defaultFrameCount,
        startTime = 0.5,
        duration = 3,
        maxWidth = isMobileOrSafari ? 240 : 320,
        frameDelay = 150
    } = options;

    return new Promise(async (resolve, reject) => {
        const video = document.getElementById('videoPreviewPlayer');
        if (!video || !video.src) {
            reject(new Error('Video preview player not found'));
            return;
        }

        // Wait for video to be ready if needed
        if (video.readyState < 2) {
            await new Promise((res) => {
                video.onloadeddata = () => {
                    video.onloadeddata = null;
                    res();
                };
            });
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        // Calculate scaled dimensions
        const aspectRatio = video.videoWidth / video.videoHeight;
        let width = Math.min(maxWidth, video.videoWidth);
        let height = Math.round(width / aspectRatio);

        // Ensure even dimensions
        width = width - (width % 2);
        height = height - (height % 2);

        canvas.width = width;
        canvas.height = height;

        // Calculate frame times
        const videoDuration = video.duration;
        const actualDuration = Math.min(duration, videoDuration - startTime);
        const frameInterval = actualDuration / (frameCount - 1);

        const frameTimes = [];
        for (let i = 0; i < frameCount; i++) {
            frameTimes.push(Math.min(startTime + (i * frameInterval), videoDuration - 0.1));
        }

        // Capture frames sequentially by seeking the video player
        const frames = [];
        const originalTime = video.currentTime;

        const captureFrameAtTime = (time) => {
            return new Promise((res) => {
                const onSeeked = () => {
                    video.removeEventListener('seeked', onSeeked);
                    try {
                        ctx.drawImage(video, 0, 0, width, height);
                        const imageData = ctx.getImageData(0, 0, width, height);
                        res(new Uint8Array(imageData.data));
                    } catch (error) {
                        console.warn('Frame capture failed:', error);
                        res(null);
                    }
                };
                video.addEventListener('seeked', onSeeked);
                video.currentTime = time;
            });
        };

        try {
            for (const time of frameTimes) {
                const frame = await captureFrameAtTime(time);
                if (frame) frames.push(frame);
            }

            // Restore original video position
            video.currentTime = originalTime;

            // Need at least 2 frames for a GIF
            if (frames.length < 2) {
                reject(new Error('Could not capture enough frames'));
                return;
            }

            // Generate GIF
            const gifData = GIFEncoder.encode(width, height, frames, frameDelay);
            const blob = new Blob([gifData], { type: 'image/gif' });
            const file = new File([blob], 'preview.gif', { type: 'image/gif' });

            resolve({
                file: file,
                width: width,
                height: height,
                frameCount: frames.length
            });
        } catch (error) {
            reject(new Error('Failed to generate GIF: ' + error.message));
        }
    });
}

// Determine if a video should be a "short" (kind 22) based on dimensions and duration
function isVideoShort(width, height, duration = null) {
    if (!width || !height) return false;

    // Video is considered a "short" if it's vertical (height > width)
    const aspectRatio = width / height;
    const isVertical = aspectRatio < 1; // Portrait orientation

    // If duration is provided, also check if it's under 60 seconds
    // A short must be vertical AND (if duration is known) under 60 seconds
    if (duration !== null && duration > 0) {
        return isVertical && duration <= 60;
    }

    // If no duration, just check orientation
    return isVertical;
}

// Validate that a video file is vertical (for Create Short modal validation)
function validateVideoIsVertical(file) {
    return new Promise((resolve) => {
        const video = document.createElement('video');
        video.preload = 'metadata';

        video.onloadedmetadata = function () {
            URL.revokeObjectURL(video.src);
            const isVertical = video.videoHeight > video.videoWidth;
            resolve(isVertical);
        };

        video.onerror = function () {
            URL.revokeObjectURL(video.src);
            // On error, allow upload (let the normal processing handle it)
            resolve(true);
        };

        video.src = URL.createObjectURL(file);
    });
}

// Create NIP-71 imeta tag from video data
function createImetaTag(videoData) {
    const parts = [];

    // Primary URL
    if (videoData.url) {
        parts.push(`url ${videoData.url}`);
    }

    // Fallback URLs from successful blossom uploads
    if (videoData.mirrors && videoData.mirrors.length > 0) {
        videoData.mirrors.forEach(mirror => {
            if (mirror.url && mirror.url !== videoData.url) {
                parts.push(`fallback ${mirror.url}`);
            }
        });
    }

    // File hash
    if (videoData.hash) {
        parts.push(`x ${videoData.hash}`);
    }

    // MIME type
    if (videoData.type) {
        parts.push(`m ${videoData.type}`);
    }

    // File size
    if (videoData.size) {
        parts.push(`size ${videoData.size}`);
    }

    // Dimensions
    if (videoData.width && videoData.height) {
        parts.push(`dim ${videoData.width}x${videoData.height}`);
    }

    // Duration (in seconds)
    if (videoData.duration) {
        parts.push(`duration ${Math.floor(videoData.duration)}`);
    }

    // Thumbnail/preview image
    if (videoData.thumbnail) {
        parts.push(`image ${videoData.thumbnail}`);
    }

    // Animated preview GIF for hover effect
    if (videoData.preview) {
        parts.push(`preview ${videoData.preview}`);
    }

    return ['imeta', ...parts];
}

// Create a NIP-71 video event (kind 21 or 22)
function createNip71VideoEvent(videoData) {
    // When editing, preserve the original kind to ensure proper replacement
    // Otherwise, calculate kind based on dimensions
    let kind;
    if (videoData.originalKind === NIP71_VIDEO_KIND || videoData.originalKind === NIP71_SHORT_KIND) {
        kind = videoData.originalKind;
    } else {
        const isShort = isVideoShort(videoData.width, videoData.height, videoData.duration);
        kind = isShort ? NIP71_SHORT_KIND : NIP71_VIDEO_KIND;
    }

    // Generate or use existing d-tag for parameterized replaceable event
    const dTag = videoData.dTag || generateVideoDTag();

    const extraTags = Array.isArray(videoData.extraTags) ? videoData.extraTags : [];
    const tags = [
        ['d', dTag],
        ['title', videoData.title],
        createImetaTag(videoData),
        ['t', 'pv69420'], // Keep our app identifier for easy filtering
        ...videoData.tags.map(tag => ['t', tag]),
        ...extraTags,
        ['client', 'Plebs']
    ];

    // Add published_at if this is an edit (use original publish time)
    if (videoData.publishedAt) {
        tags.push(['published_at', videoData.publishedAt.toString()]);
    }

    // Add content warning if NSFW
    if (videoData.isNSFW) {
        tags.push(['content-warning', 'nsfw']);
    }

    // Add thumbnail as separate tag for backwards compatibility
    if (videoData.thumbnail) {
        tags.push(['thumb', videoData.thumbnail]);
    }

    // Add preview GIF as separate tag for hover previews
    if (videoData.preview) {
        tags.push(['preview', videoData.preview]);
    }

    // Add legacy tags for broader compatibility
    if (videoData.hash) {
        tags.push(['x', videoData.hash]);
    }
    if (videoData.url) {
        tags.push(['url', videoData.url]);
    }
    if (videoData.type) {
        tags.push(['m', videoData.type]);
    }
    tags.push(['size', (videoData.size || 0).toString()]);
    tags.push(['duration', Math.floor(videoData.duration || 0).toString()]);

    return {
        kind: kind,
        tags: tags,
        content: videoData.description || '',
        created_at: Math.floor(Date.now() / 1000)
    };
}

// Create a kind 1 video event (for backwards compatibility)
function createKind1VideoEvent(videoData, addressableEventId = null) {
    const extraTags = Array.isArray(videoData.extraTags) ? videoData.extraTags : [];
    const tags = [
        ['title', videoData.title],
        ['t', 'pv69420'],
        ...videoData.tags.map(tag => ['t', tag]),
        ...extraTags,
        ['client', 'Plebs']
    ];

    if (videoData.hash) {
        tags.push(['x', videoData.hash]);
    }
    if (videoData.url) {
        tags.push(['url', videoData.url]);
    }
    if (videoData.type) {
        tags.push(['m', videoData.type]);
    }
    tags.push(['size', (videoData.size || 0).toString()]);
    tags.push(['duration', Math.floor(videoData.duration || 0).toString()]);
    if (videoData.thumbnail) {
        tags.push(['thumb', videoData.thumbnail]);
    }
    if (videoData.preview) {
        tags.push(['preview', videoData.preview]);
    }

    if (videoData.isNSFW) {
        tags.push(['content-warning', 'nsfw']);
    }

    // Link to NIP-71 event if we have a d-tag
    if (videoData.dTag) {
        tags.push(['nip71-d', videoData.dTag]);
    }

    // Build content with video URL above description and plebs link at end
    let content = `${escapeHtml(videoData.title)}\n\n${videoData.url}`;
    if (videoData.description) {
        content += `\n\n${escapeHtml(videoData.description)}`;
    }
    if (addressableEventId) {
        content += `\n\nhttps://plebs.app/#/video/${addressableEventId}`;
    }

    return {
        kind: 1,
        tags: tags,
        content: content,
        created_at: Math.floor(Date.now() / 1000)
    };
}

// Create a legacy NIP-71 video event (kind 21/22 - for maximum reach on other clients)
function createLegacyNip71VideoEvent(videoData) {
    const isShort = isVideoShort(videoData.width, videoData.height, videoData.duration);
    const kind = isShort ? NIP71_SHORT_KIND_LEGACY : NIP71_VIDEO_KIND_LEGACY;

    const extraTags = Array.isArray(videoData.extraTags) ? videoData.extraTags : [];
    const tags = [
        ['d', videoData.dTag || generateVideoDTag()],
        ['title', videoData.title],
        createImetaTag(videoData),
        ['t', 'pv69420'],
        ...videoData.tags.map(tag => ['t', tag]),
        ...extraTags,
        ['client', 'Plebs']
    ];

    // Add published_at if this is an edit
    if (videoData.publishedAt) {
        tags.push(['published_at', videoData.publishedAt.toString()]);
    }

    // Add content warning if NSFW
    if (videoData.isNSFW) {
        tags.push(['content-warning', 'nsfw']);
    }

    // Add thumbnail as separate tag for backwards compatibility
    if (videoData.thumbnail) {
        tags.push(['thumb', videoData.thumbnail]);
    }

    // Add preview GIF as separate tag for hover previews
    if (videoData.preview) {
        tags.push(['preview', videoData.preview]);
    }

    // Add legacy tags for broader compatibility
    if (videoData.hash) {
        tags.push(['x', videoData.hash]);
    }
    if (videoData.url) {
        tags.push(['url', videoData.url]);
    }
    if (videoData.type) {
        tags.push(['m', videoData.type]);
    }
    tags.push(['size', (videoData.size || 0).toString()]);
    tags.push(['duration', Math.floor(videoData.duration || 0).toString()]);

    return {
        kind: kind,
        tags: tags,
        content: videoData.description || '',
        created_at: Math.floor(Date.now() / 1000)
    };
}

// Helper to check if event kind is a NIP-71 video (normal) kind
function isNip71VideoKind(kind) {
    return kind === NIP71_VIDEO_KIND || kind === NIP71_VIDEO_KIND_LEGACY;
}

// Helper to check if event kind is a NIP-71 short kind
function isNip71ShortKind(kind) {
    return kind === NIP71_SHORT_KIND || kind === NIP71_SHORT_KIND_LEGACY;
}

// Helper to check if event kind is any NIP-71 kind
function isNip71Kind(kind) {
    return isNip71VideoKind(kind) || isNip71ShortKind(kind);
}

// Helper to check if a video event is a short (based on kind)
function isShortVideoEvent(event) {
    if (!event) return false;
    // NIP-71 short kinds (34236, 22) are shorts
    return isNip71ShortKind(event.kind);
}

// Helper to get video kinds for filtering (shorts vs normal)
function getVideoKindsForType(preferShorts) {
    if (preferShorts) {
        // Short kinds first
        return [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY, NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1];
    } else {
        // Normal video kinds first
        return [NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1, NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY];
    }
}

// Parse NIP-71 video event (kind 34235/34236 or legacy 21/22)
function parseNip71VideoEvent(event) {
    if (!isNip71Kind(event.kind)) {
        return null;
    }

    const tags = event.tags || [];

    // Check for our app identifier
    if (!tags.some(tag => tag[0] === 't' && tag[1] === 'pv69420')) {
        return null;
    }

    const videoData = {
        title: '',
        description: event.content || '',
        hash: '',
        url: '',
        fallbackUrls: [],
        thumbnail: '',
        preview: '',
        duration: 0,
        size: 0,
        type: 'video/mp4',
        width: 0,
        height: 0,
        tags: [],
        author: event.pubkey,
        dTag: '',
        publishedAt: event.created_at,
        isShort: isNip71ShortKind(event.kind),
        kind: event.kind
    };

    for (const tag of tags) {
        switch (tag[0]) {
            case 'd':
                videoData.dTag = tag[1];
                break;
            case 'title':
                videoData.title = tag[1];
                break;
            case 'imeta':
                // Parse imeta tag (NIP-92 format)
                for (let i = 1; i < tag.length; i++) {
                    const part = tag[i];
                    const spaceIndex = part.indexOf(' ');
                    if (spaceIndex === -1) continue;

                    const key = part.substring(0, spaceIndex);
                    const value = part.substring(spaceIndex + 1);

                    switch (key) {
                        case 'url':
                            if (!videoData.url) {
                                videoData.url = value;
                            } else {
                                videoData.fallbackUrls.push(value);
                            }
                            break;
                        case 'fallback':
                            videoData.fallbackUrls.push(value);
                            break;
                        case 'x':
                            videoData.hash = value;
                            break;
                        case 'm':
                            videoData.type = value;
                            break;
                        case 'size':
                            videoData.size = parseInt(value) || 0;
                            break;
                        case 'dim':
                            const dims = value.split('x');
                            if (dims.length === 2) {
                                videoData.width = parseInt(dims[0]) || 0;
                                videoData.height = parseInt(dims[1]) || 0;
                            }
                            break;
                        case 'duration':
                            videoData.duration = parseInt(value) || 0;
                            break;
                        case 'image':
                            if (!videoData.thumbnail) {
                                videoData.thumbnail = value;
                            }
                            break;
                        case 'preview':
                            if (!videoData.preview) {
                                videoData.preview = value;
                            }
                            break;
                    }
                }
                break;
            case 'thumb':
                if (!videoData.thumbnail) {
                    videoData.thumbnail = tag[1];
                }
                break;
            case 'preview':
                if (!videoData.preview) {
                    videoData.preview = tag[1];
                }
                break;
            case 'x':
                if (!videoData.hash) {
                    videoData.hash = tag[1];
                }
                break;
            case 'url':
                if (!videoData.url) {
                    videoData.url = tag[1];
                }
                break;
            case 'm':
                if (videoData.type === 'video/mp4') {
                    videoData.type = tag[1];
                }
                break;
            case 'size':
                if (!videoData.size) {
                    videoData.size = parseInt(tag[1]) || 0;
                }
                break;
            case 'duration':
                if (!videoData.duration) {
                    videoData.duration = parseInt(tag[1]) || 0;
                }
                break;
            case 'published_at':
                videoData.publishedAt = parseInt(tag[1]) || event.created_at;
                break;
            case 't':
                if (tag[1] && tag[1] !== 'pv69420') {
                    videoData.tags.push(tag[1]);
                }
                break;
            case 'content-warning':
                videoData.isNSFW = tag[1] === 'nsfw';
                break;
        }
    }

    return videoData.title ? videoData : null;
}

// Parse any video event (supports both kind 1 and NIP-71)
function parseAnyVideoEvent(event) {
    if (isNip71Kind(event.kind)) {
        return parseNip71VideoEvent(event);
    } else if (event.kind === 1) {
        return parseVideoEvent(event);
    }
    return null;
}

// Check if an event is a video event (kind 1 with pv69420, or NIP-71 kinds)
function isVideoEvent(event) {
    if (isNip71Kind(event.kind)) {
        return event.tags?.some(tag => tag[0] === 't' && tag[1] === 'pv69420');
    }
    if (event.kind === 1) {
        return event.tags?.some(tag => tag[0] === 't' && tag[1] === 'pv69420');
    }
    return false;
}

// Find linked events (kind 1 <-> NIP-71) by d-tag
async function findLinkedVideoEvents(event) {
    const linkedIds = [];
    const dTag = event.tags?.find(t => t[0] === 'd')?.[1] ||
        event.tags?.find(t => t[0] === 'nip71-d')?.[1];

    if (!dTag) return linkedIds;

    // If this is a kind 1 event, look for NIP-71 events with matching d-tag
    if (event.kind === 1) {
        const filter = {
            kinds: [NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY],
            authors: [event.pubkey],
            '#d': [dTag]
        };

        return new Promise(resolve => {
            requestEventsStream(filter, (linkedEvent) => {
                linkedIds.push(linkedEvent.id);
                allEvents.set(linkedEvent.id, linkedEvent);
                videoEventLinks.set(event.id, linkedEvent.id);
                videoEventLinks.set(linkedEvent.id, event.id);
            }, () => resolve(linkedIds));
        });
    }

    // If this is an addressable NIP-71 event (34235/34236), look for kind 1, legacy kind 21/22, AND historical versions
    if (event.kind === NIP71_VIDEO_KIND || event.kind === NIP71_SHORT_KIND) {
        return new Promise(resolve => {
            // Query ALL video events from this author with pv69420 tag, then filter locally by d-tag
            // This is more reliable than using #d or #nip71-d filters which some relays don't support
            const filter = {
                kinds: [1, NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY],
                authors: [event.pubkey],
                '#t': ['pv69420']
            };

            requestEventsStream(filter, (linkedEvent) => {
                // Skip self
                if (linkedEvent.id === event.id) return;
                if (linkedIds.includes(linkedEvent.id)) return;

                // Check if this event has matching d-tag or nip71-d tag
                const linkedDTag = linkedEvent.tags?.find(t => t[0] === 'd')?.[1];
                const linkedNip71DTag = linkedEvent.tags?.find(t => t[0] === 'nip71-d')?.[1];

                if (linkedDTag === dTag || linkedNip71DTag === dTag) {
                    linkedIds.push(linkedEvent.id);
                    allEvents.set(linkedEvent.id, linkedEvent);
                    videoEventLinks.set(event.id, linkedEvent.id);
                    videoEventLinks.set(linkedEvent.id, event.id);
                }
            }, () => resolve(linkedIds));
        });
    }

    // If this is a legacy NIP-71 event (21/22), look for kind 1 with matching nip71-d tag
    if (event.kind === NIP71_VIDEO_KIND_LEGACY || event.kind === NIP71_SHORT_KIND_LEGACY) {
        const filter = {
            kinds: [1],
            authors: [event.pubkey],
            '#nip71-d': [dTag],
            '#t': ['pv69420']
        };

        return new Promise(resolve => {
            requestEventsStream(filter, (linkedEvent) => {
                linkedIds.push(linkedEvent.id);
                allEvents.set(linkedEvent.id, linkedEvent);
                videoEventLinks.set(event.id, linkedEvent.id);
                videoEventLinks.set(linkedEvent.id, event.id);
            }, () => resolve(linkedIds));
        });
    }

    return linkedIds;
}

// Check if a legacy event (kind 1 or kind 21/22) should be skipped
// We only show addressable events (kind 34235/34236) as the primary source
// This prevents showing duplicate videos when multiple event types exist
function shouldSkipLegacyEvent(event) {
    // Addressable events (34235/34236) are always shown
    if (event.kind === NIP71_VIDEO_KIND || event.kind === NIP71_SHORT_KIND) {
        return false;
    }

    // For kind 1 events: skip if they have a nip71-d tag OR if addressable counterpart exists
    if (event.kind === 1) {
        const nip71DTag = event.tags?.find(t => t[0] === 'nip71-d')?.[1];
        if (nip71DTag) {
            // Has nip71-d tag - check if addressable counterpart exists in cache
            for (const [id, cachedEvent] of allEvents) {
                if ((cachedEvent.kind === NIP71_VIDEO_KIND || cachedEvent.kind === NIP71_SHORT_KIND) &&
                    cachedEvent.pubkey === event.pubkey) {
                    const cachedDTag = cachedEvent.tags?.find(t => t[0] === 'd')?.[1];
                    if (cachedDTag === nip71DTag) {
                        return true;
                    }
                }
            }
            // nip71-d tag exists but addressable counterpart not in cache yet
            // Still skip if we know the NIP-71 version exists (indicated by the tag)
            return true;
        }
    }

    // For legacy NIP-71 events (21/22): skip only if we find the addressable counterpart in cache
    if (event.kind === NIP71_VIDEO_KIND_LEGACY || event.kind === NIP71_SHORT_KIND_LEGACY) {
        const dTag = event.tags?.find(t => t[0] === 'd')?.[1];
        if (dTag) {
            // Check if we have an addressable counterpart with the same d-tag
            for (const [id, cachedEvent] of allEvents) {
                if ((cachedEvent.kind === NIP71_VIDEO_KIND || cachedEvent.kind === NIP71_SHORT_KIND) &&
                    cachedEvent.pubkey === event.pubkey) {
                    const cachedDTag = cachedEvent.tags?.find(t => t[0] === 'd')?.[1];
                    if (cachedDTag === dTag) {
                        return true;
                    }
                }
            }
            // Don't skip if addressable counterpart not found - show the legacy event
        }
    }

    // Check via videoEventLinks for events linked to addressable events
    const linkedId = videoEventLinks.get(event.id);
    if (linkedId) {
        const linkedEvent = allEvents.get(linkedId);
        if (linkedEvent && (linkedEvent.kind === NIP71_VIDEO_KIND || linkedEvent.kind === NIP71_SHORT_KIND)) {
            return true;
        }
    }

    return false;
}

// Remove legacy counterpart from videos array when addressable event arrives
// This handles the race condition where legacy events (kind 1/21/22) may arrive before their addressable counterparts (kind 34235/34236)
// Returns array of removed legacy events
function removeLegacyCounterpart(event, videosArray, renderedIds = null) {
    // Only process addressable events
    if (event.kind !== NIP71_VIDEO_KIND && event.kind !== NIP71_SHORT_KIND) {
        return [];
    }

    const dTag = event.tags?.find(t => t[0] === 'd')?.[1];
    if (!dTag) return [];

    const removedEvents = [];

    // Helper to remove an event at index
    const removeAtIndex = (index) => {
        const legacyEvent = videosArray[index];
        videosArray.splice(index, 1);

        // Remove from rendered IDs set if provided
        if (renderedIds) {
            renderedIds.delete(legacyEvent.id);
        }

        // Remove from DOM if rendered
        const legacyCard = document.getElementById(`video-card-${legacyEvent.id}`);
        if (legacyCard) {
            legacyCard.remove();
        }

        removedEvents.push(legacyEvent);
    };

    // 1. Find and remove legacy NIP-71 counterpart (kind 21/22) with same d-tag
    const legacyKind = event.kind === NIP71_VIDEO_KIND ? NIP71_VIDEO_KIND_LEGACY : NIP71_SHORT_KIND_LEGACY;
    const legacyIndex = videosArray.findIndex(v =>
        v.kind === legacyKind &&
        v.pubkey === event.pubkey &&
        v.tags?.find(t => t[0] === 'd')?.[1] === dTag
    );
    if (legacyIndex !== -1) {
        removeAtIndex(legacyIndex);
    }

    // 2. Find and remove kind 1 counterpart with matching nip71-d tag
    const kind1Index = videosArray.findIndex(v =>
        v.kind === 1 &&
        v.pubkey === event.pubkey &&
        v.tags?.find(t => t[0] === 'nip71-d')?.[1] === dTag
    );
    if (kind1Index !== -1) {
        removeAtIndex(kind1Index);
    }

    return removedEvents;
}

// Get all event IDs to query for reactions/zaps (includes linked events)
// This allows merging reactions from addressable, legacy NIP-71, and kind 1 events
function getAllLinkedEventIds(eventId) {
    const ids = new Set([eventId]);
    const toProcess = [eventId];

    // Traverse all linked events (BFS)
    while (toProcess.length > 0) {
        const currentId = toProcess.shift();

        // Check for linked events in videoEventLinks
        for (const [id, linkedId] of videoEventLinks) {
            if (id === currentId && !ids.has(linkedId)) {
                ids.add(linkedId);
                toProcess.push(linkedId);
            }
            if (linkedId === currentId && !ids.has(id)) {
                ids.add(id);
                toProcess.push(id);
            }
        }
    }

    // Also check allEvents for videos with matching d-tag or nip71-d tag
    const event = allEvents.get(eventId);
    if (event) {
        const dTag = event.tags?.find(t => t[0] === 'd')?.[1] ||
            event.tags?.find(t => t[0] === 'nip71-d')?.[1];
        if (dTag) {
            for (const [id, cachedEvent] of allEvents) {
                if (ids.has(id)) continue;
                if (cachedEvent.pubkey !== event.pubkey) continue;

                // Check if this event has matching d-tag or nip71-d tag
                const cachedDTag = cachedEvent.tags?.find(t => t[0] === 'd')?.[1];
                const cachedNip71DTag = cachedEvent.tags?.find(t => t[0] === 'nip71-d')?.[1];

                if (cachedDTag === dTag || cachedNip71DTag === dTag) {
                    ids.add(id);
                    // Also add to videoEventLinks for future lookups
                    videoEventLinks.set(eventId, id);
                    videoEventLinks.set(id, eventId);
                }
            }
        }
    }

    return Array.from(ids);
}

// ===== NIP-13 Proof of Work Validation =====
// Count leading zero bits in a hex string (event ID)
function countLeadingZeroBits(hexString) {
    let count = 0;
    for (let i = 0; i < hexString.length; i++) {
        const nibble = parseInt(hexString[i], 16);
        if (nibble === 0) {
            count += 4;
        } else {
            // Count leading zeros in this nibble
            if (nibble < 2) count += 3;
            else if (nibble < 4) count += 2;
            else if (nibble < 8) count += 1;
            break;
        }
    }
    return count;
}

// Validate that an event has sufficient proof of work (NIP-13)
function validateEventPoW(event, minDifficulty = MIN_POW_DIFFICULTY) {
    if (!event || !event.id) return false;

    // Check for nonce tag (NIP-13 compliance)
    const nonceTag = event.tags?.find(t => t[0] === 'nonce');
    if (!nonceTag) return false;

    // The nonce tag should have: ['nonce', '<random>', '<target_difficulty>']
    const targetDifficulty = parseInt(nonceTag[2], 10);
    if (isNaN(targetDifficulty) || targetDifficulty < minDifficulty) return false;

    // Count actual leading zero bits in the event ID
    const actualDifficulty = countLeadingZeroBits(event.id);

    return actualDifficulty >= minDifficulty;
}

// Generate proof of work for an event (NIP-13)
// This is computationally intensive - runs in a loop until target difficulty is met
async function generatePoW(eventTemplate, targetDifficulty = MIN_POW_DIFFICULTY) {
    let nonce = 0;
    const maxIterations = 10000000; // Safety limit

    // Add nonce tag placeholder
    const nonceTagIndex = eventTemplate.tags.findIndex(t => t[0] === 'nonce');
    if (nonceTagIndex >= 0) {
        eventTemplate.tags.splice(nonceTagIndex, 1);
    }

    while (nonce < maxIterations) {
        // Update nonce tag
        const tagsWithNonce = [...eventTemplate.tags, ['nonce', nonce.toString(), targetDifficulty.toString()]];

        // Create event for hashing
        const eventForHash = {
            pubkey: eventTemplate.pubkey,
            created_at: eventTemplate.created_at,
            kind: eventTemplate.kind,
            tags: tagsWithNonce,
            content: eventTemplate.content
        };

        // Serialize and hash (NIP-01 format)
        const serialized = JSON.stringify([
            0,
            eventForHash.pubkey,
            eventForHash.created_at,
            eventForHash.kind,
            eventForHash.tags,
            eventForHash.content
        ]);

        // Hash using Web Crypto API
        const encoder = new TextEncoder();
        const data = encoder.encode(serialized);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

        // Check difficulty
        const difficulty = countLeadingZeroBits(hashHex);
        if (difficulty >= targetDifficulty) {
            eventTemplate.tags = tagsWithNonce;
            return eventTemplate;
        }

        nonce++;

        // Yield to UI every 10000 iterations
        if (nonce % 10000 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    throw new Error('Failed to generate proof of work within iteration limit');
}

// Get the editable event ID for a video
// Returns the NIP-71 event ID if available, null otherwise
// Only addressable kinds (34235/34236) support true replacement editing
// Legacy kinds (21/22) use delete + republish flow
function getEditableEventId(eventId) {
    const event = allEvents.get(eventId);
    if (!event) return null;

    // If this is an addressable NIP-71 event (34235/34236), it's directly editable
    if (event.kind === NIP71_VIDEO_KIND || event.kind === NIP71_SHORT_KIND) {
        return eventId;
    }

    // Legacy NIP-71 kinds (21/22) also support editing via delete + republish
    if (event.kind === NIP71_VIDEO_KIND_LEGACY || event.kind === NIP71_SHORT_KIND_LEGACY) {
        return eventId;
    }

    // If this is a kind 1 event, check for a linked NIP-71 event
    if (event.kind === 1) {
        const linkedId = videoEventLinks.get(eventId);
        if (linkedId) {
            const linkedEvent = allEvents.get(linkedId);
            if (linkedEvent && isNip71Kind(linkedEvent.kind)) {
                return linkedId;
            }
        }
    }

    // No editable event found (legacy kind 1 without NIP-71 counterpart)
    return null;
}

// Merge reactions from multiple event IDs into a single result
// Used when we have both kind 1 and kind 21/22 events for the same video
function mergeReactionsForLinkedEvents(primaryEventId, reactionsByEventId) {
    const mergedUserReactions = new Map();

    // Get all linked event IDs
    const allIds = getAllLinkedEventIds(primaryEventId);

    // Merge reactions from all linked events
    for (const eventId of allIds) {
        const reactions = reactionsByEventId.get(eventId);
        if (reactions) {
            for (const [userPubkey, reactionData] of reactions) {
                const existing = mergedUserReactions.get(userPubkey);
                // Keep the most recent reaction from each user
                if (!existing || existing.timestamp < reactionData.timestamp) {
                    mergedUserReactions.set(userPubkey, reactionData);
                }
            }
        }
    }

    return mergedUserReactions;
}

// Calculate merged reaction counts for a video
function getMergedReactionCounts(primaryEventId, reactionsByEventId) {
    const mergedReactions = mergeReactionsForLinkedEvents(primaryEventId, reactionsByEventId);

    let likes = 0;
    let dislikes = 0;
    let userReaction = null;

    for (const [userPubkey, reactionData] of mergedReactions) {
        if (reactionData.reaction === '👍') {
            likes++;
        } else if (reactionData.reaction === '👎') {
            dislikes++;
        }

        // Track current user's reaction
        if (currentUser && userPubkey === currentUser.pubkey) {
            userReaction = reactionData.reaction === '👍' ? 'like' : reactionData.reaction === '👎' ? 'dislike' : null;
        }
    }

    return { likes, dislikes, userReaction };
}

// ===== DRAFT MANAGEMENT (NIP-78 kind 30078) =====

// NIP-78 Application Data kind for storing drafts
const NIP78_APP_DATA_KIND = 30078;
const DRAFT_APP_IDENTIFIER = 'plebs/video-draft';

// Save video draft to localStorage and optionally to Nostr (NIP-78)
async function saveDraft(draftData, saveToNostr = false) {
    const drafts = getDrafts();
    const draftId = draftData.id || `draft-${Date.now()}`;

    const draft = {
        ...draftData,
        id: draftId,
        updatedAt: Date.now()
    };

    drafts[draftId] = draft;
    localStorage.setItem(DRAFTS_STORAGE_KEY, JSON.stringify(drafts));

    // Save to Nostr if user is logged in and saveToNostr is enabled
    if (saveToNostr && currentUser) {
        try {
            await saveDraftToNostr(draft);
        } catch (e) {
            console.error('Failed to save draft to Nostr:', e);
            // Don't fail - local save succeeded
        }
    }

    return draftId;
}

// Save draft to Nostr using NIP-78 (kind 30078)
async function saveDraftToNostr(draftData) {
    if (!currentUser) {
        throw new Error('Not logged in');
    }

    const dTag = `${DRAFT_APP_IDENTIFIER}/${draftData.id}`;

    const event = {
        kind: NIP78_APP_DATA_KIND,
        tags: [
            ['d', dTag],
            ['t', 'video-draft'],
            ['client', 'Plebs']
        ],
        content: JSON.stringify(draftData),
        created_at: Math.floor(Date.now() / 1000)
    };

    const signedEvent = await signEvent(event);
    const published = await publishEvent(signedEvent);

    if (!published) {
        throw new Error('Failed to publish draft to relays');
    }

    return signedEvent.id;
}

// Get all drafts from localStorage
function getDrafts() {
    try {
        const draftsJson = localStorage.getItem(DRAFTS_STORAGE_KEY);
        return draftsJson ? JSON.parse(draftsJson) : {};
    } catch (e) {
        console.error('Failed to load drafts:', e);
        return {};
    }
}

// Load drafts from Nostr (NIP-78) and merge with localStorage
async function loadDraftsFromNostr() {
    if (!currentUser) return {};

    const filter = {
        kinds: [NIP78_APP_DATA_KIND],
        authors: [currentUser.pubkey],
        '#t': ['video-draft']
    };

    const nostrDrafts = {};

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            try {
                const draftData = JSON.parse(event.content);
                const dTag = event.tags.find(t => t[0] === 'd')?.[1] || '';
                const draftId = dTag.replace(`${DRAFT_APP_IDENTIFIER}/`, '');

                if (draftId && draftData) {
                    // Use event timestamp for ordering
                    draftData.updatedAt = event.created_at * 1000;
                    draftData.nostrEventId = event.id;
                    nostrDrafts[draftId] = draftData;
                }
            } catch (e) {
                console.error('Failed to parse draft from Nostr:', e);
            }
        }, () => {
            // Merge with localStorage drafts
            const localDrafts = getDrafts();
            const mergedDrafts = { ...localDrafts };

            for (const [draftId, nostrDraft] of Object.entries(nostrDrafts)) {
                const localDraft = localDrafts[draftId];
                // Use the more recent version
                if (!localDraft || (nostrDraft.updatedAt > localDraft.updatedAt)) {
                    mergedDrafts[draftId] = nostrDraft;
                }
            }

            // Save merged drafts to localStorage
            localStorage.setItem(DRAFTS_STORAGE_KEY, JSON.stringify(mergedDrafts));

            resolve(mergedDrafts);
        });
    });
}

// Get a single draft by ID
function getDraft(draftId) {
    const drafts = getDrafts();
    return drafts[draftId] || null;
}

// Delete a draft from localStorage and optionally from Nostr
async function deleteDraft(draftId, deleteFromNostr = false) {
    const drafts = getDrafts();
    const draft = drafts[draftId];

    delete drafts[draftId];
    localStorage.setItem(DRAFTS_STORAGE_KEY, JSON.stringify(drafts));

    // Delete from Nostr by publishing a deletion event
    if (deleteFromNostr && currentUser && draft?.nostrEventId) {
        try {
            await deleteDraftFromNostr(draftId, draft.nostrEventId);
        } catch (e) {
            console.error('Failed to delete draft from Nostr:', e);
            // Don't fail - local delete succeeded
        }
    }
}

// Delete draft from Nostr using NIP-09 deletion
async function deleteDraftFromNostr(draftId, nostrEventId) {
    if (!currentUser) return;

    const dTag = `${DRAFT_APP_IDENTIFIER}/${draftId}`;

    const deleteEvent = {
        kind: 5,
        tags: [
            ['e', nostrEventId],
            ['a', `${NIP78_APP_DATA_KIND}:${currentUser.pubkey}:${dTag}`]
        ],
        content: 'Draft deleted',
        created_at: Math.floor(Date.now() / 1000)
    };

    const signedEvent = await signEvent(deleteEvent);
    await publishEvent(signedEvent);
}

// ===== VIEW TRACKING (NIP-78 kind 30078) =====
// Track video views using NIP-78 application-specific data
// Views are aggregated per video, stored as replaceable events by each viewer
// Supports both logged-in users and anonymous viewers (using ephemeral keys)

// Get canonical d-tag for a video event
function getVideoCanonicalDTag(videoEventId) {
    const event = allEvents.get(videoEventId);
    if (!event) return null;

    // Get all linked event IDs for this video
    const allLinkedIds = getAllLinkedEventIds(videoEventId);

    // Get the canonical d-tag for this video (prefer from addressable event)
    let canonicalDTag = null;
    for (const id of allLinkedIds) {
        const linkedEvent = allEvents.get(id);
        if (linkedEvent && (linkedEvent.kind === NIP71_VIDEO_KIND || linkedEvent.kind === NIP71_SHORT_KIND)) {
            canonicalDTag = linkedEvent.tags?.find(t => t[0] === 'd')?.[1];
            if (canonicalDTag) break;
        }
    }

    // Fall back to nip71-d tag or event id
    if (!canonicalDTag) {
        canonicalDTag = event.tags?.find(t => t[0] === 'nip71-d')?.[1] ||
            event.tags?.find(t => t[0] === 'd')?.[1] ||
            videoEventId;
    }

    return canonicalDTag;
}

// Record a view for a video (works for both logged-in and anonymous users)
async function recordVideoView(videoEventId) {
    const event = allEvents.get(videoEventId);
    if (!event) return;

    const canonicalDTag = getVideoCanonicalDTag(videoEventId);
    if (!canonicalDTag) return;

    const now = Date.now();
    const isLoggedIn = currentUser;

    // Create view key for deduplication (different for logged-in vs anonymous)
    const viewKey = isLoggedIn
        ? `view_${canonicalDTag}_${currentUser.pubkey}`
        : `anon_view_${canonicalDTag}`;

    // Check if already viewed recently (within 24 hours)
    const lastView = localStorage.getItem(viewKey);
    if (lastView && (now - parseInt(lastView)) < 24 * 60 * 60 * 1000) {
        return; // Already viewed recently
    }

    // Record view locally to prevent duplicate publishing
    localStorage.setItem(viewKey, now.toString());

    // Build view event
    const viewEvent = {
        kind: VIEW_EVENT_KIND,
        tags: [
            ['d', `${VIEW_TRACKING_APP_ID}/${canonicalDTag}`],
            ['t', 'video-view'],
            ['e', videoEventId],
            ['p', event.pubkey],
            ['client', 'Plebs']
        ],
        content: JSON.stringify({
            viewedAt: Math.floor(now / 1000),
            videoId: videoEventId,
            videoDTag: canonicalDTag
        }),
        created_at: Math.floor(now / 1000)
    };

    try {
        if (isLoggedIn) {
            // Logged-in user: sign with their key
            const signedEvent = await signEvent(viewEvent);
            await publishEvent(signedEvent);
        } else {
            // Anonymous user: generate ephemeral keypair and sign
            const sk = window.NostrTools.generateSecretKey();
            const signedViewEvent = window.NostrTools.finalizeEvent(viewEvent, sk);

            await publishEvent(signedViewEvent);
        }
    } catch (e) {
        console.error('Failed to record view:', e);
    }
}

// Record video share when share modal is opened
async function recordVideoShare(videoEventId) {
    const event = allEvents.get(videoEventId);
    if (!event) return;

    const canonicalDTag = getVideoCanonicalDTag(videoEventId);
    if (!canonicalDTag) return;

    // Only record shares for logged-in users
    if (!currentUser) return;

    const now = Date.now();

    // Create share key for deduplication (once per 24 hours per video per user)
    const shareKey = `share_${canonicalDTag}_${currentUser.pubkey}`;

    // Check if already shared recently (within 24 hours)
    const lastShare = localStorage.getItem(shareKey);
    if (lastShare && (now - parseInt(lastShare)) < 24 * 60 * 60 * 1000) {
        return; // Already shared recently
    }

    // Record share locally to prevent duplicate publishing
    localStorage.setItem(shareKey, now.toString());

    // Build share event
    const shareEvent = {
        kind: VIEW_EVENT_KIND,
        tags: [
            ['d', `${VIEW_TRACKING_APP_ID}/share/${canonicalDTag}`],
            ['t', 'video-share'],
            ['e', videoEventId],
            ['p', event.pubkey],
            ['client', 'Plebs']
        ],
        content: JSON.stringify({
            sharedAt: Math.floor(now / 1000),
            videoId: videoEventId,
            videoDTag: canonicalDTag
        }),
        created_at: Math.floor(now / 1000)
    };

    try {
        const signedEvent = await signEvent(shareEvent);
        await publishEvent(signedEvent);
    } catch (e) {
        console.error('Failed to record share:', e);
    }
}

// Record channel follow event for analytics tracking
async function recordChannelFollow(channelPubkey) {
    if (!currentUser) return;

    const now = Date.now();

    // Create unique follow event (one per channel per user, can be replaced)
    const followEvent = {
        kind: VIEW_EVENT_KIND,
        tags: [
            ['d', `${VIEW_TRACKING_APP_ID}/follow/${channelPubkey}`],
            ['t', 'channel-follow'],
            ['p', channelPubkey],
            ['client', 'Plebs']
        ],
        content: JSON.stringify({
            action: 'follow',
            followedAt: Math.floor(now / 1000),
            channelPubkey: channelPubkey
        }),
        created_at: Math.floor(now / 1000)
    };

    try {
        const signedEvent = await signEvent(followEvent);
        await publishEvent(signedEvent);
    } catch (e) {
        console.error('Failed to record follow:', e);
    }
}

// Record channel unfollow event for analytics tracking
async function recordChannelUnfollow(channelPubkey) {
    if (!currentUser) return;

    const now = Date.now();

    // Create unfollow event (separate from follow to track history)
    const unfollowEvent = {
        kind: VIEW_EVENT_KIND,
        tags: [
            ['d', `${VIEW_TRACKING_APP_ID}/unfollow/${channelPubkey}/${Math.floor(now / 1000)}`],
            ['t', 'channel-unfollow'],
            ['p', channelPubkey],
            ['client', 'Plebs']
        ],
        content: JSON.stringify({
            action: 'unfollow',
            unfollowedAt: Math.floor(now / 1000),
            channelPubkey: channelPubkey
        }),
        created_at: Math.floor(now / 1000)
    };

    try {
        const signedEvent = await signEvent(unfollowEvent);
        await publishEvent(signedEvent);
    } catch (e) {
        console.error('Failed to record unfollow:', e);
    }
}

// Load aggregated view count for a video with pagination support
// Handles relay limits by paginating through older events
async function loadVideoViews(videoEventId) {
    // Check TTL cache first
    const cached = getCachedViewCount(videoEventId);
    if (cached !== null) {
        return cached;
    }

    // Check if there's already an in-flight request for this video
    if (pendingViewRequests.has(videoEventId)) {
        return pendingViewRequests.get(videoEventId);
    }

    // Create the actual fetch promise
    const fetchPromise = (async () => {
        try {
            // Get all linked event IDs
            const allLinkedIds = getAllLinkedEventIds(videoEventId);
            const viewers = new Set(); // Track unique viewers from Nostr

            // Pagination settings
            const PAGE_SIZE = 500; // Request up to 500 at a time
            const MAX_PAGES = 10; // Safety limit to prevent infinite loops
            let until = undefined; // Start from most recent
            let page = 0;
            let hasMore = true;

            while (hasMore && page < MAX_PAGES) {
                const filter = {
                    kinds: [VIEW_EVENT_KIND],
                    '#e': allLinkedIds,
                    '#t': ['video-view'],
                    limit: PAGE_SIZE
                };

                if (until !== undefined) {
                    filter.until = until;
                }

                const pageEvents = await new Promise((resolve) => {
                    const events = [];
                    requestEventsStream(filter, (event) => {
                        events.push(event);
                        viewers.add(event.pubkey);
                    }, () => {
                        resolve(events);
                    });
                });

                // Check if we got a full page (might be more)
                if (pageEvents.length >= PAGE_SIZE) {
                    // Find oldest timestamp for next page
                    const oldestTimestamp = Math.min(...pageEvents.map(e => e.created_at));
                    until = oldestTimestamp - 1;
                    page++;
                } else {
                    // Got less than a full page, we're done
                    hasMore = false;
                }
            }

            const viewCount = viewers.size;
            // Cache for all linked IDs with TTL
            allLinkedIds.forEach(id => setCachedViewCount(id, viewCount));
            return viewCount;
        } finally {
            // Clean up pending request
            pendingViewRequests.delete(videoEventId);
        }
    })();

    // Store the pending request
    pendingViewRequests.set(videoEventId, fetchPromise);
    return fetchPromise;
}

// Batch load views for multiple videos and update UI
// Uses pagination to handle relay limits
async function loadViewsForVideos(videoIds, updateUI = false) {
    const viewCounts = new Map();

    // Check cache and pending requests first
    const uncachedIds = [];
    const pendingPromises = [];

    videoIds.forEach(id => {
        const cached = getCachedViewCount(id);
        if (cached !== null) {
            viewCounts.set(id, cached);
        } else if (pendingViewRequests.has(id)) {
            // Wait for existing in-flight request
            pendingPromises.push(
                pendingViewRequests.get(id).then(count => {
                    viewCounts.set(id, count);
                })
            );
        } else {
            uncachedIds.push(id);
        }
    });

    // Wait for any pending requests to complete first
    if (pendingPromises.length > 0) {
        await Promise.all(pendingPromises);
    }

    if (uncachedIds.length === 0) {
        if (updateUI) updateViewCountsInUI(viewCounts);
        return viewCounts;
    }

    // Expand uncached video IDs to include linked events
    const primaryToLinked = new Map();
    const linkedToPrimary = new Map();
    const allLinkedIds = new Set();

    // Create a shared promise that will resolve with all view counts
    // This allows individual loadVideoViews calls to await this batch operation
    let resolveBatchPromise;
    const batchPromise = new Promise(resolve => {
        resolveBatchPromise = resolve;
    });

    uncachedIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        primaryToLinked.set(id, linkedIds);
        linkedIds.forEach(linkedId => {
            linkedToPrimary.set(linkedId, id);
            allLinkedIds.add(linkedId);
        });
        viewCounts.set(id, 0);
        // Register pending request so individual calls wait for this batch
        pendingViewRequests.set(id, batchPromise.then(() => getCachedViewCount(id) || 0));
    });

    const allIdsArray = Array.from(allLinkedIds);

    // Batch fetch views with pagination support
    const BATCH_SIZE = 50; // Video IDs per batch
    const PAGE_SIZE = 500; // Events per page
    const MAX_PAGES = 5; // Max pages per batch
    const batches = [];
    for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
        batches.push(allIdsArray.slice(i, i + BATCH_SIZE));
    }

    const viewersByVideo = new Map();

    try {
        await Promise.all(batches.map(async (batch) => {
            let until = undefined;
            let page = 0;
            let hasMore = true;

            while (hasMore && page < MAX_PAGES) {
                const filter = {
                    kinds: [VIEW_EVENT_KIND],
                    '#e': batch,
                    '#t': ['video-view'],
                    limit: PAGE_SIZE
                };

                if (until !== undefined) {
                    filter.until = until;
                }

                const pageEvents = await new Promise((resolve) => {
                    const events = [];
                    requestEventsStream(filter, (event) => {
                        events.push(event);
                        const videoId = event.tags.find(t => t[0] === 'e')?.[1];
                        if (videoId && allLinkedIds.has(videoId)) {
                            const primaryId = linkedToPrimary.get(videoId);
                            if (primaryId) {
                                if (!viewersByVideo.has(primaryId)) {
                                    viewersByVideo.set(primaryId, new Set());
                                }
                                viewersByVideo.get(primaryId).add(event.pubkey);
                            }
                        }
                    }, () => resolve(events));
                });

                if (pageEvents.length >= PAGE_SIZE) {
                    const oldestTimestamp = Math.min(...pageEvents.map(e => e.created_at));
                    until = oldestTimestamp - 1;
                    page++;
                } else {
                    hasMore = false;
                }
            }
        }));

        // Convert sets to counts and cache
        uncachedIds.forEach(id => {
            const viewers = viewersByVideo.get(id);
            const count = viewers ? viewers.size : 0;

            viewCounts.set(id, count);
            setCachedViewCount(id, count);

            // Also cache for all linked IDs
            const linkedIds = primaryToLinked.get(id) || [id];
            linkedIds.forEach(linkedId => setCachedViewCount(linkedId, count));
        });
    } catch (error) {
        console.error('Error loading batch views:', error);
        // Cache 0 views on error to prevent retries flooding
        uncachedIds.forEach(id => {
            viewCounts.set(id, 0);
            setCachedViewCount(id, 0);
        });
    } finally {
        // Always resolve batch promise and clean up pending requests
        resolveBatchPromise();
        uncachedIds.forEach(id => pendingViewRequests.delete(id));
    }

    if (updateUI) updateViewCountsInUI(viewCounts);
    return viewCounts;
}

// Update view counts in the UI for rendered video cards
function updateViewCountsInUI(viewCounts) {
    viewCounts.forEach((count, eventId) => {
        // Update video cards - always show view count, even if 0
        document.querySelectorAll(`.video-views[data-event-id="${eventId}"]`).forEach(el => {
            el.textContent = ` • ${formatNumber(count)} ${t('stat.views')}`;
        });
        // Update video page view count
        const pageViewEl = document.getElementById(`video-views-${eventId}`);
        if (pageViewEl) {
            pageViewEl.textContent = `${formatNumber(count)} ${t('stat.views')}`;
        }
    });
}

// Toast notification system
const toastQueue = [];
let toastContainer = null;

function showToast(message, type = 'info', duration = 3000) {
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.className = 'toast-container';
        document.body.appendChild(toastContainer);
    }

    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.innerHTML = `
        <span>${message}</span>
    `;
    toastContainer.appendChild(toast);

    setTimeout(() => {
        toast.style.animation = 'toastOut 0.3s ease forwards';
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

// Confirmation modal system
let confirmModalCallback = null;

function showConfirmModal(title, message, onConfirm, options = {}) {
    const modal = document.getElementById('confirmModal');
    const titleEl = document.getElementById('confirmModalTitle');
    const messageEl = document.getElementById('confirmModalMessage');
    const confirmBtn = document.getElementById('confirmModalBtn');

    titleEl.textContent = title;
    messageEl.textContent = message;
    confirmBtn.textContent = options.confirmText || 'Confirm';

    // Add danger class for destructive actions
    if (options.danger) {
        confirmBtn.classList.add('danger');
    } else {
        confirmBtn.classList.remove('danger');
    }

    confirmModalCallback = onConfirm;
    confirmBtn.onclick = () => {
        // Save callback reference before hiding (which clears it)
        const callback = confirmModalCallback;
        hideConfirmModal();
        if (callback) {
            callback();
        }
    };

    modal.classList.add('active');
}

function hideConfirmModal() {
    const modal = document.getElementById('confirmModal');
    modal.classList.remove('active');
    confirmModalCallback = null;
}

function cancelConfirmModal() {
    hideConfirmModal();
}

// Skeleton loader generator
function createSkeletonCard() {
    return `
        <div class="video-card skeleton-card">
            <div class="skeleton skeleton-thumbnail"></div>
            <div class="video-info">
                <div class="skeleton-info">
                    <div class="skeleton skeleton-avatar"></div>
                    <div class="skeleton-details">
                        <div class="skeleton skeleton-text title"></div>
                        <div class="skeleton skeleton-text subtitle"></div>
                        <div class="skeleton skeleton-text small"></div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

// Skeleton loader for short cards (vertical 9:16 aspect ratio)
function createShortSkeletonCard() {
    return `
        <div class="video-card short-card skeleton-card skeleton-short-card">
            <div class="skeleton skeleton-thumbnail"></div>
            <div class="video-info">
                <div class="skeleton-info">
                    <div class="skeleton skeleton-avatar"></div>
                    <div class="skeleton-details">
                        <div class="skeleton skeleton-text title"></div>
                        <div class="skeleton skeleton-text subtitle"></div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function showSkeletonGrid(container, count = 8) {
    let skeletons = '';
    for (let i = 0; i < count; i++) {
        skeletons += createSkeletonCard();
    }
    container.innerHTML = `<div class="video-grid">${skeletons}</div>`;
}

// Skeleton card for following page user cards (vertical layout with centered avatar)
function createSkeletonFollowingUserCard() {
    return `
        <div class="following-user-card skeleton-user-card">
            <div class="skeleton skeleton-user-avatar-large"></div>
            <div class="skeleton skeleton-text skeleton-user-name"></div>
            <div class="skeleton skeleton-text skeleton-user-nip05"></div>
        </div>
    `;
}

// Skeleton card for search page user cards (horizontal layout)
function createSkeletonUserSearchCard() {
    return `
        <div class="user-search-card skeleton-user-card">
            <div class="skeleton skeleton-user-avatar-medium"></div>
            <div class="skeleton-user-info">
                <div class="skeleton skeleton-text skeleton-user-name-wide"></div>
                <div class="skeleton skeleton-text skeleton-user-nip05"></div>
                <div class="skeleton skeleton-text skeleton-user-about"></div>
            </div>
        </div>
    `;
}

// Show skeleton grid for user cards (following page)
function showSkeletonFollowingUsersGrid(container, count = 6) {
    let skeletons = '';
    for (let i = 0; i < count; i++) {
        skeletons += createSkeletonFollowingUserCard();
    }
    container.innerHTML = skeletons;
}

// Show skeleton grid for user cards (search page)
function showSkeletonUserSearchGrid(container, count = 3) {
    let skeletons = '';
    for (let i = 0; i < count; i++) {
        skeletons += createSkeletonUserSearchCard();
    }
    container.innerHTML = skeletons;
}

// Skeleton card for live stream cards
function createLiveStreamSkeletonCard() {
    return `
        <div class="video-card skeleton-card skeleton-live-card">
            <div class="skeleton skeleton-thumbnail">
                <div class="skeleton-live-badge"></div>
                <div class="skeleton-live-viewers"></div>
            </div>
            <div class="video-info">
                <div class="skeleton-info">
                    <div class="skeleton skeleton-avatar"></div>
                    <div class="skeleton-details">
                        <div class="skeleton skeleton-text title"></div>
                        <div class="skeleton skeleton-text subtitle"></div>
                    </div>
                </div>
                <div class="skeleton skeleton-text skeleton-title-large"></div>
                <div class="skeleton skeleton-text small"></div>
            </div>
        </div>
    `;
}

// Show skeleton grid for live stream cards
function showLiveStreamSkeletonGrid(container, count = 4) {
    let skeletons = '';
    for (let i = 0; i < count; i++) {
        skeletons += createLiveStreamSkeletonCard();
    }
    container.innerHTML = skeletons;
}

// Lazy loading with Intersection Observer
let lazyLoadObserver = null;

function initLazyLoading() {
    if (!('IntersectionObserver' in window)) {
        // Fallback: load all images immediately
        return;
    }

    lazyLoadObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const card = entry.target;
                loadLazyCard(card);
            }
        });
    }, {
        rootMargin: '300px',  // Increased for earlier loading
        threshold: 0.01       // Lower threshold to trigger sooner
    });

    // Fallback: periodically check for visible unloaded cards
    setInterval(checkVisibleLazyCards, 1000);
}

// Load a lazy card's media (both thumbnail and preview GIF) with caching
function loadLazyCard(card) {
    if (card.dataset.loaded === 'true') return;

    // Load thumbnail image - use cache if available, otherwise load normally
    const thumbnailImg = card.querySelector('img.thumbnail-img[data-src]');
    if (thumbnailImg && thumbnailImg.dataset.src) {
        const originalUrl = thumbnailImg.dataset.src;
        thumbnailImg.removeAttribute('data-src');
        thumbnailImg.dataset.originalSrc = originalUrl;

        // Use cached blob URL if available, otherwise use original URL
        const cachedUrl = getCachedImageUrl(originalUrl);
        thumbnailImg.src = cachedUrl || originalUrl;
        thumbnailImg.onload = () => {
            thumbnailImg.classList.add('loaded');
            // Cache for future use if not already cached (same-origin only)
            if (!cachedUrl && !isCrossOrigin(originalUrl)) {
                fetchAndCacheImage(originalUrl).catch(() => { });
            }
        };
    }

    // Load preview GIF image - use cache if available, otherwise load normally
    const previewImg = card.querySelector('img.preview-img[data-src]');
    if (previewImg && previewImg.dataset.src) {
        const originalUrl = previewImg.dataset.src;
        previewImg.removeAttribute('data-src');
        previewImg.dataset.originalSrc = originalUrl;

        // Use cached blob URL if available, otherwise use original URL
        const cachedUrl = getCachedImageUrl(originalUrl);
        previewImg.src = cachedUrl || originalUrl;
        previewImg.onload = () => {
            previewImg.classList.add('loaded');
            card.dataset.previewReady = 'true';
            // Cache for future use if not already cached (same-origin only)
            if (!cachedUrl && !isCrossOrigin(originalUrl)) {
                fetchAndCacheImage(originalUrl).catch(() => { });
            }
        };
    }

    // Load video element if no thumbnail (no caching for video sources)
    const video = card.querySelector('video[data-src]');
    if (video && video.dataset.src) {
        video.src = video.dataset.src;
        video.removeAttribute('data-src');
    }

    card.dataset.loaded = 'true';
    if (lazyLoadObserver) {
        lazyLoadObserver.unobserve(card);
    }
}


// Fallback check for cards that might have been missed by IntersectionObserver
function checkVisibleLazyCards() {
    const cards = document.querySelectorAll('.video-card[data-lazy="true"]:not([data-loaded="true"])');
    cards.forEach(card => {
        const rect = card.getBoundingClientRect();
        const isVisible = (
            rect.top < window.innerHeight + 300 &&
            rect.bottom > -300 &&
            rect.left < window.innerWidth + 300 &&
            rect.right > -300
        );
        if (isVisible) {
            loadLazyCard(card);
        }
    });
}

function observeLazyCards() {
    if (!lazyLoadObserver) return;

    document.querySelectorAll('.video-card[data-lazy="true"]:not([data-loaded="true"])').forEach(card => {
        lazyLoadObserver.observe(card);
    });
}

// Image asset cache functions for reusing loaded thumbnails and preview GIFs
// Check if an image URL is already cached and return the blob URL if available
function getCachedImageUrl(originalUrl) {
    if (!originalUrl) return null;
    const cached = imageAssetCache.get(originalUrl);
    if (cached) {
        // Update last accessed time for LRU
        cached.lastAccessed = Date.now();
        return cached.blobUrl;
    }
    return null;
}

// Fetch and cache an image, returning a blob URL for reuse
// Returns null if CORS blocks the request - caller should fall back to direct img src
async function fetchAndCacheImage(url) {
    if (!url) return null;

    // Check if already cached
    const cached = getCachedImageUrl(url);
    if (cached) return cached;

    // Skip URLs that previously failed due to CORS
    if (corsFailedUrls.has(url)) return null;

    try {
        const response = await fetch(url, { mode: 'cors' });
        if (!response.ok) return null;

        const blob = await response.blob();
        const size = blob.size;

        // Evict old entries if needed before adding new one
        evictImageCacheIfNeeded(size);

        const blobUrl = URL.createObjectURL(blob);
        imageAssetCache.set(url, {
            blobUrl,
            size,
            lastAccessed: Date.now()
        });
        imageCacheTotalSize += size;

        return blobUrl;
    } catch (e) {
        // CORS or network error - mark URL to avoid retrying
        // This allows the image to load via <img> tag which doesn't require CORS
        corsFailedUrls.add(url);
        return null;
    }
}

// Evict oldest entries from cache if over limits
function evictImageCacheIfNeeded(incomingSize = 0) {
    // Check if we need to evict based on entry count or size
    while (
        (imageAssetCache.size >= IMAGE_CACHE_MAX_ENTRIES ||
            imageCacheTotalSize + incomingSize > IMAGE_CACHE_MAX_SIZE) &&
        imageAssetCache.size > 0
    ) {
        // Find the least recently accessed entry
        let oldestKey = null;
        let oldestTime = Infinity;

        for (const [key, value] of imageAssetCache) {
            if (value.lastAccessed < oldestTime) {
                oldestTime = value.lastAccessed;
                oldestKey = key;
            }
        }

        if (oldestKey) {
            const entry = imageAssetCache.get(oldestKey);
            if (entry) {
                // Revoke the blob URL to free memory
                URL.revokeObjectURL(entry.blobUrl);
                imageCacheTotalSize -= entry.size;
                imageAssetCache.delete(oldestKey);
            }
        } else {
            break;
        }
    }
}

// Clear the entire image cache (useful on navigation or memory pressure)
function clearImageCache() {
    for (const [, entry] of imageAssetCache) {
        URL.revokeObjectURL(entry.blobUrl);
    }
    imageAssetCache.clear();
    imageCacheTotalSize = 0;
}

// Apply cached image to an img element if available
function applyCachedImage(imgElement, originalUrl) {
    const cachedUrl = getCachedImageUrl(originalUrl);
    if (cachedUrl) {
        imgElement.src = cachedUrl;
        return true;
    }
    return false;
}

// Load image with caching - fetches, caches, and applies to element
async function loadImageWithCache(imgElement, originalUrl, onLoad) {
    if (!originalUrl) return;

    // First check if already cached
    const cachedUrl = getCachedImageUrl(originalUrl);
    if (cachedUrl) {
        imgElement.src = cachedUrl;
        if (onLoad) onLoad();
        return;
    }

    // Try to fetch and cache
    const blobUrl = await fetchAndCacheImage(originalUrl);
    if (blobUrl) {
        imgElement.src = blobUrl;
        if (onLoad) onLoad();
    } else {
        // Fall back to direct URL loading
        imgElement.src = originalUrl;
        imgElement.onload = onLoad;
    }
}

// Check if a URL is cross-origin (different host than current page)
function isCrossOrigin(url) {
    try {
        const urlObj = new URL(url, window.location.origin);
        return urlObj.origin !== window.location.origin;
    } catch {
        return true; // Assume cross-origin if URL parsing fails
    }
}

// Cache an already-loaded image element (called from onload for immediate-load images)
// Only caches same-origin images - cross-origin images rely on browser cache
function cacheLoadedImage(imgElement) {
    const originalUrl = imgElement.dataset.originalSrc;
    if (!originalUrl) return;

    // Skip if already cached
    if (imageAssetCache.has(originalUrl)) return;

    // Skip cross-origin URLs - they can't be fetched due to CORS
    // Browser cache will handle them when loaded via <img> tags
    if (isCrossOrigin(originalUrl)) return;

    // Fetch and cache in background (browser should serve from cache)
    fetchAndCacheImage(originalUrl).catch(() => {
        // Silently ignore cache failures
    });
}

// Relay status indicator UI
let relayStatusDropdownVisible = false;

function createRelayStatusIndicator() {
    // Remove existing indicator if any
    const existing = document.querySelector('.relay-status-indicator');
    if (existing) existing.remove();

    const existingDropdown = document.querySelector('.relay-status-dropdown');
    if (existingDropdown) existingDropdown.remove();

    const indicator = document.createElement('div');
    indicator.className = 'relay-status-indicator';
    indicator.setAttribute('role', 'status');
    indicator.setAttribute('aria-live', 'polite');
    indicator.onclick = toggleRelayStatusDropdown;

    const dropdown = document.createElement('div');
    dropdown.className = 'relay-status-dropdown';
    dropdown.id = 'relayStatusDropdown';

    document.body.appendChild(indicator);
    document.body.appendChild(dropdown);

    updateRelayStatusIndicator();
}

function updateRelayStatusIndicator() {
    const indicator = document.querySelector('.relay-status-indicator');
    if (!indicator) return;

    // Only show read relays in the status indicator (not publish-only relays like sendit)
    const displayRelays = RELAY_URLS;
    let connectedCount = 0;
    let totalLatency = 0;
    let latencyCount = 0;

    displayRelays.forEach(url => {
        const ws = relayConnections[url];
        if (ws && ws.readyState === WebSocket.OPEN) {
            connectedCount++;
            const latency = relayLatency.get(url);
            if (latency) {
                totalLatency += latency;
                latencyCount++;
            }
        }
    });

    const avgLatency = latencyCount > 0 ? Math.round(totalLatency / latencyCount) : null;
    const status = connectedCount === 0 ? 'disconnected' :
        connectedCount < displayRelays.length / 2 ? 'connecting' : 'connected';

    indicator.innerHTML = `
        <span class="status-dot ${status}"></span>
        <span class="relay-count">${connectedCount}/${displayRelays.length}</span>
        ${avgLatency ? `<span class="latency">${avgLatency}ms</span>` : ''}
    `;
    indicator.title = `${connectedCount} of ${displayRelays.length} relays connected`;

    // Update dropdown if visible
    if (relayStatusDropdownVisible) {
        updateRelayStatusDropdown();
    }
}

function toggleRelayStatusDropdown() {
    const dropdown = document.getElementById('relayStatusDropdown');
    if (!dropdown) return;

    relayStatusDropdownVisible = !relayStatusDropdownVisible;
    dropdown.classList.toggle('active', relayStatusDropdownVisible);

    if (relayStatusDropdownVisible) {
        updateRelayStatusDropdown();
    }
}

function updateRelayStatusDropdown() {
    const dropdown = document.getElementById('relayStatusDropdown');
    if (!dropdown) return;

    // Only show read relays in the dropdown (not publish-only relays like sendit)
    const displayRelays = RELAY_URLS;

    let html = '<h4>Relay Connections</h4>';

    displayRelays.forEach(url => {
        const ws = relayConnections[url];
        const isConnected = ws && ws.readyState === WebSocket.OPEN;
        const latency = relayLatency.get(url);
        const latencyClass = latency ? (latency < 200 ? 'fast' : latency < 500 ? 'medium' : 'slow') : '';

        html += `
            <div class="relay-item">
                <span class="relay-url">${url.replace('wss://', '')}</span>
                <div class="relay-info">
                    ${latency ? `<span class="relay-latency ${latencyClass}">${latency}ms</span>` : ''}
                    <span class="status-dot ${isConnected ? 'connected' : 'disconnected'}"></span>
                </div>
            </div>
        `;
    });

    dropdown.innerHTML = html;
}

// Close dropdown when clicking outside
document.addEventListener('click', (e) => {
    if (relayStatusDropdownVisible &&
        !e.target.closest('.relay-status-indicator') &&
        !e.target.closest('.relay-status-dropdown')) {
        relayStatusDropdownVisible = false;
        const dropdown = document.getElementById('relayStatusDropdown');
        if (dropdown) dropdown.classList.remove('active');
    }
});

// Search debouncing
let searchDebounceTimeout = null;
const debouncedSearch = debounce((query) => {
    if (query.length >= 2) {
        // Update URL without adding to history (replaceState instead of pushState)
        const newHash = `#/search/${encodeURIComponent(query)}`;
        if (window.location.hash !== newHash) {
            history.replaceState(null, '', newHash);
        }
        performSearch(query);
    }
}, 300);

function initSearchEnhancements() {
    const searchInput = document.getElementById('searchInput');
    if (!searchInput) return;

    // Add input event for real-time search
    searchInput.addEventListener('input', (e) => {
        const query = e.target.value.trim();
        if (query.length >= 2) {
            debouncedSearch(query);
        }
    });

    // Handle Enter key
    searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            searchVideos();
        }
    });
}

// Touch gesture support for carousel
let touchStartX = 0;
let touchEndX = 0;
let carouselElement = null;

function initCarouselTouchSupport() {
    const container = document.querySelector('.trending-carousel-container');
    if (!container) return;

    container.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        carouselElement = container;
    }, { passive: true });

    container.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        handleCarouselSwipe();
    }, { passive: true });
}

function handleCarouselSwipe() {
    const swipeThreshold = 50;
    const diff = touchStartX - touchEndX;

    if (Math.abs(diff) > swipeThreshold) {
        if (diff > 0) {
            // Swipe left - next slide
            const nextBtn = document.querySelector('.carousel-btn.next');
            if (nextBtn && !nextBtn.disabled) nextBtn.click();
        } else {
            // Swipe right - previous slide
            const prevBtn = document.querySelector('.carousel-btn.prev');
            if (prevBtn && !prevBtn.disabled) prevBtn.click();
        }
    }
}

// Keyboard navigation for video grid
function initKeyboardNavigation() {
    document.addEventListener('keydown', (e) => {
        // Only if not in an input field
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        const focusedCard = document.activeElement.closest('.video-card');
        if (!focusedCard) return;

        const cards = Array.from(document.querySelectorAll('.video-card'));
        const currentIndex = cards.indexOf(focusedCard);

        let newIndex = -1;
        const gridCols = Math.floor(document.querySelector('.video-grid')?.offsetWidth / 280) || 4;

        switch (e.key) {
            case 'ArrowRight':
                newIndex = Math.min(currentIndex + 1, cards.length - 1);
                break;
            case 'ArrowLeft':
                newIndex = Math.max(currentIndex - 1, 0);
                break;
            case 'ArrowDown':
                newIndex = Math.min(currentIndex + gridCols, cards.length - 1);
                break;
            case 'ArrowUp':
                newIndex = Math.max(currentIndex - gridCols, 0);
                break;
            case 'Enter':
                const thumbnail = focusedCard.querySelector('.video-thumbnail');
                if (thumbnail) thumbnail.click();
                return;
        }

        if (newIndex >= 0 && newIndex !== currentIndex) {
            e.preventDefault();
            cards[newIndex].focus();
        }
    });
}

// Add tabindex to video cards for keyboard navigation
function makeCardsKeyboardAccessible() {
    document.querySelectorAll('.video-card:not([tabindex])').forEach((card, index) => {
        card.setAttribute('tabindex', '0');
        card.setAttribute('role', 'article');
        card.setAttribute('aria-label', card.querySelector('.video-title')?.textContent || `Video ${index + 1}`);
    });
}

// Connection retry with exponential backoff
const connectionRetryState = new Map();

async function connectWithRetry(url, maxRetries = 4) {
    let retryCount = connectionRetryState.get(url) || 0;

    if (retryCount >= maxRetries) {
        console.log(`Max retries reached for ${url}, will try again later`);
        connectionRetryState.set(url, 0);
        return null;
    }

    const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s, 8s

    if (retryCount > 0) {
        console.log(`Retry ${retryCount}/${maxRetries} for ${url} after ${delay}ms`);
        await new Promise(resolve => setTimeout(resolve, delay));
    }

    try {
        const ws = await connectToRelay(url);
        connectionRetryState.set(url, 0);
        return ws;
    } catch (error) {
        connectionRetryState.set(url, retryCount + 1);
        return connectWithRetry(url, maxRetries);
    }
}

// Measure relay latency
async function measureRelayLatency(url) {
    const ws = relayConnections[url];
    if (!ws || ws.readyState !== WebSocket.OPEN) return;

    const start = performance.now();
    const testSubId = `latency_${Date.now()}`;

    return new Promise((resolve) => {
        const timeout = setTimeout(() => {
            relayLatency.set(url, 999);
            resolve(999);
        }, 5000);

        const handler = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data[0] === 'EOSE' && data[1] === testSubId) {
                    clearTimeout(timeout);
                    const latency = Math.round(performance.now() - start);
                    relayLatency.set(url, latency);
                    ws.removeEventListener('message', handler);
                    ws.send(JSON.stringify(['CLOSE', testSubId]));
                    resolve(latency);
                }
            } catch (e) { }
        };

        ws.addEventListener('message', handler);
        ws.send(JSON.stringify(['REQ', testSubId, { kinds: [0], limit: 1 }]));
    });
}

// Periodically measure relay latency
function startLatencyMonitoring() {
    // Initial measurement after connections are established
    setTimeout(async () => {
        for (const url of RELAY_URLS) {
            await measureRelayLatency(url);
        }
        updateRelayStatusIndicator();
    }, 5000);

    // Update every 60 seconds
    setInterval(async () => {
        for (const url of RELAY_URLS) {
            await measureRelayLatency(url);
        }
        updateRelayStatusIndicator();
    }, 60000);
}

// Batch DOM updates for better performance
const pendingDOMUpdates = [];
let rafScheduled = false;

function scheduleDOMUpdate(updateFn) {
    pendingDOMUpdates.push(updateFn);

    if (!rafScheduled) {
        rafScheduled = true;
        requestAnimationFrame(() => {
            const updates = [...pendingDOMUpdates];
            pendingDOMUpdates.length = 0;
            rafScheduled = false;

            updates.forEach(fn => fn());
        });
    }
}

// Initialize all performance optimizations
function initPerformanceOptimizations() {
    initLazyLoading();
    initSearchEnhancements();
    initKeyboardNavigation();
    createRelayStatusIndicator();
    startLatencyMonitoring();

    // Initialize touch support after DOM is ready
    setTimeout(() => {
        initCarouselTouchSupport();
        makeCardsKeyboardAccessible();
    }, 1000);
}

// ===== END PERFORMANCE OPTIMIZATIONS =====

// Theme management
function initTheme() {
    const savedTheme = localStorage.getItem('theme');
    let theme;
    if (savedTheme) {
        theme = savedTheme;
    } else {
        // Use system preference if no saved theme
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        theme = prefersDark ? 'dark' : 'light';
    }
    document.documentElement.setAttribute('data-theme', theme);
}

// Handle dark mode toggle from settings modal
function handleDarkModeToggle() {
    const isDark = document.getElementById('darkModeToggle').checked;
    const newTheme = isDark ? 'dark' : 'light';
    setTheme(newTheme);
}

// Set theme and sync to Nostr
function setTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);

    // Sync theme to Nostr if logged in
    if (currentUser && userSettings) {
        userSettings.theme = theme;
        localStorage.setItem('plebsSettings', JSON.stringify(userSettings));
        if (userSettings.saveToNostr) {
            saveSettingsToNostr().catch(err => console.error('Failed to sync theme to Nostr:', err));
        }
    }
}

// Legacy function for backwards compatibility
function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    setTheme(newTheme);
}

// Initialize all relay connections
async function initializeRelayConnections() {
    console.log('Initializing relay connections...');
    const connectionPromises = RELAY_URLS.map(url =>
        connectToRelay(url).catch(err =>
            console.error(`Failed to initialize connection to ${url}:`, err)
        )
    );

    await Promise.allSettled(connectionPromises);
    console.log('Relay initialization complete');
}

// Track relay connection status for UI feedback
let relayStatus = new Map();

// Monitor relay connection health (reduced frequency - event-based reconnection handles immediate cases)
function monitorRelayConnections() {
    // Initial status update
    updateRelayStatus();

    // Less frequent background check since ws.onclose already triggers reconnection
    // Only monitor read relays - publish-only relays (sendit) connect on-demand when needed
    setInterval(() => {
        const relaysToCheck = RELAY_URLS;
        let reconnectAttempts = 0;

        relaysToCheck.forEach(url => {
            const ws = relayConnections[url];
            const isConnected = ws && ws.readyState === WebSocket.OPEN;
            relayStatus.set(url, isConnected ? 'connected' : 'disconnected');

            if (!isConnected && reconnectAttempts < 2) {
                // Limit concurrent reconnection attempts to avoid hammering relays
                reconnectAttempts++;
                console.log(`Connection to ${url} lost, attempting to reconnect...`);
                connectToRelay(url).catch(err =>
                    console.error(`Failed to reconnect to ${url}:`, err)
                );
            }
        });

        updateRelayStatus();
    }, 30000); // Check every 30 seconds (event-based reconnection handles immediate cases)
}

// Update relay status for potential UI display
function updateRelayStatus() {
    const connected = [...relayStatus.values()].filter(s => s === 'connected').length;
    const total = RELAY_URLS.length;
    if (connected < total) {
        console.log(`Relay status: ${connected}/${total} connected`);
    }
}

// Video compression
const VideoCompressor = {
    isAvailable: true,
    compressionInProgress: false,
    calibrationData: null,
    currentMimeType: null,

    async compressVideo(file, options = {}) {
        const { maxSizeMB = 100, onProgress = () => { }, cropToPortrait = false } = options;
        this.cropToPortrait = cropToPortrait; // Store for use in frame drawing

        if (this.compressionInProgress) {
            throw new Error('Compression already in progress');
        }

        const fileSizeMB = file.size / (1024 * 1024);

        // If file is already small enough AND doesn't need cropping, return it
        if (fileSizeMB <= maxSizeMB && !cropToPortrait) {
            console.log('File already meets size requirements');
            return file;
        }

        // If we need cropping, force processing even for small files
        if (cropToPortrait) {
            console.log('File needs cropping to portrait - will process regardless of size');
        }

        this.compressionInProgress = true;
        this.calibrationData = null;

        try {
            onProgress({ stage: 'analyzing', progress: 5 });

            // Get video metadata first
            const metadata = await this.getVideoMetadata(file);
            if (!metadata) {
                throw new Error('Could not read video metadata');
            }

            // Analyze video complexity for better compression predictions
            const complexity = await this.analyzeVideoComplexity(file, metadata);
            metadata.complexity = complexity;

            // Select optimal codec based on browser support and efficiency
            const codecInfo = this.selectOptimalCodec();
            console.log(`Selected codec: ${codecInfo.name} (${codecInfo.mimeType})`);

            // Calculate initial compression settings
            let compressionSettings = this.calculateCompressionSettings(
                fileSizeMB,
                maxSizeMB,
                metadata,
                codecInfo
            );

            onProgress({
                stage: 'preparing',
                progress: 10,
                originalSize: file.size,
                quality: compressionSettings.quality
            });

            // For large files (>500MB), do a calibration pass first
            const needsCalibration = fileSizeMB > 500;
            if (needsCalibration) {
                onProgress({
                    stage: 'calibrating',
                    progress: 12,
                    message: 'Calibrating compression settings...'
                });

                const calibrationResult = await this.runCalibrationPass(
                    file,
                    compressionSettings,
                    metadata,
                    codecInfo
                );

                if (calibrationResult.adjustmentFactor !== 1.0) {
                    console.log(`Calibration adjustment: ${calibrationResult.adjustmentFactor.toFixed(3)}x`);
                    compressionSettings = this.applyCalibration(
                        compressionSettings,
                        calibrationResult,
                        maxSizeMB,
                        metadata
                    );
                }
            }

            // Perform main compression with adaptive bitrate monitoring
            const compressedBlob = await this.performAdaptiveCompression(
                file,
                compressionSettings,
                metadata,
                codecInfo,
                maxSizeMB,
                onProgress
            );

            let compressedSizeMB = compressedBlob.size / (1024 * 1024);
            console.log(`Compressed blob size: ${compressedBlob.size} bytes (${compressedSizeMB.toFixed(2)} MB)`);

            // If still too large, use intelligent retry with adjusted parameters
            if (compressedSizeMB > maxSizeMB) {
                const retryResult = await this.intelligentRetry(
                    file,
                    compressedSizeMB,
                    maxSizeMB,
                    metadata,
                    codecInfo,
                    compressionSettings,
                    onProgress
                );

                if (retryResult) {
                    return retryResult;
                }

                throw new Error(
                    `Unable to compress video to under ${maxSizeMB}MB. ` +
                    `Final size: ${compressedSizeMB.toFixed(1)}MB. ` +
                    `Consider using a shorter video or lower resolution.`
                );
            }

            const mimeType = this.currentMimeType || codecInfo.mimeType.split(';')[0];
            const extension = mimeType.includes('mp4') ? '.mp4' : '.webm';

            const compressedFile = new File(
                [compressedBlob],
                file.name.replace(/\.[^/.]+$/, extension),
                { type: mimeType }
            );

            onProgress({
                stage: 'complete',
                progress: 100,
                originalSize: file.size,
                compressedSize: compressedFile.size,
                compressionRatio: compressedFile.size / file.size,
                quality: compressionSettings.quality,
                outputFormat: mimeType
            });

            return compressedFile;

        } catch (error) {
            console.error('Video compression failed:', error);
            throw error;
        } finally {
            this.compressionInProgress = false;
            this.currentMimeType = null;
            this.calibrationData = null;
            window.userSelectedQuality = null;
        }
    },

    // Analyze video complexity by sampling frames
    async analyzeVideoComplexity(file, metadata) {
        return new Promise((resolve) => {
            const video = document.createElement('video');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            video.muted = true;
            video.preload = 'auto';

            const videoUrl = URL.createObjectURL(file);
            let complexityScores = [];
            let samplesCollected = 0;
            const targetSamples = Math.min(10, Math.max(3, Math.floor(metadata.duration / 30)));
            const sampleInterval = metadata.duration / (targetSamples + 1);

            video.onloadeddata = async () => {
                canvas.width = Math.min(320, video.videoWidth);
                canvas.height = Math.round(canvas.width * (video.videoHeight / video.videoWidth));

                const collectSample = () => {
                    return new Promise((res) => {
                        if (samplesCollected >= targetSamples) {
                            res();
                            return;
                        }

                        const seekTime = sampleInterval * (samplesCollected + 1);
                        video.currentTime = Math.min(seekTime, metadata.duration - 0.5);

                        video.onseeked = () => {
                            try {
                                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                                const complexity = this.calculateFrameComplexity(imageData);
                                complexityScores.push(complexity);
                            } catch (e) {
                                console.warn('Frame analysis error:', e);
                            }
                            samplesCollected++;
                            res();
                        };
                    });
                };

                // Collect samples sequentially
                for (let i = 0; i < targetSamples; i++) {
                    await collectSample();
                }

                URL.revokeObjectURL(videoUrl);
                video.remove();

                if (complexityScores.length === 0) {
                    resolve({ score: 0.5, type: 'unknown' });
                    return;
                }

                // Calculate average complexity
                const avgComplexity = complexityScores.reduce((a, b) => a + b, 0) / complexityScores.length;
                const variance = complexityScores.reduce((sum, c) => sum + Math.pow(c - avgComplexity, 2), 0) / complexityScores.length;

                // Classify video type
                let type = 'mixed';
                if (avgComplexity < 0.2 && variance < 0.01) {
                    type = 'static'; // Screencast, presentation
                } else if (avgComplexity > 0.6 || variance > 0.05) {
                    type = 'dynamic'; // Action, sports, fast motion
                } else if (avgComplexity < 0.4) {
                    type = 'talking-head'; // Vlogs, interviews
                }

                console.log(`Video complexity: ${avgComplexity.toFixed(3)} (${type}), variance: ${variance.toFixed(4)}`);

                resolve({
                    score: avgComplexity,
                    variance: variance,
                    type: type,
                    samples: complexityScores.length
                });
            };

            video.onerror = () => {
                URL.revokeObjectURL(videoUrl);
                resolve({ score: 0.5, type: 'unknown' });
            };

            // Timeout after 15 seconds
            setTimeout(() => {
                if (complexityScores.length > 0) {
                    URL.revokeObjectURL(videoUrl);
                    const avgComplexity = complexityScores.reduce((a, b) => a + b, 0) / complexityScores.length;
                    resolve({ score: avgComplexity, type: 'unknown', samples: complexityScores.length });
                } else {
                    resolve({ score: 0.5, type: 'unknown' });
                }
            }, 15000);

            video.src = videoUrl;
        });
    },

    // Calculate complexity of a single frame using edge detection approximation
    calculateFrameComplexity(imageData) {
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;
        let totalDiff = 0;
        let samples = 0;

        // Sample pixels and calculate local variance (edge detection approximation)
        const step = 4; // Sample every 4th pixel for speed
        for (let y = 1; y < height - 1; y += step) {
            for (let x = 1; x < width - 1; x += step) {
                const idx = (y * width + x) * 4;
                const idxRight = (y * width + x + 1) * 4;
                const idxDown = ((y + 1) * width + x) * 4;

                // Calculate luminance differences
                const lum = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;
                const lumRight = data[idxRight] * 0.299 + data[idxRight + 1] * 0.587 + data[idxRight + 2] * 0.114;
                const lumDown = data[idxDown] * 0.299 + data[idxDown + 1] * 0.587 + data[idxDown + 2] * 0.114;

                totalDiff += Math.abs(lum - lumRight) + Math.abs(lum - lumDown);
                samples++;
            }
        }

        // Normalize to 0-1 range (255 * 2 is max possible diff per sample)
        return Math.min(1, (totalDiff / samples) / 100);
    },

    // Check if browser supports iOS-compatible encoding (H.264/MP4)
    checkiOSCompatibility() {
        const h264Types = [
            'video/mp4;codecs="avc1.64001F"',
            'video/mp4;codecs="avc1.640028"',
            'video/mp4;codecs="avc1.4D401F"',
            'video/mp4;codecs="avc1.4D4028"',
            'video/mp4;codecs="avc1.42E01E"',
            'video/mp4;codecs="avc1.42001E"',
            'video/mp4;codecs=avc1',
            'video/mp4'
        ];

        for (const type of h264Types) {
            if (MediaRecorder.isTypeSupported(type)) {
                return { supported: true, codec: type };
            }
        }

        return { supported: false, codec: null };
    },

    // Select optimal codec based on browser support and compatibility
    // Prioritizes H.264/MP4 for universal playback (iOS, Android, web)
    selectOptimalCodec() {
        const codecs = [
            // H.264 High Profile - best quality H.264, widely supported
            { name: 'H.264 High', mimeType: 'video/mp4;codecs="avc1.64001F"', efficiency: 1.2, iosCompatible: true },
            { name: 'H.264 High', mimeType: 'video/mp4;codecs="avc1.640028"', efficiency: 1.2, iosCompatible: true },
            // H.264 Main Profile
            { name: 'H.264 Main', mimeType: 'video/mp4;codecs="avc1.4D401F"', efficiency: 1.1, iosCompatible: true },
            { name: 'H.264 Main', mimeType: 'video/mp4;codecs="avc1.4D4028"', efficiency: 1.1, iosCompatible: true },
            // H.264 Baseline - most compatible across all devices
            { name: 'H.264 Baseline', mimeType: 'video/mp4;codecs="avc1.42E01E"', efficiency: 1.0, iosCompatible: true },
            { name: 'H.264 Baseline', mimeType: 'video/mp4;codecs="avc1.42001E"', efficiency: 1.0, iosCompatible: true },
            { name: 'H.264', mimeType: 'video/mp4;codecs=avc1', efficiency: 1.0, iosCompatible: true },
            { name: 'H.264', mimeType: 'video/mp4', efficiency: 1.0, iosCompatible: true },
            // WebM/VP9 fallback only if H.264 not available (won't play on iOS)
            { name: 'VP9', mimeType: 'video/webm;codecs=vp9', efficiency: 1.4, iosCompatible: false },
            { name: 'VP8', mimeType: 'video/webm;codecs=vp8', efficiency: 0.9, iosCompatible: false },
            { name: 'WebM', mimeType: 'video/webm', efficiency: 0.85, iosCompatible: false }
        ];

        for (const codec of codecs) {
            if (MediaRecorder.isTypeSupported(codec.mimeType)) {
                const isIosCompatible = codec.iosCompatible !== false;
                console.log(`Selected codec: ${codec.name} (${codec.mimeType})`);
                console.log(`iOS compatible: ${isIosCompatible}`);

                // Store iOS compatibility flag for UI warnings
                this.lastCodecIosCompatible = isIosCompatible;

                if (!isIosCompatible) {
                    console.warn('WARNING: This browser does not support H.264 encoding.');
                    console.warn('Compressed videos will be in WebM format which may not play on iOS devices.');
                    console.warn('For iOS-compatible uploads, use Chrome on Windows or macOS.');
                }

                return codec;
            }
        }

        // Ultimate fallback - warn about compatibility
        console.warn('No H.264 codec available, falling back to WebM (will not play on iOS)');
        this.lastCodecIosCompatible = false;
        return { name: 'Default', mimeType: 'video/webm', efficiency: 0.8, iosCompatible: false };
    },

    calculateCompressionSettings(fileSizeMB, maxSizeMB, metadata, codecInfo) {
        const duration = metadata.duration;
        const complexity = metadata.complexity || { score: 0.5, type: 'mixed' };

        let settings = {
            quality: 'high',
            scale: 1,
            fps: 30,
            bitrate: 2000000
        };

        // Always use high quality - UI no longer allows selection
        const userQuality = window.userSelectedQuality || window.suggestedCompressionQuality || 'high';

        // Codec efficiency adjustment
        const codecEfficiency = codecInfo.efficiency || 1.0;

        // Calculate required compression ratio
        const compressionRatio = fileSizeMB / maxSizeMB;

        // Improved quality tiers with better scaling for large files
        const getQualitySettings = (quality, sizeMB, complexity) => {
            // Base quality parameters - improved for large files
            const qualityBase = {
                'ultra-low': {
                    scaleMin: 0.20, scaleMax: 0.45,
                    fpsMin: 15, fpsMax: 24,
                    bitrateMultiplier: 0.5
                },
                'low': {
                    scaleMin: 0.28, scaleMax: 0.55,
                    fpsMin: 20, fpsMax: 30,
                    bitrateMultiplier: 0.65
                },
                'medium': {
                    scaleMin: 0.35, scaleMax: 0.70,
                    fpsMin: 24, fpsMax: 30,
                    bitrateMultiplier: 0.8
                },
                'high': {
                    scaleMin: 0.45, scaleMax: 0.90,
                    fpsMin: 24, fpsMax: 30,
                    bitrateMultiplier: 1.0
                }
            };

            const params = qualityBase[quality] || qualityBase['medium'];

            // Scale based on file size - use logarithmic scaling for very large files
            // This prevents overly aggressive reduction for huge files
            const sizeFactorLog = Math.log10(Math.max(100, sizeMB)) / Math.log10(2000);
            const sizeFactor = Math.max(0, Math.min(1, 1 - sizeFactorLog));

            // Adjust for video complexity
            let complexityAdjust = 1.0;
            if (complexity.type === 'static') {
                complexityAdjust = 1.15; // Can use higher scale for static content
            } else if (complexity.type === 'dynamic') {
                complexityAdjust = 0.9; // Need more headroom for motion
            }

            const scale = params.scaleMin + (params.scaleMax - params.scaleMin) * sizeFactor * complexityAdjust;

            // FPS: prioritize keeping FPS high, reduce resolution instead
            let fps = params.fpsMax;
            if (sizeMB > 2000) {
                fps = Math.max(params.fpsMin, params.fpsMax - 6);
            } else if (sizeMB > 1000) {
                fps = Math.max(params.fpsMin, params.fpsMax - 3);
            }

            // Snap FPS to standard values
            if (fps >= 28) fps = 30;
            else if (fps >= 22) fps = 24;
            else if (fps >= 18) fps = 20;
            else fps = Math.max(15, Math.round(fps));

            return {
                scale: Math.max(params.scaleMin, Math.min(params.scaleMax, scale)),
                fps: fps,
                bitrateMultiplier: params.bitrateMultiplier
            };
        };

        // Calculate target size with safety margin
        const getTargetSize = (quality, sizeMB, duration) => {
            // Base targets adjusted for codec efficiency
            const baseTargets = {
                'ultra-low': 75 * codecEfficiency,
                'low': 82 * codecEfficiency,
                'medium': 88 * codecEfficiency,
                'high': 94 * codecEfficiency
            };

            let targetSize = baseTargets[quality] || 85;

            // Safety margin based on file size (larger files need more margin)
            const safetyMargin = Math.max(0.90, 0.98 - (sizeMB / 20000));
            targetSize *= safetyMargin;

            // Duration-based adjustment
            if (duration > 7200) { // > 2 hours
                targetSize *= 0.92;
            } else if (duration > 3600) { // > 1 hour
                targetSize *= 0.95;
            } else if (duration > 1800) { // > 30 min
                targetSize *= 0.97;
            }

            return Math.min(maxSizeMB * 0.98, Math.floor(targetSize));
        };

        // Improved bitrate calculation
        const calculateOptimalBitrate = (targetSizeMB, duration, scale, complexity) => {
            const audioBitrate = 64000; // 64 kbps
            const audioSizeMB = (audioBitrate * duration) / (8 * 1024 * 1024);
            const videoTargetSizeMB = Math.max(targetSizeMB - audioSizeMB, targetSizeMB * 0.85);

            // Base bitrate calculation
            const baseBitrate = (videoTargetSizeMB * 8 * 1024 * 1024) / duration;

            // MediaRecorder compensation - learned from actual behavior
            // VP9 is more predictable, H.264 varies more
            let compensation;
            if (codecInfo.name.includes('VP9')) {
                compensation = 1.3 + (0.4 * (1 - codecEfficiency));
            } else if (codecInfo.name.includes('H.264')) {
                // H.264 in MediaRecorder often overshoots by 1.5-2.5x
                compensation = 1.8 + (fileSizeMB / 3000);
            } else {
                compensation = 2.2 + (fileSizeMB / 2500);
            }

            // Apply calibration data if available
            if (this.calibrationData && this.calibrationData.adjustmentFactor) {
                compensation *= this.calibrationData.adjustmentFactor;
            }

            // Complexity adjustment
            let complexityMultiplier = 1.0;
            if (complexity.type === 'static') {
                complexityMultiplier = 0.7; // Static content compresses better
            } else if (complexity.type === 'dynamic') {
                complexityMultiplier = 1.2; // Dynamic content needs more bits
            } else if (complexity.type === 'talking-head') {
                complexityMultiplier = 0.85;
            }

            const compensatedBitrate = baseBitrate * compensation * complexityMultiplier;

            // Resolution-based bounds
            const pixels = Math.pow(scale, 2); // Approximate pixel ratio
            const minBitrate = pixels * 300000; // Minimum quality floor
            const maxBitrate = pixels * 8000000; // Reasonable maximum

            return Math.max(minBitrate, Math.min(maxBitrate, compensatedBitrate));
        };

        // Apply calculations
        const qualitySettings = getQualitySettings(userQuality, fileSizeMB, complexity);
        const targetSizeMB = getTargetSize(userQuality, fileSizeMB, duration);

        settings.quality = userQuality;
        settings.scale = qualitySettings.scale;
        settings.fps = qualitySettings.fps;
        settings.bitrate = calculateOptimalBitrate(
            targetSizeMB,
            duration,
            settings.scale,
            complexity
        );

        // Apply extreme compression ratio adjustments (but less aggressive than before)
        if (compressionRatio > 30) {
            settings.scale *= 0.88;
            settings.bitrate *= 0.7;
            console.log('Applied extreme compression adjustment (>30x ratio)');
        } else if (compressionRatio > 20) {
            settings.scale *= 0.92;
            settings.bitrate *= 0.8;
        } else if (compressionRatio > 10) {
            settings.scale *= 0.96;
            settings.bitrate *= 0.9;
        }

        // Ensure minimum quality thresholds
        const minScale = userQuality === 'ultra-low' ? 0.18 : 0.25;
        settings.scale = Math.max(minScale, settings.scale);

        // CRITICAL: Verify expected output size is under target and adjust if needed
        const audioBitrate = 64000; // 64 kbps audio
        const audioSizeMB = (audioBitrate * duration) / (8 * 1024 * 1024);

        const calculateExpectedSize = (bitrate) => {
            const videoBitrateMbps = bitrate / 1000000;
            const videoSizeMB = (videoBitrateMbps * duration * 1000000) / (8 * 1024 * 1024);
            return videoSizeMB + audioSizeMB;
        };

        let expectedSizeMB = calculateExpectedSize(settings.bitrate);
        const hardLimit = maxSizeMB * 0.95; // 95MB for 100MB target - leave safety margin
        let adjustmentIterations = 0;

        // If expected size exceeds target, reduce bitrate iteratively
        while (expectedSizeMB > hardLimit && adjustmentIterations < 10) {
            const reduction = hardLimit / expectedSizeMB;
            settings.bitrate = Math.round(settings.bitrate * reduction * 0.92); // Extra 8% safety
            expectedSizeMB = calculateExpectedSize(settings.bitrate);
            adjustmentIterations++;
            console.log(`Bitrate adjustment ${adjustmentIterations}: ${(settings.bitrate / 1000000).toFixed(2)} Mbps → expected ${expectedSizeMB.toFixed(1)}MB`);
        }

        // If still over after iterations, also reduce scale
        if (expectedSizeMB > hardLimit) {
            settings.scale *= 0.85;
            settings.scale = Math.max(minScale, settings.scale);
            settings.bitrate = Math.round(settings.bitrate * 0.8);
            expectedSizeMB = calculateExpectedSize(settings.bitrate);
            console.log(`Applied additional scale reduction: ${(settings.scale * 100).toFixed(0)}%`);
        }

        // Final safety check - set absolute maximum bitrate based on duration
        const absoluteMaxBitrate = ((hardLimit - audioSizeMB) * 8 * 1024 * 1024) / duration;
        if (settings.bitrate > absoluteMaxBitrate) {
            settings.bitrate = Math.round(absoluteMaxBitrate * 0.9);
            expectedSizeMB = calculateExpectedSize(settings.bitrate);
            console.log(`Applied absolute max bitrate cap: ${(settings.bitrate / 1000000).toFixed(2)} Mbps`);
        }

        console.log(`=== Compression Settings ===`);
        console.log(`Input: ${fileSizeMB.toFixed(1)}MB (${formatDuration(Math.floor(duration))})`);
        console.log(`Target: ${targetSizeMB}MB (hard limit: ${hardLimit.toFixed(0)}MB) | Compression ratio: ${compressionRatio.toFixed(1)}x`);
        console.log(`Quality: ${userQuality} | Scale: ${(settings.scale * 100).toFixed(0)}% | FPS: ${settings.fps}`);
        console.log(`Codec: ${codecInfo.name} (efficiency: ${codecInfo.efficiency}x)`);
        console.log(`Complexity: ${complexity.score.toFixed(2)} (${complexity.type})`);
        console.log(`Bitrate: ${(settings.bitrate / 1000000).toFixed(2)} Mbps`);
        console.log(`Expected output: ~${expectedSizeMB.toFixed(1)}MB (${adjustmentIterations > 0 ? adjustmentIterations + ' adjustments made' : 'no adjustments needed'})`);

        settings.metrics = {
            inputSize: fileSizeMB,
            targetSize: targetSizeMB,
            compressionRatio,
            codecEfficiency,
            complexity: complexity,
            expectedSize: expectedSizeMB
        };

        return settings;
    },

    // Run a short calibration pass to measure actual encoder behavior
    async runCalibrationPass(file, settings, metadata, codecInfo) {
        return new Promise((resolve) => {
            const video = document.createElement('video');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { alpha: false });

            video.muted = true;
            video.playsInline = true;

            const videoUrl = URL.createObjectURL(file);
            const calibrationDuration = Math.min(10, metadata.duration * 0.05); // 5% of video or 10 seconds max
            let totalBytes = 0;
            let elapsedTime = 0;

            video.onloadedmetadata = async () => {
                const targetWidth = Math.round(video.videoWidth * settings.scale);
                const targetHeight = Math.round(video.videoHeight * settings.scale);
                canvas.width = targetWidth % 2 === 0 ? targetWidth : targetWidth - 1;
                canvas.height = targetHeight % 2 === 0 ? targetHeight : targetHeight - 1;

                const stream = canvas.captureStream(settings.fps);

                try {
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: codecInfo.mimeType,
                        videoBitsPerSecond: settings.bitrate
                    });

                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data && e.data.size > 0) {
                            totalBytes += e.data.size;
                        }
                    };

                    mediaRecorder.start(500); // Collect data every 500ms

                    // Seek to middle of video for representative sample
                    video.currentTime = Math.max(0, (metadata.duration / 2) - (calibrationDuration / 2));

                    await video.play();

                    const startTime = Date.now();
                    const frameInterval = 1000 / settings.fps;
                    let lastFrameTime = 0;

                    const drawLoop = (timestamp) => {
                        elapsedTime = (Date.now() - startTime) / 1000;

                        if (elapsedTime >= calibrationDuration || video.ended) {
                            video.pause();
                            mediaRecorder.stop();

                            setTimeout(() => {
                                URL.revokeObjectURL(videoUrl);

                                // Calculate actual vs expected bitrate
                                const actualBitrate = (totalBytes * 8) / elapsedTime;
                                const expectedBitrate = settings.bitrate;
                                const adjustmentFactor = actualBitrate / expectedBitrate;

                                console.log(`Calibration: ${elapsedTime.toFixed(1)}s sampled`);
                                console.log(`Expected bitrate: ${(expectedBitrate / 1000000).toFixed(2)} Mbps`);
                                console.log(`Actual bitrate: ${(actualBitrate / 1000000).toFixed(2)} Mbps`);
                                console.log(`Adjustment factor: ${adjustmentFactor.toFixed(3)}x`);

                                this.calibrationData = {
                                    adjustmentFactor: adjustmentFactor,
                                    sampleDuration: elapsedTime,
                                    actualBitrate: actualBitrate
                                };

                                resolve(this.calibrationData);
                            }, 200);
                            return;
                        }

                        if (timestamp - lastFrameTime >= frameInterval) {
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            lastFrameTime = timestamp;
                        }

                        requestAnimationFrame(drawLoop);
                    };

                    requestAnimationFrame(drawLoop);

                } catch (e) {
                    console.warn('Calibration failed:', e);
                    URL.revokeObjectURL(videoUrl);
                    resolve({ adjustmentFactor: 1.0 });
                }
            };

            video.onerror = () => {
                URL.revokeObjectURL(videoUrl);
                resolve({ adjustmentFactor: 1.0 });
            };

            // Timeout
            setTimeout(() => {
                if (!this.calibrationData) {
                    URL.revokeObjectURL(videoUrl);
                    resolve({ adjustmentFactor: 1.0 });
                }
            }, 20000);

            video.src = videoUrl;
        });
    },

    // Apply calibration results to adjust settings
    applyCalibration(settings, calibration, maxSizeMB, metadata) {
        if (!calibration || calibration.adjustmentFactor === 1.0) {
            return settings;
        }

        const newSettings = { ...settings };

        // If actual output is higher than expected, reduce bitrate
        if (calibration.adjustmentFactor > 1.1) {
            const reduction = 1 / calibration.adjustmentFactor;
            newSettings.bitrate = Math.round(settings.bitrate * reduction * 0.95); // Extra 5% safety
            console.log(`Calibration: Reducing bitrate by ${((1 - reduction) * 100).toFixed(1)}%`);
        }
        // If actual output is lower, we can increase quality slightly
        else if (calibration.adjustmentFactor < 0.85) {
            const increase = Math.min(1.2, 1 / calibration.adjustmentFactor);
            newSettings.bitrate = Math.round(settings.bitrate * increase * 0.9);
            console.log(`Calibration: Encoder is efficient, adjusting bitrate up by ${((increase - 1) * 100).toFixed(1)}%`);
        }

        return newSettings;
    },

    // Main compression with adaptive monitoring
    async performAdaptiveCompression(file, settings, metadata, codecInfo, maxSizeMB, onProgress) {
        return new Promise((resolve, reject) => {
            const video = document.createElement('video');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', {
                alpha: false,
                desynchronized: true,
                willReadFrequently: false,
                imageSmoothingEnabled: true,
                imageSmoothingQuality: 'high'
            });

            video.muted = true;
            video.playsInline = true;
            video.crossOrigin = 'anonymous';

            let videoUrl;
            try {
                videoUrl = URL.createObjectURL(file);
            } catch (error) {
                console.error('Failed to create blob URL:', error);
                reject(new Error('Failed to create video URL'));
                return;
            }

            video.onloadedmetadata = async () => {
                try {
                    let targetWidth = Math.round(video.videoWidth * settings.scale);
                    let targetHeight = Math.round(video.videoHeight * settings.scale);

                    // If cropping to portrait (9:16), calculate crop dimensions
                    if (this.cropToPortrait) {
                        const srcWidth = video.videoWidth;
                        const srcHeight = video.videoHeight;
                        const targetAspect = 9 / 16;

                        // Calculate the crop region from the source video
                        let cropWidth, cropHeight, cropX, cropY;

                        if (srcWidth / srcHeight > targetAspect) {
                            // Video is wider than 9:16 - crop the sides
                            cropHeight = srcHeight;
                            cropWidth = Math.round(srcHeight * targetAspect);
                            cropX = Math.round((srcWidth - cropWidth) / 2);
                            cropY = 0;
                        } else {
                            // Video is taller than 9:16 - crop top/bottom
                            cropWidth = srcWidth;
                            cropHeight = Math.round(srcWidth / targetAspect);
                            cropX = 0;
                            cropY = Math.round((srcHeight - cropHeight) / 2);
                        }

                        // Store crop parameters for drawing
                        this.cropParams = { cropX, cropY, cropWidth, cropHeight };

                        // Output dimensions (scaled portrait)
                        targetWidth = Math.round(cropWidth * settings.scale);
                        targetHeight = Math.round(cropHeight * settings.scale);

                        console.log(`Crop region: (${cropX}, ${cropY}) ${cropWidth}x${cropHeight} from ${srcWidth}x${srcHeight}`);
                    }

                    // Ensure even dimensions for codec compatibility
                    canvas.width = targetWidth % 2 === 0 ? targetWidth : targetWidth - 1;
                    canvas.height = targetHeight % 2 === 0 ? targetHeight : targetHeight - 1;

                    // Enforce minimum resolution
                    if (canvas.width < 320) {
                        const ratio = 320 / canvas.width;
                        canvas.width = 320;
                        canvas.height = Math.round(canvas.height * ratio);
                        canvas.height = canvas.height % 2 === 0 ? canvas.height : canvas.height - 1;
                    }

                    console.log(`Compressing: ${video.videoWidth}x${video.videoHeight} -> ${canvas.width}x${canvas.height}${this.cropToPortrait ? ' (cropping to 9:16 portrait)' : ''}`);
                    if (this.cropToPortrait) {
                        console.log(`Cropping enabled: output ${canvas.width}x${canvas.height} (portrait 9:16)`);
                    }
                    console.log(`Bitrate: ${(settings.bitrate / 1000000).toFixed(2)} Mbps, FPS: ${settings.fps}`);

                    const stream = canvas.captureStream(settings.fps);

                    // Extract and add audio track
                    let hasAudio = false;
                    if (video.mozCaptureStream || video.captureStream) {
                        try {
                            const videoStream = video.mozCaptureStream ? video.mozCaptureStream() : video.captureStream();
                            const audioTracks = videoStream.getAudioTracks();

                            if (audioTracks.length > 0) {
                                audioTracks.forEach(track => {
                                    stream.addTrack(track);
                                    hasAudio = true;
                                });
                                console.log('Audio track added successfully');
                            }
                        } catch (e) {
                            console.warn('Audio extraction failed:', e);
                        }
                    }

                    const recorderOptions = {
                        mimeType: codecInfo.mimeType,
                        videoBitsPerSecond: settings.bitrate
                    };

                    if (hasAudio) {
                        recorderOptions.audioBitsPerSecond = 64000;
                    }

                    const mediaRecorder = new MediaRecorder(stream, recorderOptions);

                    this.currentMimeType = mediaRecorder.mimeType ?
                        mediaRecorder.mimeType.split(';')[0] :
                        codecInfo.mimeType.split(';')[0];

                    const chunks = [];
                    let lastProgressUpdate = 0;
                    let frameCount = 0;
                    let rafId = null;
                    let totalBytesRecorded = 0;
                    let lastBitrateCheck = 0;
                    let bitrateWarningIssued = false;

                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data && e.data.size > 0) {
                            chunks.push(e.data);
                            totalBytesRecorded += e.data.size;

                            // Adaptive bitrate monitoring (check every 5 seconds of video)
                            const now = Date.now();
                            if (now - lastBitrateCheck > 5000 && video.currentTime > 5) {
                                lastBitrateCheck = now;
                                const currentSizeMB = totalBytesRecorded / (1024 * 1024);
                                const progress = video.currentTime / metadata.duration;
                                const projectedSizeMB = currentSizeMB / progress;

                                if (projectedSizeMB > maxSizeMB * 1.15 && !bitrateWarningIssued) {
                                    console.warn(`Projected size ${projectedSizeMB.toFixed(1)}MB exceeds target. May need retry.`);
                                    bitrateWarningIssued = true;
                                }
                            }
                        }
                    };

                    mediaRecorder.onstop = () => {
                        console.log(`Encoding complete: ${chunks.length} chunks, ${frameCount} frames`);

                        const blob = new Blob(chunks, {
                            type: this.currentMimeType.includes('mp4') ? 'video/mp4' : this.currentMimeType
                        });

                        const sizeMB = blob.size / (1024 * 1024);
                        const originalSizeMB = file.size / (1024 * 1024);
                        const reduction = ((originalSizeMB - sizeMB) / originalSizeMB * 100).toFixed(1);

                        console.log(`Result: ${originalSizeMB.toFixed(1)}MB -> ${sizeMB.toFixed(1)}MB (${reduction}% reduction)`);

                        video.pause();
                        URL.revokeObjectURL(videoUrl);

                        // Clean up canvas
                        canvas.width = 0;
                        canvas.height = 0;

                        resolve(blob);
                    };

                    mediaRecorder.onerror = (e) => {
                        console.error('MediaRecorder error:', e);
                        URL.revokeObjectURL(videoUrl);
                        reject(new Error('MediaRecorder error: ' + (e.error || 'Unknown error')));
                    };

                    // Use larger chunks for efficiency (1 second)
                    mediaRecorder.start(1000);
                    console.log('MediaRecorder started');

                    video.currentTime = 0;

                    const targetDuration = metadata.duration;
                    let lastDrawTime = 0;
                    const frameInterval = 1000 / settings.fps;

                    // Helper to draw frame with optional cropping
                    const drawVideoFrame = () => {
                        if (this.cropToPortrait && this.cropParams) {
                            // Draw cropped region to fill canvas (center crop to 9:16)
                            const { cropX, cropY, cropWidth, cropHeight } = this.cropParams;
                            ctx.drawImage(
                                video,
                                cropX, cropY, cropWidth, cropHeight,  // Source crop region
                                0, 0, canvas.width, canvas.height     // Destination (full canvas)
                            );
                        } else {
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        }
                    };

                    const drawFrame = (timestamp) => {
                        if (!video.paused && !video.ended && mediaRecorder.state === 'recording') {
                            // Draw frame at correct interval
                            if (timestamp - lastDrawTime >= frameInterval) {
                                try {
                                    drawVideoFrame();
                                    frameCount++;
                                    lastDrawTime = timestamp;
                                } catch (e) {
                                    console.warn('Frame draw error:', e);
                                }
                            }

                            // Progress update
                            const now = Date.now();
                            if (now - lastProgressUpdate > 500) {
                                const videoTime = video.currentTime;
                                const progress = Math.min(95, 20 + (videoTime / targetDuration) * 75);
                                const currentSizeMB = totalBytesRecorded / (1024 * 1024);

                                onProgress({
                                    stage: 'compressing',
                                    progress: Math.round(progress),
                                    quality: settings.quality,
                                    currentTime: videoTime.toFixed(1),
                                    duration: targetDuration.toFixed(1),
                                    currentSize: currentSizeMB.toFixed(1)
                                });
                                lastProgressUpdate = now;
                            }

                            rafId = requestAnimationFrame(drawFrame);
                        }
                    };

                    video.addEventListener('ended', () => {
                        console.log('Video playback ended');
                        if (rafId) {
                            cancelAnimationFrame(rafId);
                        }
                        // Small delay to ensure all frames are recorded
                        setTimeout(() => {
                            if (mediaRecorder.state === 'recording') {
                                mediaRecorder.stop();
                            }
                        }, 300);
                    });

                    video.muted = true;
                    video.volume = 0;
                    video.playbackRate = 1.0;

                    // Start playback
                    setTimeout(async () => {
                        try {
                            await video.play();
                            console.log('Video playback started');
                            rafId = requestAnimationFrame(drawFrame);
                        } catch (err) {
                            console.error('Failed to start video playback:', err);
                            reject(err);
                        }
                    }, 100);

                } catch (error) {
                    console.error('Compression setup error:', error);
                    URL.revokeObjectURL(videoUrl);
                    reject(error);
                }
            };

            video.onerror = (e) => {
                console.error('Video loading error:', e);
                URL.revokeObjectURL(videoUrl);
                reject(new Error('Video loading error: ' + (e.message || 'Unknown error')));
            };

            video.src = videoUrl;
            video.load();
        });
    },

    // Intelligent retry with learned parameters
    async intelligentRetry(file, currentSizeMB, maxSizeMB, metadata, codecInfo, previousSettings, onProgress) {
        const overageRatio = currentSizeMB / maxSizeMB;
        console.log(`Retry needed: ${currentSizeMB.toFixed(1)}MB (${((overageRatio - 1) * 100).toFixed(1)}% over target)`);

        // Calculate required reduction
        const requiredReduction = maxSizeMB / currentSizeMB;

        // Determine retry strategy based on how far over we are
        let retryStrategy;
        if (overageRatio <= 1.15) {
            // Close to target - just reduce bitrate
            retryStrategy = 'bitrate-only';
        } else if (overageRatio <= 1.4) {
            // Moderate overage - reduce bitrate and slightly lower quality
            retryStrategy = 'bitrate-and-quality';
        } else {
            // Significant overage - need aggressive reduction
            retryStrategy = 'aggressive';
        }

        console.log(`Retry strategy: ${retryStrategy}`);

        // Determine quality levels for retry
        const qualityLevels = ['high', 'medium', 'low', 'ultra-low'];
        const currentQualityIndex = qualityLevels.indexOf(previousSettings.quality);

        let attempts = 0;
        const maxAttempts = 3;

        while (attempts < maxAttempts) {
            attempts++;

            let newSettings = { ...previousSettings };

            if (retryStrategy === 'bitrate-only' || attempts === 1) {
                // First attempt: reduce bitrate by the overage amount + safety margin
                newSettings.bitrate = Math.round(previousSettings.bitrate * requiredReduction * 0.88);
            } else if (retryStrategy === 'bitrate-and-quality' || attempts === 2) {
                // Second attempt: also drop quality level
                const nextQualityIndex = Math.min(currentQualityIndex + 1, qualityLevels.length - 1);
                window.userSelectedQuality = qualityLevels[nextQualityIndex];
                newSettings = this.calculateCompressionSettings(
                    file.size / (1024 * 1024),
                    maxSizeMB,
                    metadata,
                    codecInfo
                );
                // Apply additional bitrate reduction based on overage
                newSettings.bitrate = Math.round(newSettings.bitrate * requiredReduction * 0.85);
            } else {
                // Third attempt: ultra-low quality with aggressive bitrate
                window.userSelectedQuality = 'ultra-low';
                newSettings = this.calculateCompressionSettings(
                    file.size / (1024 * 1024),
                    maxSizeMB,
                    metadata,
                    codecInfo
                );
                newSettings.bitrate = Math.round(newSettings.bitrate * 0.7);
                newSettings.scale = Math.max(0.2, newSettings.scale * 0.85);
            }

            onProgress({
                stage: 'retrying',
                message: `Attempt ${attempts}: Adjusting compression (target reduction: ${((1 - requiredReduction) * 100).toFixed(0)}%)`,
                quality: newSettings.quality
            });

            console.log(`Retry attempt ${attempts}: bitrate=${(newSettings.bitrate / 1000000).toFixed(2)} Mbps, scale=${(newSettings.scale * 100).toFixed(0)}%`);

            const retryBlob = await this.performAdaptiveCompression(
                file,
                newSettings,
                metadata,
                codecInfo,
                maxSizeMB,
                onProgress
            );

            const retrySizeMB = retryBlob.size / (1024 * 1024);
            console.log(`Retry attempt ${attempts} result: ${retrySizeMB.toFixed(1)}MB`);

            if (retrySizeMB <= maxSizeMB) {
                const mimeType = this.currentMimeType || codecInfo.mimeType.split(';')[0];
                const extension = mimeType.includes('mp4') ? '.mp4' : '.webm';

                const compressedFile = new File(
                    [retryBlob],
                    file.name.replace(/\.[^/.]+$/, extension),
                    { type: mimeType }
                );

                onProgress({
                    stage: 'complete',
                    progress: 100,
                    originalSize: file.size,
                    compressedSize: compressedFile.size,
                    compressionRatio: compressedFile.size / file.size,
                    quality: newSettings.quality,
                    outputFormat: mimeType
                });

                return compressedFile;
            }

            // Update for next iteration
            currentSizeMB = retrySizeMB;
        }

        return null; // All retries failed
    },

    // Legacy method for compatibility
    getSupportedMimeType() {
        const codecInfo = this.selectOptimalCodec();
        console.log('Using mime type:', codecInfo.mimeType);
        return codecInfo.mimeType;
    },

    async getVideoMetadata(file) {
        return new Promise((resolve, reject) => {
            const video = document.createElement('video');
            video.preload = 'metadata';
            video.muted = true;

            const timeout = setTimeout(() => {
                URL.revokeObjectURL(video.src);
                reject(new Error('Video metadata loading timeout'));
            }, 30000);

            video.onloadedmetadata = async () => {
                clearTimeout(timeout);

                // WebM files from MediaRecorder often have Infinity duration
                // We need to seek to get the actual duration
                if (!video.duration || video.duration === Infinity) {
                    try {
                        // Seek to a large time to force browser to calculate duration
                        video.currentTime = Number.MAX_SAFE_INTEGER;
                        await new Promise((res) => {
                            video.ontimeupdate = () => {
                                video.ontimeupdate = null;
                                res();
                            };
                            // Fallback timeout
                            setTimeout(res, 2000);
                        });
                        video.currentTime = 0;
                    } catch (e) {
                        console.warn('Could not seek to get duration:', e);
                    }
                }

                // If still no valid duration, estimate from file size (rough estimate)
                let duration = video.duration;
                if (!duration || duration === Infinity || isNaN(duration)) {
                    // Estimate: assume ~1MB per 10 seconds for typical WebM
                    duration = Math.max(1, file.size / (1024 * 1024) * 10);
                    console.warn(`Could not get video duration, estimating: ${duration.toFixed(1)}s`);
                }

                URL.revokeObjectURL(video.src);

                resolve({
                    duration: duration,
                    width: video.videoWidth || 1920,
                    height: video.videoHeight || 1080,
                    aspectRatio: (video.videoWidth || 1920) / (video.videoHeight || 1080)
                });
            };

            video.onerror = () => {
                clearTimeout(timeout);
                URL.revokeObjectURL(video.src);
                reject(new Error('Failed to load video metadata'));
            };

            video.src = URL.createObjectURL(file);
        });
    }
};

// Initialize app without checking for login
async function initializeApp() {
    initTheme();

    // Initialize filter packs from localStorage
    initFilterPacks();

    // Load admin blocklist from localStorage
    loadAdminBlocklist();

    // Start relay connections in the background (non-blocking)
    // This allows the UI to render immediately while connections establish
    initializeRelayConnections();

    // Check for stored login (fast, local storage based)
    // Don't await - let it run in parallel with route handling
    // Store globally so protected routes (like admin) can await it
    loginCheckPromise = checkStoredLogin();

    // Handle route immediately - content will render progressively as relays connect
    handleRoute();

    // Ensure login completes (for UI state updates)
    await loginCheckPromise;
}

// Check for stored login
async function checkStoredLogin() {
    return new Promise((resolve) => {
        const storedMethod = localStorage.getItem(STORAGE_KEYS.loginMethod);
        const storedPubkey = localStorage.getItem(STORAGE_KEYS.publicKey);

        if (storedMethod && storedPubkey) {
            if (storedMethod === 'extension') {
                // Try to reconnect with extension
                if (window.nostr) {
                    window.nostr.getPublicKey().then(pubkey => {
                        if (pubkey === storedPubkey) {
                            currentUser = { pubkey };
                            onUserLoggedIn().then(resolve);
                        } else {
                            resolve();
                        }
                    }).catch(() => {
                        console.log('Extension login failed, clearing stored login');
                        clearStoredLogin();
                        resolve();
                    });
                } else {
                    resolve();
                }
            } else if (storedMethod === 'privateKey') {
                const storedKey = localStorage.getItem(STORAGE_KEYS.privateKey);
                if (storedKey) {
                    const pubkey = getPublicKeyFromPrivate(storedKey);
                    currentUser = { pubkey, privateKey: storedKey };
                    onUserLoggedIn().then(resolve);
                } else {
                    resolve();
                }
            } else if (storedMethod === 'connect') {
                const bunkerURL = localStorage.getItem(STORAGE_KEYS.bunkerURL);
                const secret = localStorage.getItem(STORAGE_KEYS.nip46Secret);
                if (bunkerURL && secret) {
                    reconnectNip46(bunkerURL, secret).then(resolve);
                } else {
                    resolve();
                }
            }
        } else {
            resolve();
        }
    });
}

// Clear stored login
function clearStoredLogin() {
    Object.values(STORAGE_KEYS).forEach(key => {
        localStorage.removeItem(key);
    });
    currentUser = null;
    // Clear mute list cache
    mutedUsersCache.clear();
    muteListLoaded = false;
    sessionUnhiddenMutedUsers.clear();
    updateUserInterface();
}

// User logged in handler
async function onUserLoggedIn(freshLogin = false) {
    updateUserInterface();
    await initializeSettings();
    // Load user's mute list in background
    fetchMuteList().catch(err => console.error('Failed to load mute list:', err));
    // Load user's follows for report warnings in background
    fetchUserFollows().catch(err => console.error('Failed to load follows:', err));
    // Check for new notifications in background
    checkNotificationsInBackground().catch(err => console.error('Failed to check notifications:', err));
    // Load watch history from Nostr and merge with local
    loadWatchHistoryFromNostr().catch(err => console.error('Failed to load watch history from Nostr:', err));

    // Unlock login-gated features without page reload
    if (freshLogin) {
        unlockLoginGatedFeatures();
    }
}

// Unlock login-gated features after fresh login (AJAX style, no page reload)
function unlockLoginGatedFeatures() {
    // Reload content for login-gated pages based on current view
    if (currentView === 'liked') {
        // Reload liked videos page
        loadLikedVideos();
        showToast('Logged in successfully!', 'success');
        return;
    }

    if (currentView === 'following') {
        // Reload following page
        loadFollowing();
        showToast('Logged in successfully!', 'success');
        return;
    }

    if (currentView === 'my-videos') {
        // Reload my videos page
        loadMyVideos();
        showToast('Logged in successfully!', 'success');
        return;
    }

    // Unlock comment form on video pages
    const commentContainer = document.getElementById('main-comment-input');
    if (commentContainer) {
        const textarea = commentContainer.querySelector('.comment-textarea');
        const submitBtn = commentContainer.querySelector('.comment-submit-btn');
        const loginPrompt = commentContainer.querySelector('.comment-login-prompt');

        if (textarea) {
            textarea.disabled = false;
            textarea.placeholder = 'Write a comment...';
        }
        if (submitBtn) {
            submitBtn.disabled = false;
        }
        if (loginPrompt) {
            loginPrompt.remove();
        }
    }

    // Unlock any reply input forms that might be open
    document.querySelectorAll('[id^="reply-input-"]').forEach(replyContainer => {
        const textarea = replyContainer.querySelector('.comment-textarea');
        const submitBtn = replyContainer.querySelector('.comment-submit-btn');
        const loginPrompt = replyContainer.querySelector('.comment-login-prompt');

        if (textarea) textarea.disabled = false;
        if (submitBtn) submitBtn.disabled = false;
        if (loginPrompt) loginPrompt.remove();
    });

    // Unlock comment action buttons (like, dislike, reply, zap)
    document.querySelectorAll('.comment').forEach(comment => {
        const commentPubkey = comment.querySelector('.comment-author')?.getAttribute('href')?.split('/').pop();

        // Enable like, dislike, reply, zap buttons
        comment.querySelectorAll('.comment-like-btn, .comment-dislike-btn, .comment-reply-btn, .comment-zap-btn').forEach(btn => {
            btn.disabled = false;
        });

        // Add mute/report buttons if they don't exist and it's not the user's own comment
        if (commentPubkey && commentPubkey !== currentUser?.pubkey) {
            const actionsContainer = comment.querySelector('.comment-actions');
            if (actionsContainer && !actionsContainer.querySelector('.comment-mute-btn')) {
                const commentId = comment.querySelector('[data-comment-id]')?.dataset.commentId;
                const isMuted = isUserMuted(commentPubkey);

                // Add mute button
                const muteBtn = document.createElement('button');
                muteBtn.className = `comment-action-btn comment-mute-btn ${isMuted ? 'muted' : ''}`;
                muteBtn.onclick = () => handleMute(commentPubkey, isMuted);
                muteBtn.title = isMuted ? 'Unmute user' : 'Mute user';
                muteBtn.innerHTML = `${getMuteIconSVG(14)}<span>${isMuted ? t('button.unmute') : t('button.mute')}</span>`;
                actionsContainer.appendChild(muteBtn);

                // Add report button
                const reportBtn = document.createElement('button');
                reportBtn.className = 'comment-action-btn comment-report-btn';
                reportBtn.onclick = () => showReportModal(commentId, commentPubkey, 'comment');
                reportBtn.title = 'Report comment';
                reportBtn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"/>
                    </svg>
                    <span>Report</span>
                `;
                actionsContainer.appendChild(reportBtn);
            }
        }
    });

    // Update follow/mute buttons on profile pages
    if (currentView.startsWith('profile-')) {
        const profilePubkey = currentView.replace('profile-', '');
        if (profilePubkey && profilePubkey !== currentUser?.pubkey) {
            // Update follow button
            const followBtn = document.querySelector('.follow-btn');
            if (followBtn) {
                const isFollowing = userFollows.has(profilePubkey);
                followBtn.textContent = isFollowing ? t('button.unfollow') : t('button.follow');
                followBtn.classList.toggle('following', isFollowing);
                followBtn.onclick = () => toggleFollow(profilePubkey);
            }

            // Update mute button
            const muteBtn = document.querySelector('.mute-btn');
            if (muteBtn) {
                const isMuted = mutedUsersCache.has(profilePubkey);
                muteBtn.textContent = isMuted ? t('button.unmute') : t('button.mute');
                muteBtn.classList.toggle('muted', isMuted);
                muteBtn.onclick = () => toggleMute(profilePubkey);
            }
        }
    }

    // Update any "login to X" links/buttons throughout the page
    document.querySelectorAll('a[onclick*="showLoginModal"]').forEach(link => {
        // Check if parent contains login prompt text
        const parent = link.closest('p');
        if (parent && parent.textContent.includes('login')) {
            // This is likely a login prompt that should be removed/updated
            // The page content should reload based on context
        }
    });

    // Show toast to confirm login success
    showToast('Logged in successfully!', 'success');
}

// Update user interface
function updateUserInterface() {
    const userIcon = document.getElementById('userIcon');
    const userAvatar = document.getElementById('userAvatar');
    const userDropdown = document.getElementById('userDropdown');
    const adminMenuBtn = document.getElementById('adminMenuBtn');

    if (currentUser) {
        // Show/hide admin button based on admin status
        if (adminMenuBtn) {
            adminMenuBtn.style.display = isAdmin() ? 'flex' : 'none';
        }

        // Try to get profile from cache or storage
        const storedProfile = localStorage.getItem(STORAGE_KEYS.profile);
        if (storedProfile) {
            try {
                const profile = JSON.parse(storedProfile);
                if (profile.picture) {
                    userAvatar.src = profile.picture;
                    userAvatar.style.display = 'block';
                    userIcon.style.display = 'none';
                }
            } catch (e) {
                console.error('Failed to parse stored profile');
            }
        }

        // Fetch latest profile
        fetchUserProfile(currentUser.pubkey).then(profile => {
            if (profile && profile.picture) {
                userAvatar.src = profile.picture;
                userAvatar.style.display = 'block';
                userIcon.style.display = 'none';
                localStorage.setItem(STORAGE_KEYS.profile, JSON.stringify(profile));
            }
        });
    } else {
        userAvatar.style.display = 'none';
        userIcon.style.display = 'block';
        // Hide admin button when logged out
        if (adminMenuBtn) {
            adminMenuBtn.style.display = 'none';
        }
    }
}

// User menu functions
function toggleUserMenu() {
    if (!currentUser) {
        showLoginModal();
    } else {
        const dropdown = document.getElementById('userDropdown');
        dropdown.classList.toggle('active');

        // Close dropdown when clicking outside
        if (dropdown.classList.contains('active')) {
            document.addEventListener('click', closeUserMenuOnClickOutside);
        }
    }
}

function closeUserMenuOnClickOutside(e) {
    const userMenu = document.getElementById('userMenu');
    if (!userMenu.contains(e.target)) {
        document.getElementById('userDropdown').classList.remove('active');
        document.removeEventListener('click', closeUserMenuOnClickOutside);
    }
}

// Login modal functions
function showLoginModal() {
    document.getElementById('loginModal').classList.add('active');
}

function hideLoginModal() {
    document.getElementById('loginModal').classList.remove('active');
}

// Login with extension
async function loginWithExtension() {
    if (!window.nostr) {
        showToast('Please install a Nostr browser extension like Alby or nos2x', 'warning');
        return;
    }

    try {
        const pubkey = await window.nostr.getPublicKey();

        currentUser = { pubkey };

        // Store login method
        localStorage.setItem(STORAGE_KEYS.loginMethod, 'extension');
        localStorage.setItem(STORAGE_KEYS.publicKey, pubkey);

        hideLoginModal();
        await onUserLoggedIn(true);

    } catch (error) {
        console.error('Extension login failed:', error);
        showToast('Failed to login with extension. Please try again.', 'error');
    }
}

// NIP-46 Connect functions
function showConnectModal() {
    hideLoginModal();
    const modal = document.getElementById('connectModal');
    modal.classList.add('active');

    // Generate the connection URI and prepare for listening
    const uri = generateNostrConnectURI();
    document.getElementById('nostrConnectURI').value = uri;
}

function hideConnectModal() {
    document.getElementById('connectModal').classList.remove('active');
    window.pendingNostrConnect = null;
    window.isListeningForConnect = false;
}

// Generate nostrconnect:// URI for the user
function generateNostrConnectURI() {
    // Generate a new ephemeral key pair for this connection
    const ephemeralPrivKey = window.NostrTools.generateSecretKey();
    const ephemeralPubKey = window.NostrTools.getPublicKey(ephemeralPrivKey);

    // Store for later use
    window.pendingNostrConnect = {
        ephemeralPrivKey: bytesToHex(ephemeralPrivKey),
        ephemeralPubKey
    };

    // Create the metadata
    const metadata = {
        name: "Plebs",
        url: window.location.origin,
        description: "Decentralized video platform"
    };

    // Use multiple relays for better compatibility
    const relays = [
        'wss://relay.nsec.app',
        'wss://relay.damus.io',
        'wss://nos.lol',
        'wss://relay.coinos.io'
    ];

    // Some apps want base64, others want URL-encoded JSON
    const params = new URLSearchParams();

    // Add primary relay
    params.append('relay', relays[0]);

    // Add additional relays
    relays.slice(1).forEach(relay => {
        params.append('relay', relay);
    });

    // Add metadata
    params.append('metadata', JSON.stringify(metadata));

    return `nostrconnect://${ephemeralPubKey}?${params.toString()}`;
}

// Show QR code for mobile scanning
function showNostrConnectQR() {
    const uri = document.getElementById('nostrConnectURI').value;

    // Generate QR code
    const qrContainer = document.getElementById('nostrConnectQR');
    qrContainer.innerHTML = ''; // Clear existing QR

    if (window.QRCode) {
        new QRCode(qrContainer, {
            text: uri,
            width: 256,
            height: 256,
            colorDark: "#000000",
            colorLight: "#FFFFFF",
            correctLevel: QRCode.CorrectLevel.L
        });
    }

    // Show listening status for QR code
    document.getElementById('qrConnectionStatus').style.display = 'block';

    // Start listening for connection only if not already listening
    if (!window.isListeningForConnect) {
        window.isListeningForConnect = true;
        listenForNostrConnect();
    }
}

function toggleQRDisplay() {
    const qrSection = document.getElementById('qrCodeSection');
    const btn = event.target;

    if (qrSection.style.display === 'none') {
        qrSection.style.display = 'block';
        btn.textContent = t('button.hideQR');
        showNostrConnectQR(); // Use existing function
    } else {
        qrSection.style.display = 'none';
        btn.textContent = t('button.showQR');
    }
}

// Listen for incoming connection from the app
async function listenForNostrConnect() {
    if (!window.pendingNostrConnect) return;

    const { ephemeralPrivKey, ephemeralPubKey } = window.pendingNostrConnect;

    showConnectionStatus('Waiting for app connection...');

    const relays = ['wss://relay.nsec.app', 'wss://relay.damus.io', 'wss://nos.lol', 'wss://relay.coinos.io'];
    const connections = [];

    for (const relay of relays) {
        try {
            const ws = await connectToRelay(relay);
            connections.push({ relay, ws });

            const subId = generateRandomId();
            const subscription = JSON.stringify([
                'REQ',
                subId,
                {
                    kinds: [24133],
                    '#p': [ephemeralPubKey],
                    since: Math.floor(Date.now() / 1000) - 60
                }
            ]);
            ws.send(subscription);
        } catch (error) {
            console.error(`Failed to connect to ${relay}:`, error);
        }
    }

    if (connections.length === 0) {
        showConnectionStatus('Failed to connect to any relay');
        setTimeout(hideConnectionStatus, 3000);
        window.pendingNostrConnect = null;
        return;
    }

    const timeout = setTimeout(() => {
        showConnectionStatus('Connection timeout. Please try again.');
        setTimeout(hideConnectionStatus, 3000);
        window.pendingNostrConnect = null;
    }, 120000);

    let isConnected = false;
    let remotePubkey = null;
    let connectedRelay = null;

    const checkForConnection = async () => {
        if (isConnected) return;

        try {
            for (const { relay, ws } of connections) {
                if (ws.readyState !== WebSocket.OPEN) continue;

                const handler = (event) => {
                    try {
                        const message = JSON.parse(event.data);

                        if (message[0] === 'EVENT') {
                            const responseEvent = message.length === 2 ? message[1] : message[2];

                            if (responseEvent && responseEvent.kind === 24133) {
                                const pTag = responseEvent.tags.find(t => t[0] === 'p');

                                if (pTag && pTag[1] === ephemeralPubKey) {
                                    remotePubkey = responseEvent.pubkey;

                                    let decryptedContent;
                                    try {
                                        if (responseEvent.content.includes('?iv=')) {
                                            decryptedContent = window.NostrTools.nip04.decrypt(
                                                ephemeralPrivKey,
                                                remotePubkey,
                                                responseEvent.content
                                            );
                                        } else {
                                            const conversationKey = window.NostrTools.nip44.v2.utils.getConversationKey(
                                                hexToBytes(ephemeralPrivKey),
                                                remotePubkey
                                            );

                                            decryptedContent = window.NostrTools.nip44.v2.decrypt(
                                                responseEvent.content,
                                                conversationKey
                                            );
                                        }

                                        const response = JSON.parse(decryptedContent);

                                        if (response.result === 'ack') {
                                            isConnected = true;
                                            connectedRelay = relay;
                                            clearTimeout(timeout);

                                            showConnectionStatus('Connected! Getting public key...');

                                            handleNostrConnectSuccess(ws, ephemeralPrivKey, ephemeralPubKey, remotePubkey, relay);
                                        }
                                    } catch (decryptError) {
                                        console.error('Failed to decrypt response:', decryptError);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error processing message:', e);
                    }
                };

                ws.addEventListener('message', handler);

                setTimeout(() => {
                    ws.removeEventListener('message', handler);
                }, 1000);
            }

            if (!isConnected) {
                setTimeout(checkForConnection, 2000);
            }

        } catch (e) {
            console.error('Connection check error:', e);
            setTimeout(checkForConnection, 2000);
        }
    };

    checkForConnection();
}

// Handle successful nostrconnect connection
async function handleNostrConnectSuccess(ws, ephemeralPrivKey, ephemeralPubKey, remotePubkey, relay) {
    try {
        // Now request the public key
        const getPubkeyRequest = {
            id: generateRandomId(),
            method: 'get_public_key',
            params: []
        };

        let encryptedContent;
        try {
            encryptedContent = await encryptNip44(ephemeralPrivKey, remotePubkey, JSON.stringify(getPubkeyRequest));
        } catch (e) {
            encryptedContent = await window.NostrTools.nip04.encrypt(
                ephemeralPrivKey,
                remotePubkey,
                JSON.stringify(getPubkeyRequest)
            );
        }

        const requestEvent = {
            kind: 24133,
            pubkey: ephemeralPubKey,
            content: encryptedContent,
            tags: [['p', remotePubkey]],
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedRequestEvent = window.NostrTools.finalizeEvent(requestEvent, hexToBytes(ephemeralPrivKey));

        ws.send(JSON.stringify(['EVENT', signedRequestEvent]));

        const pubkeyResponse = await waitForNip46Response(ws, getPubkeyRequest.id, ephemeralPrivKey, remotePubkey);

        if (pubkeyResponse.result) {
            const userPubkey = pubkeyResponse.result;

            currentUser = { pubkey: userPubkey, nip46: true };
            nip46Connection = {
                relay: relay,
                remotePubkey,
                ephemeralPrivKey,
                ephemeralPubKey,
                secret: null
            };

            // Store connection info
            localStorage.setItem(STORAGE_KEYS.loginMethod, 'connect');
            localStorage.setItem(STORAGE_KEYS.publicKey, userPubkey);
            localStorage.setItem(STORAGE_KEYS.bunkerURL, `nostrconnect://${remotePubkey}`);
            localStorage.setItem(STORAGE_KEYS.nip46Secret, JSON.stringify({
                ephemeralPrivKey,
                remotePubkey,
                relay: relay
            }));

            hideConnectionStatus();
            hideConnectModal();
            window.pendingNostrConnect = null;
            await onUserLoggedIn(true);

            showConnectionStatus('Successfully connected!');
            setTimeout(hideConnectionStatus, 3000);

        } else {
            throw new Error('Failed to get public key from app');
        }
    } catch (error) {
        console.error('Failed to complete connection:', error);
        showConnectionStatus('Connection failed: ' + error.message);
        setTimeout(hideConnectionStatus, 5000);
        window.pendingNostrConnect = null;
    }
}

// Copy nostrconnect URI
function copyNostrConnectURI() {
    const textarea = document.getElementById('nostrConnectURI');
    const uri = textarea.value;

    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(uri).then(() => {
            handleCopySuccess();
        }).catch(err => {
            console.error('Clipboard API failed:', err);
            fallbackCopy();
        });
    } else {
        fallbackCopy();
    }

    function fallbackCopy() {
        try {
            textarea.select();
            textarea.setSelectionRange(0, 99999);
            document.execCommand('copy');
            handleCopySuccess();
        } catch (err) {
            console.error('Fallback copy failed:', err);
            showToast('Failed to copy. Please manually select and copy the text.', 'error');
        }
    }

    function handleCopySuccess() {
        const btn = document.querySelector('.copy-btn');
        const originalText = btn.textContent;
        btn.textContent = t('button.copied');
        btn.style.background = 'var(--accent)';

        // Show listening status
        document.getElementById('connectStringStatus').style.display = 'block';

        // Start listening for connections only if not already listening
        if (!window.isListeningForConnect) {
            window.isListeningForConnect = true;
            listenForNostrConnect();
        }

        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
        }, 2000);
    }
}

function showConnectTab(tab) {
    const bunkerTab = document.getElementById('bunkerTab');
    const qrTab = document.getElementById('qrTab');
    const tabBtns = document.querySelectorAll('.tab-btn');

    tabBtns.forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');

    if (tab === 'bunker') {
        bunkerTab.style.display = 'block';
        qrTab.style.display = 'none';
    } else {
        bunkerTab.style.display = 'none';
        qrTab.style.display = 'block';
        showNostrConnectQR();
    }
}

function selectBunker(provider) {
    // Update UI to show selected bunker
    document.querySelectorAll('.bunker-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');

    // Pre-fill bunker URL based on provider
    const bunkerUrlInput = document.getElementById('bunkerUrl');
    if (provider === 'nsec.app') {
        bunkerUrlInput.placeholder = 'bunker://...@relay.nsec.app';
    } else if (provider === 'highlighter.com') {
        bunkerUrlInput.placeholder = 'bunker://...@relay.highlighter.com';
    }
}

// Helper to wait for NIP-46
async function waitForNip46Response(ws, requestId, ephemeralPrivKey, remotePubkey) {
    return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
            reject(new Error('NIP-46 response timeout'));
        }, 30000);

        const privKeyHex = typeof ephemeralPrivKey === 'string' ?
            ephemeralPrivKey : bytesToHex(ephemeralPrivKey);
        const privKeyBytes = typeof ephemeralPrivKey === 'string' ?
            hexToBytes(ephemeralPrivKey) : ephemeralPrivKey;

        const ephemeralPubKey = window.NostrTools.getPublicKey(privKeyBytes);

        const handler = async (event) => {
            try {
                const message = JSON.parse(event.data);

                if (message[0] === 'EVENT') {
                    const responseEvent = message.length === 2 ? message[1] : message[2];

                    if (responseEvent && responseEvent.kind === 24133) {
                        if (responseEvent.pubkey === remotePubkey) {
                            const pTag = responseEvent.tags.find(t => t[0] === 'p');

                            if (pTag && pTag[1] === ephemeralPubKey) {
                                try {
                                    let decryptedContent;

                                    if (responseEvent.content.includes('?iv=')) {
                                        decryptedContent = await window.NostrTools.nip04.decrypt(
                                            privKeyHex,
                                            remotePubkey,
                                            responseEvent.content
                                        );
                                    } else {
                                        const conversationKey = window.NostrTools.nip44.v2.utils.getConversationKey(
                                            privKeyBytes,
                                            remotePubkey
                                        );

                                        decryptedContent = window.NostrTools.nip44.v2.decrypt(
                                            responseEvent.content,
                                            conversationKey
                                        );
                                    }

                                    const response = JSON.parse(decryptedContent);

                                    if (response.id === requestId) {
                                        clearTimeout(timeout);
                                        ws.removeEventListener('message', handler);
                                        resolve(response);
                                    }
                                } catch (decryptError) {
                                    console.error('Failed to decrypt NIP-46 response:', decryptError);
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                console.error('Error processing message:', e);
            }
        };

        ws.addEventListener('message', handler);
    });
}

// Connect using a bunker string
async function connectWithBunker() {
    const bunkerUrl = document.getElementById('bunkerUrl').value.trim();

    if (!bunkerUrl || !bunkerUrl.startsWith('bunker://')) {
        showToast('Please enter a valid bunker URL', 'warning');
        return;
    }

    try {
        const urlParts = bunkerUrl.slice(9).split('?');
        const remotePubkey = urlParts[0];

        if (!remotePubkey) {
            throw new Error('Invalid bunker URL format - missing pubkey');
        }

        const params = new URLSearchParams(urlParts[1] || '');
        const relay = params.get('relay');
        let secret = params.get('secret');

        if (!relay) {
            throw new Error('Invalid bunker URL format - missing relay parameter');
        }

        const ephemeralPrivKey = window.NostrTools.generateSecretKey();
        const ephemeralPubKey = window.NostrTools.getPublicKey(ephemeralPrivKey);
        const ephemeralPrivKeyHex = bytesToHex(ephemeralPrivKey);

        nip46Secret = secret || remotePubkey;

        const ws = await connectToRelay(relay);

        const subId = generateRandomId();
        const subscription = JSON.stringify([
            'REQ',
            subId,
            {
                kinds: [24133],
                '#p': [ephemeralPubKey],
                since: Math.floor(Date.now() / 1000) - 60
            }
        ]);
        ws.send(subscription);

        showConnectionStatus('Connecting to bunker...');

        const connectRequest = {
            id: generateRandomId(),
            method: 'connect',
            params: [ephemeralPubKey, secret || '']
        };

        let encryptedContent;
        try {
            encryptedContent = await encryptNip44(ephemeralPrivKeyHex, remotePubkey, JSON.stringify(connectRequest));
        } catch (encryptError) {
            encryptedContent = await window.NostrTools.nip04.encrypt(
                ephemeralPrivKeyHex,
                remotePubkey,
                JSON.stringify(connectRequest)
            );
        }

        const requestEvent = {
            kind: 24133,
            pubkey: ephemeralPubKey,
            content: encryptedContent,
            tags: [['p', remotePubkey]],
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedRequestEvent = window.NostrTools.finalizeEvent(requestEvent, ephemeralPrivKey);

        ws.send(JSON.stringify(['EVENT', signedRequestEvent]));

        const connectResponse = await waitForNip46Response(ws, connectRequest.id, ephemeralPrivKeyHex, remotePubkey);

        if (connectResponse.result === 'auth_url' && connectResponse.error) {
            showConnectionStatus('Authorization required. Opening approval page...');

            const authUrl = connectResponse.error;
            const authWindow = window.open(authUrl, 'nostr-auth', 'width=600,height=800');

            showConnectionStatus('Waiting for approval...');

            let approved = false;
            let attempts = 0;
            const maxAttempts = 60;

            while (!approved && attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 1000));

                if (authWindow && authWindow.closed) {
                    const getPubkeyRequest = {
                        id: generateRandomId(),
                        method: 'get_public_key',
                        params: []
                    };

                    let pubkeyEncrypted;
                    try {
                        pubkeyEncrypted = await encryptNip44(ephemeralPrivKeyHex, remotePubkey, JSON.stringify(getPubkeyRequest));
                    } catch (e) {
                        pubkeyEncrypted = await window.NostrTools.nip04.encrypt(
                            ephemeralPrivKeyHex,
                            remotePubkey,
                            JSON.stringify(getPubkeyRequest)
                        );
                    }

                    const pubkeyRequestEvent = {
                        kind: 24133,
                        pubkey: ephemeralPubKey,
                        content: pubkeyEncrypted,
                        tags: [['p', remotePubkey]],
                        created_at: Math.floor(Date.now() / 1000)
                    };

                    const signedPubkeyRequestEvent = window.NostrTools.finalizeEvent(pubkeyRequestEvent, ephemeralPrivKey);

                    ws.send(JSON.stringify(['EVENT', signedPubkeyRequestEvent]));

                    try {
                        const pubkeyResponse = await waitForNip46Response(ws, getPubkeyRequest.id, ephemeralPrivKeyHex, remotePubkey);

                        if (pubkeyResponse.result) {
                            approved = true;
                            const userPubkey = pubkeyResponse.result;

                            currentUser = { pubkey: userPubkey, nip46: true };
                            nip46Connection = {
                                relay,
                                remotePubkey,
                                ephemeralPrivKey: ephemeralPrivKeyHex,
                                ephemeralPubKey,
                                secret: nip46Secret
                            };

                            localStorage.setItem(STORAGE_KEYS.loginMethod, 'connect');
                            localStorage.setItem(STORAGE_KEYS.publicKey, userPubkey);
                            localStorage.setItem(STORAGE_KEYS.bunkerURL, bunkerUrl);
                            localStorage.setItem(STORAGE_KEYS.nip46Secret, JSON.stringify({
                                ephemeralPrivKey: ephemeralPrivKeyHex,
                                remotePubkey,
                                relay
                            }));

                            hideConnectionStatus();
                            hideConnectModal();
                            await onUserLoggedIn(true);
                        }
                    } catch (e) {
                        // Not approved yet, continue waiting
                    }
                }

                attempts++;
            }

            if (!approved) {
                throw new Error('Connection approval timeout');
            }

        } else if (connectResponse.result === 'ack') {
            showConnectionStatus('Connected! Getting public key...');

            const getPubkeyRequest = {
                id: generateRandomId(),
                method: 'get_public_key',
                params: []
            };

            let pubkeyEncrypted;
            try {
                pubkeyEncrypted = await encryptNip44(ephemeralPrivKeyHex, remotePubkey, JSON.stringify(getPubkeyRequest));
            } catch (e) {
                pubkeyEncrypted = await window.NostrTools.nip04.encrypt(
                    ephemeralPrivKeyHex,
                    remotePubkey,
                    JSON.stringify(getPubkeyRequest)
                );
            }

            const pubkeyRequestEvent = {
                kind: 24133,
                pubkey: ephemeralPubKey,
                content: pubkeyEncrypted,
                tags: [['p', remotePubkey]],
                created_at: Math.floor(Date.now() / 1000)
            };

            const signedPubkeyRequestEvent = window.NostrTools.finalizeEvent(pubkeyRequestEvent, ephemeralPrivKey);

            ws.send(JSON.stringify(['EVENT', signedPubkeyRequestEvent]));

            const pubkeyResponse = await waitForNip46Response(ws, getPubkeyRequest.id, ephemeralPrivKeyHex, remotePubkey);

            if (pubkeyResponse.result) {
                const userPubkey = pubkeyResponse.result;

                currentUser = { pubkey: userPubkey, nip46: true };
                nip46Connection = {
                    relay,
                    remotePubkey,
                    ephemeralPrivKey: ephemeralPrivKeyHex,
                    ephemeralPubKey,
                    secret: nip46Secret
                };

                localStorage.setItem(STORAGE_KEYS.loginMethod, 'connect');
                localStorage.setItem(STORAGE_KEYS.publicKey, userPubkey);
                localStorage.setItem(STORAGE_KEYS.bunkerURL, bunkerUrl);
                localStorage.setItem(STORAGE_KEYS.nip46Secret, JSON.stringify({
                    ephemeralPrivKey: ephemeralPrivKeyHex,
                    remotePubkey,
                    relay
                }));

                hideConnectionStatus();
                hideConnectModal();
                await onUserLoggedIn(true);
            } else {
                throw new Error('Failed to get public key from bunker');
            }
        } else {
            throw new Error(connectResponse.error || 'Connection rejected by bunker');
        }

    } catch (error) {
        console.error('NIP-46 connection failed:', error);
        hideConnectionStatus();
        showToast('Failed to connect: ' + error.message, 'error');
    }
}

// Show connection status
function showConnectionStatus(message) {
    // Update all possible status displays
    const stringStatus = document.getElementById('connectStringStatus');
    const qrStatus = document.getElementById('qrConnectionStatus');

    if (stringStatus && stringStatus.style.display !== 'none') {
        stringStatus.querySelector('span').textContent = message;
    }

    if (qrStatus && qrStatus.style.display !== 'none') {
        qrStatus.querySelector('span').textContent = message;
    }
}

function hideConnectionStatus() {
    const stringStatus = document.getElementById('connectStringStatus');
    const qrStatus = document.getElementById('qrConnectionStatus');

    if (stringStatus) stringStatus.style.display = 'none';
    if (qrStatus) qrStatus.style.display = 'none';
}

// Private key login functions
function showPrivateKeyModal() {
    hideLoginModal();
    document.getElementById('privateKeyModal').classList.add('active');
}

function hidePrivateKeyModal() {
    document.getElementById('privateKeyModal').classList.remove('active');
}

function toggleKeyVisibility() {
    const input = document.getElementById('privateKeyInput');
    const checkbox = document.getElementById('showKey');
    input.type = checkbox.checked ? 'text' : 'password';
}

async function loginWithPrivateKey() {
    const keyInput = document.getElementById('privateKeyInput').value.trim();

    if (!keyInput) {
        showToast('Please enter your private key', 'warning');
        return;
    }

    try {
        let privateKey;
        let publicKey;

        if (keyInput.startsWith('nsec1')) {
            // Decode nsec
            const decoded = window.NostrTools.nip19.decode(keyInput);
            if (decoded.type !== 'nsec') {
                throw new Error('Invalid nsec key');
            }
            privateKey = decoded.data;
            publicKey = window.NostrTools.getPublicKey(privateKey);
        } else if (/^[0-9a-fA-F]{64}$/.test(keyInput)) {
            // Hex private key - convert to Uint8Array for nostr-tools
            privateKey = hexToBytes(keyInput);
            publicKey = window.NostrTools.getPublicKey(privateKey);
        } else {
            throw new Error('Invalid private key format');
        }

        currentUser = { pubkey: publicKey, privateKey: bytesToHex(privateKey) };

        // Store login info
        localStorage.setItem(STORAGE_KEYS.loginMethod, 'privateKey');
        localStorage.setItem(STORAGE_KEYS.publicKey, publicKey);
        localStorage.setItem(STORAGE_KEYS.privateKey, bytesToHex(privateKey));

        hidePrivateKeyModal();
        await onUserLoggedIn(true);

    } catch (error) {
        console.error('Private key login failed:', error);
        showToast('Invalid private key. Please check and try again.', 'error');
    }
}

// Signup functions
let signupAvatarUrl = null;
let preGeneratedKeys = null; // Pre-generated keys for signup avatar upload

function showSignupModal() {
    hideLoginModal();
    // Reset the modal to initial state
    document.getElementById('nostrExplainer').style.display = 'block';
    document.getElementById('signupFormSection').style.display = 'none';
    document.getElementById('signupSuccess').style.display = 'none';
    signupAvatarUrl = null;
    preGeneratedKeys = null;

    // Reset form fields
    const usernameInput = document.getElementById('signupUsername');
    const aboutInput = document.getElementById('signupAbout');
    const lnInput = document.getElementById('signupLightningAddress');
    const nostrAddressInput = document.getElementById('signupNostrAddress');
    const nostrAddressStatus = document.getElementById('nostrAddressStatus');
    if (usernameInput) usernameInput.value = '';
    if (aboutInput) aboutInput.value = '';
    if (lnInput) lnInput.value = '';
    if (nostrAddressInput) nostrAddressInput.value = '';
    if (nostrAddressStatus) nostrAddressStatus.style.display = 'none';

    // Reset avatar preview
    resetAvatarUpload();

    document.getElementById('signupModal').classList.add('active');
}

function showSignupForm() {
    // Pre-generate keys so we can use them for avatar upload
    const privateKey = window.NostrTools.generateSecretKey();
    const publicKey = window.NostrTools.getPublicKey(privateKey);
    preGeneratedKeys = { privateKey, publicKey };

    document.getElementById('nostrExplainer').style.display = 'none';
    document.getElementById('signupFormSection').style.display = 'flex';
    updateSignupPreview();

    // Add input listeners for preview updates
    const usernameInput = document.getElementById('signupUsername');
    const aboutInput = document.getElementById('signupAbout');

    if (usernameInput) {
        usernameInput.addEventListener('input', updateSignupPreview);
    }
    if (aboutInput) {
        aboutInput.addEventListener('input', updateSignupPreview);
    }
}

function hideSignupModal() {
    document.getElementById('signupModal').classList.remove('active');
}

function updateSignupPreview() {
    const username = document.getElementById('signupUsername')?.value || 'Your Username';
    const about = document.getElementById('signupAbout')?.value || 'Your bio will appear here';

    const previewName = document.getElementById('previewName');
    const previewAbout = document.getElementById('previewAbout');
    const previewAvatarInitial = document.getElementById('previewAvatarInitial');
    const previewAvatarImage = document.getElementById('previewAvatarImage');
    const avatarInitial = document.getElementById('avatarInitial');

    if (previewName) previewName.textContent = username;
    if (previewAbout) previewAbout.textContent = about;

    // Update avatar preview
    if (signupAvatarUrl) {
        if (previewAvatarImage) {
            previewAvatarImage.src = signupAvatarUrl;
            previewAvatarImage.style.display = 'block';
        }
        if (previewAvatarInitial) previewAvatarInitial.style.display = 'none';
    } else {
        if (previewAvatarImage) previewAvatarImage.style.display = 'none';
        if (previewAvatarInitial) {
            previewAvatarInitial.style.display = 'block';
            previewAvatarInitial.textContent = username.charAt(0).toUpperCase() || '?';
        }
    }

    // Update the avatar placeholder initial
    if (avatarInitial && !signupAvatarUrl) {
        avatarInitial.textContent = username.charAt(0).toUpperCase() || '?';
    }
}

// Avatar upload for signup using Blossom (requires pre-generated keys)
async function handleAvatarSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    // Validate file
    if (!file.type.startsWith('image/')) {
        showToast('Please select an image file', 'error');
        return;
    }

    if (file.size > 5 * 1024 * 1024) {
        showToast('Image must be less than 5MB', 'error');
        return;
    }

    if (!preGeneratedKeys) {
        showToast('Please try again', 'error');
        return;
    }

    // Show local preview immediately
    const reader = new FileReader();
    reader.onload = (e) => {
        const avatarPreviewImage = document.getElementById('avatarPreviewImage');
        const avatarPlaceholder = document.getElementById('avatarPlaceholder');
        const avatarRemoveBtn = document.getElementById('avatarRemoveBtn');

        if (avatarPreviewImage) {
            avatarPreviewImage.src = e.target.result;
            avatarPreviewImage.style.display = 'block';
        }
        if (avatarPlaceholder) avatarPlaceholder.style.display = 'none';
        if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'block';
    };
    reader.readAsDataURL(file);

    // Show upload progress
    const progressDiv = document.getElementById('avatarUploadProgress');
    const progressFill = document.getElementById('avatarProgressFill');
    const statusSpan = document.getElementById('avatarUploadStatus');

    if (progressDiv) progressDiv.style.display = 'block';
    if (progressFill) progressFill.style.width = '20%';
    if (statusSpan) statusSpan.textContent = t('status.uploading');

    try {
        // Upload using Blossom with pre-generated keys
        const uploadedUrl = await uploadAvatarWithKeys(file, preGeneratedKeys.privateKey, preGeneratedKeys.publicKey);

        if (uploadedUrl) {
            signupAvatarUrl = uploadedUrl;
            if (progressFill) progressFill.style.width = '100%';
            if (statusSpan) statusSpan.textContent = t('status.uploadComplete');

            setTimeout(() => {
                if (progressDiv) progressDiv.style.display = 'none';
            }, 1500);

            updateSignupPreview();
            showToast('Avatar uploaded successfully!', 'success');
        } else {
            throw new Error('Upload failed');
        }
    } catch (error) {
        console.error('Avatar upload failed:', error);
        if (progressDiv) progressDiv.style.display = 'none';
        showToast('Failed to upload avatar. Please try again.', 'error');
        removeAvatarUpload();
    }
}

// Upload avatar to Blossom with specific keys (for signup flow)
async function uploadAvatarWithKeys(file, privateKey, publicKey) {
    const hash = await calculateSHA256(file);

    // Try each Blossom server
    for (const server of BLOSSOM_SERVERS) {
        try {
            // Create auth event for Blossom
            const expiration = Math.floor(Date.now() / 1000) + 300; // 5 minutes
            const authEvent = {
                kind: 24242,
                pubkey: publicKey,
                created_at: Math.floor(Date.now() / 1000),
                tags: [
                    ['t', 'upload'],
                    ['x', hash],
                    ['expiration', expiration.toString()]
                ],
                content: `Upload ${hash}`
            };

            // Sign with the provided keys
            const signedAuthEvent = window.NostrTools.finalizeEvent(authEvent, privateKey);
            const authHeader = btoa(JSON.stringify(signedAuthEvent));

            const response = await fetch(`${server}/upload`, {
                method: 'PUT',
                body: file,
                headers: {
                    'Content-Type': file.type,
                    'Authorization': `Nostr ${authHeader}`
                }
            });

            if (response.ok) {
                const result = await response.json();
                console.log(`Avatar uploaded successfully to ${server}`);
                return result.url || `${server}/${hash}`;
            }
        } catch (error) {
            console.error(`Failed to upload avatar to ${server}:`, error);
        }
    }

    throw new Error('Failed to upload to all servers');
}

function removeAvatarUpload() {
    signupAvatarUrl = null;

    const avatarPreviewImage = document.getElementById('avatarPreviewImage');
    const avatarPlaceholder = document.getElementById('avatarPlaceholder');
    const avatarRemoveBtn = document.getElementById('avatarRemoveBtn');
    const avatarFileInput = document.getElementById('avatarFileInput');

    if (avatarPreviewImage) avatarPreviewImage.style.display = 'none';
    if (avatarPlaceholder) avatarPlaceholder.style.display = 'flex';
    if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'none';
    if (avatarFileInput) avatarFileInput.value = '';

    updateSignupPreview();
}

function resetAvatarUpload() {
    signupAvatarUrl = null;

    const avatarPreviewImage = document.getElementById('avatarPreviewImage');
    const avatarPlaceholder = document.getElementById('avatarPlaceholder');
    const avatarRemoveBtn = document.getElementById('avatarRemoveBtn');
    const avatarFileInput = document.getElementById('avatarFileInput');
    const previewAvatarImage = document.getElementById('previewAvatarImage');
    const previewAvatarInitial = document.getElementById('previewAvatarInitial');

    if (avatarPreviewImage) avatarPreviewImage.style.display = 'none';
    if (avatarPlaceholder) {
        avatarPlaceholder.style.display = 'flex';
        const initial = avatarPlaceholder.querySelector('#avatarInitial');
        if (initial) initial.textContent = '?';
    }
    if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'none';
    if (avatarFileInput) avatarFileInput.value = '';
    if (previewAvatarImage) previewAvatarImage.style.display = 'none';
    if (previewAvatarInitial) {
        previewAvatarInitial.style.display = 'block';
        previewAvatarInitial.textContent = '?';
    }
}

async function signEvent(event) {
    if (!currentUser) {
        throw new Error('No user logged in');
    }

    // Ensure pubkey is set
    if (!event.pubkey) {
        event.pubkey = currentUser.pubkey;
    }

    if (window.nostr && !currentUser.privateKey && !currentUser.nip46) {
        // NIP-07 extension signing
        return await window.nostr.signEvent(event);
    } else if (currentUser.nip46) {
        // NIP-46 remote signing
        return await signEventWithNip46(event);
    } else if (currentUser.privateKey) {
        // Local key signing using nostr-tools
        const privKey = typeof currentUser.privateKey === 'string' ?
            hexToBytes(currentUser.privateKey) : currentUser.privateKey;

        // finalizeEvent returns the complete signed event
        const signedEvent = window.NostrTools.finalizeEvent(event, privKey);

        return signedEvent;
    } else {
        throw new Error('No signing method available');
    }
}

// Store generated keys for later use in finishAccountCreation
let generatedKeys = null;

async function createAccount() {
    const username = document.getElementById('signupUsername').value.trim();
    const about = document.getElementById('signupAbout').value.trim();
    const lightningAddress = document.getElementById('signupLightningAddress')?.value.trim() || '';
    const nostrAddressUsername = document.getElementById('signupNostrAddress')?.value.trim().toLowerCase() || '';

    if (!username) {
        showToast('Please enter a username', 'error');
        return;
    }

    // Validate required nostr address
    if (!nostrAddressUsername) {
        showToast(t('signup.nostrAddressRequired'), 'error');
        return;
    }

    if (!/^[a-z0-9_-]+$/.test(nostrAddressUsername)) {
        showToast(t('signup.nostrAddressInvalid'), 'error');
        return;
    }

    // Use pre-generated keys (created when entering signup form for avatar upload)
    if (!preGeneratedKeys) {
        showToast('Error: Keys not generated. Please try again.', 'error');
        return;
    }

    const createBtn = document.getElementById('createAccountBtn');
    if (createBtn) {
        createBtn.disabled = true;
        createBtn.textContent = t('button.creatingAccount');
    }

    try {
        // Use the pre-generated keys
        const privateKey = preGeneratedKeys.privateKey;
        const publicKey = preGeneratedKeys.publicKey;

        // Build profile content
        const profileContent = {
            name: username,
            about: about,
            picture: signupAvatarUrl
        };

        // Add lightning address if provided
        if (lightningAddress) {
            profileContent.lud16 = lightningAddress;
        }

        // Register NIP-05 address (required)
        // First check availability
        const availabilityResult = await checkNostrAddressAvailability(nostrAddressUsername);

        if (!availabilityResult.available) {
            if (availabilityResult.error === 'taken') {
                showToast(t('signup.nostrAddressUnavailable'), 'error');
            } else if (availabilityResult.error === 'invalid') {
                showToast(t('signup.nostrAddressInvalid'), 'error');
            } else {
                showToast(t('signup.nostrAddressFailed'), 'error');
            }
            if (createBtn) {
                createBtn.disabled = false;
                createBtn.textContent = t('signup.createAccountBtn');
            }
            return;
        }

        // Try to register
        if (createBtn) {
            createBtn.textContent = t('signup.nostrAddressRegistering');
        }

        const registerResult = await registerNostrAddress(nostrAddressUsername, publicKey, privateKey);

        if (registerResult.success) {
            profileContent.nip05 = registerResult.nip05;
        } else {
            // Registration failed - show error and stop
            console.error('NIP-05 registration failed:', registerResult.error);
            showToast(t('signup.nostrAddressFailed'), 'error');
            if (createBtn) {
                createBtn.disabled = false;
                createBtn.textContent = t('signup.createAccountBtn');
            }
            return;
        }

        if (createBtn) {
            createBtn.textContent = t('button.creatingAccount');
        }

        // Create profile event
        const profileEvent = {
            kind: 0,
            pubkey: publicKey,
            created_at: Math.floor(Date.now() / 1000),
            tags: [],
            content: JSON.stringify(profileContent)
        };

        // Use finalizeEvent to sign
        const signedProfileEvent = window.NostrTools.finalizeEvent(profileEvent, privateKey);

        // Publish profile
        await publishEvent(signedProfileEvent);

        // Create contact list
        const contactListEvent = {
            kind: 3,
            pubkey: publicKey,
            created_at: Math.floor(Date.now() / 1000),
            tags: [],
            content: ''
        };

        const signedContactListEvent = window.NostrTools.finalizeEvent(contactListEvent, privateKey);
        await publishEvent(signedContactListEvent);

        // Store keys for later use in finishAccountCreation
        generatedKeys = {
            privateKey: privateKey,
            publicKey: publicKey,
            nsec: window.NostrTools.nip19.nsecEncode(privateKey)
        };

        // Hide the form section and show success section
        document.getElementById('signupFormSection').style.display = 'none';
        document.getElementById('signupSuccess').style.display = 'block';
        document.getElementById('generatedNsec').textContent = generatedKeys.nsec;

    } catch (error) {
        console.error('Account creation failed:', error);
        showToast('Failed to create account. Please try again.', 'error');
    } finally {
        if (createBtn) {
            createBtn.disabled = false;
            createBtn.textContent = t('login.createAccount');
        }
    }
}

function copyGeneratedKey() {
    const nsec = document.getElementById('generatedNsec').textContent;
    navigator.clipboard.writeText(nsec).then(() => {
        // Update button to show copied
        const copyBtn = document.getElementById('copyNsecBtn');
        if (copyBtn) {
            copyBtn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
                </svg>
                Copied!
            `;
            copyBtn.style.background = 'var(--success-color)';
        }

        // Show the instructions section
        const keyInstructions = document.getElementById('keyInstructions');
        if (keyInstructions) {
            keyInstructions.style.display = 'block';
        }

        showToast('Private key copied to clipboard!', 'success');
    }).catch(() => {
        showToast('Failed to copy. Please copy manually.', 'error');
    });
}

function finishAccountCreation() {
    if (!generatedKeys) {
        showToast('Error: Keys not found. Please try again.', 'error');
        return;
    }

    // Log the user in
    currentUser = {
        pubkey: generatedKeys.publicKey,
        privateKey: bytesToHex(generatedKeys.privateKey)
    };

    localStorage.setItem(STORAGE_KEYS.loginMethod, 'privateKey');
    localStorage.setItem(STORAGE_KEYS.publicKey, generatedKeys.publicKey);
    localStorage.setItem(STORAGE_KEYS.privateKey, bytesToHex(generatedKeys.privateKey));

    // Clear the stored keys
    generatedKeys = null;
    signupAvatarUrl = null;
    preGeneratedKeys = null;

    hideSignupModal();
    onUserLoggedIn(true);

    showToast('Welcome to Plebs! You are now logged in.', 'success');
}

// NostrCheck.me API integration for NIP-05 registration
const NOSTRCHECK_API = 'https://nostrcheck.me/api/v2';
let nostrAddressCheckTimer = null;

// Check if a username is available on nostrcheck.me
async function checkNostrAddressAvailability(username) {
    if (!username || username.length < 1) {
        return { available: false, error: 'empty' };
    }

    // Validate username format (lowercase alphanumeric, underscore, hyphen)
    if (!/^[a-z0-9_-]+$/.test(username)) {
        return { available: false, error: 'invalid' };
    }

    try {
        const response = await fetch(`${NOSTRCHECK_API}/nostraddress?name=${encodeURIComponent(username)}`);

        // 404 means username is available (not found)
        if (response.status === 404) {
            return { available: true };
        }

        const data = await response.json();

        // If the username exists in the names object, it's taken
        if (data.names && data.names[username]) {
            return { available: false, error: 'taken' };
        }

        return { available: true };
    } catch (error) {
        console.error('Error checking nostr address availability:', error);
        return { available: false, error: 'network' };
    }
}

// Register a NIP-05 address on nostrcheck.me
async function registerNostrAddress(username, pubkey, privateKey) {
    if (!username || !pubkey || !privateKey) {
        return { success: false, error: 'missing_params' };
    }

    try {
        // Create NIP-98 authorization header
        const authEvent = {
            kind: 27235,
            created_at: Math.floor(Date.now() / 1000),
            tags: [
                ['u', `${NOSTRCHECK_API}/register`],
                ['method', 'POST']
            ],
            content: '',
            pubkey: pubkey
        };

        const signedAuthEvent = window.NostrTools.finalizeEvent(authEvent, privateKey);
        const authHeader = btoa(JSON.stringify(signedAuthEvent));

        // Generate a random password (not needed for login with nostr, but required by API)
        const randomPassword = Array.from(crypto.getRandomValues(new Uint8Array(16)))
            .map(b => b.toString(16).padStart(2, '0')).join('');

        const response = await fetch(`${NOSTRCHECK_API}/register`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Nostr ${authHeader}`
            },
            body: JSON.stringify({
                username: username,
                domain: 'nostrcheck.me',
                pubkey: pubkey,
                password: randomPassword
            })
        });

        const data = await response.json();

        if (response.ok && data.status === 'success') {
            return { success: true, nip05: `${username}@nostrcheck.me` };
        } else {
            console.error('NostrCheck registration failed:', data);
            return { success: false, error: data.message || 'registration_failed' };
        }
    } catch (error) {
        console.error('Error registering nostr address:', error);
        return { success: false, error: 'network' };
    }
}

// Update the nostr address status display
function updateNostrAddressStatus(status, message) {
    const statusDiv = document.getElementById('nostrAddressStatus');
    if (!statusDiv) return;

    statusDiv.style.display = 'flex';
    statusDiv.className = 'nostr-address-status ' + status;
    statusDiv.querySelector('.status-text').textContent = message;
}

// Handle nostr address input changes with debounce
function handleNostrAddressInput(event) {
    const username = event.target.value.trim().toLowerCase();
    const statusDiv = document.getElementById('nostrAddressStatus');

    // Clear previous timer
    if (nostrAddressCheckTimer) {
        clearTimeout(nostrAddressCheckTimer);
    }

    // Hide status if empty
    if (!username) {
        if (statusDiv) statusDiv.style.display = 'none';
        return;
    }

    // Validate format immediately
    if (!/^[a-z0-9_-]+$/.test(username)) {
        updateNostrAddressStatus('unavailable', t('signup.nostrAddressInvalid'));
        return;
    }

    // Show checking status
    updateNostrAddressStatus('checking', t('signup.nostrAddressChecking'));

    // Debounce the availability check
    nostrAddressCheckTimer = setTimeout(async () => {
        const result = await checkNostrAddressAvailability(username);

        if (result.available) {
            updateNostrAddressStatus('available', t('signup.nostrAddressAvailable'));
        } else if (result.error === 'taken') {
            updateNostrAddressStatus('unavailable', t('signup.nostrAddressUnavailable'));
        } else if (result.error === 'invalid') {
            updateNostrAddressStatus('unavailable', t('signup.nostrAddressInvalid'));
        } else {
            // Network error - hide status
            if (statusDiv) statusDiv.style.display = 'none';
        }
    }, 500);
}

// View own profile function
function viewOwnProfile() {
    if (!currentUser) {
        showLoginModal();
        return;
    }

    // Close the dropdown
    document.getElementById('userDropdown').classList.remove('active');

    // Navigate to profile
    const npub = window.NostrTools.nip19.npubEncode(currentUser.pubkey);
    navigateTo(`/profile/${npub}`);
}

// ===== Edit Profile Modal Functions =====

let editAvatarUrl = null;
let currentEditProfile = null;

async function showEditProfileModal() {
    if (!currentUser) {
        showLoginModal();
        return;
    }

    // Fetch current profile
    const profile = await fetchUserProfile(currentUser.pubkey);
    currentEditProfile = profile || {};

    // Populate form fields
    document.getElementById('editProfileName').value = profile?.name || profile?.display_name || '';
    document.getElementById('editProfileAbout').value = profile?.about || '';
    document.getElementById('editProfilePicture').value = profile?.picture || '';
    document.getElementById('editProfileLud16').value = profile?.lud16 || '';
    document.getElementById('editProfileNip05').value = profile?.nip05 || '';
    document.getElementById('editProfileWebsite').value = profile?.website || '';

    // Set avatar preview
    editAvatarUrl = profile?.picture || null;
    updateEditAvatarPreview();

    // Load muted users list
    loadMutedUsersList();

    // Show modal
    document.getElementById('editProfileModal').classList.add('active');
}

// Load and display muted users list in the profile edit modal
async function loadMutedUsersList(containerId = 'mutedUsersList', hideModalFn = 'hideEditProfileModal') {
    const container = document.getElementById(containerId);
    if (!container) return;

    container.innerHTML = '<div class="spinner" style="margin: 1rem auto;"></div>';

    // Ensure mute list is loaded
    if (!muteListLoaded) {
        await fetchMuteList();
    }

    if (mutedUsersCache.size === 0) {
        container.innerHTML = `<p class="no-muted-users">${t('empty.noMutedUsers')}</p>`;
        return;
    }

    // Fetch profiles for muted users
    const mutedPubkeys = Array.from(mutedUsersCache);
    const profiles = new Map();

    // Fetch profiles in batches
    const batchSize = 20;
    for (let i = 0; i < mutedPubkeys.length; i += batchSize) {
        const batch = mutedPubkeys.slice(i, i + batchSize);
        await Promise.all(batch.map(async (pubkey) => {
            const profile = await fetchUserProfile(pubkey);
            if (profile) profiles.set(pubkey, profile);
        }));
    }

    container.innerHTML = '';

    mutedPubkeys.forEach(pubkey => {
        const profile = profiles.get(pubkey) || {};
        const displayName = profile.name || profile.display_name || `User ${pubkey.slice(0, 8)}`;
        const avatarUrl = profile.picture || profile.avatar || '';

        const userItem = document.createElement('div');
        userItem.className = 'muted-user-item';
        userItem.dataset.pubkey = pubkey;
        userItem.innerHTML = `
            <a href="#/profile/${pubkey}" class="muted-user-info" onclick="${hideModalFn}()">
                <div class="muted-user-avatar">
                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${escapeHtml(displayName)}">` : `<span>${displayName.charAt(0).toUpperCase()}</span>`}
                </div>
                <span class="muted-user-name">${escapeHtml(displayName)}</span>
            </a>
            <button class="unmute-btn" onclick="handleUnmuteFromModal('${pubkey}')" title="${t('button.unmuteUser')}">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                </svg>
            </button>
        `;
        container.appendChild(userItem);
    });
}

// Handle unmute from any modal (profile edit or settings)
async function handleUnmuteFromModal(pubkey) {
    // Get all matching items from both modals
    const userItems = document.querySelectorAll(`.muted-user-item[data-pubkey="${pubkey}"]`);
    userItems.forEach(item => item.classList.add('removing'));

    const success = await unmuteUser(pubkey);

    if (success) {
        userItems.forEach(item => item.remove());
        // Check both containers for empty state
        const containers = ['mutedUsersList', 'settingsMutedUsersList'];
        containers.forEach(containerId => {
            const container = document.getElementById(containerId);
            if (container && container.children.length === 0) {
                container.innerHTML = `<p class="no-muted-users">${t('empty.noMutedUsers')}</p>`;
            }
        });
        showToast('User unmuted', 'success');
    } else {
        userItems.forEach(item => item.classList.remove('removing'));
        showToast('Failed to unmute user', 'error');
    }
}

function hideEditProfileModal() {
    document.getElementById('editProfileModal').classList.remove('active');
    editAvatarUrl = null;
    currentEditProfile = null;
}

function updateEditAvatarPreview() {
    const avatarPreviewImage = document.getElementById('editAvatarPreviewImage');
    const avatarPlaceholder = document.getElementById('editAvatarPlaceholder');
    const avatarRemoveBtn = document.getElementById('editAvatarRemoveBtn');
    const name = document.getElementById('editProfileName')?.value || '';

    if (editAvatarUrl) {
        if (avatarPreviewImage) {
            avatarPreviewImage.src = editAvatarUrl;
            avatarPreviewImage.style.display = 'block';
        }
        if (avatarPlaceholder) avatarPlaceholder.style.display = 'none';
        if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'block';
    } else {
        if (avatarPreviewImage) avatarPreviewImage.style.display = 'none';
        if (avatarPlaceholder) {
            avatarPlaceholder.style.display = 'flex';
            const initial = document.getElementById('editAvatarInitial');
            if (initial) initial.textContent = name.charAt(0).toUpperCase() || '?';
        }
        if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'none';
    }
}

async function handleEditAvatarSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    // Validate file
    if (!file.type.startsWith('image/')) {
        showToast('Please select an image file', 'error');
        return;
    }

    if (file.size > 5 * 1024 * 1024) {
        showToast('Image must be less than 5MB', 'error');
        return;
    }

    // Show local preview immediately
    const reader = new FileReader();
    reader.onload = (e) => {
        const avatarPreviewImage = document.getElementById('editAvatarPreviewImage');
        const avatarPlaceholder = document.getElementById('editAvatarPlaceholder');
        const avatarRemoveBtn = document.getElementById('editAvatarRemoveBtn');

        if (avatarPreviewImage) {
            avatarPreviewImage.src = e.target.result;
            avatarPreviewImage.style.display = 'block';
        }
        if (avatarPlaceholder) avatarPlaceholder.style.display = 'none';
        if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'block';
    };
    reader.readAsDataURL(file);

    // Show upload progress
    const progressDiv = document.getElementById('editAvatarUploadProgress');
    const progressFill = document.getElementById('editAvatarProgressFill');
    const statusSpan = document.getElementById('editAvatarUploadStatus');

    if (progressDiv) progressDiv.style.display = 'block';
    if (progressFill) progressFill.style.width = '20%';
    if (statusSpan) statusSpan.textContent = t('status.uploadingToNostrBuild');

    try {
        // Upload to nostr.build
        const uploadedUrl = await uploadToNostrBuild(file);

        if (uploadedUrl) {
            editAvatarUrl = uploadedUrl;
            document.getElementById('editProfilePicture').value = uploadedUrl;

            if (progressFill) progressFill.style.width = '100%';
            if (statusSpan) statusSpan.textContent = t('status.uploadComplete');

            setTimeout(() => {
                if (progressDiv) progressDiv.style.display = 'none';
            }, 1500);

            showToast('Avatar uploaded successfully!', 'success');
        } else {
            throw new Error('Upload failed');
        }
    } catch (error) {
        console.error('Avatar upload failed:', error);
        if (progressDiv) progressDiv.style.display = 'none';
        showToast('Failed to upload avatar. Please try again.', 'error');
    }
}

function removeEditAvatarUpload() {
    editAvatarUrl = null;
    document.getElementById('editProfilePicture').value = '';

    const avatarPreviewImage = document.getElementById('editAvatarPreviewImage');
    const avatarPlaceholder = document.getElementById('editAvatarPlaceholder');
    const avatarRemoveBtn = document.getElementById('editAvatarRemoveBtn');
    const avatarFileInput = document.getElementById('editAvatarFileInput');

    if (avatarPreviewImage) avatarPreviewImage.style.display = 'none';
    if (avatarPlaceholder) avatarPlaceholder.style.display = 'flex';
    if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'none';
    if (avatarFileInput) avatarFileInput.value = '';
}

async function saveProfile() {
    if (!currentUser) {
        showToast('You must be logged in to edit your profile', 'error');
        return;
    }

    const name = document.getElementById('editProfileName').value.trim();
    const about = document.getElementById('editProfileAbout').value.trim();
    const picture = document.getElementById('editProfilePicture').value.trim() || editAvatarUrl || '';
    const lud16 = document.getElementById('editProfileLud16').value.trim();
    const nip05 = document.getElementById('editProfileNip05').value.trim();
    const website = document.getElementById('editProfileWebsite').value.trim();

    if (!name) {
        showToast('Please enter a display name', 'error');
        return;
    }

    const saveBtn = document.getElementById('saveProfileBtn');
    if (saveBtn) {
        saveBtn.disabled = true;
        saveBtn.textContent = t('status.saving');
    }

    try {
        // Build profile content, preserving any existing fields
        const profileContent = {
            ...currentEditProfile,
            name: name
        };

        // Only include fields if they have values
        if (about) profileContent.about = about;
        else delete profileContent.about;

        if (picture) profileContent.picture = picture;
        else delete profileContent.picture;

        if (lud16) profileContent.lud16 = lud16;
        else delete profileContent.lud16;

        if (nip05) profileContent.nip05 = nip05;
        else delete profileContent.nip05;

        if (website) profileContent.website = website;
        else delete profileContent.website;

        // Create kind 0 event
        const profileEvent = {
            kind: 0,
            created_at: Math.floor(Date.now() / 1000),
            tags: [],
            content: JSON.stringify(profileContent)
        };

        // Sign and publish
        const signedEvent = await signEvent(profileEvent);
        const published = await publishEvent(signedEvent);

        if (published) {
            // Update local cache
            profileCache.set(currentUser.pubkey, profileContent);
            localStorage.setItem(STORAGE_KEYS.profile, JSON.stringify(profileContent));

            // Update user avatar in header
            updateUserInterface();

            showToast('Profile updated successfully!', 'success');
            hideEditProfileModal();

            // Reload the profile page if we're on it
            if (currentView.startsWith('profile-')) {
                loadProfile(currentUser.pubkey);
            }
        } else {
            throw new Error('Failed to publish profile update');
        }
    } catch (error) {
        console.error('Failed to save profile:', error);
        showToast('Failed to save profile. Please try again.', 'error');
    } finally {
        if (saveBtn) {
            saveBtn.disabled = false;
            saveBtn.textContent = t('common.saveChanges');
        }
    }
}

// Logout function
async function handleLogout() {
    showConfirmModal(
        'Logout',
        'Are you sure you want to logout?',
        () => {
            // Close any NIP-46 connections
            if (nip46Connection) {
                // Send disconnect message
                nip46Connection = null;
            }

            clearStoredLogin();

            // Close dropdown
            document.getElementById('userDropdown').classList.remove('active');

            // Refresh current view
            handleRoute();
        },
        { confirmText: 'Logout' }
    );
}

// Helper functions
function getPublicKeyFromPrivate(privateKey) {
    // Convert hex to Uint8Array if needed
    if (typeof privateKey === 'string') {
        return window.NostrTools.getPublicKey(hexToBytes(privateKey));
    }
    return window.NostrTools.getPublicKey(privateKey);
}

function generateRandomId() {
    // Use crypto.getRandomValues for browser compatibility
    const bytes = new Uint8Array(32);
    crypto.getRandomValues(bytes);
    return bytesToHex(bytes);
}

function generateRandomHex(length) {
    const bytes = new Uint8Array(length / 2);
    crypto.getRandomValues(bytes);
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

// Sign event based on current auth method
async function signEventForBundle(event, privateKey) {
    // The browser bundle uses finalizeEvent which both calculates id and signs
    const signedEvent = window.NostrTools.finalizeEvent(event, privateKey);
    return signedEvent.sig;
}

async function encryptNip44(privateKey, publicKey, content) {
    const privKeyBytes = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;
    const pubKeyHex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);

    try {
        if (window.NostrTools.nip44.encrypt) {
            return await window.NostrTools.nip44.encrypt(
                privateKey,
                publicKey,
                content
            );
        }
    } catch (e) {
        // Silently fall back to NIP-04
    }

    try {
        const conversationKey = window.NostrTools.nip44.getConversationKey(
            privKeyBytes,
            pubKeyHex
        );

        if (window.NostrTools.nip44.v2 && window.NostrTools.nip44.v2.encrypt) {
            return window.NostrTools.nip44.v2.encrypt(
                content,
                conversationKey
            );
        }
    } catch (e) {
        // Silently fall back to NIP-04
    }

    throw new Error('Failed to encrypt with NIP-44');
}

// NIP-46 signing
async function signEventWithNip46(event) {
    if (!nip46Connection) {
        throw new Error('No NIP-46 connection');
    }

    const request = {
        id: generateRandomId(),
        method: 'sign_event',
        params: [JSON.stringify(event)]
    };

    const ws = await connectToRelay(nip46Connection.relay);

    const ephemeralPrivKeyHex = nip46Connection.ephemeralPrivKey;

    let encryptedContent;
    try {
        encryptedContent = await encryptNip44(
            ephemeralPrivKeyHex,
            nip46Connection.remotePubkey,
            JSON.stringify(request)
        );
    } catch (e) {
        encryptedContent = await window.NostrTools.nip04.encrypt(
            ephemeralPrivKeyHex,
            nip46Connection.remotePubkey,
            JSON.stringify(request)
        );
    }

    const requestEvent = {
        kind: 24133,
        pubkey: nip46Connection.ephemeralPubKey,
        content: encryptedContent,
        tags: [['p', nip46Connection.remotePubkey]],
        created_at: Math.floor(Date.now() / 1000)
    };

    const signedRequestEvent = window.NostrTools.finalizeEvent(requestEvent, hexToBytes(ephemeralPrivKeyHex));

    ws.send(JSON.stringify(['EVENT', signedRequestEvent]));

    const response = await waitForNip46Response(
        ws,
        request.id,
        ephemeralPrivKeyHex,
        nip46Connection.remotePubkey
    );

    if (response.error) {
        throw new Error(response.error);
    }

    return JSON.parse(response.result);
}

// Compute shared secret for NIP-04 encryption
async function computeSharedSecret(privateKey, publicKey) {
    // Convert keys to proper format if needed
    const privKeyBytes = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;
    const pubKeyBytes = typeof publicKey === 'string' ? hexToBytes(publicKey) : publicKey;

    // Use secp256k1 to compute shared secret
    const sharedPoint = window.NostrTools.secp256k1.getSharedSecret(privKeyBytes, '02' + bytesToHex(pubKeyBytes));
    return sharedPoint.slice(1); // Remove the prefix byte
}

// Encrypt message using NIP-04
async function encryptMessage(message, sharedSecret) {
    const iv = crypto.getRandomValues(new Uint8Array(16));
    const key = await crypto.subtle.importKey(
        'raw',
        sharedSecret.slice(0, 32),
        { name: 'AES-CBC' },
        false,
        ['encrypt']
    );

    const encoded = new TextEncoder().encode(message);
    const padded = addPKCS7Padding(encoded);

    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-CBC', iv },
        key,
        padded
    );

    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encrypted), iv.length);

    return bytesToBase64(combined);
}

// Decrypt message using NIP-04
async function decryptMessage(encryptedBase64, sharedSecret) {
    const combined = base64ToBytes(encryptedBase64);
    const iv = combined.slice(0, 16);
    const ciphertext = combined.slice(16);

    const key = await crypto.subtle.importKey(
        'raw',
        sharedSecret.slice(0, 32),
        { name: 'AES-CBC' },
        false,
        ['decrypt']
    );

    const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-CBC', iv },
        key,
        ciphertext
    );

    const decoded = removePKCS7Padding(new Uint8Array(decrypted));
    return new TextDecoder().decode(decoded);
}

// Helper functions for encryption
function hexToBytes(hex) {
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
    }
    return bytes;
}

function bytesToHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

function bytesToBase64(bytes) {
    return btoa(String.fromCharCode.apply(null, bytes));
}

function base64ToBytes(base64) {
    return new Uint8Array(atob(base64).split('').map(c => c.charCodeAt(0)));
}

function addPKCS7Padding(data) {
    const blockSize = 16;
    const padding = blockSize - (data.length % blockSize);
    const padded = new Uint8Array(data.length + padding);
    padded.set(data);
    padded.fill(padding, data.length);
    return padded;
}

function removePKCS7Padding(data) {
    const padding = data[data.length - 1];
    return data.slice(0, data.length - padding);
}

async function signEventWithConnection(event) {
    // Sign with local ephemeral key for NIP-46 connection
    const ephemeralKey = generateRandomHex(32);
    event.pubkey = window.NostrTools.getPublicKey(ephemeralKey);
    event.id = window.NostrTools.getEventHash(event);
    event.sig = window.NostrTools.signEvent(event, ephemeralKey);
    return event;
}

async function reconnectNip46(bunkerUrl, secretData) {
    try {
        const data = JSON.parse(secretData);
        const { ephemeralPrivKey, remotePubkey, relay } = data;

        // Convert hex private key back to Uint8Array if needed
        const privKeyBytes = typeof ephemeralPrivKey === 'string' ?
            hexToBytes(ephemeralPrivKey) : ephemeralPrivKey;
        const ephemeralPrivKeyHex = typeof ephemeralPrivKey === 'string' ?
            ephemeralPrivKey : bytesToHex(ephemeralPrivKey);

        const ephemeralPubKey = window.NostrTools.getPublicKey(privKeyBytes);

        // Reconnect and verify
        const ws = await connectToRelay(relay);

        // Subscribe to responses
        const subId = generateRandomId();
        const subscription = JSON.stringify([
            'REQ',
            subId,
            {
                kinds: [24133],
                '#p': [ephemeralPubKey],
                since: Math.floor(Date.now() / 1000) - 60
            }
        ]);
        ws.send(subscription);

        // Test connection with get_public_key
        const getPubkeyRequest = {
            id: generateRandomId(),
            method: 'get_public_key',
            params: []
        };

        let encryptedContent;
        try {
            encryptedContent = await encryptNip44(ephemeralPrivKeyHex, remotePubkey, JSON.stringify(getPubkeyRequest));
        } catch (e) {
            encryptedContent = await window.NostrTools.nip04.encrypt(
                ephemeralPrivKeyHex,
                remotePubkey,
                JSON.stringify(getPubkeyRequest)
            );
        }

        const requestEvent = {
            kind: 24133,
            pubkey: ephemeralPubKey,
            content: encryptedContent,
            tags: [['p', remotePubkey]],
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedRequestEvent = window.NostrTools.finalizeEvent(requestEvent, privKeyBytes);

        ws.send(JSON.stringify(['EVENT', signedRequestEvent]));

        const response = await waitForNip46Response(ws, getPubkeyRequest.id, ephemeralPrivKeyHex, remotePubkey);

        if (response.result) {
            currentUser = { pubkey: response.result, nip46: true };
            nip46Connection = {
                relay,
                remotePubkey,
                ephemeralPrivKey: ephemeralPrivKeyHex,
                ephemeralPubKey,
                secret: remotePubkey
            };
            await onUserLoggedIn();
        } else {
            throw new Error('Failed to reconnect');
        }
    } catch (error) {
        console.error('NIP-46 reconnection failed:', error);
        clearStoredLogin();
    }
}

// Ensure user is logged in
async function ensureLoggedIn() {
    if (currentUser) {
        return true;
    }

    showLoginModal();
    return false;
}

// Default settings for merging
const defaultSettings = {
    useWotRelays: false,
    usePremiumBlossom: false,
    customBlossomServers: [],
    saveToNostr: true,
    showNSFWWarnings: true,
    showCommunityWarnings: true,
    showFollowsReportWarnings: true,
    enabledFilterPacks: [],
    customKeywordFilter: [],
    theme: null, // null means use system preference
    lastNotificationView: 0, // Timestamp of last notification view
    notifications: {
        reactions: true,
        replies: true,
        zaps: true,
        chatMentions: true,
        newFollowers: true
    }
};

// Initialize settings after login
async function initializeSettings() {
    if (isInitializingSettings) return;
    isInitializingSettings = true;

    try {
        // Try to load from Nostr if user is logged in
        if (currentUser) {
            const nostrSettings = await loadSettingsFromNostr();
            if (nostrSettings) {
                // Deep merge with defaults to ensure all fields exist (especially nested notifications)
                userSettings = {
                    ...defaultSettings,
                    ...nostrSettings,
                    notifications: { ...defaultSettings.notifications, ...(nostrSettings.notifications || {}) }
                };
                applySettings();
                return;
            }
        }

        // Fall back to localStorage
        const savedSettings = localStorage.getItem('plebsSettings');
        if (savedSettings) {
            try {
                const parsed = JSON.parse(savedSettings);
                // Deep merge with defaults to ensure all fields exist (especially nested notifications)
                userSettings = {
                    ...defaultSettings,
                    ...parsed,
                    notifications: { ...defaultSettings.notifications, ...(parsed.notifications || {}) }
                };
                applySettings();
            } catch (e) {
                console.error('Failed to parse saved settings:', e);
            }
        }
    } finally {
        isInitializingSettings = false;
    }
}

// Load settings from Nostr
async function loadSettingsFromNostr() {
    if (!currentUser) return null;

    try {
        const filter = {
            kinds: [30078],
            authors: [currentUser.pubkey],
            '#d': ['plebs-settings'],
            limit: 1
        };

        let settings = null;
        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                try {
                    settings = JSON.parse(event.content);
                } catch (e) {
                    console.error('Failed to parse Nostr settings:', e);
                }
            }, resolve);
        });

        return settings;
    } catch (error) {
        console.error('Failed to load settings from Nostr:', error);
        return null;
    }
}

// Save settings to Nostr
async function saveSettingsToNostr() {
    if (!currentUser) return false;

    try {
        const settingsEvent = {
            kind: 30078,
            tags: [
                ['d', 'plebs-settings'],
                ['title', 'Plebs App Settings'],
                ['client', 'Plebs']
            ],
            content: JSON.stringify(userSettings),
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(settingsEvent);
        return await publishEvent(signedEvent);
    } catch (error) {
        console.error('Failed to save settings to Nostr:', error);
        return false;
    }
}

// Apply settings to the app
function applySettings() {
    const previousRelayUrls = [...RELAY_URLS];

    // Update relay URLs based on settings
    if (userSettings.useWotRelays) {
        RELAY_URLS.length = 0;
        RELAY_URLS.push(...WOT_RELAY_URLS);
    } else {
        RELAY_URLS.length = 0;
        RELAY_URLS.push(
            'wss://relay.damus.io',
            'wss://relay.coinos.io',
            'wss://nos.lol',
            'wss://relay.primal.net'
        );
    }

    // Only disconnect if relay URLs actually changed
    const relaysChanged = previousRelayUrls.length !== RELAY_URLS.length ||
        previousRelayUrls.some((url, index) => url !== RELAY_URLS[index]);

    if (relaysChanged) {
        // Close connections to ALL existing relays first
        Object.entries(relayConnections).forEach(([url, ws]) => {
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                ws.close();
            }
            delete relayConnections[url];
        });

        // Clear any existing subscription handlers to prevent memory leaks
        if (window.subscriptionHandlers) {
            window.subscriptionHandlers = {};
        }

        // Initialize connections to new relays
        initializeRelayConnections().then(() => {
            console.log('Relay connections updated after settings change');
        });
    }

    // Update Blossom servers based on settings
    BLOSSOM_SERVERS.length = 0;

    BLOSSOM_SERVERS.push(
        'https://blossom.primal.net',
        'https://blossom.band',
        'https://24242.io',
        'https://nostr.media'
    );

    if (userSettings.usePremiumBlossom) {
        BLOSSOM_SERVERS.unshift(PREMIUM_BLOSSOM_SERVER);
    }

    if (userSettings.customBlossomServers.length > 0) {
        BLOSSOM_SERVERS.push(...userSettings.customBlossomServers);
    }

    // Apply warning preferences
    if (userSettings.showNSFWWarnings) {
        localStorage.removeItem('allowNSFW');
        sessionNSFWAllowed = false;
    } else {
        localStorage.setItem('allowNSFW', 'true');
        sessionNSFWAllowed = true;
    }

    if (userSettings.showCommunityWarnings) {
        localStorage.removeItem('allowCommunityWarning');
    } else {
        localStorage.setItem('allowCommunityWarning', 'true');
    }

    // Apply filter packs
    if (userSettings.enabledFilterPacks && userSettings.enabledFilterPacks.length > 0) {
        enabledFilterPacks = new Set(userSettings.enabledFilterPacks);
        saveFilterPacks();
    }

    // Apply theme from settings if set
    if (userSettings.theme) {
        document.documentElement.setAttribute('data-theme', userSettings.theme);
        localStorage.setItem('theme', userSettings.theme);
    }
}

// Show settings modal
function showSettingsModal() {
    if (!currentUser) {
        ensureLoggedIn().then(loggedIn => {
            if (!loggedIn) {
                return;
            }
            // If user logs in successfully, show the settings modal
            showSettingsModalContent();
        });
        return;
    }

    showSettingsModalContent();
}

// Helper function to show settings modal content
function showSettingsModalContent() {
    document.getElementById('useWotRelays').checked = userSettings.useWotRelays;
    document.getElementById('usePremiumBlossom').checked = userSettings.usePremiumBlossom;
    document.getElementById('customBlossomServers').value = userSettings.customBlossomServers.join(', ');
    document.getElementById('saveToNostr').checked = userSettings.saveToNostr;

    // Set dark mode toggle state
    const currentTheme = document.documentElement.getAttribute('data-theme');
    document.getElementById('darkModeToggle').checked = currentTheme === 'dark';

    // Set language selector value
    const langSelect = document.getElementById('languageSelect');
    if (langSelect) {
        langSelect.value = currentLanguage;
    }

    // Load warning preferences from userSettings
    document.getElementById('showNSFWWarnings').checked = userSettings.showNSFWWarnings;
    document.getElementById('showCommunityWarnings').checked = userSettings.showCommunityWarnings;
    document.getElementById('showFollowsReportWarnings').checked = userSettings.showFollowsReportWarnings;

    // Load custom keyword filter
    document.getElementById('customKeywordFilter').value = userSettings.customKeywordFilter.join(', ');

    // Sync enabledFilterPacks Set with userSettings
    if (userSettings.enabledFilterPacks && userSettings.enabledFilterPacks.length > 0) {
        enabledFilterPacks = new Set(userSettings.enabledFilterPacks);
    }

    // Populate filter packs list
    populateFilterPacksList();

    // Load muted users list
    loadMutedUsersList('settingsMutedUsersList', 'hideSettingsModal');

    document.getElementById('settingsModal').classList.add('active');
}

// Populate filter packs list in settings
function populateFilterPacksList() {
    const container = document.getElementById('filterPacksList');
    if (!container) return;

    let html = '';
    for (const [packId, pack] of Object.entries(FILTER_PACKS)) {
        const isEnabled = enabledFilterPacks.has(packId);
        const packName = t(pack.nameKey);
        const packDesc = t(pack.descKey);
        html += `
            <div class="filter-pack-item">
                <div class="filter-pack-header">
                    <div class="checkbox-group">
                        <input type="checkbox" id="filterPack_${packId}"
                               ${isEnabled ? 'checked' : ''}
                               onchange="toggleFilterPack('${packId}')">
                        <label for="filterPack_${packId}">
                            <span class="filter-pack-icon">${pack.icon}</span>
                            ${packName}
                        </label>
                    </div>
                </div>
                <p class="filter-pack-description">${packDesc}</p>
            </div>
        `;
    }
    container.innerHTML = html;
}

// Hide settings modal
function hideSettingsModal() {
    document.getElementById('settingsModal').classList.remove('active');
}

// Toggle WoT relays
function toggleWotRelays() {
    const checkbox = document.getElementById('useWotRelays');
    userSettings.useWotRelays = checkbox.checked;
}

// Toggle premium Blossom
function togglePremiumBlossom() {
    const checkbox = document.getElementById('usePremiumBlossom');
    userSettings.usePremiumBlossom = checkbox.checked;
}

// Save settings
async function saveSettings() {
    const customServersInput = document.getElementById('customBlossomServers').value;
    userSettings.customBlossomServers = customServersInput
        .split(',')
        .map(url => url.trim())
        .filter(url => url.startsWith('http'));

    userSettings.saveToNostr = document.getElementById('saveToNostr').checked;

    // Save warning preferences
    userSettings.showNSFWWarnings = document.getElementById('showNSFWWarnings').checked;
    userSettings.showCommunityWarnings = document.getElementById('showCommunityWarnings').checked;
    userSettings.showFollowsReportWarnings = document.getElementById('showFollowsReportWarnings').checked;

    // Save custom keyword filter
    const customKeywordsInput = document.getElementById('customKeywordFilter').value;
    userSettings.customKeywordFilter = customKeywordsInput
        .split(',')
        .map(kw => kw.trim().toLowerCase())
        .filter(kw => kw.length > 0);

    // Save enabled filter packs
    userSettings.enabledFilterPacks = [...enabledFilterPacks];

    // Update legacy localStorage for backwards compatibility
    if (userSettings.showNSFWWarnings) {
        localStorage.removeItem('allowNSFW');
        sessionNSFWAllowed = false;
    } else {
        localStorage.setItem('allowNSFW', 'true');
        sessionNSFWAllowed = true;
    }

    if (userSettings.showCommunityWarnings) {
        localStorage.removeItem('allowCommunityWarning');
    } else {
        localStorage.setItem('allowCommunityWarning', 'true');
    }

    localStorage.setItem('plebsSettings', JSON.stringify(userSettings));

    if (userSettings.saveToNostr && currentUser) {
        const saved = await saveSettingsToNostr();
        if (saved) {
            showToast('Settings saved successfully!', 'success');
        } else {
            showToast('Settings saved locally. Could not save to Nostr.', 'warning');
        }
    } else {
        showToast('Settings saved locally!', 'success');
    }

    applySettings();
    hideSettingsModal();
    handleRoute();
}

// Reset settings to defaults
function resetSettings() {
    showConfirmModal(
        'Reset Settings',
        'Are you sure you want to reset all settings to defaults?',
        () => {
            userSettings = {
                useWotRelays: false,
                usePremiumBlossom: false,
                customBlossomServers: [],
                saveToNostr: true,
                showNSFWWarnings: true,
                showCommunityWarnings: true,
                showFollowsReportWarnings: true,
                enabledFilterPacks: [],
                customKeywordFilter: []
            };

            // Clear filter packs
            enabledFilterPacks.clear();
            localStorage.removeItem('plebsFilterPacks');

            localStorage.removeItem('plebsSettings');

            // Reset warning preferences to show warnings (remove allow flags)
            localStorage.removeItem('allowNSFW');
            localStorage.removeItem('allowCommunityWarning');
            sessionNSFWAllowed = false;

            applySettings();
            showSettingsModal();

            showToast('Settings reset to defaults!', 'success');
        },
        { confirmText: 'Reset', danger: true }
    );
}

// Sidebar management
function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.querySelector('.sidebar-overlay');

    sidebar.classList.toggle('expanded');
    overlay.classList.toggle('active');
}

function closeSidebarOnNavigate() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.querySelector('.sidebar-overlay');
    if (sidebar.classList.contains('expanded')) {
        sidebar.classList.remove('expanded');
        overlay.classList.remove('active');
    }
}

// Close sidebar when clicking on any link inside it (using event delegation)
document.getElementById('sidebar').addEventListener('click', (e) => {
    const link = e.target.closest('a');
    if (link) {
        closeSidebarOnNavigate();
    }
});

// Swipe gesture support for opening/closing sidebar
(function initSidebarSwipe() {
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const swipeThreshold = 50;
    const edgeThreshold = 30; // How close to edge to start swipe

    document.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    }, { passive: true });

    document.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        handleSwipe();
    }, { passive: true });

    function handleSwipe() {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const sidebar = document.getElementById('sidebar');
        const overlay = document.querySelector('.sidebar-overlay');

        // Only handle horizontal swipes (ignore if vertical movement is greater)
        if (Math.abs(deltaY) > Math.abs(deltaX)) {
            return;
        }

        // Swipe right from left edge to open sidebar
        if (deltaX > swipeThreshold && touchStartX < edgeThreshold) {
            if (!sidebar.classList.contains('expanded')) {
                sidebar.classList.add('expanded');
                overlay.classList.add('active');
            }
        }

        // Swipe left to close sidebar (when sidebar is open)
        if (deltaX < -swipeThreshold && sidebar.classList.contains('expanded')) {
            sidebar.classList.remove('expanded');
            overlay.classList.remove('active');
        }
    }
})();

// URL Routing with hash
function navigateTo(path) {
    window.location.hash = path;
}

// Routes based on page type
async function handleRoute() {
    hideNotificationsModal();

    // Clean up live chat subscriptions when navigating away
    if (currentView === 'live') {
        cleanupLiveChatSubscriptions();
    }

    const hash = window.location.hash.slice(1) || '/';
    const pathParts = hash.split('/').filter(p => p);

    // Update meta tags with structured data
    const updateMetaTags = (title, description, image = null, type = 'website') => {
        const ogImage = image || './images/plebs-og.png';

        document.title = title;

        const setMetaTag = (selector, attribute, value) => {
            let tag = document.querySelector(selector);
            if (!tag && selector.includes('property')) {
                tag = document.createElement('meta');
                tag.setAttribute('property', selector.match(/property="([^"]+)"/)[1]);
                document.head.appendChild(tag);
            } else if (!tag && selector.includes('name')) {
                tag = document.createElement('meta');
                tag.setAttribute('name', selector.match(/name="([^"]+)"/)[1]);
                document.head.appendChild(tag);
            }
            if (tag) tag.setAttribute('content', value);
        };

        setMetaTag('meta[name="description"]', 'content', description);
        setMetaTag('meta[property="og:title"]', 'content', title);
        setMetaTag('meta[property="og:description"]', 'content', description);
        setMetaTag('meta[property="og:type"]', 'content', type);
        setMetaTag('meta[property="og:site_name"]', 'content', 'Plebs');
        setMetaTag('meta[property="og:image"]', 'content', ogImage);

        // Include the full URL with hash
        const fullUrl = window.location.href;
        setMetaTag('meta[property="og:url"]', 'content', fullUrl);

        setMetaTag('meta[name="twitter:card"]', 'content', image ? 'summary_large_image' : 'summary');
        setMetaTag('meta[name="twitter:title"]', 'content', title);
        setMetaTag('meta[name="twitter:description"]', 'content', description);
        setMetaTag('meta[name="twitter:image"]', 'content', ogImage);

        let canonical = document.querySelector('link[rel="canonical"]');
        if (!canonical) {
            canonical = document.createElement('link');
            canonical.setAttribute('rel', 'canonical');
            document.head.appendChild(canonical);
        }
        canonical.setAttribute('href', fullUrl);
    };

    // Add JSON-LD structured data
    const setStructuredData = (data) => {
        let script = document.querySelector('script[type="application/ld+json"]');
        if (!script) {
            script = document.createElement('script');
            script.type = 'application/ld+json';
            document.head.appendChild(script);
        }
        script.textContent = JSON.stringify(data);
    };

    updateMetaTags(
        'Plebs - Decentralized Video Platform',
        'Plebs is a censorship-resistant, decentralized video platform powered by the Nostr social protocol'
    );

    setStructuredData({
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "Plebs",
        "description": "Censorship-resistant, decentralized video platform powered by Nostr",
        "url": window.location.href
    });

    if (pathParts.length === 0) {
        loadHomeFeed();
    } else if (pathParts[0] === 'video' && pathParts[1]) {
        const eventId = pathParts[1];

        document.getElementById('mainContent').innerHTML = '<div class="spinner"></div>';

        // Fetch video metadata for SEO
        try {
            const event = await fetchVideoEvent(eventId);
            if (event) {
                const videoData = parseVideoEvent(event);
                const profile = await fetchUserProfile(event.pubkey);

                if (videoData) {
                    const authorName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;

                    updateMetaTags(
                        `${videoData.title} - Plebs`,
                        videoData.description ? videoData.description.slice(0, 155) : `Watch "${videoData.title}" by ${authorName} on Plebs`,
                        videoData.thumbnail,
                        'video.other'
                    );

                    setStructuredData({
                        "@context": "https://schema.org",
                        "@type": "VideoObject",
                        "name": videoData.title,
                        "description": videoData.description || `Watch "${videoData.title}" on Plebs`,
                        "thumbnailUrl": videoData.thumbnail || undefined,
                        "uploadDate": new Date(event.created_at * 1000).toISOString(),
                        "duration": videoData.duration ? `PT${Math.floor(videoData.duration / 60)}M${videoData.duration % 60}S` : undefined,
                        "author": {
                            "@type": "Person",
                            "name": authorName,
                            "url": `${window.location.origin}${window.location.pathname}#/profile/${event.pubkey}`
                        },
                        "url": window.location.href  // Use full URL including hash
                    });
                }
            }
        } catch (error) {
            console.error('Failed to fetch video metadata:', error);
        }

        playVideo(eventId);
    } else if (pathParts[0] === 'profile' && pathParts[1]) {
        let pubkey = pathParts[1];

        // Decode npub to hex pubkey if needed
        if (pubkey.startsWith('npub1')) {
            try {
                const decoded = window.NostrTools.nip19.decode(pubkey);
                if (decoded.type === 'npub') {
                    pubkey = decoded.data;
                }
            } catch (e) {
                console.error('Failed to decode npub:', e);
            }
        }

        try {
            const profile = await fetchUserProfile(pubkey);
            if (profile) {
                const displayName = profile?.name || profile?.display_name || `User ${pubkey.slice(0, 8)}`;
                const about = profile?.about || '';
                const avatarUrl = profile?.picture || profile?.avatar || '';

                updateMetaTags(
                    `${displayName} - Plebs`,
                    about ? about.slice(0, 155) : `Watch videos from ${displayName} on Plebs`,
                    avatarUrl,
                    'profile'
                );

                setStructuredData({
                    "@context": "https://schema.org",
                    "@type": "Person",
                    "name": displayName,
                    "description": about,
                    "image": avatarUrl || undefined,
                    "url": window.location.href  // Use full URL including hash
                });
            }
        } catch (error) {
            console.error('Failed to fetch profile metadata:', error);
        }

        loadProfile(pubkey);
    } else if (pathParts[0] === 'tag' && pathParts[1]) {
        const originalTag = pathParts[1];
        const normalizedTag = originalTag.toLowerCase();

        if (originalTag !== normalizedTag) {
            navigateTo(`/tag/${normalizedTag}`);
            return;
        }

        updateMetaTags(
            `${normalizedTag.charAt(0).toUpperCase() + normalizedTag.slice(1)} Videos - Plebs`,
            `Watch ${normalizedTag} videos on Plebs, the censorship-resistant decentralized video platform`
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": `${normalizedTag.charAt(0).toUpperCase() + normalizedTag.slice(1)} Videos`,
            "description": `Watch ${normalizedTag} videos on Plebs`,
            "url": window.location.href
        });

        loadTag(normalizedTag);
    } else if (pathParts[0] === 'search' && pathParts[1]) {
        const query = decodeURIComponent(pathParts[1]);
        updateMetaTags(
            `Search: ${query} - Plebs`,
            `Search results for "${query}" on Plebs`
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "SearchResultsPage",
            "name": `Search: ${query}`,
            "description": `Search results for "${query}" on Plebs`,
            "url": window.location.href
        });

        document.getElementById('searchInput').value = query;
        performSearch(pathParts[1]);
    } else if (pathParts[0] === 'following') {
        updateMetaTags(
            'Following - Plebs',
            'Watch videos from creators you follow on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": "Following",
            "description": "Watch videos from creators you follow on Plebs",
            "url": window.location.href
        });

        loadFollowing();
    } else if (pathParts[0] === 'my-videos') {
        updateMetaTags(
            'My Videos - Plebs',
            'Manage your videos on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": "My Videos",
            "description": "Manage your videos on Plebs",
            "url": window.location.href
        });

        loadMyVideos();
    } else if (pathParts[0] === 'analytics') {
        updateMetaTags(
            'Analytics - Plebs',
            'View your channel analytics and video performance on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "Analytics",
            "description": "View your channel analytics and video performance on Plebs",
            "url": window.location.href
        });

        loadAnalytics();
    } else if (pathParts[0] === 'liked') {
        updateMetaTags(
            'Liked Videos - Plebs',
            'Watch your liked videos on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": "Liked Videos",
            "description": "Watch your liked videos on Plebs",
            "url": window.location.href
        });

        loadLikedVideos();
    } else if (pathParts[0] === 'history') {
        updateMetaTags(
            'Watched History - Plebs',
            'View your recently watched videos on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": "Watched History",
            "description": "View your recently watched videos on Plebs",
            "url": window.location.href
        });

        loadWatchHistory();
    } else if (pathParts[0] === 'about') {
        updateMetaTags(
            'About - Plebs',
            'Learn about Plebs, a censorship-resistant decentralized video platform powered by Nostr'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "AboutPage",
            "name": "About Plebs",
            "description": "Learn about Plebs, a censorship-resistant decentralized video platform powered by Nostr",
            "url": window.location.href
        });

        loadAboutPage();
    } else if (pathParts[0] === 'contact') {
        updateMetaTags(
            'Contact - Plebs',
            'Get in touch with the Plebs team'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "ContactPage",
            "name": "Contact Plebs",
            "description": "Get in touch with the Plebs team",
            "url": window.location.href
        });

        loadContactPage();
    } else if (pathParts[0] === 'terms') {
        updateMetaTags(
            'Terms of Service - Plebs',
            'Terms of Service for using the Plebs platform'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "Terms of Service",
            "description": "Terms of Service for using the Plebs platform",
            "url": window.location.href
        });

        loadTermsPage();
    } else if (pathParts[0] === 'privacy') {
        updateMetaTags(
            'Privacy Policy - Plebs',
            'Privacy Policy for the Plebs platform'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "Privacy Policy",
            "description": "Privacy Policy for the Plebs platform",
            "url": window.location.href
        });

        loadPrivacyPage();
    } else if (pathParts[0] === 'faq') {
        updateMetaTags(
            'FAQ - Plebs',
            'Frequently asked questions about Plebs, Nostr, and decentralized video'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "FAQPage",
            "name": "Frequently Asked Questions",
            "description": "Frequently asked questions about Plebs, Nostr, and decentralized video",
            "url": window.location.href
        });

        loadFaqPage();
    } else if (pathParts[0] === 'dmca') {
        updateMetaTags(
            'DMCA & Content Policy - Plebs',
            'DMCA and content policy information for Plebs decentralized video platform'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "DMCA & Content Policy",
            "description": "DMCA and content policy information for Plebs decentralized video platform",
            "url": window.location.href
        });

        loadDmcaPage();
    } else if (pathParts[0] === 'admin') {
        updateMetaTags(
            'Admin Dashboard - Plebs',
            'Admin dashboard for Plebs platform management'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "Admin Dashboard",
            "description": "Admin dashboard for Plebs platform management",
            "url": window.location.href
        });

        loadAdminPage();
    } else if (pathParts[0] === 'live' && pathParts[1]) {
        // Individual live stream page
        const eventId = pathParts[1];

        updateMetaTags(
            'Live Stream - Plebs',
            'Watch this live stream on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "BroadcastEvent",
            "name": "Live Stream",
            "description": "Watch this live stream on Plebs",
            "url": window.location.href
        });

        playLiveStream(eventId);
    } else if (pathParts[0] === 'live') {
        // Live feed page
        updateMetaTags(
            'Live Streams - Plebs',
            'Watch live streams on Plebs, the decentralized video platform'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": "Live Streams",
            "description": "Watch live streams on Plebs",
            "url": window.location.href
        });

        loadLiveFeed();
    } else {
        loadHomeFeed();
    }

    updateSidebarActive();
}

// Show notifications modal and fetch notifications
async function loadNotifications() {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            return;
        }
    }

    const modal = document.getElementById("notificationsModal");
    const list = document.getElementById("notificationsList");
    list.innerHTML = '<div class="spinner"></div>';
    modal.classList.add("active");

    // Mark notifications as viewed when modal is opened
    markNotificationsViewed();

    try {
        const userVideosFilter = {
            kinds: ALL_VIDEO_KINDS,
            authors: [currentUser.pubkey],
            '#t': ['pv69420']
        };

        const userVideos = await fetchEvents(userVideosFilter);
        const videoIds = userVideos.map(e => e.id);

        if (videoIds.length === 0) {
            list.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.noVideosToMonitor')}</p>`;
            return;
        }

        // Fetch reactions
        const reactions = [];
        const reactionFilter = {
            kinds: [7],
            '#e': videoIds
        };

        const reactionAuthors = new Set();

        await new Promise((resolve) => {
            requestEventsStream(reactionFilter, (reactionEvent) => {
                const videoId = reactionEvent.tags.find(t => t[0] === 'e')?.[1];
                if (
                    videoId &&
                    videoIds.includes(videoId) &&
                    reactionEvent.pubkey !== currentUser.pubkey
                ) {
                    reactions.push(reactionEvent);
                    // Collect reaction authors for validation
                    reactionAuthors.add(reactionEvent.pubkey);
                }
            }, resolve);
        });

        // Validate reaction authors
        const validatedAuthors = new Set();

        if (reactionAuthors.size > 0) {
            const profileFilter = {
                kinds: [0],
                authors: Array.from(reactionAuthors)
            };

            await new Promise((resolve) => {
                requestEventsStream(profileFilter, async (profileEvent) => {
                    try {
                        const profile = JSON.parse(profileEvent.content);
                        profileCache.set(profileEvent.pubkey, profile);

                        if (profile.nip05) {
                            const isValid = await validateNip05(profile.nip05, profileEvent.pubkey);
                            if (isValid) {
                                validatedAuthors.add(profileEvent.pubkey);
                            }
                        }
                    } catch (e) {
                        console.error('Failed to parse profile:', e);
                    }
                }, resolve);
            });
        }

        // Filter reactions to only include validated authors
        const validReactions = reactions.filter(r => validatedAuthors.has(r.pubkey));

        // Fetch replies
        const replies = [];
        const repliesFilter = {
            kinds: [1],
            '#e': videoIds
        };

        await new Promise((resolve) => {
            requestEventsStream(repliesFilter, (event) => {
                const videoId = event.tags.find(t => t[0] === 'e')?.[1];
                if (
                    videoId &&
                    videoIds.includes(videoId) &&
                    event.pubkey !== currentUser.pubkey
                ) {
                    replies.push(event);
                }
            }, resolve);
        });

        // Fetch zaps
        const zaps = [];
        const zapsFilter = {
            kinds: [9735], // Zap receipts
            '#e': videoIds
        };

        await new Promise((resolve) => {
            requestEventsStream(zapsFilter, (zapEvent) => {
                const videoId = zapEvent.tags.find(t => t[0] === 'e')?.[1];
                if (videoId && videoIds.includes(videoId)) {
                    // Extract zapper pubkey from the 'P' tag (uppercase P for zap receipts)
                    const zapperTag = zapEvent.tags.find(t => t[0] === 'P');
                    if (zapperTag && zapperTag[1] !== currentUser.pubkey) {
                        zaps.push(zapEvent);
                    }
                }
            }, resolve);
        });

        // Fetch live chat mentions (kind 1311 messages that mention the current user)
        const chatMentions = [];
        const myProfile = profileCache.get(currentUser.pubkey);
        const myName = myProfile?.name || myProfile?.display_name || '';

        // First, fetch user's live streams to build 'a' tags
        const userStreamsFilter = {
            kinds: [NIP53_LIVE_EVENT_KIND],
            authors: [currentUser.pubkey],
            '#t': ['pv69420']
        };
        const userStreams = await fetchEvents(userStreamsFilter);

        // Build 'a' tags for user's streams and map them to event IDs
        const streamATags = [];
        const aTagToEventId = new Map();
        for (const stream of userStreams) {
            const liveData = parseLiveEvent(stream);
            if (liveData && liveData.dTag) {
                const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${stream.pubkey}:${liveData.dTag}`;
                streamATags.push(aTagValue);
                aTagToEventId.set(aTagValue, stream.id);
                allEvents.set(stream.id, stream);
            }
        }

        if (myName && streamATags.length > 0) {
            const chatMentionFilter = {
                kinds: [NIP53_LIVE_CHAT_KIND],
                '#a': streamATags,
                limit: 200,
                since: Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60) // Last 30 days
            };

            await new Promise((resolve) => {
                requestEventsStream(chatMentionFilter, (chatEvent) => {
                    // Check if the message mentions the current user
                    if (chatEvent.pubkey !== currentUser.pubkey) {
                        const mentionPattern = new RegExp(`@${myName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                        if (mentionPattern.test(chatEvent.content)) {
                            // Attach the stream event ID for easy lookup later
                            const aTag = chatEvent.tags?.find(t => t[0] === 'a')?.[1];
                            if (aTag) {
                                chatEvent._streamEventId = aTagToEventId.get(aTag);
                            }
                            chatMentions.push(chatEvent);
                        }
                    }
                }, resolve);
            });
        }

        // Combine and sort all notifications (using filtered reactions)
        const notifications = [...validReactions, ...replies, ...zaps, ...chatMentions].sort((a, b) => b.created_at - a.created_at);

        if (notifications.length === 0) {
            list.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.noRecentActivity')}</p>`;
            return;
        }

        // Fetch profiles for all notification authors (already have profiles for reactions)
        const uniquePubkeys = [...new Set([
            ...notifications.filter(n => n.kind === 1).map(n => n.pubkey), // replies
            ...notifications.filter(n => n.kind === NIP53_LIVE_CHAT_KIND).map(n => n.pubkey), // chat mentions
            ...notifications.filter(n => n.kind === 9735).map(n => {
                const zapperTag = n.tags.find(t => t[0] === 'P');
                return zapperTag ? zapperTag[1] : null;
            }).filter(Boolean)
        ])];

        const profilePromises = uniquePubkeys.map(pubkey => fetchUserProfile(pubkey));
        await Promise.all(profilePromises);

        list.innerHTML = '';

        // Get notification settings
        const notifSettings = userSettings.notifications || {};

        notifications.forEach(event => {
            const isReaction = event.kind === 7;
            const isReply = event.kind === 1;
            const isZap = event.kind === 9735;
            const isChatMention = event.kind === NIP53_LIVE_CHAT_KIND;

            // Skip based on notification settings
            if (isReaction && notifSettings.reactions === false) return;
            if (isReply && notifSettings.replies === false) return;
            if (isZap && notifSettings.zaps === false) return;
            if (isChatMention && notifSettings.chatMentions === false) return;

            // Get the pubkey of the person who triggered the notification
            let notificationPubkey;
            if (isZap) {
                const zapperTag = event.tags.find(t => t[0] === 'P');
                notificationPubkey = zapperTag ? zapperTag[1] : '';
            } else {
                notificationPubkey = event.pubkey;
            }

            // Skip notifications from muted users
            if (isUserMuted(notificationPubkey)) return;

            // For chat mentions, get the stream info from the attached event ID
            let videoId, videoTitle, streamEventId;
            if (isChatMention) {
                // Use the stream event ID we attached during fetch
                streamEventId = event._streamEventId;
                // Try to get the stream title
                const streamEvent = streamEventId ? allEvents.get(streamEventId) : null;
                if (streamEvent) {
                    const liveData = parseLiveEvent(streamEvent);
                    videoTitle = liveData?.title || 'Live Stream';
                } else {
                    videoTitle = 'Live Stream';
                }
            } else {
                const originalVideoId = event.tags.find(t => t[0] === 'e')?.[1];
                const video = userVideos.find(v => v.id === originalVideoId);
                const parsedVideo = video ? parseVideoEvent(video) : null;
                videoTitle = parsedVideo?.title || 'Unknown Video';

                // For legacy kinds (1, 21, 22), find the NIP-71 addressable counterpart
                videoId = originalVideoId;
                if (video && (video.kind === 1 || video.kind === NIP71_VIDEO_KIND_LEGACY || video.kind === NIP71_SHORT_KIND_LEGACY)) {
                    const dTag = video.tags?.find(t => t[0] === 'd')?.[1] ||
                        video.tags?.find(t => t[0] === 'nip71-d')?.[1];
                    if (dTag) {
                        // Find the NIP-71 addressable counterpart with the same d-tag
                        const nip71Video = userVideos.find(v =>
                            (v.kind === NIP71_VIDEO_KIND || v.kind === NIP71_SHORT_KIND) &&
                            v.tags?.find(t => t[0] === 'd')?.[1] === dTag
                        );
                        if (nip71Video) {
                            videoId = nip71Video.id;
                        }
                    }
                }
            }

            const profile = profileCache.get(notificationPubkey) || {};
            const displayName = profile.name || profile.display_name || `User ${notificationPubkey.slice(0, 8)}`;
            const avatarUrl = profile.picture || profile.avatar || '';
            const nip05 = profile.nip05 || '';

            let content;
            if (isZap) {
                // Extract amount from bolt11 tag
                const bolt11Tag = event.tags.find(t => t[0] === 'bolt11');
                const amount = bolt11Tag ? extractAmountFromBolt11(bolt11Tag[1]) : 0;
                content = `Zapped: ${formatSats(amount)} sats ⚡`;
            } else if (isChatMention) {
                content = `Mentioned you: "${event.content.slice(0, 40)}${event.content.length > 40 ? '...' : ''}"`;
            } else {
                content = isReaction
                    ? `Reacted: ${event.content}`
                    : `Replied: "${event.content.slice(0, 40)}${event.content.length > 40 ? '...' : ''}"`;
            }

            const timestamp = formatTimestamp(event.created_at);

            // Determine the link based on notification type
            const linkHref = isChatMention && streamEventId
                ? `#/live/${streamEventId}`
                : `#/video/${videoId}`;

            const item = document.createElement('div');
            item.className = 'notification-item';
            item.innerHTML = `
                <div class="notification-content">
                    <div class="notification-author">
                        ${avatarUrl ? `
                            <div class="notification-avatar">
                                <img src="${avatarUrl}" alt="${displayName}">
                            </div>
                        ` : ''}
                        <div>
                            <div style="font-weight: 500;">${displayName}</div>
                            ${nip05 ? `<div style="font-size: 0.75rem; color: var(--text-secondary);">${nip05}</div>` : ''}
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">${timestamp}</div>
                        </div>
                    </div>
                    <div style="margin-top: 0.25rem; ${isZap ? 'color: #f7931a; font-weight: 500;' : ''}">${content}</div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">on "${videoTitle || 'Live Stream'}"</div>
                </div>
                <a href="${linkHref}" onclick="hideNotificationsModal();" class="notification-link">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                    </svg>
                </a>
            `;
            list.appendChild(item);
        });

    } catch (error) {
        console.error("Failed to load notifications:", error);
        list.innerHTML = `<div class="error-message">${t('empty.failedLoadNotifications')}</div>`;
    }
}

// Fetch events via stream
function fetchEvents(filter) {
    return new Promise((resolve, reject) => {
        const results = [];
        requestEventsStream(filter, (event) => {
            results.push(event);
        }, () => resolve(results));
    });
}

// Close modal
function hideNotificationsModal() {
    document.getElementById("notificationsModal").classList.remove("active");
    // Reset to notifications view when closing
    const settingsPanel = document.getElementById('notificationSettingsPanel');
    const notificationsList = document.getElementById('notificationsList');
    const settingsBtn = document.querySelector('.notification-settings-btn');
    const title = document.getElementById('notificationsModalTitle');
    if (settingsPanel) settingsPanel.style.display = 'none';
    if (notificationsList) notificationsList.style.display = 'flex';
    if (settingsBtn) settingsBtn.classList.remove('active');
    if (title) title.textContent = t('header.notifications');
}

// Toggle notification settings panel
function toggleNotificationSettings() {
    const settingsPanel = document.getElementById('notificationSettingsPanel');
    const notificationsList = document.getElementById('notificationsList');
    const settingsBtn = document.querySelector('.notification-settings-btn');
    const title = document.getElementById('notificationsModalTitle');

    const showingSettings = settingsPanel.style.display === 'none';

    if (showingSettings) {
        // Show settings
        settingsPanel.style.display = 'block';
        notificationsList.style.display = 'none';
        settingsBtn.classList.add('active');
        title.textContent = t('settings.notificationSettings') || 'Notification Settings';
        // Sync checkboxes with current settings
        syncNotificationSettingsUI();
    } else {
        // Show notifications
        settingsPanel.style.display = 'none';
        notificationsList.style.display = 'flex';
        settingsBtn.classList.remove('active');
        title.textContent = t('header.notifications');
    }
}

// Sync notification settings UI with current userSettings
function syncNotificationSettingsUI() {
    const settings = userSettings.notifications || {};
    document.getElementById('notifReactions').checked = settings.reactions !== false;
    document.getElementById('notifReplies').checked = settings.replies !== false;
    document.getElementById('notifZaps').checked = settings.zaps !== false;
    document.getElementById('notifChatMentions').checked = settings.chatMentions !== false;
    document.getElementById('notifNewFollowers').checked = settings.newFollowers !== false;
}

// Update a notification setting
async function updateNotificationSetting(setting, enabled) {
    // Ensure notifications object exists
    if (!userSettings.notifications) {
        userSettings.notifications = {
            reactions: true,
            replies: true,
            zaps: true,
            chatMentions: true,
            newFollowers: true
        };
    }

    userSettings.notifications[setting] = enabled;

    // Save to localStorage immediately
    localStorage.setItem('plebs_settings', JSON.stringify(userSettings));

    // Save to Nostr in background
    if (currentUser) {
        saveSettingsToNostr().catch(err => console.error('Failed to sync notification settings to Nostr:', err));
    }
}

// Check for new notifications in background and update badge
async function checkNotificationsInBackground() {
    if (!currentUser) return;

    try {
        const userVideosFilter = {
            kinds: ALL_VIDEO_KINDS,
            authors: [currentUser.pubkey],
            '#t': ['pv69420']
        };

        const userVideos = await fetchEvents(userVideosFilter);
        const videoIds = userVideos.map(e => e.id);

        if (videoIds.length === 0) {
            updateNotificationBadge(0);
            return;
        }

        // Get last viewed time from userSettings (synced via Nostr) or fall back to localStorage
        const lastViewedTime = userSettings?.lastNotificationView || parseInt(localStorage.getItem(STORAGE_KEYS.lastNotificationView) || '0', 10);

        // Get notification settings
        const notifSettings = userSettings.notifications || {};

        // Fetch notification types based on settings
        const fetchPromises = [];
        if (notifSettings.reactions !== false) {
            fetchPromises.push(fetchNotificationEvents({ kinds: [7], '#e': videoIds }, videoIds));
        }
        if (notifSettings.replies !== false) {
            fetchPromises.push(fetchNotificationEvents({ kinds: [1], '#e': videoIds }, videoIds));
        }
        if (notifSettings.zaps !== false) {
            fetchPromises.push(fetchNotificationEvents({ kinds: [9735], '#e': videoIds }, videoIds, true));
        }

        const results = await Promise.all(fetchPromises);

        // Count notifications newer than last viewed time
        const allNotifications = results.flat();
        const unreadCount = allNotifications.filter(n => n.created_at > lastViewedTime).length;

        updateNotificationBadge(unreadCount);
    } catch (error) {
        console.error('Failed to check notifications in background:', error);
    }
}

// Helper to fetch notification events
async function fetchNotificationEvents(filter, videoIds, isZap = false) {
    const events = [];
    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            const videoId = event.tags.find(t => t[0] === 'e')?.[1];
            if (videoId && videoIds.includes(videoId)) {
                if (isZap) {
                    const zapperTag = event.tags.find(t => t[0] === 'P');
                    if (zapperTag && zapperTag[1] !== currentUser.pubkey) {
                        events.push(event);
                    }
                } else if (event.pubkey !== currentUser.pubkey) {
                    events.push(event);
                }
            }
        }, resolve);
    });
    return events;
}

// Update notification badge
function updateNotificationBadge(count) {
    const badge = document.getElementById('notificationBadge');
    if (!badge) return;

    if (count > 0) {
        badge.textContent = count > 99 ? '99+' : count.toString();
        badge.style.display = 'flex';
    } else {
        badge.style.display = 'none';
    }
}

// Mark notifications as viewed
function markNotificationsViewed() {
    const timestamp = Math.floor(Date.now() / 1000);
    localStorage.setItem(STORAGE_KEYS.lastNotificationView, timestamp.toString());
    updateNotificationBadge(0);

    // Sync to Nostr if logged in
    if (currentUser && userSettings) {
        userSettings.lastNotificationView = timestamp;
        localStorage.setItem('plebsSettings', JSON.stringify(userSettings));
        if (userSettings.saveToNostr) {
            saveSettingsToNostr().catch(err => console.error('Failed to sync notification view to Nostr:', err));
        }
    }
}

// Function to load liked videos
async function loadLikedVideos() {
    if (!currentUser) {
        await checkStoredLogin(); // Wait for login check
        if (!currentUser) {
            document.getElementById('mainContent').innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.loginToViewLiked')}</p>`;
            return;
        }
    }

    currentView = 'liked';

    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const skeletonCount = cardsPerRow * 10; // 10 rows of skeletons
    const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');

    mainContent.innerHTML = `
        <h2 style="margin-bottom: 1.5rem;">${t('pageTitle.likedVideos')}</h2>
        <!-- Live Streams Section -->
        <div id="likedLiveSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <circle cx="12" cy="12" r="4" fill="#f44336"/>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                </svg>
                ${t('pageTitle.liveStreams')}
            </h3>
            <div class="video-grid" id="likedLiveGrid"></div>
        </div>
        <!-- Shorts Section -->
        <div id="likedShortsSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M10 8l6 4-6 4V8z"/>
                </svg>
                ${t('section.shorts')}
            </h3>
            <div class="shorts-grid" id="likedShortsGrid"></div>
            <div class="view-more-container" id="likedShortsViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('likedShorts')">${t('button.viewMore')}</button>
            </div>
        </div>
        <!-- Videos Section -->
        <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                </svg>
                ${t('section.videos')}
            </h3>
        <div class="video-grid" id="videoGrid">
            ${skeletons}
        </div>
    `;

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('likedShortsGrid');
    const shortsSection = document.getElementById('likedShortsSection');
    const shortsViewMore = document.getElementById('likedShortsViewMore');
    const liveGrid = document.getElementById('likedLiveGrid');
    const liveSection = document.getElementById('likedLiveSection');
    const maxInitialShorts = getShortsCardsPerRow();
    const likedVideoIds = new Set();
    const likedLiveATags = new Set(); // Track #a tags for live streams

    // Reset cached liked shorts
    cachedLikedShorts = [];
    sectionExpanded.likedShorts = false;

    const reactionFilter = {
        kinds: [7],
        authors: [currentUser.pubkey],
        '#t': ['pv69420']
    };

    // Also fetch live stream reactions that may not have the #t tag (backwards compatibility)
    const liveReactionFilter = {
        kinds: [7],
        authors: [currentUser.pubkey]
    };

    await Promise.all([
        new Promise((resolve) => {
            requestEventsStream(reactionFilter, (event) => {
                if (event.content === '👍' || event.content === '+') {
                    const videoIdTag = event.tags.find(tag => tag[0] === 'e');
                    if (videoIdTag) {
                        likedVideoIds.add(videoIdTag[1]);
                    }
                    // Also check for #a tags (live streams use these)
                    const aTag = event.tags.find(tag => tag[0] === 'a' && tag[1]?.startsWith('30311:'));
                    if (aTag) {
                        likedLiveATags.add(aTag[1]);
                    }
                }
            }, resolve);
        }),
        new Promise((resolve) => {
            requestEventsStream(liveReactionFilter, (event) => {
                // Only process live stream reactions (those with #a tag starting with 30311:)
                if (event.content === '👍' || event.content === '+') {
                    const aTag = event.tags.find(tag => tag[0] === 'a' && tag[1]?.startsWith('30311:'));
                    if (aTag) {
                        likedLiveATags.add(aTag[1]);
                    }
                }
            }, resolve);
        })
    ]);

    if (likedVideoIds.size === 0 && likedLiveATags.size === 0) {
        videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noLikedVideosYet')}</p>`;
        return;
    }

    // Batch the IDs to handle relay limits
    const BATCH_SIZE = 50;
    const likedIds = Array.from(likedVideoIds);
    const idBatches = [];
    for (let i = 0; i < likedIds.length; i += BATCH_SIZE) {
        idBatches.push(likedIds.slice(i, i + BATCH_SIZE));
    }

    // Fetch all videos first, then separate shorts from videos
    const allVideos = [];
    const seenIds = new Set();

    await Promise.all(idBatches.map(async (batch) => {
        const videoFilter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            ids: batch
        };

        await new Promise((resolve) => {
            requestEventsStream(videoFilter, (event) => {
                if (!seenIds.has(event.id)) {
                    seenIds.add(event.id);
                    allVideos.push(event);
                    allEvents.set(event.id, event);
                }
            }, resolve);
        });
    }));

    // Fetch liked live streams by #a tags
    const likedLiveStreams = [];
    if (likedLiveATags.size > 0) {
        const aTagsArray = Array.from(likedLiveATags);
        for (const aTagValue of aTagsArray) {
            // Parse the #a tag: "30311:pubkey:dTag"
            const parts = aTagValue.split(':');
            if (parts.length >= 3) {
                const pubkey = parts[1];
                const dTag = parts.slice(2).join(':'); // Handle dTags with colons

                await new Promise((resolve) => {
                    requestEventsStream({
                        kinds: [NIP53_LIVE_EVENT_KIND],
                        authors: [pubkey],
                        '#d': [dTag]
                    }, (event) => {
                        if (!seenIds.has(event.id)) {
                            seenIds.add(event.id);
                            likedLiveStreams.push(event);
                            allEvents.set(event.id, event);
                        }
                    }, resolve);
                });
            }
        }
    }

    videoGrid.innerHTML = '';

    if (allVideos.length === 0 && likedLiveStreams.length === 0) {
        videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noLikedVideosFound')}</p>`;
        return;
    }

    // Separate shorts from videos and filter kind 1 duplicates
    const shorts = [];
    const videos = [];
    for (const event of allVideos) {
        if (shouldSkipLegacyEvent(event)) continue;
        if (isNip71ShortKind(event.kind)) {
            shorts.push(event);
        } else {
            videos.push(event);
        }
    }

    // Sort both by created_at descending
    shorts.sort((a, b) => b.created_at - a.created_at);
    videos.sort((a, b) => b.created_at - a.created_at);

    // Cache shorts for View More
    cachedLikedShorts = shorts;

    // Display live streams
    if (likedLiveStreams.length > 0) {
        // Sort by most recent
        likedLiveStreams.sort((a, b) => b.created_at - a.created_at);
        liveSection.style.display = 'block';
        const liveEventIds = [];

        for (const event of likedLiveStreams) {
            const liveData = parseLiveEvent(event);
            if (!liveData) continue;

            const profile = profileCache.get(event.pubkey);
            const isEnded = liveData.status === 'ended';
            const cardHTML = createLiveStreamCard(event, liveData, profile, isEnded);
            if (cardHTML) {
                liveGrid.insertAdjacentHTML('beforeend', cardHTML);
                liveEventIds.push(event.id);
            }
        }

        // Load viewer counts and boosts for live streams
        if (liveEventIds.length > 0) {
            loadLiveStreamCardsViewers(liveEventIds);
            liveEventIds.forEach(id => {
                if (!boostsCache.has(id)) {
                    loadBoostsForVideo(id);
                }
            });
        }
    }

    // Display shorts (only first row initially)
    if (shorts.length > 0) {
        shortsSection.style.display = 'block';
        const initialShorts = shorts.slice(0, maxInitialShorts);
        for (const event of initialShorts) {
            const profile = profileCache.get(event.pubkey);
            const reactions = reactionsCache.get(event.id);
            const cardHTML = createShortCard(event, profile, reactions);
            if (cardHTML) {
                shortsGrid.insertAdjacentHTML('beforeend', cardHTML);
            }
        }

        // Show View More if there are more shorts
        if (shorts.length > maxInitialShorts && shortsViewMore) {
            shortsViewMore.style.display = 'block';
        }
    }

    // Display videos
    if (videos.length > 0) {
        for (const event of videos) {
            const profile = profileCache.get(event.pubkey);
            const reactions = reactionsCache.get(event.id);
            const cardHTML = createVideoCard(event, profile, reactions);
            if (cardHTML) {
                videoGrid.insertAdjacentHTML('beforeend', cardHTML);
            }
        }
    } else {
        videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthLikedVideos')}</p>`;
    }

    // Load profiles and reactions in batches
    const allMedia = [...shorts, ...videos, ...likedLiveStreams];
    const uniquePubkeys = [...new Set(allMedia.map(v => v.pubkey))];
    const profileBatches = [];
    for (let i = 0; i < uniquePubkeys.length; i += BATCH_SIZE) {
        profileBatches.push(uniquePubkeys.slice(i, i + BATCH_SIZE));
    }

    await Promise.all(profileBatches.map(async (batch) => {
        const profileFilter = { kinds: [0], authors: batch };
        await new Promise((resolve) => {
            requestEventsStream(profileFilter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);
                    // Update cards with this profile (in-place to prevent flickering)
                    allMedia.forEach(video => {
                        if (video.pubkey === profileEvent.pubkey) {
                            updateVideoCardInPlace(video.id, profile, reactionsCache.get(video.id));
                        }
                    });
                } catch (e) { }
            }, resolve);
        });
    }));

    // Load reactions
    await loadReactionsForVideos(allMedia.map(v => v.id));

    // Load views for liked videos
    const likedMediaIds = allMedia.map(v => v.id);
    if (likedMediaIds.length > 0) {
        loadViewsForVideos(likedMediaIds, true);
    }

    observeLazyCards();
}

// Watch history management
const WATCH_HISTORY_KEY = 'plebs_watch_history';
const MAX_HISTORY_ITEMS = 200;

function addToWatchHistory(eventId, videoTags = [], authorPubkey = null) {
    try {
        let history = JSON.parse(localStorage.getItem(WATCH_HISTORY_KEY) || '[]');

        // Remove if already exists (to move it to top)
        history = history.filter(item => item.id !== eventId);

        // Add to beginning with timestamp and metadata for recommendations
        history.unshift({
            id: eventId,
            timestamp: Date.now(),
            tags: videoTags || [],
            author: authorPubkey || null
        });

        // Keep only the last MAX_HISTORY_ITEMS
        if (history.length > MAX_HISTORY_ITEMS) {
            history = history.slice(0, MAX_HISTORY_ITEMS);
        }

        localStorage.setItem(WATCH_HISTORY_KEY, JSON.stringify(history));

        // Trigger recommendation refresh if section exists
        if (history.length >= 3) {
            refreshRecommendedSection();
        }

        // Sync to Nostr if logged in and saveToNostr is enabled
        if (currentUser && userSettings?.saveToNostr) {
            saveWatchHistoryToNostr(history).catch(err =>
                console.error('Failed to sync watch history to Nostr:', err)
            );
        }
    } catch (e) {
        console.error('Failed to save watch history:', e);
    }
}

function getWatchHistory() {
    try {
        return JSON.parse(localStorage.getItem(WATCH_HISTORY_KEY) || '[]');
    } catch (e) {
        console.error('Failed to load watch history:', e);
        return [];
    }
}

function clearWatchHistory() {
    localStorage.removeItem(WATCH_HISTORY_KEY);

    // Clear from Nostr if logged in
    if (currentUser && userSettings?.saveToNostr) {
        clearWatchHistoryFromNostr().catch(err =>
            console.error('Failed to clear watch history from Nostr:', err)
        );
    }
}

// Remove a single item from watch history
function removeFromWatchHistory(eventId) {
    try {
        let history = JSON.parse(localStorage.getItem(WATCH_HISTORY_KEY) || '[]');
        history = history.filter(item => item.id !== eventId);
        localStorage.setItem(WATCH_HISTORY_KEY, JSON.stringify(history));

        // Sync to Nostr if logged in
        if (currentUser && userSettings?.saveToNostr) {
            saveWatchHistoryToNostr(history).catch(err =>
                console.error('Failed to sync watch history to Nostr:', err)
            );
        }
    } catch (e) {
        console.error('Failed to remove from watch history:', e);
    }
}

// ===== WATCH HISTORY NOSTR SYNC (NIP-78 kind 30078) =====

const WATCH_HISTORY_APP_IDENTIFIER = 'plebs/watch-history';

// Save watch history to Nostr
async function saveWatchHistoryToNostr(history) {
    if (!currentUser) return false;

    try {
        const event = {
            kind: 30078,
            tags: [
                ['d', WATCH_HISTORY_APP_IDENTIFIER],
                ['t', 'watch-history'],
                ['client', 'Plebs']
            ],
            content: JSON.stringify(history),
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(event);
        return await publishEvent(signedEvent);
    } catch (error) {
        console.error('Failed to save watch history to Nostr:', error);
        return false;
    }
}

// Load watch history from Nostr and merge with localStorage
async function loadWatchHistoryFromNostr() {
    if (!currentUser) return [];

    try {
        const filter = {
            kinds: [30078],
            authors: [currentUser.pubkey],
            '#d': [WATCH_HISTORY_APP_IDENTIFIER],
            limit: 1
        };

        let nostrHistory = null;
        let nostrTimestamp = 0;

        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                try {
                    nostrHistory = JSON.parse(event.content);
                    nostrTimestamp = event.created_at * 1000;
                } catch (e) {
                    console.error('Failed to parse watch history from Nostr:', e);
                }
            }, resolve);
        });

        if (!nostrHistory || !Array.isArray(nostrHistory)) {
            return getWatchHistory();
        }

        // Merge with local history
        const localHistory = getWatchHistory();
        const mergedHistory = mergeWatchHistories(localHistory, nostrHistory);

        // Save merged history to localStorage
        localStorage.setItem(WATCH_HISTORY_KEY, JSON.stringify(mergedHistory));

        return mergedHistory;
    } catch (error) {
        console.error('Failed to load watch history from Nostr:', error);
        return getWatchHistory();
    }
}

// Merge two watch histories, prioritizing more recent entries
function mergeWatchHistories(localHistory, nostrHistory) {
    const merged = new Map();

    // Add nostr history first
    nostrHistory.forEach(item => {
        if (item.id) {
            merged.set(item.id, item);
        }
    });

    // Override with local history if more recent
    localHistory.forEach(item => {
        if (item.id) {
            const existing = merged.get(item.id);
            if (!existing || (item.timestamp && (!existing.timestamp || item.timestamp > existing.timestamp))) {
                merged.set(item.id, item);
            }
        }
    });

    // Convert back to array and sort by timestamp (newest first)
    const result = Array.from(merged.values())
        .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0))
        .slice(0, MAX_HISTORY_ITEMS);

    return result;
}

// Clear watch history from Nostr using NIP-09 deletion
async function clearWatchHistoryFromNostr() {
    if (!currentUser) return false;

    try {
        // First, find the existing watch history event
        const filter = {
            kinds: [30078],
            authors: [currentUser.pubkey],
            '#d': [WATCH_HISTORY_APP_IDENTIFIER],
            limit: 1
        };

        let existingEventId = null;

        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                existingEventId = event.id;
            }, resolve);
        });

        if (existingEventId) {
            // Publish a deletion event (NIP-09)
            const deleteEvent = {
                kind: 5,
                tags: [
                    ['e', existingEventId],
                    ['a', `30078:${currentUser.pubkey}:${WATCH_HISTORY_APP_IDENTIFIER}`]
                ],
                content: 'Cleared watch history',
                created_at: Math.floor(Date.now() / 1000)
            };

            const signedEvent = await signEvent(deleteEvent);
            await publishEvent(signedEvent);
        }

        // Also publish an empty watch history to replace
        await saveWatchHistoryToNostr([]);

        return true;
    } catch (error) {
        console.error('Failed to clear watch history from Nostr:', error);
        return false;
    }
}

// ===== RECOMMENDATION ENGINE =====

const RECOMMENDATION_THRESHOLD = 3; // Minimum videos watched before showing recommendations
const RECOMMENDATION_CACHE_KEY = 'plebs_recommendation_cache';
const RECOMMENDATION_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Calculate user preferences based on watch history
function calculateUserPreferences() {
    const history = getWatchHistory();
    const tagWeights = new Map();
    const authorWeights = new Map();

    // Weight recent views more heavily (exponential decay)
    history.forEach((item, index) => {
        const recencyWeight = Math.exp(-index * 0.1); // More recent = higher weight

        // Accumulate tag weights
        if (item.tags && Array.isArray(item.tags)) {
            item.tags.forEach(tag => {
                // Handle both string tags and nostr tag arrays ['t', 'tagname']
                let tagValue;
                if (typeof tag === 'string') {
                    tagValue = tag;
                } else if (Array.isArray(tag) && tag[0] === 't' && tag[1]) {
                    tagValue = tag[1];
                }
                if (tagValue && typeof tagValue === 'string') {
                    const normalizedTag = tagValue.toLowerCase();
                    const currentWeight = tagWeights.get(normalizedTag) || 0;
                    tagWeights.set(normalizedTag, currentWeight + recencyWeight);
                }
            });
        }

        // Accumulate author weights
        if (item.author) {
            const currentWeight = authorWeights.get(item.author) || 0;
            authorWeights.set(item.author, currentWeight + recencyWeight);
        }
    });

    // Normalize weights
    const maxTagWeight = Math.max(...tagWeights.values(), 1);
    const maxAuthorWeight = Math.max(...authorWeights.values(), 1);

    tagWeights.forEach((weight, tag) => {
        tagWeights.set(tag, weight / maxTagWeight);
    });

    authorWeights.forEach((weight, author) => {
        authorWeights.set(author, weight / maxAuthorWeight);
    });

    return { tagWeights, authorWeights };
}

// Calculate similarity score between a video and user preferences
function calculateVideoScore(videoEvent, preferences, watchedIds = new Set()) {
    // Skip already watched videos
    if (watchedIds.has(videoEvent.id)) {
        return -1;
    }

    const videoData = parseVideoEvent(videoEvent);
    if (!videoData) return -1;

    // Base score so all videos have some chance
    let score = 0.05;
    const { tagWeights, authorWeights } = preferences;

    // Tag matching score (0-0.6)
    if (videoData.tags && videoData.tags.length > 0 && tagWeights.size > 0) {
        let tagScore = 0;
        let matchedTags = 0;
        videoData.tags.forEach(tag => {
            const normalizedTag = tag.toLowerCase();
            if (tagWeights.has(normalizedTag)) {
                tagScore += tagWeights.get(normalizedTag);
                matchedTags++;
            }
        });
        // Normalize by number of tags and apply weight
        if (matchedTags > 0) {
            score += (tagScore / videoData.tags.length) * 0.6;
        }
    }

    // Author matching score (0-0.3)
    if (videoEvent.pubkey && authorWeights.has(videoEvent.pubkey)) {
        score += authorWeights.get(videoEvent.pubkey) * 0.3;
    }

    // Recency boost for newer videos (0-0.15)
    const ageHours = (Date.now() / 1000 - videoEvent.created_at) / 3600;
    const recencyBoost = Math.max(0, 1 - (ageHours / (24 * 7))) * 0.15; // Decay over 1 week
    score += recencyBoost;

    return score;
}

// Calculate similarity between two videos (for "similar videos" feature)
function calculateVideoSimilarity(videoA, videoB) {
    const dataA = parseVideoEvent(videoA);
    const dataB = parseVideoEvent(videoB);

    if (!dataA || !dataB) return 0;

    let score = 0;

    // Same author bonus (0.3)
    if (videoA.pubkey === videoB.pubkey) {
        score += 0.3;
    }

    // Tag overlap (0-0.7)
    if (dataA.tags && dataB.tags && dataA.tags.length > 0 && dataB.tags.length > 0) {
        const tagsA = new Set(dataA.tags.map(t => t.toLowerCase()));
        const tagsB = new Set(dataB.tags.map(t => t.toLowerCase()));

        let overlap = 0;
        tagsA.forEach(tag => {
            if (tagsB.has(tag)) overlap++;
        });

        const jaccardSimilarity = overlap / (tagsA.size + tagsB.size - overlap);
        score += jaccardSimilarity * 0.7;
    }

    return score;
}

// Get personalized recommendations
async function getRecommendations(limit = 12, excludeIds = []) {
    const history = getWatchHistory();
    const watchedIds = new Set(history.map(h => h.id));

    // Check cache first
    try {
        const cached = JSON.parse(localStorage.getItem(RECOMMENDATION_CACHE_KEY) || '{}');
        if (cached.timestamp && Date.now() - cached.timestamp < RECOMMENDATION_CACHE_DURATION) {
            if (cached.recommendations && cached.recommendations.length > 0) {
                // Filter out excluded IDs and already watched videos
                return cached.recommendations.filter(id => !excludeIds.includes(id) && !watchedIds.has(id)).slice(0, limit);
            }
        }
    } catch (e) {
        console.error('Failed to read recommendation cache:', e);
    }

    if (history.length < RECOMMENDATION_THRESHOLD) {
        return [];
    }

    const preferences = calculateUserPreferences();
    excludeIds.forEach(id => watchedIds.add(id));

    // Fetch recent videos to score
    const now = Math.floor(Date.now() / 1000);
    const twoWeeksAgo = now - (14 * 24 * 60 * 60);

    const filter = {
        kinds: ALL_VIDEO_KINDS,
        '#t': ['pv69420'],
        since: twoWeeksAgo,
        limit: 200
    };

    return new Promise((resolve) => {
        const candidateVideos = [];

        requestEventsStream(filter, (event) => {
            if (!watchedIds.has(event.id)) {
                const score = calculateVideoScore(event, preferences, watchedIds);
                if (score >= 0) {
                    candidateVideos.push({ event, score });
                }
            }
        }, () => {
            // Sort by score and take top results
            candidateVideos.sort((a, b) => b.score - a.score);
            const recommendations = candidateVideos.slice(0, limit * 2).map(c => c.event.id);

            // Cache results only if we have recommendations
            if (recommendations.length > 0) {
                try {
                    localStorage.setItem(RECOMMENDATION_CACHE_KEY, JSON.stringify({
                        timestamp: Date.now(),
                        recommendations
                    }));
                } catch (e) {
                    console.error('Failed to cache recommendations:', e);
                }
            }

            resolve(recommendations.slice(0, limit));
        });
    });
}

// Get similar videos to a specific video
// preferShorts: true = prefer shorts, false = prefer normal videos, null = no preference
async function getSimilarVideos(currentVideoEvent, limit = 8, excludeIds = [], preferShorts = null) {
    const videoData = parseAnyVideoEvent(currentVideoEvent);
    if (!videoData) return [];

    const history = getWatchHistory();
    const watchedIds = new Set(history.map(h => h.id));
    watchedIds.add(currentVideoEvent.id);
    excludeIds.forEach(id => watchedIds.add(id));

    // Build filter to find similar videos - just get recent videos and filter locally
    const now = Math.floor(Date.now() / 1000);
    const oneMonthAgo = now - (30 * 24 * 60 * 60);

    // Get general recent videos (we'll filter by similarity locally)
    // Fetch more candidates to support dynamic sidebar capacity
    const filter = {
        kinds: ALL_VIDEO_KINDS,
        '#t': ['pv69420'],
        since: oneMonthAgo,
        limit: Math.max(200, limit * 8)
    };

    // Also get videos from same author
    const authorFilter = {
        kinds: ALL_VIDEO_KINDS,
        '#t': ['pv69420'],
        authors: [currentVideoEvent.pubkey],
        since: oneMonthAgo,
        limit: 50
    };

    // Get videos with matching tags (same topic) - boosts topic relevance
    const currentTags = (videoData.tags || []).map(t => t.toLowerCase()).filter(t => t !== 'pv69420');
    const tagFilters = currentTags.slice(0, 3).map(tag => ({
        kinds: [1],
        '#t': ['pv69420', tag],
        since: oneMonthAgo,
        limit: 50
    }));

    // Helper to calculate type preference boost
    const getTypeBoost = (event) => {
        if (preferShorts === null) return 0;
        const eventIsShort = isShortVideoEvent(event);
        // Matching the preferred type gets a significant boost
        return (eventIsShort === preferShorts) ? 0.5 : 0;
    };

    return new Promise((resolve) => {
        const candidateVideos = [];
        const seenIds = new Set();
        let completedRequests = 0;
        const totalRequests = 2 + Math.max(1, tagFilters.length); // At least 3 requests

        const processComplete = () => {
            completedRequests++;
            if (completedRequests >= totalRequests) {
                // Sort by similarity score (which includes type preference boost)
                candidateVideos.sort((a, b) => b.score - a.score);
                const similarIds = candidateVideos.slice(0, limit).map(c => c.event.id);
                resolve(similarIds);
            }
        };

        // Fetch recent videos and score by similarity
        requestEventsStream(filter, (event) => {
            if (!watchedIds.has(event.id) && !seenIds.has(event.id) && event.id !== currentVideoEvent.id) {
                seenIds.add(event.id);
                const score = calculateVideoSimilarity(currentVideoEvent, event);
                const typeBoost = getTypeBoost(event);
                // Include videos with score >= 0, but prioritize higher scores
                candidateVideos.push({ event, score: Math.max(score, 0.01) + typeBoost });
            }
        }, processComplete);

        // Fetch by author (these get a boost)
        requestEventsStream(authorFilter, (event) => {
            if (!watchedIds.has(event.id) && !seenIds.has(event.id) && event.id !== currentVideoEvent.id) {
                seenIds.add(event.id);
                const score = calculateVideoSimilarity(currentVideoEvent, event);
                const typeBoost = getTypeBoost(event);
                // Author matches get a significant boost
                candidateVideos.push({ event, score: score + 0.4 + typeBoost });
            }
        }, processComplete);

        // Fetch by matching tags (topic-related videos get a boost)
        if (tagFilters.length > 0) {
            tagFilters.forEach(tagFilter => {
                requestEventsStream(tagFilter, (event) => {
                    if (!watchedIds.has(event.id) && !seenIds.has(event.id) && event.id !== currentVideoEvent.id) {
                        seenIds.add(event.id);
                        const score = calculateVideoSimilarity(currentVideoEvent, event);
                        const typeBoost = getTypeBoost(event);
                        // Tag-matched videos get an additional boost
                        candidateVideos.push({ event, score: score + 0.2 + typeBoost });
                    }
                }, processComplete);
            });
        } else {
            // No tags on current video, complete this request immediately
            processComplete();
        }
    });
}

// Get mixed recommendations (similar + personalized) for video page sidebar
// preferShorts: true = prefer shorts, false = prefer normal videos, null = no preference
async function getMixedRecommendations(currentVideoEvent, limit = 8, preferShorts = null) {
    const history = getWatchHistory();
    const hasEnoughHistory = history.length >= RECOMMENDATION_THRESHOLD;

    if (hasEnoughHistory) {
        // Mix similar videos with personalized recommendations
        const similarLimit = Math.ceil(limit * 0.6); // 60% similar
        const personalizedLimit = limit - similarLimit; // 40% personalized

        const [similarIds, recommendedIds] = await Promise.all([
            getSimilarVideos(currentVideoEvent, similarLimit, [], preferShorts),
            getRecommendations(personalizedLimit, [currentVideoEvent.id])
        ]);

        // Combine and deduplicate
        const seenIds = new Set();
        const mixedIds = [];

        // Interleave similar and personalized
        const maxLen = Math.max(similarIds.length, recommendedIds.length);
        for (let i = 0; i < maxLen && mixedIds.length < limit; i++) {
            if (i < similarIds.length && !seenIds.has(similarIds[i])) {
                seenIds.add(similarIds[i]);
                mixedIds.push(similarIds[i]);
            }
            if (i < recommendedIds.length && !seenIds.has(recommendedIds[i]) && mixedIds.length < limit) {
                seenIds.add(recommendedIds[i]);
                mixedIds.push(recommendedIds[i]);
            }
        }

        return mixedIds;
    } else {
        // Just show similar videos
        return getSimilarVideos(currentVideoEvent, limit, [], preferShorts);
    }
}

// Refresh the recommended section on home page - uses progressive rendering
async function refreshRecommendedSection() {
    const recommendedSection = document.getElementById('recommendedSection');
    if (!recommendedSection) return;

    const history = getWatchHistory();
    if (history.length < RECOMMENDATION_THRESHOLD) {
        recommendedSection.style.display = 'none';
        return;
    }

    recommendedSection.style.display = 'block';
    const recommendedGrid = document.getElementById('recommendedGrid');
    if (!recommendedGrid) return;

    recommendedGrid.innerHTML = '<div class="spinner"></div>';

    try {
        const recommendedIds = await getRecommendations(12);

        if (recommendedIds.length === 0) {
            recommendedSection.style.display = 'none';
            return;
        }

        // Fetch video events
        const videoFilter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            ids: recommendedIds
        };

        const videos = [];
        const renderedIds = new Set();
        let hasCleared = false;
        let renderTimeout = null;
        let firstRenderDone = false;

        // Order map for sorting
        const orderMap = new Map(recommendedIds.map((id, i) => [id, i]));

        // Progressive render function
        const renderProgressively = () => {
            if (videos.length === 0) return;

            // Sort by recommendation order
            const sortedVideos = [...videos].sort((a, b) =>
                (orderMap.get(a.id) || 0) - (orderMap.get(b.id) || 0)
            );

            // Clear spinner on first render
            if (!hasCleared && sortedVideos.length > 0) {
                hasCleared = true;
                recommendedGrid.innerHTML = '';
            }

            // Render new cards
            sortedVideos.forEach(event => {
                if (renderedIds.has(event.id)) return;
                renderedIds.add(event.id);

                const profile = profileCache.get(event.pubkey);
                const reactions = reactionsCache.get(event.id);
                // First row loads immediately (non-lazy)
                const isFirstRow = renderedIds.size <= 4;
                const cardHtml = createVideoCard(event, profile, reactions, false, null, !isFirstRow);

                if (cardHtml) {
                    recommendedGrid.insertAdjacentHTML('beforeend', cardHtml);

                    // Load profile immediately if not cached
                    loadProfileAndUpdateCards(event.pubkey);

                    // Load boosts if not cached (fire-and-forget)
                    if (!boostsCache.has(event.id)) {
                        loadBoostsForVideo(event.id, (totalBoosts) => {
                            const card = document.getElementById(`video-card-${event.id}`);
                            if (!card) return;
                            const boostLevel = getBoostLevel(totalBoosts);
                            const isBoosted = boostLevel > 0;
                            if (isBoosted) {
                                card.classList.add('boosted', `boost-level-${boostLevel}`);
                                for (let i = 1; i <= 4; i++) {
                                    if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                                }
                                const thumbnail = card.querySelector('.video-thumbnail');
                                if (thumbnail) {
                                    const existingIndicator = thumbnail.querySelector('.boost-indicator');
                                    const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                                    if (existingIndicator) {
                                        existingIndicator.outerHTML = indicatorHTML;
                                    } else {
                                        thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                                    }
                                }
                            }
                        });
                    }
                }
            });

            observeLazyCards();
            firstRenderDone = true;
        };

        // Debounced render (immediate on first event)
        const scheduleRender = () => {
            if (renderTimeout) clearTimeout(renderTimeout);
            if (!firstRenderDone) {
                renderProgressively();
            } else {
                renderTimeout = setTimeout(renderProgressively, 50);
            }
        };

        // Stream events and render progressively
        requestEventsStream(videoFilter, (event) => {
            allEvents.set(event.id, event);
            // Remove any legacy counterpart that was already added (handles race condition)
            removeLegacyCounterpart(event, videos, renderedIds);
            // Skip legacy events when addressable counterpart exists
            if (shouldSkipLegacyEvent(event)) return;
            // Never show logged-in user's own videos in recommendations
            if (currentUser && event.pubkey === currentUser.pubkey) return;
            videos.push(event);
            scheduleRender();
        }, () => {
            // On completion
            clearTimeout(renderTimeout);
            renderProgressively();

            if (videos.length === 0) {
                recommendedSection.style.display = 'none';
                return;
            }

            initializeRecommendedCarousel();

            // Load reactions in background
            loadReactionsForVideos(videos.map(v => v.id));
        });
    } catch (error) {
        console.error('Failed to load recommendations:', error);
        recommendedSection.style.display = 'none';
    }
}

// Initialize carousel for recommended section
function initializeRecommendedCarousel() {
    const recommendedGrid = document.getElementById('recommendedGrid');
    const carouselDots = document.getElementById('recommendedCarouselDots');
    const container = recommendedGrid?.parentElement;

    if (!recommendedGrid || !carouselDots || !container) return;

    const cards = recommendedGrid.querySelectorAll('.video-card');
    const totalCards = cards.length;

    if (totalCards === 0) return;

    let itemsPerPage;
    if (window.innerWidth <= 480) {
        itemsPerPage = 2; // 2 on mobile
    } else if (window.innerWidth <= 768) {
        itemsPerPage = 3; // 3 on tablet
    } else {
        itemsPerPage = 4; // 4 on desktop
    }

    itemsPerPage = Math.min(itemsPerPage, totalCards);
    const totalPages = Math.ceil(totalCards / itemsPerPage);

    // Calculate card width in pixels to fit exactly itemsPerPage cards
    const gap = 16; // 1rem gap
    const containerWidth = container.clientWidth;
    const totalGapWidth = (itemsPerPage - 1) * gap;
    const cardWidth = (containerWidth - totalGapWidth) / itemsPerPage;

    cards.forEach(card => {
        card.style.flex = `0 0 ${cardWidth}px`;
        card.style.maxWidth = `${cardWidth}px`;
        card.style.width = `${cardWidth}px`;
    });

    carouselDots.innerHTML = '';
    for (let i = 0; i < totalPages; i++) {
        const dot = document.createElement('div');
        dot.className = `carousel-dot ${i === 0 ? 'active' : ''}`;
        dot.onclick = () => goToRecommendedPage(i);
        carouselDots.appendChild(dot);
    }

    recommendedGrid.dataset.currentPage = '0';
    recommendedGrid.dataset.totalPages = totalPages;
    recommendedGrid.dataset.itemsPerPage = itemsPerPage;
    recommendedGrid.dataset.cardWidth = cardWidth;
    recommendedGrid.dataset.gap = gap;

    updateRecommendedCarouselButtons();
    goToRecommendedPage(0);
}

function goToRecommendedPage(pageIndex) {
    const recommendedGrid = document.getElementById('recommendedGrid');
    const carouselDots = document.getElementById('recommendedCarouselDots');
    if (!recommendedGrid) return;

    const totalPages = parseInt(recommendedGrid.dataset.totalPages) || 1;

    pageIndex = Math.max(0, Math.min(pageIndex, totalPages - 1));
    recommendedGrid.dataset.currentPage = pageIndex;

    const cards = recommendedGrid.querySelectorAll('.video-card');
    if (cards.length === 0) return;

    // Use stored card dimensions for precise scrolling
    const cardWidth = parseFloat(recommendedGrid.dataset.cardWidth) || cards[0].offsetWidth;
    const gap = parseFloat(recommendedGrid.dataset.gap) || 16;
    const itemsPerPage = parseInt(recommendedGrid.dataset.itemsPerPage) || 3;
    const offset = pageIndex * itemsPerPage * (cardWidth + gap);

    recommendedGrid.style.transform = `translateX(-${offset}px)`;

    if (carouselDots) {
        carouselDots.querySelectorAll('.carousel-dot').forEach((dot, i) => {
            dot.classList.toggle('active', i === pageIndex);
        });
    }

    updateRecommendedCarouselButtons();
}

function scrollRecommendedCarousel(direction) {
    const recommendedGrid = document.getElementById('recommendedGrid');
    if (!recommendedGrid) return;

    const currentPage = parseInt(recommendedGrid.dataset.currentPage) || 0;
    goToRecommendedPage(currentPage + direction);
}

function updateRecommendedCarouselButtons() {
    const recommendedGrid = document.getElementById('recommendedGrid');
    const prevBtn = document.querySelector('.recommended-section .carousel-btn.prev');
    const nextBtn = document.querySelector('.recommended-section .carousel-btn.next');

    if (!recommendedGrid || !prevBtn || !nextBtn) return;

    const currentPage = parseInt(recommendedGrid.dataset.currentPage) || 0;
    const totalPages = parseInt(recommendedGrid.dataset.totalPages) || 1;

    prevBtn.disabled = currentPage === 0;
    nextBtn.disabled = currentPage >= totalPages - 1;
}

// Calculate how many video cards fit in the desktop sidebar based on viewport
function calculateSidebarCapacity() {
    const viewportHeight = window.innerHeight;
    const headerHeight = 60; // --header-height
    const sidebarMargin = 32; // 2rem margin from CSS calc
    const sidebarPadding = 32; // 1rem top + 1rem bottom
    const sidebarHeaderHeight = 52; // Header with "Up Next" title + margin + padding
    const cardHeight = 95; // ~79px thumbnail + 16px card padding
    const cardGap = 12; // 0.75rem gap between cards

    const availableHeight = viewportHeight - headerHeight - sidebarMargin - sidebarPadding - sidebarHeaderHeight;
    // Formula: N cards need N*cardHeight + (N-1)*gap space
    // Simplified: (availableHeight + gap) / (cardHeight + gap)
    const cardCount = Math.floor((availableHeight + cardGap) / (cardHeight + cardGap));

    // Return at least 5, at most 30 videos
    return Math.max(5, Math.min(30, cardCount));
}

// Load and render sidebar recommendations on video page - progressive rendering
async function loadSidebarRecommendations(currentVideoEvent) {
    const desktopSidebar = document.getElementById('recommendationsSidebarDesktop');
    const mobileSidebar = document.getElementById('recommendationsSidebarMobile');

    if (!desktopSidebar && !mobileSidebar) return;

    const desktopGrid = desktopSidebar?.querySelector('.sidebar-recommendations-grid');
    const mobileGrid = mobileSidebar?.querySelector('.sidebar-recommendations-grid');

    if (desktopGrid) desktopGrid.innerHTML = '<div class="spinner"></div>';
    if (mobileGrid) mobileGrid.innerHTML = '<div class="spinner"></div>';

    const noRecsMessage = '<p style="color: var(--text-secondary); text-align: center; padding: 1rem;">No recommendations available yet.</p>';

    try {
        // Calculate how many videos fit in the desktop sidebar based on viewport height
        const desktopLimit = calculateSidebarCapacity();

        // Determine if current video is a short - prefer same type in recommendations
        const currentIsShort = isShortVideoEvent(currentVideoEvent);

        // Track all IDs to avoid duplicates - include watched videos
        const watchHistory = getWatchHistory();
        const usedIds = new Set([currentVideoEvent.id, ...watchHistory.map(h => h.id)]);

        // Track video hashes to avoid showing same video in different event kinds (legacy vs addressable)
        const usedHashes = new Set();
        const currentVideoHash = currentVideoEvent.tags?.find(t => t[0] === 'x')?.[1];
        if (currentVideoHash) usedHashes.add(currentVideoHash);

        // Progressive rendering state
        const videoMap = new Map();
        const renderedIds = new Set();
        let hasCleared = false;
        let recommendedIds = [];
        let orderMap = new Map();

        // Render sidebar card in order
        const renderSidebarCard = (event) => {
            if (renderedIds.has(event.id)) return;
            // Never show logged-in user's own videos in Up Next
            if (currentUser && event.pubkey === currentUser.pubkey) return;

            // Skip videos with same hash (same video in different event kind)
            const videoHash = event.tags?.find(t => t[0] === 'x')?.[1];
            if (videoHash && usedHashes.has(videoHash)) return;

            // Skip videos that match content filter packs or custom keywords
            const videoData = parseNip71VideoEvent(event) || parseVideoEvent(event);
            if (videoData) {
                const filterResult = shouldFilterVideoContent(event, videoData);
                if (filterResult.filtered) return;
            }

            // Clear spinner on first render
            if (!hasCleared) {
                hasCleared = true;
                if (desktopGrid) desktopGrid.innerHTML = '';
                if (mobileGrid) mobileGrid.innerHTML = '';
            }

            const profile = profileCache.get(event.pubkey);
            const reactions = reactionsCache.get(event.id);
            const cardHTML = createSidebarVideoCard(event, profile, reactions);
            if (!cardHTML) return;

            // Load profile immediately if not cached
            loadProfileAndUpdateCards(event.pubkey);

            // Load boosts if not cached (fire-and-forget)
            if (!boostsCache.has(event.id)) {
                loadBoostsForVideo(event.id, (totalBoosts) => {
                    updateSidebarCardBoosts(event.id, totalBoosts);
                });
            }

            // Load views if not cached (fire-and-forget)
            if (getCachedViewCount(event.id) === null) {
                loadVideoViews(event.id).then(viewCount => {
                    // Update sidebar cards with view count
                    document.querySelectorAll(`.sidebar-video-card[data-event-id="${event.id}"] .video-views`).forEach(el => {
                        el.textContent = ` • ${formatNumber(viewCount)} ${t('stat.views')}`;
                    });
                });
            }

            // Find correct position based on recommendation order
            const eventOrder = orderMap.get(event.id) ?? 999;
            let wasInserted = false;

            // Insert into desktop grid
            if (desktopGrid) {
                const existingCards = desktopGrid.querySelectorAll('.sidebar-video-card');
                // Only insert if under limit
                if (existingCards.length < desktopLimit) {
                    let inserted = false;
                    for (const card of existingCards) {
                        const existingId = card.dataset.eventId;
                        const existingOrder = orderMap.get(existingId) ?? 999;
                        if (eventOrder < existingOrder) {
                            card.insertAdjacentHTML('beforebegin', cardHTML);
                            inserted = true;
                            wasInserted = true;
                            break;
                        }
                    }
                    if (!inserted) {
                        desktopGrid.insertAdjacentHTML('beforeend', cardHTML);
                        wasInserted = true;
                    }
                }
            }

            // Insert into mobile grid (up to 10)
            if (mobileGrid) {
                const existingCards = mobileGrid.querySelectorAll('.sidebar-video-card');
                if (existingCards.length < 10) {
                    let inserted = false;
                    for (const card of existingCards) {
                        const existingId = card.dataset.eventId;
                        const existingOrder = orderMap.get(existingId) ?? 999;
                        if (eventOrder < existingOrder) {
                            card.insertAdjacentHTML('beforebegin', cardHTML);
                            inserted = true;
                            break;
                        }
                    }
                    if (!inserted) {
                        mobileGrid.insertAdjacentHTML('beforeend', cardHTML);
                    }
                }
            }

            // Only count as rendered if actually inserted into desktop grid
            if (wasInserted) {
                renderedIds.add(event.id);
                // Track hash to avoid showing same video in different event kinds
                if (videoHash) usedHashes.add(videoHash);
            }

            // Set next video data from first rendered video
            if (renderedIds.size === 1) {
                const videoData = parseVideoEvent(event);
                const reactions = reactionsCache.get(event.id) || {};
                const isNSFW = isVideoNSFW(event);
                const isRatioed = isVideoRatioed(reactions);
                // Check validation cache for suspicious profile status
                const validationCached = profileValidationCache.get(event.pubkey);
                const isSuspicious = validationCached ? validationCached.isSuspicious :
                    (profileCache.has(event.pubkey) && (!profile || !profile.picture || !profile.nip05));

                nextVideoData = {
                    eventId: event.id,
                    pubkey: event.pubkey,
                    title: videoData?.title || 'Untitled',
                    thumbnail: videoData?.thumbnail || '',
                    channelName: profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`,
                    isNSFW: isNSFW,
                    isRatioed: isRatioed,
                    isSuspicious: isSuspicious
                };
            }

            observeLazyCards();
        };

        // Step 1: Get recommended video IDs (prefer same type as current video)
        recommendedIds = await getMixedRecommendations(currentVideoEvent, desktopLimit + 10, currentIsShort);
        recommendedIds.forEach(id => usedIds.add(id));
        orderMap = new Map(recommendedIds.map((id, i) => [id, i]));

        // Step 2: Fetch videos progressively
        if (recommendedIds.length > 0) {
            const videoFilter = {
                kinds: ALL_VIDEO_KINDS,
                '#t': ['pv69420'],
                ids: recommendedIds
            };

            requestEventsStream(videoFilter, (event) => {
                videoMap.set(event.id, event);
                allEvents.set(event.id, event);
                renderSidebarCard(event);
            }, async () => {
                // On completion - check if we need more videos
                if (renderedIds.size < desktopLimit) {
                    // Fetch latest videos to fill - prefer same type as current video
                    const needed = desktopLimit - renderedIds.size + 10;

                    // Get preferred kinds based on current video type
                    const preferredKinds = currentIsShort
                        ? [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY]
                        : [NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1];
                    const fallbackKinds = currentIsShort
                        ? [NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1]
                        : [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY];

                    let latestOrder = recommendedIds.length;

                    // First fetch preferred type
                    const preferredFilter = {
                        kinds: preferredKinds,
                        '#t': ['pv69420'],
                        limit: needed + 30
                    };

                    requestEventsStream(preferredFilter, (event) => {
                        if (!usedIds.has(event.id)) {
                            usedIds.add(event.id);
                            orderMap.set(event.id, latestOrder++);
                            videoMap.set(event.id, event);
                            allEvents.set(event.id, event);
                            renderSidebarCard(event);
                        }
                    }, () => {
                        // If still not enough, fetch fallback type
                        if (renderedIds.size < desktopLimit) {
                            const stillNeeded = desktopLimit - renderedIds.size + 10;
                            const fallbackFilter = {
                                kinds: fallbackKinds,
                                '#t': ['pv69420'],
                                limit: stillNeeded + 20
                            };

                            requestEventsStream(fallbackFilter, (event) => {
                                if (!usedIds.has(event.id)) {
                                    usedIds.add(event.id);
                                    orderMap.set(event.id, latestOrder++);
                                    videoMap.set(event.id, event);
                                    allEvents.set(event.id, event);
                                    renderSidebarCard(event);
                                }
                            }, () => {
                                // Final fallback: fill with watched videos if still not full
                                fillWithWatchedVideos(latestOrder, finalizeSidebar);
                            });
                        } else {
                            // Final fallback: fill with watched videos if still not full
                            fillWithWatchedVideos(latestOrder, finalizeSidebar);
                        }
                    });
                } else {
                    // Final fallback: fill with watched videos if still not full
                    fillWithWatchedVideos(recommendedIds.length, finalizeSidebar);
                }
            });
        } else {
            // No recommendations - fetch latest, preferring same type as current video
            const preferredKinds = currentIsShort
                ? [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY]
                : [NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1];
            const fallbackKinds = currentIsShort
                ? [NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1]
                : [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY];

            let latestOrder = 0;

            // First fetch preferred type
            const preferredFilter = {
                kinds: preferredKinds,
                '#t': ['pv69420'],
                limit: desktopLimit + 30
            };

            requestEventsStream(preferredFilter, (event) => {
                if (!usedIds.has(event.id)) {
                    usedIds.add(event.id);
                    orderMap.set(event.id, latestOrder++);
                    videoMap.set(event.id, event);
                    allEvents.set(event.id, event);
                    renderSidebarCard(event);
                }
            }, () => {
                // If still not enough, fetch fallback type
                if (renderedIds.size < desktopLimit) {
                    const stillNeeded = desktopLimit - renderedIds.size + 10;
                    const fallbackFilter = {
                        kinds: fallbackKinds,
                        '#t': ['pv69420'],
                        limit: stillNeeded + 20
                    };

                    requestEventsStream(fallbackFilter, (event) => {
                        if (!usedIds.has(event.id)) {
                            usedIds.add(event.id);
                            orderMap.set(event.id, latestOrder++);
                            videoMap.set(event.id, event);
                            allEvents.set(event.id, event);
                            renderSidebarCard(event);
                        }
                    }, () => {
                        // Final fallback: fill with watched videos if still not full
                        fillWithWatchedVideos(latestOrder, finalizeSidebar);
                    });
                } else {
                    // Final fallback: fill with watched videos if still not full
                    fillWithWatchedVideos(latestOrder, finalizeSidebar);
                }
            });
        }

        // Final fallback: fill with watched videos if sidebar still not full
        function fillWithWatchedVideos(latestOrder, callback) {
            if (renderedIds.size >= desktopLimit) {
                callback();
                return;
            }

            // Get recent watch history but exclude very recent watches (last 10)
            const recentHistory = watchHistory.slice(0, 10).map(h => h.id);
            const olderWatchedIds = watchHistory.slice(10).map(h => h.id);

            // Skip if no older watched videos to show
            if (olderWatchedIds.length === 0) {
                callback();
                return;
            }

            const stillNeeded = desktopLimit - renderedIds.size + 5;
            const watchedFilter = {
                kinds: ALL_VIDEO_KINDS,
                '#t': ['pv69420'],
                ids: olderWatchedIds.slice(0, stillNeeded + 10)
            };

            requestEventsStream(watchedFilter, (event) => {
                // Only skip current video and very recent watches
                if (event.id !== currentVideoEvent.id && !recentHistory.includes(event.id) && !renderedIds.has(event.id)) {
                    orderMap.set(event.id, latestOrder++);
                    videoMap.set(event.id, event);
                    allEvents.set(event.id, event);
                    renderSidebarCard(event);
                }
            }, callback);
        }

        // Finalize sidebar after all loading
        function finalizeSidebar() {
            if (renderedIds.size === 0) {
                if (desktopGrid) desktopGrid.innerHTML = noRecsMessage;
                if (mobileGrid) mobileGrid.innerHTML = noRecsMessage;
                nextVideoData = null;
                return;
            }

            // Setup sticky sidebar
            if (window.innerWidth > 1024) {
                setupStickySidebar();
            }

            // Load profiles in background and update cards
            // Load reactions in background
            loadReactionsForVideos([...renderedIds]);
        }

    } catch (error) {
        console.error('Failed to load sidebar recommendations:', error);
        const errorMessage = '<p style="color: var(--text-secondary); text-align: center; padding: 1rem;">Failed to load recommendations.</p>';
        if (desktopGrid) desktopGrid.innerHTML = errorMessage;
        if (mobileGrid) mobileGrid.innerHTML = errorMessage;
    }
}

// Update sidebar card profile in-place
function updateSidebarCardInPlace(eventId, profile) {
    if (!profile) return;

    const cards = document.querySelectorAll(`.sidebar-video-card[data-event-id="${eventId}"]`);
    cards.forEach(card => {
        const displayName = profile.name || profile.display_name || `User ${card.dataset.pubkey?.slice(0, 8) || ''}`;

        // Update channel name (correct selector)
        const nameEl = card.querySelector('.sidebar-channel-name');
        if (nameEl) nameEl.textContent = displayName;
    });
}

// Apply validation result to sidebar cards
// Update sidebar card with boost indicator
function updateSidebarCardBoosts(eventId, boostAmount) {
    const cards = document.querySelectorAll(`.sidebar-video-card[data-event-id="${eventId}"]`);
    if (cards.length === 0) return;

    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;

    cards.forEach(card => {
        // Update card classes
        if (isBoosted) {
            card.classList.add('boosted', `boost-level-${boostLevel}`);
            for (let i = 1; i <= 4; i++) {
                if (i !== boostLevel) {
                    card.classList.remove(`boost-level-${i}`);
                }
            }
        } else {
            card.classList.remove('boosted', 'boost-level-1', 'boost-level-2', 'boost-level-3', 'boost-level-4');
        }

        // Update boost indicator on thumbnail
        const thumbnail = card.querySelector('.sidebar-video-thumbnail');
        if (!thumbnail) return;

        const existingIndicator = thumbnail.querySelector('.boost-indicator');

        if (isBoosted) {
            const indicatorHTML = `
                <div class="boost-indicator" style="font-size: 0.55rem; padding: 0.1rem 0.25rem;">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width: 10px; height: 10px;">
                        <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                    </svg>
                    ${formatSats(boostAmount)}
                </div>
            `;
            if (existingIndicator) {
                existingIndicator.outerHTML = indicatorHTML;
            } else {
                thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
            }
        } else if (existingIndicator) {
            existingIndicator.remove();
        }
    });
}

function applySidebarValidation(card, isSuspiciousProfile) {
    if (!card || !card.classList.contains('sidebar-video-card')) return;

    const eventId = card.dataset.eventId;
    if (!eventId) return;

    const event = allEvents.get(eventId);
    if (!event) return;

    const isNSFW = isVideoNSFW(event);
    const reactions = reactionsCache.get(eventId) || {};
    const isRatioed = isVideoRatioed(reactions);

    // Skip overlays for own videos
    const isOwnVideo = currentUser?.pubkey === event.pubkey;
    const shouldShowNSFWOverlay = !isOwnVideo && isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own videos)
    const isReportedByFollowsCheck = !isOwnVideo && isReportedByFollowsSync(eventId, event.pubkey);
    const shouldShowCommunityWarning = !isOwnVideo && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning();
    const needsOverlay = shouldShowNSFWOverlay || shouldShowCommunityWarning;
    const overlayType = shouldShowNSFWOverlay ? 'nsfw' : 'ratioed';

    const thumbnail = card.querySelector('.sidebar-video-thumbnail');
    if (!thumbnail) return;

    const currentOverlay = thumbnail.querySelector('.ratioed-overlay, .nsfw-overlay');

    // Add overlay if needed and not present
    if (needsOverlay && !currentOverlay) {
        thumbnail.classList.add(overlayType);
        card.setAttribute('onclick',
            overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${eventId}')` : `showRatioedModal('${eventId}')`
        );
        const overlayHTML = `
            <div class="${overlayType}-overlay">
                <div class="${overlayType}-badge" style="font-size: 0.6rem; padding: 0.15rem 0.3rem;">${overlayType === 'nsfw' ? 'NSFW' : 'WARNING'}</div>
            </div>
        `;
        thumbnail.insertAdjacentHTML('beforeend', overlayHTML);

        // Hide duration when overlay shown
        const duration = thumbnail.querySelector('.video-duration');
        if (duration) duration.style.display = 'none';
    } else if (!needsOverlay && currentOverlay) {
        // Remove overlay if not needed
        thumbnail.classList.remove('ratioed', 'nsfw');
        card.setAttribute('onclick', `navigateTo('/video/${eventId}')`);
        currentOverlay.remove();

        // Show duration again
        const duration = thumbnail.querySelector('.video-duration');
        if (duration) duration.style.display = '';
    }

    // Update warning indicator in meta
    const meta = card.querySelector('.sidebar-video-meta');
    if (meta) {
        const existingWarning = meta.querySelector('[style*="color: #ff9800"]');
        if (shouldShowCommunityWarning && !shouldShowNSFWOverlay && !existingWarning) {
            meta.insertAdjacentHTML('beforeend', '<span style="color: #ff9800; font-size: 0.65rem;">⚠</span>');
        } else if ((!shouldShowCommunityWarning || shouldShowNSFWOverlay) && existingWarning) {
            existingWarning.remove();
        }
    }
}

// Create a compact video card for the sidebar
function createSidebarVideoCard(event, profile, reactions) {
    const videoData = parseNip71VideoEvent(event) || parseVideoEvent(event);
    if (!videoData) return '';

    // Skip videos from muted users in recommendations
    if (shouldHideMutedContent(event.pubkey)) return '';

    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';
    const isNSFW = isVideoNSFW(event);
    const isRatioed = isVideoRatioed(reactions || {});

    // Check validation cache first - if we've validated this pubkey, use cached result
    let isSuspiciousProfile = false;
    if (profileValidationCache.has(event.pubkey)) {
        isSuspiciousProfile = profileValidationCache.get(event.pubkey).isSuspicious;
    } else {
        // Fallback to basic field check if not validated yet
        const profileChecked = profileCache.has(event.pubkey);
        isSuspiciousProfile = profileChecked && (!profile || !avatarUrl || !nip05);
    }

    // Check boosts cache for boost highlighting
    const boostAmount = boostsCache.get(event.id) || 0;
    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;
    const boostClasses = isBoosted ? `boosted boost-level-${boostLevel}` : '';

    // Determine what type of overlay to show (skip for own videos)
    const isOwnVideo = currentUser?.pubkey === event.pubkey;
    const showNSFWOverlay = !isOwnVideo && isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own videos)
    const isReportedByFollowsCheck = !isOwnVideo && isReportedByFollowsSync(event.id, event.pubkey);
    const showCommunityWarning = !isOwnVideo && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning();
    const showBlurred = showNSFWOverlay || showCommunityWarning;

    // NSFW takes precedence for overlay type
    const overlayType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    // Determine onclick handler based on overlay type
    const onclickHandler = showBlurred
        ? (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${event.id}')` : `showRatioedModal('${event.id}')`)
        : `navigateTo('/video/${event.id}')`;

    // Boost indicator HTML for sidebar (smaller styling)
    const boostIndicatorHTML = isBoosted ? `
        <div class="boost-indicator" style="font-size: 0.55rem; padding: 0.1rem 0.25rem;">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width: 10px; height: 10px;">
                <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
            </svg>
            ${formatSats(boostAmount)}
        </div>
    ` : '';

    return `
        <div class="sidebar-video-card ${boostClasses}" data-event-id="${event.id}" data-pubkey="${event.pubkey}" onclick="${onclickHandler}">
            <div class="sidebar-video-thumbnail ${showBlurred ? overlayType : ''}"
                 ${videoData.preview ? `data-preview="${escapeHtml(videoData.preview)}" data-thumbnail="${escapeHtml(videoData.thumbnail || '')}"` : ''}>
                ${videoData.thumbnail ?
            `<img class="thumbnail-img" src="${videoData.thumbnail}" data-original-src="${videoData.thumbnail}" alt="${videoData.title}" onload="cacheLoadedImage(this)" onerror="this.style.display='none'">` :
            `<video src="${videoData.url}" preload="metadata"></video>`
        }
                ${showBlurred ? `
                    <div class="${overlayType}-overlay">
                        <div class="${overlayType}-badge" style="font-size: 0.6rem; padding: 0.15rem 0.3rem;">${overlayType === 'nsfw' ? 'NSFW' : 'WARNING'}</div>
                    </div>
                ` : ''}
                ${!showBlurred && videoData.duration ? `<span class="video-duration" style="font-size: 0.65rem; padding: 0.1rem 0.3rem;">${formatDuration(videoData.duration)}</span>` : ''}
                ${boostIndicatorHTML}
            </div>
            <div class="sidebar-video-info">
                <h4 class="sidebar-video-title">${videoData.title}</h4>
                <div class="sidebar-video-meta">
                    <span class="sidebar-channel-name">${displayName}</span>
                    <span class="sidebar-video-time">${formatTimestamp(event.created_at)}<span class="video-views" data-event-id="${event.id}">${(() => { const c = getCachedViewCount(event.id); return c !== null ? ` • ${formatNumber(c)} ${t('stat.views')}` : ''; })()}</span></span>
                    ${isNSFW ? '<span style="color: #ff0000; font-size: 0.65rem;">NSFW</span>' : ''}
                    ${showCommunityWarning && !showNSFWOverlay ? '<span style="color: #ff9800; font-size: 0.65rem;">⚠</span>' : ''}
                </div>
            </div>
        </div>
    `;
}

// Auto-play next video overlay functions
function showNextVideoOverlay() {
    if (!nextVideoData) return;

    const videoPlayer = document.querySelector('.video-player');
    if (!videoPlayer) return;

    // Remove any existing overlay
    hideNextVideoOverlay();

    const circumference = 2 * Math.PI * 16; // radius = 16

    // Determine warning status
    const showNSFWOverlay = nextVideoData.isNSFW && !shouldShowNSFW();
    const showCommunityWarning = (nextVideoData.isRatioed || nextVideoData.isSuspicious) && !sessionRatioedAllowed.has(nextVideoData.eventId) && !shouldSkipCommunityWarning();
    const hasWarning = showNSFWOverlay || showCommunityWarning;
    const warningType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    // Determine click handler - show modal if has warning
    const clickHandler = hasWarning
        ? (showNSFWOverlay ? `showNSFWModal('playVideo', '${nextVideoData.eventId}')` : `showRatioedModal('${nextVideoData.eventId}')`)
        : 'playNextVideo()';

    const overlay = document.createElement('div');
    overlay.className = 'next-video-overlay';
    overlay.id = 'nextVideoOverlay';
    overlay.innerHTML = `
        <div class="overlay-header">
            <div class="countdown-ring">
                <svg viewBox="0 0 40 40">
                    <circle class="bg" cx="20" cy="20" r="16"></circle>
                    <circle class="progress" cx="20" cy="20" r="16"
                        stroke-dasharray="${circumference}"
                        stroke-dashoffset="0"></circle>
                </svg>
                <span class="countdown-number">${AUTO_PLAY_COUNTDOWN_SECONDS}</span>
            </div>
            <span>Up next</span>
        </div>
        <div class="next-video-card" onclick="${clickHandler}">
            <div class="next-video-thumbnail ${hasWarning ? warningType : ''}">
                ${nextVideoData.thumbnail ?
            `<img src="${nextVideoData.thumbnail}" alt="${nextVideoData.title}"${hasWarning ? ' style="filter: blur(10px);"' : ''}>` :
            '<div style="width:100%;height:100%;background:var(--bg-primary);"></div>'
        }
                ${hasWarning ? `
                    <div class="${warningType}-overlay" style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;">
                        <div class="${warningType}-badge" style="font-size:0.7rem;padding:0.2rem 0.4rem;">${showNSFWOverlay ? 'NSFW' : 'WARNING'}</div>
                    </div>
                ` : ''}
            </div>
            <div class="next-video-info">
                <div class="next-video-title">${nextVideoData.title}</div>
                <div class="next-video-channel">
                    ${nextVideoData.channelName}
                    ${nextVideoData.isNSFW ? '<span style="color:#ff0000;font-size:0.7rem;margin-left:0.3rem;">NSFW</span>' : ''}
                    ${showCommunityWarning && !showNSFWOverlay ? '<span style="color:#ff9800;font-size:0.7rem;margin-left:0.3rem;">⚠</span>' : ''}
                </div>
            </div>
        </div>
        <div class="overlay-actions">
            <button class="overlay-btn cancel" onclick="cancelAutoPlay()">Cancel</button>
            <button class="overlay-btn play-now" onclick="${clickHandler}">${hasWarning ? 'View' : 'Play Now'}</button>
        </div>
    `;

    videoPlayer.appendChild(overlay);

    // Start countdown
    let secondsLeft = AUTO_PLAY_COUNTDOWN_SECONDS;
    const progressCircle = overlay.querySelector('.progress');
    const countdownNumber = overlay.querySelector('.countdown-number');

    autoPlayCountdownTimer = setInterval(() => {
        secondsLeft--;
        countdownNumber.textContent = secondsLeft;

        // Update progress ring
        const offset = circumference * (1 - secondsLeft / AUTO_PLAY_COUNTDOWN_SECONDS);
        progressCircle.style.strokeDashoffset = offset;

        if (secondsLeft <= 0) {
            clearInterval(autoPlayCountdownTimer);
            autoPlayCountdownTimer = null;

            // If warning, show modal instead of auto-playing
            if (hasWarning) {
                hideNextVideoOverlay();
                if (showNSFWOverlay) {
                    showNSFWModal('playVideo', nextVideoData.eventId);
                } else {
                    showRatioedModal(nextVideoData.eventId);
                }
            } else {
                playNextVideo();
            }
        }
    }, 1000);
}

function hideNextVideoOverlay() {
    if (autoPlayCountdownTimer) {
        clearInterval(autoPlayCountdownTimer);
        autoPlayCountdownTimer = null;
    }

    const overlay = document.getElementById('nextVideoOverlay');
    if (overlay) {
        overlay.remove();
    }
}

function cancelAutoPlay() {
    hideNextVideoOverlay();
}

function playNextVideo() {
    hideNextVideoOverlay();

    if (nextVideoData && nextVideoData.eventId) {
        navigateTo(`/video/${nextVideoData.eventId}`);
    }
}

// Sticky sidebar scroll handler
let stickyScrollHandler = null;
let sidebarPlaceholder = null;

function setupStickySidebar() {
    // Clean up previous handler if exists
    if (stickyScrollHandler) {
        window.removeEventListener('scroll', stickyScrollHandler);
        window.removeEventListener('resize', stickyScrollHandler);
        stickyScrollHandler = null;
    }

    // Remove any existing placeholder
    if (sidebarPlaceholder) {
        sidebarPlaceholder.remove();
        sidebarPlaceholder = null;
    }

    const sidebar = document.getElementById('recommendationsSidebarDesktop');
    if (!sidebar) return;

    const wrapper = document.querySelector('.video-content-wrapper');
    if (!wrapper) return;

    const headerHeight = 60; // --header-height
    const topOffset = headerHeight + 16; // 1rem gap
    const sidebarWidth = sidebar.offsetWidth;

    // Create placeholder to reserve space when sidebar is fixed
    sidebarPlaceholder = document.createElement('div');
    sidebarPlaceholder.className = 'sidebar-placeholder';
    sidebarPlaceholder.style.width = `${sidebarWidth}px`;
    sidebarPlaceholder.style.flexShrink = '0';
    sidebarPlaceholder.style.display = 'none';
    sidebar.parentNode.insertBefore(sidebarPlaceholder, sidebar.nextSibling);

    stickyScrollHandler = () => {
        const wrapperRect = wrapper.getBoundingClientRect();
        const sidebarHeight = sidebar.offsetHeight;

        // Check if we should be sticky
        if (wrapperRect.top <= topOffset) {
            // Calculate how far down we can go
            const maxScroll = wrapperRect.bottom - sidebarHeight - topOffset;

            if (maxScroll > 0) {
                // Sidebar should be fixed - show placeholder to reserve space
                sidebar.classList.add('is-sticky');
                sidebarPlaceholder.style.display = 'block';
                // Calculate the right position based on wrapper
                const containerRight = window.innerWidth - wrapperRect.right;
                sidebar.style.right = `${containerRight}px`;
                sidebar.style.transform = '';
            } else {
                // Sidebar should stick to bottom of wrapper
                sidebar.classList.remove('is-sticky');
                sidebarPlaceholder.style.display = 'none';
                sidebar.style.right = '';
                sidebar.style.transform = `translateY(${wrapperRect.height - sidebarHeight}px)`;
            }
        } else {
            // Not scrolled enough, sidebar at natural position
            sidebar.classList.remove('is-sticky');
            sidebarPlaceholder.style.display = 'none';
            sidebar.style.right = '';
            sidebar.style.transform = '';
        }
    };

    window.addEventListener('scroll', stickyScrollHandler, { passive: true });
    // Also handle resize
    window.addEventListener('resize', stickyScrollHandler, { passive: true });
    // Initial call
    stickyScrollHandler();
}

// Function to load watch history page
// Progressive watch history loading - renders videos as they arrive
async function loadWatchHistory() {
    currentView = 'history';

    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const skeletonCount = cardsPerRow * 10; // 10 rows of skeletons
    const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');

    mainContent.innerHTML = `
        <div class="history-header" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem;">
            <h2 style="margin: 0;">${t('pageTitle.watchHistory')}</h2>
            <div style="display: flex; gap: 0.75rem; align-items: center;">
                <div class="history-search-container" style="position: relative;">
                    <input type="text" id="historySearch" placeholder="${t('placeholder.searchHistory')}"
                           style="padding: 0.5rem 0.75rem 0.5rem 2.25rem; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-secondary); color: var(--text-primary); width: 200px; font-size: 0.875rem;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); color: var(--text-secondary);">
                        <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                    </svg>
                </div>
                <button id="clearHistoryBtn" class="action-btn" style="padding: 0.5rem 1rem; border-radius: 8px; font-size: 0.875rem;" onclick="confirmClearHistory()">
                    ${t('button.clearAll')}
                </button>
            </div>
        </div>
        <!-- Live Streams Section -->
        <div id="historyLiveSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <circle cx="12" cy="12" r="4" fill="#f44336"/>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                </svg>
                ${t('pageTitle.liveStreams')}
            </h3>
            <div class="video-grid" id="historyLiveGrid"></div>
        </div>
        <!-- Shorts Section -->
        <div id="historyShortsSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M10 8l6 4-6 4V8z"/>
                </svg>
                ${t('section.shorts')}
            </h3>
            <div class="shorts-grid" id="historyShortsGrid"></div>
        </div>
        <!-- Videos Section -->
        <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                </svg>
                ${t('section.videos')}
            </h3>
        <div class="video-grid" id="videoGrid">
            ${skeletons}
        </div>
    `;

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('historyShortsGrid');
    const shortsSection = document.getElementById('historyShortsSection');
    const liveGrid = document.getElementById('historyLiveGrid');
    const liveSection = document.getElementById('historyLiveSection');
    const searchInput = document.getElementById('historySearch');

    const history = getWatchHistory();

    if (history.length === 0) {
        videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noWatchHistory')}</p>`;
        return;
    }

    const historyIds = history.map(item => item.id);
    const historyOrder = new Map(historyIds.map((id, i) => [id, i]));

    // Progressive rendering state
    const videoMap = new Map();
    const shortMap = new Map();
    const liveMap = new Map();
    const renderedVideoIds = new Set();
    const renderedShortIds = new Set();
    const renderedLiveIds = new Set();
    let hasCleared = false;
    let renderTimeout = null;
    let firstRenderDone = false;

    // Create card HTML with history remove button
    const createHistoryCard = (event, type = 'video') => {
        const profile = profileCache.get(event.pubkey);
        const reactions = reactionsCache.get(event.id);
        const isFirstRow = type === 'short' ? renderedShortIds.size < cardsPerRow :
            type === 'live' ? renderedLiveIds.size < cardsPerRow :
                renderedVideoIds.size < cardsPerRow;

        let cardHTML;
        if (type === 'short') {
            cardHTML = createShortCard(event, profile, reactions);
        } else if (type === 'live') {
            const liveData = parseLiveEvent(event);
            if (!liveData) return null;
            const isEnded = liveData.status === 'ended';
            cardHTML = createLiveStreamCard(event, liveData, profile, isEnded);
        } else {
            cardHTML = createVideoCard(event, profile, reactions, false, null, !isFirstRow);
        }

        if (!cardHTML) return null;

        // Add remove from history button to the card
        const removeBtn = `<button class="history-remove-btn" onclick="event.stopPropagation(); removeFromHistory('${event.id}')" title="${t('button.removeFromHistory')}">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
            </svg>
        </button>`;

        // Add history-card class to the card (both shorts and videos use video-card class)
        // Short cards have "video-card short-card", regular videos have just "video-card"
        cardHTML = cardHTML.replace('<div class="video-card', '<div class="video-card history-card');

        // Insert remove button inside the video-thumbnail div (after opening tag)
        // Find the video-thumbnail div and insert the button right after it opens
        const thumbnailMatch = cardHTML.match(/<div class="video-thumbnail[^>]*>/);
        if (thumbnailMatch) {
            const insertPos = cardHTML.indexOf(thumbnailMatch[0]) + thumbnailMatch[0].length;
            cardHTML = cardHTML.slice(0, insertPos) + removeBtn + cardHTML.slice(insertPos);
        }

        return cardHTML;
    };

    // Render video card in history order
    const renderVideoInOrder = (event, targetGrid, renderedIds, orderMap, type = 'video') => {
        const cardId = type === 'live' ? `live-card-${event.id}` : `video-card-${event.id}`;
        if (document.getElementById(cardId)) return;
        // Also check by data attribute for live streams
        if (type === 'live' && document.querySelector(`[data-live-event-id="${event.id}"]`)) return;

        // Clear skeletons on first render (videos only)
        if (type === 'video' && !hasCleared) {
            hasCleared = true;
            videoGrid.innerHTML = '';
        }

        const cardHTML = createHistoryCard(event, type);
        if (!cardHTML) return;

        // Load profile immediately if not cached
        loadProfileAndUpdateCards(event.pubkey);

        // Load boosts if not cached (fire-and-forget)
        if (!boostsCache.has(event.id)) {
            loadBoostsForVideo(event.id, (totalBoosts) => {
                const card = document.getElementById(`video-card-${event.id}`);
                if (!card) return;
                const boostLevel = getBoostLevel(totalBoosts);
                const isBoosted = boostLevel > 0;
                if (isBoosted) {
                    card.classList.add('boosted', `boost-level-${boostLevel}`);
                    for (let i = 1; i <= 4; i++) {
                        if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                    }
                    const thumbnail = card.querySelector('.video-thumbnail');
                    if (thumbnail) {
                        const existingIndicator = thumbnail.querySelector('.boost-indicator');
                        const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                        if (existingIndicator) {
                            existingIndicator.outerHTML = indicatorHTML;
                        } else {
                            thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                        }
                    }
                }
            });
        }

        // Find correct position based on history order
        const eventOrder = orderMap.get(event.id) ?? 999;
        const cardSelector = type === 'short' ? '.short-card' : '.video-card';
        const existingCards = targetGrid.querySelectorAll(cardSelector);
        let inserted = false;

        for (const card of existingCards) {
            const existingId = card.dataset.liveEventId || card.id.replace('video-card-', '').replace('live-card-', '');
            const existingOrder = orderMap.get(existingId) ?? 999;
            if (eventOrder < existingOrder) {
                card.insertAdjacentHTML('beforebegin', cardHTML);
                inserted = true;
                break;
            }
        }

        if (!inserted) {
            targetGrid.insertAdjacentHTML('beforeend', cardHTML);
        }

        // Set the ID on the card (live stream cards already have data-live-event-id)
        if (type !== 'live') {
            const insertedCard = targetGrid.querySelector(`${cardSelector}:not([id])`);
            if (insertedCard) {
                insertedCard.id = cardId;
            }
        }

        renderedIds.add(event.id);
        observeLazyCards();

        // Load boosts for live streams
        if (type === 'live' && !boostsCache.has(event.id)) {
            loadBoostsForVideo(event.id);
        }
    };

    // Progressive render function
    const renderProgressively = () => {
        // Process all content in history order, separating by type
        historyIds.forEach(id => {
            const event = videoMap.get(id) || shortMap.get(id) || liveMap.get(id);
            if (!event) return;

            // Skip legacy events when addressable counterpart exists
            if (shouldSkipLegacyEvent(event)) return;

            // Determine content type
            const isLive = event.kind === NIP53_LIVE_EVENT_KIND;
            const isShort = isNip71ShortKind(event.kind);

            if (isLive) {
                if (!renderedLiveIds.has(event.id)) {
                    liveSection.style.display = 'block';
                    renderVideoInOrder(event, liveGrid, renderedLiveIds, historyOrder, 'live');
                }
            } else if (isShort) {
                if (!renderedShortIds.has(event.id)) {
                    shortsSection.style.display = 'block';
                    renderVideoInOrder(event, shortsGrid, renderedShortIds, historyOrder, 'short');
                }
            } else {
                if (!renderedVideoIds.has(event.id)) {
                    renderVideoInOrder(event, videoGrid, renderedVideoIds, historyOrder, 'video');
                }
            }
        });
        firstRenderDone = true;
    };

    // Debounced render (immediate on first event)
    const scheduleRender = () => {
        if (renderTimeout) clearTimeout(renderTimeout);
        if (!firstRenderDone) {
            renderProgressively();
        } else {
            renderTimeout = setTimeout(renderProgressively, 50);
        }
    };

    // Fetch history videos in batches with progressive rendering
    const BATCH_SIZE = 50;
    const idBatches = [];
    for (let i = 0; i < historyIds.length; i += BATCH_SIZE) {
        idBatches.push(historyIds.slice(i, i + BATCH_SIZE));
    }

    // Process all batches - render as videos arrive
    idBatches.forEach(batch => {
        // Fetch regular videos
        const videoFilter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            ids: batch
        };

        requestEventsStream(videoFilter, (event) => {
            allEvents.set(event.id, event);

            // Separate shorts from videos
            if (isNip71ShortKind(event.kind)) {
                shortMap.set(event.id, event);
            } else {
                videoMap.set(event.id, event);
            }
            scheduleRender();
        }, () => {
            // Batch complete
            clearTimeout(renderTimeout);
            renderProgressively();
        });

        // Also fetch live streams (they use kind 30311)
        const liveFilter = {
            kinds: [NIP53_LIVE_EVENT_KIND],
            ids: batch
        };

        requestEventsStream(liveFilter, (event) => {
            allEvents.set(event.id, event);
            liveMap.set(event.id, event);
            scheduleRender();
        }, () => {
            // Live stream batch complete
            clearTimeout(renderTimeout);
            renderProgressively();
        });
    });

    // After a delay, check if no content found
    setTimeout(() => {
        if (renderedVideoIds.size === 0 && renderedShortIds.size === 0 && renderedLiveIds.size === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosInHistory')}</p>`;
        } else if (renderedVideoIds.size === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthHistory')}</p>`;
        }
    }, 3000);

    // Display function for search filtering
    function displayHistoryVideos(videos, shorts) {
        videoGrid.innerHTML = '';
        shortsGrid.innerHTML = '';
        renderedVideoIds.clear();
        renderedShortIds.clear();

        if (videos.length === 0 && shorts.length === 0) {
            shortsSection.style.display = 'none';
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noMatchingVideos')}</p>`;
            return;
        }

        // Render shorts
        if (shorts.length > 0) {
            shortsSection.style.display = 'block';
            for (const event of shorts) {
                const cardHTML = createHistoryCard(event, true);
                if (cardHTML) {
                    shortsGrid.insertAdjacentHTML('beforeend', cardHTML);
                    renderedShortIds.add(event.id);
                }
            }
        } else {
            shortsSection.style.display = 'none';
        }

        // Render videos
        if (videos.length > 0) {
            for (const event of videos) {
                const cardHTML = createHistoryCard(event, false);
                if (cardHTML) {
                    videoGrid.insertAdjacentHTML('beforeend', cardHTML);
                    renderedVideoIds.add(event.id);
                }
            }
        } else {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthVideos')}</p>`;
        }

        observeLazyCards();
    }

    // Search functionality
    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.toLowerCase().trim();

        searchTimeout = setTimeout(() => {
            // Get current videos and shorts
            const allMedia = historyIds
                .map(id => videoMap.get(id) || shortMap.get(id))
                .filter(Boolean)
                .filter(event => !shouldSkipLegacyEvent(event));

            if (!query) {
                const shorts = allMedia.filter(e => isNip71ShortKind(e.kind));
                const videos = allMedia.filter(e => !isNip71ShortKind(e.kind));
                displayHistoryVideos(videos, shorts);
                return;
            }

            const filteredMedia = allMedia.filter(event => {
                const videoData = parseAnyVideoEvent(event);
                if (!videoData) return false;

                const title = (videoData.title || '').toLowerCase();
                const description = (videoData.description || '').toLowerCase();
                const tags = (videoData.tags || []).map(t => t.toLowerCase());

                return title.includes(query) ||
                    description.includes(query) ||
                    tags.some(tag => tag.includes(query));
            });

            const filteredShorts = filteredMedia.filter(e => isNip71ShortKind(e.kind));
            const filteredVideos = filteredMedia.filter(e => !isNip71ShortKind(e.kind));
            displayHistoryVideos(filteredVideos, filteredShorts);
        }, 300);
    });
}

// Remove a single video from watch history
function removeFromHistory(eventId) {
    try {
        // Use the removeFromWatchHistory function which syncs to Nostr
        removeFromWatchHistory(eventId);

        // Remove the card from the UI
        const card = document.getElementById(`video-card-${eventId}`);
        if (card) {
            card.remove();
        }

        showToast('Removed from history', 'success');
    } catch (e) {
        console.error('Failed to remove from history:', e);
        showToast('Failed to remove from history', 'error');
    }
}

// Confirm clear history dialog
function confirmClearHistory() {
    showConfirmModal(
        'Clear Watch History',
        'Are you sure you want to clear your entire watch history? This cannot be undone.',
        () => {
            clearWatchHistory();
            loadWatchHistory();
        },
        { confirmText: 'Clear History', danger: true }
    );
}

// Static pages
function loadAboutPage() {
    currentView = 'about';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>${t('about.title')}</h1>

            <section class="static-section">
                <h2>${t('about.whatIs')}</h2>
                <p>${t('about.whatIsDesc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('about.whyNostr')}</h2>
                <p>${t('about.whyNostrDesc')}</p>
                <ul>
                    <li><strong>${t('about.benefit1')}</strong> ${t('about.benefit1Desc')}</li>
                    <li><strong>${t('about.benefit2')}</strong> ${t('about.benefit2Desc')}</li>
                    <li><strong>${t('about.benefit3')}</strong> ${t('about.benefit3Desc')}</li>
                    <li><strong>${t('about.benefit4')}</strong> ${t('about.benefit4Desc')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('about.howItWorks')}</h2>
                <p>${t('about.howItWorksDesc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('about.features')}</h2>
                <ul>
                    <li>${t('about.feature1')}</li>
                    <li>${t('about.feature2')}</li>
                    <li>${t('about.feature3')}</li>
                    <li>${t('about.feature4')}</li>
                    <li>${t('about.feature5')}</li>
                    <li>${t('about.feature6')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('about.openSource')}</h2>
                <p>${t('about.openSourceDesc')}</p>
                <p><a href="https://github.com/Spl0itable/plebs-app" target="_blank" rel="noopener" class="accent-link">${t('about.githubRepo')}</a></p>
            </section>

            <section class="static-section">
                <h2>${t('about.builtBy')}</h2>
                <p>${t('about.builtByDesc')}</p>
            </section>
        </div>
    `;
}

function loadContactPage() {
    currentView = 'contact';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>${t('contact.title')}</h1>

            <section class="static-section">
                <h2>${t('contact.getInTouch')}</h2>
                <p>${t('contact.getInTouchDesc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('contact.email')}</h2>
                <p>${t('contact.emailDesc')}</p>
                <p><a href="mailto:support@plebs.app" class="accent-link">support@plebs.app</a></p>
            </section>

            <section class="static-section">
                <h2>${t('contact.github')}</h2>
                <p>${t('contact.githubDesc')}</p>
                <p><a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener" class="accent-link">${t('contact.githubIssues')}</a></p>
            </section>

            <section class="static-section">
                <h2>${t('contact.company')}</h2>
                <p>${t('contact.companyDesc')}</p>
                <p><a href="https://nostrservices.com" target="_blank" rel="noopener" class="accent-link">nostrservices.com</a></p>
            </section>
        </div>
    `;
}

function loadTermsPage() {
    currentView = 'terms';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>${t('terms.title')}</h1>
            <p class="last-updated">${t('terms.lastUpdated')}</p>

            <section class="static-section">
                <h2>${t('terms.section1Title')}</h2>
                <p>${t('terms.section1Desc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('terms.section2Title')}</h2>
                <p>${t('terms.section2Desc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('terms.section3Title')}</h2>
                <p>${t('terms.section3Desc')}</p>
                <ul>
                    <li>${t('terms.section3Item1')}</li>
                    <li>${t('terms.section3Item2')}</li>
                    <li>${t('terms.section3Item3')}</li>
                    <li>${t('terms.section3Item4')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('terms.section4Title')}</h2>
                <p>${t('terms.section4Desc')}</p>
                <ul>
                    <li>${t('terms.section4Item1')}</li>
                    <li>${t('terms.section4Item2')}</li>
                    <li>${t('terms.section4Item3')}</li>
                    <li>${t('terms.section4Item4')}</li>
                </ul>
                <p>${t('terms.section4Note')}</p>
            </section>

            <section class="static-section">
                <h2>${t('terms.section5Title')}</h2>
                <p>${t('terms.section5Desc')}</p>
                <ul>
                    <li>${t('terms.section5Item1')}</li>
                    <li>${t('terms.section5Item2')}</li>
                    <li>${t('terms.section5Item3')}</li>
                    <li>${t('terms.section5Item4')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('terms.section6Title')}</h2>
                <p>${t('terms.section6Desc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('terms.section7Title')}</h2>
                <p>${t('terms.section7Desc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('terms.section8Title')}</h2>
                <p>${t('terms.section8Desc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('terms.section9Title')}</h2>
                <p>${t('terms.section9Desc')}</p>
            </section>
        </div>
    `;
}

function loadPrivacyPage() {
    currentView = 'privacy';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>${t('privacy.title')}</h1>
            <p class="last-updated">${t('privacy.lastUpdated')}</p>

            <section class="static-section">
                <h2>${t('privacy.section1Title')}</h2>
                <p>${t('privacy.section1Desc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('privacy.section2Title')}</h2>
                <p>${t('privacy.section2Desc')}</p>
                <ul>
                    <li>${t('privacy.section2Item1')}</li>
                    <li>${t('privacy.section2Item2')}</li>
                    <li>${t('privacy.section2Item3')}</li>
                    <li>${t('privacy.section2Item4')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('privacy.section3Title')}</h2>
                <p><strong>${t('privacy.section3LocalTitle')}</strong></p>
                <ul>
                    <li>${t('privacy.section3LocalItem1')}</li>
                    <li>${t('privacy.section3LocalItem2')}</li>
                    <li>${t('privacy.section3LocalItem3')}</li>
                    <li>${t('privacy.section3LocalItem4')}</li>
                </ul>
                <p><strong>${t('privacy.section3CollectTitle')}</strong></p>
                <ul>
                    <li>${t('privacy.section3CollectItem1')}</li>
                    <li>${t('privacy.section3CollectItem2')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('privacy.section4Title')}</h2>
                <p>${t('privacy.section4Desc')}</p>
                <ul>
                    <li>${t('privacy.section4Item1')}</li>
                    <li>${t('privacy.section4Item2')}</li>
                    <li>${t('privacy.section4Item3')}</li>
                    <li>${t('privacy.section4Item4')}</li>
                    <li>${t('privacy.section4Item5')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('privacy.section5Title')}</h2>
                <p>${t('privacy.section5Desc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('privacy.section6Title')}</h2>
                <p>${t('privacy.section6Desc')}</p>
                <ul>
                    <li>${t('privacy.section6Item1')}</li>
                    <li>${t('privacy.section6Item2')}</li>
                    <li>${t('privacy.section6Item3')}</li>
                </ul>
                <p>${t('privacy.section6Note')}</p>
            </section>

            <section class="static-section">
                <h2>${t('privacy.section7Title')}</h2>
                <p>${t('privacy.section7Desc')}</p>
                <ul>
                    <li>${t('privacy.section7Item1')}</li>
                    <li>${t('privacy.section7Item2')}</li>
                    <li>${t('privacy.section7Item3')}</li>
                    <li>${t('privacy.section7Item4')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('privacy.section8Title')}</h2>
                <p>${t('privacy.section8Desc')}</p>
                <ul>
                    <li>${t('privacy.section8Item1')}</li>
                    <li>${t('privacy.section8Item2')}</li>
                    <li>${t('privacy.section8Item3')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('privacy.section9Title')}</h2>
                <p>${t('privacy.section9Desc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('privacy.section10Title')}</h2>
                <p>${t('privacy.section10Desc')}</p>
            </section>
        </div>
    `;
}

function loadFaqPage() {
    currentView = 'faq';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>${t('faq.title')}</h1>

            <div class="faq-category">
                <h2>${t('faq.aboutPlebs')}</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q1')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a1')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q2')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a2')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q3')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a3')}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>${t('faq.nostrProtocol')}</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q4')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a4')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q5')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a5Title')}
                                <ul>
                                    <li><strong>${t('faq.a5Item1')}</strong> ${t('faq.a5Item1Desc')}</li>
                                    <li><strong>${t('faq.a5Item2')}</strong> ${t('faq.a5Item2Desc')}</li>
                                    <li><strong>${t('faq.a5Item3')}</strong> ${t('faq.a5Item3Desc')}</li>
                                    <li><strong>${t('faq.a5Item4')}</strong> ${t('faq.a5Item4Desc')}</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q6')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a6')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q7')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a7')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q8')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a8')}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>${t('faq.videoStorage')}</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q9')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a9')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q10')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a10')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q11')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a11')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q12')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a12')}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>${t('faq.featuresUsage')}</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q13')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a13Title')}
                                <ul>
                                    <li><strong>${t('faq.a13Item1')}</strong> ${t('faq.a13Item1Desc')}</li>
                                    <li><strong>${t('faq.a13Item2')}</strong> ${t('faq.a13Item2Desc')}</li>
                                    <li><strong>${t('faq.a13Item3')}</strong> ${t('faq.a13Item3Desc')}</li>
                                </ul>
                                ${t('faq.a13Note')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q14')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a14')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q15')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a15Title')}
                                <ul>
                                    <li>${t('faq.a15Item1')}</li>
                                    <li>${t('faq.a15Item2')}</li>
                                    <li>${t('faq.a15Item3')}</li>
                                    <li>${t('faq.a15Item4')}</li>
                                    <li>${t('faq.a15Item5')}</li>
                                </ul>
                                ${t('faq.a15Note')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            What is NSFW content and how do I access it?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                NSFW (Not Safe For Work) content is adult material that is hidden by default. To view NSFW content, go to Settings and enable the NSFW toggle. When uploading adult content, always tag it as NSFW so others can filter appropriately.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            How does the recommendation system work?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Plebs shows recommendations based on what's popular, recent content, and content from creators you follow. There's no algorithmic manipulation trying to maximize your engagement or show you controversial content. What you see is based on transparent metrics like views, likes, and zaps.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Can I watch live streams?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Yes! Plebs supports live streaming via Nostr. You can watch live streams from the Live section in the sidebar. Live streams include real-time chat and zapping capabilities. To go live yourself, you'll need streaming software that supports Nostr.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>${t('faq.selfModeration')}</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q16')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a16')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q17')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a17Intro')}
                                <ul>
                                    <li><strong>${t('faq.a17Pack1')}</strong> ${t('faq.a17Pack1Desc')}</li>
                                    <li><strong>${t('faq.a17Pack2')}</strong> ${t('faq.a17Pack2Desc')}</li>
                                    <li><strong>${t('faq.a17Pack3')}</strong> ${t('faq.a17Pack3Desc')}</li>
                                    <li><strong>${t('faq.a17Pack4')}</strong> ${t('faq.a17Pack4Desc')}</li>
                                    <li><strong>${t('faq.a17Pack5')}</strong> ${t('faq.a17Pack5Desc')}</li>
                                    <li><strong>${t('faq.a17Pack6')}</strong> ${t('faq.a17Pack6Desc')}</li>
                                    <li><strong>${t('faq.a17Pack7')}</strong> ${t('faq.a17Pack7Desc')}</li>
                                    <li><strong>${t('faq.a17Pack8')}</strong> ${t('faq.a17Pack8Desc')}</li>
                                </ul>
                                ${t('faq.a17Note')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q18')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a18')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q19')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a19')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q20')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a20')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q21')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a21')}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>${t('faq.privacySecurity')}</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q22')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a22')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q23')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a23')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q24')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a24')}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>${t('faq.troubleshooting')}</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q25')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a25Intro')}
                                <ul>
                                    <li>${t('faq.a25Item1')}</li>
                                    <li>${t('faq.a25Item2')}</li>
                                    <li>${t('faq.a25Item3')}</li>
                                    <li>${t('faq.a25Item4')}</li>
                                    <li>${t('faq.a25Item5')}</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q26')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a26')}
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            ${t('faq.q27')}
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                ${t('faq.a27')}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function toggleFaqItem(button) {
    const faqItem = button.parentElement;
    const wasActive = faqItem.classList.contains('active');

    // Close all other FAQ items in the same accordion
    const accordion = faqItem.closest('.faq-accordion');
    accordion.querySelectorAll('.faq-item').forEach(item => {
        item.classList.remove('active');
    });

    // Toggle the clicked item
    if (!wasActive) {
        faqItem.classList.add('active');
    }
}

function loadDmcaPage() {
    currentView = 'dmca';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>${t('dmca.title')}</h1>
            <p class="last-updated">${t('dmca.lastUpdated')}</p>

            <section class="static-section">
                <h2>${t('dmca.architectureTitle')}</h2>
                <p>${t('dmca.architectureDesc')}</p>
                <ul>
                    <li><strong>${t('dmca.architectureItem1')}</strong> ${t('dmca.architectureItem1Desc')}</li>
                    <li>${t('dmca.architectureItem2')}</li>
                    <li>${t('dmca.architectureItem3')}</li>
                    <li>${t('dmca.architectureItem4')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('dmca.filingTitle')}</h2>
                <p>${t('dmca.filingDesc')}</p>

                <h3 style="margin-top: 1rem; margin-bottom: 0.5rem; color: var(--text-primary);">${t('dmca.forVideoTitle')}</h3>
                <p>${t('dmca.forVideoDesc')}</p>
                <ul>
                    <li>${t('dmca.forVideoItem1')}</li>
                    <li>${t('dmca.forVideoItem2')}</li>
                    <li>${t('dmca.forVideoItem3')}</li>
                </ul>

                <h3 style="margin-top: 1rem; margin-bottom: 0.5rem; color: var(--text-primary);">${t('dmca.forMetadataTitle')}</h3>
                <p>${t('dmca.forMetadataDesc')}</p>
                <ul>
                    <li>${t('dmca.forMetadataItem1')}</li>
                    <li>${t('dmca.forMetadataItem2')}</li>
                    <li>${t('dmca.forMetadataItem3')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('dmca.whatWeCanDoTitle')}</h2>
                <p>${t('dmca.whatWeCanDoDesc')}</p>
                <ul>
                    <li>${t('dmca.whatWeCanDoItem1')}</li>
                    <li>${t('dmca.whatWeCanDoItem2')}</li>
                    <li>${t('dmca.whatWeCanDoItem3')}</li>
                </ul>
                <p>${t('dmca.toRequestAssistance')}</p>
                <ul>
                    <li>${t('dmca.assistanceItem1')}</li>
                    <li>${t('dmca.assistanceItem2')}</li>
                    <li>${t('dmca.assistanceItem3')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('dmca.blossomOperatorsTitle')}</h2>
                <p>${t('dmca.blossomOperatorsDesc')}</p>
                <p><a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener" class="accent-link">${t('dmca.blossomOperatorsLink')}</a></p>
            </section>

            <section class="static-section">
                <h2>${t('dmca.considerationsTitle')}</h2>
                <ul>
                    <li><strong>${t('dmca.considerationsItem1')}</strong> ${t('dmca.considerationsItem1Desc')}</li>
                    <li><strong>${t('dmca.considerationsItem2')}</strong> ${t('dmca.considerationsItem2Desc')}</li>
                    <li><strong>${t('dmca.considerationsItem3')}</strong> ${t('dmca.considerationsItem3Desc')}</li>
                    <li><strong>${t('dmca.considerationsItem4')}</strong> ${t('dmca.considerationsItem4Desc')}</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>${t('dmca.counterNotificationTitle')}</h2>
                <p>${t('dmca.counterNotificationDesc')}</p>
            </section>

            <section class="static-section">
                <h2>${t('dmca.contactTitle')}</h2>
                <p>${t('dmca.contactDesc')} <a href="#/contact" class="accent-link">${t('dmca.contactLink')}</a></p>
            </section>
        </div>
    `;
}

// Admin page - only accessible by admin pubkey
async function loadAdminPage() {
    // Wait for login check to complete before verifying admin access
    // This fixes the issue where direct navigation to /admin fails on page load
    if (loginCheckPromise) {
        await loginCheckPromise;
    }

    if (!isAdmin()) {
        showToast(t('admin.accessDenied'), 'error');
        navigateTo('/');
        return;
    }

    currentView = 'admin';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="admin-page">
            <div class="admin-header">
                <h1>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
                    </svg>
                    Admin Dashboard
                </h1>
            </div>

            <div class="admin-loading">
                <div class="spinner"></div>
                <p>Loading platform analytics...</p>
            </div>
        </div>
    `;

    // Load platform analytics
    await loadAdminAnalytics();
}

async function loadAdminAnalytics() {
    const mainContent = document.getElementById('mainContent');

    try {
        // Fetch global platform stats
        const now = Math.floor(Date.now() / 1000);
        const thirtyDaysAgo = now - (30 * 24 * 60 * 60);
        const sevenDaysAgo = now - (7 * 24 * 60 * 60);

        // Fetch all videos from the platform (use ALL_VIDEO_KINDS for complete coverage)
        const videoFilter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            limit: 500
        };

        const allVideos = [];
        await requestEventsStream(
            videoFilter,
            event => allVideos.push(event),
            { timeout: 15000 }
        );

        // Get unique creators
        const uniqueCreators = new Set(allVideos.map(v => v.pubkey));

        // Get all video IDs for scoped queries
        const allVideoIds = allVideos.map(v => v.id);

        // Count videos by time period
        const videosLast30Days = allVideos.filter(v => v.created_at >= thirtyDaysAgo).length;
        const videosLast7Days = allVideos.filter(v => v.created_at >= sevenDaysAgo).length;

        // Fetch boost zaps to admin's pubkey (boosts pay to platform)
        const boostZapsFilter = {
            kinds: [9735],
            '#p': [ADMIN_PUBKEY],
            since: thirtyDaysAgo,
            limit: 500
        };

        let totalBoostSats = 0;
        let boostCount = 0;
        await requestEventsStream(
            boostZapsFilter,
            event => {
                // Check if it's a boost payment
                const descTag = event.tags.find(t => t[0] === 'description');
                if (descTag) {
                    try {
                        const zapRequest = JSON.parse(descTag[1]);
                        const purposeTag = zapRequest.tags?.find(t => t[0] === 'purpose');
                        if (purposeTag && purposeTag[1] === 'boost') {
                            boostCount++;
                            const bolt11Tag = event.tags.find(t => t[0] === 'bolt11');
                            if (bolt11Tag) {
                                const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                if (amount) totalBoostSats += amount;
                            }
                        }
                    } catch (e) { }
                }
            },
            { timeout: 10000 }
        );

        // Count reactions only on Plebs videos (batch by video IDs)
        let totalLikes = 0;
        let totalDislikes = 0;

        // Track monthly active users (unique users who interacted per month)
        const sixMonthsAgo = now - (180 * 24 * 60 * 60);
        const userActivityByMonth = new Map(); // month key -> Set of pubkeys

        // Initialize months
        for (let i = 5; i >= 0; i--) {
            const date = new Date();
            date.setMonth(date.getMonth() - i);
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            userActivityByMonth.set(monthKey, new Set());
        }

        // Helper to add user activity for a given timestamp
        const trackUserActivity = (pubkey, timestamp) => {
            const date = new Date(timestamp * 1000);
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            if (userActivityByMonth.has(monthKey)) {
                userActivityByMonth.get(monthKey).add(pubkey);
            }
        };

        // Track creators from videos
        allVideos.forEach(v => {
            if (v.created_at >= sixMonthsAgo) {
                trackUserActivity(v.pubkey, v.created_at);
            }
        });

        if (allVideoIds.length > 0) {
            // Batch video IDs to avoid oversized queries
            const batchSize = 100;
            for (let i = 0; i < allVideoIds.length; i += batchSize) {
                const batch = allVideoIds.slice(i, i + batchSize);
                const reactionFilter = {
                    kinds: [7],
                    '#e': batch,
                    since: sixMonthsAgo,
                    limit: 2000
                };

                await requestEventsStream(
                    reactionFilter,
                    event => {
                        // Track user activity
                        trackUserActivity(event.pubkey, event.created_at);
                        // Count only last 30 days for summary stats
                        if (event.created_at >= thirtyDaysAgo) {
                            if (event.content === '+' || event.content === '🤙') totalLikes++;
                            else if (event.content === '-') totalDislikes++;
                        }
                    },
                    { timeout: 15000 }
                );
            }

            // Also fetch comments for user tracking
            for (let i = 0; i < allVideoIds.length; i += batchSize) {
                const batch = allVideoIds.slice(i, i + batchSize);
                const commentFilter = {
                    kinds: [1],
                    '#e': batch,
                    since: sixMonthsAgo,
                    limit: 1000
                };

                await requestEventsStream(
                    commentFilter,
                    event => {
                        trackUserActivity(event.pubkey, event.created_at);
                    },
                    { timeout: 10000 }
                );
            }
        }

        // Convert to monthly active users data
        const monthlyActiveUsers = Array.from(userActivityByMonth.entries()).map(([month, users]) => ({
            month,
            users: users.size
        }));

        // Render admin dashboard
        renderAdminDashboard({
            totalVideos: allVideos.length,
            videosLast30Days,
            videosLast7Days,
            uniqueCreators: uniqueCreators.size,
            totalBoostSats,
            boostCount,
            totalLikes,
            totalDislikes,
            blockedEvents: adminBlocklist.events.size,
            blockedPubkeys: adminBlocklist.pubkeys.size,
            monthlyActiveUsers
        });

    } catch (error) {
        console.error('Failed to load admin analytics:', error);
        mainContent.innerHTML = `
            <div class="admin-page">
                <div class="admin-header">
                    <h1>Admin Dashboard</h1>
                </div>
                <div class="admin-error">
                    <p>Failed to load analytics. Please try again.</p>
                    <button class="action-btn" onclick="loadAdminPage()">Retry</button>
                </div>
            </div>
        `;
    }
}

// Generate Monthly Active Users chart SVG for admin dashboard
function generateMAUChartSVG(monthlyActiveUsers) {
    if (!monthlyActiveUsers || monthlyActiveUsers.length === 0) {
        return '<p style="color: var(--text-secondary); text-align: center;">No data available</p>';
    }

    const values = monthlyActiveUsers.map(d => d.users);
    const maxValue = Math.max(...values, 1);

    const width = 600;
    const height = 200;
    const padding = { top: 20, right: 20, bottom: 50, left: 50 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;

    // Generate bars
    const barWidth = (chartWidth / monthlyActiveUsers.length) - 8;
    const bars = monthlyActiveUsers.map((d, i) => {
        const x = padding.left + (i / monthlyActiveUsers.length) * chartWidth + 4;
        const barHeight = (d.users / maxValue) * chartHeight;
        const y = padding.top + chartHeight - barHeight;

        // Parse month for label
        const [year, month] = d.month.split('-');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const monthLabel = monthNames[parseInt(month) - 1];

        return `
            <g class="mau-bar-group">
                <rect class="mau-bar" x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="var(--accent)" rx="4" data-value="${d.users}" data-month="${monthLabel} ${year}" />
                <text class="mau-bar-value" x="${x + barWidth / 2}" y="${y - 8}" text-anchor="middle" fill="var(--text-primary)" font-size="12">${d.users > 0 ? formatNumber(d.users) : ''}</text>
            </g>
        `;
    }).join('');

    // X-axis labels (months)
    const xLabels = monthlyActiveUsers.map((d, i) => {
        const x = padding.left + (i / monthlyActiveUsers.length) * chartWidth + barWidth / 2 + 4;
        const [year, month] = d.month.split('-');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `<text class="chart-label x-label" x="${x}" y="${height - 15}" text-anchor="middle" fill="var(--text-secondary)" font-size="11">${monthNames[parseInt(month) - 1]}</text>`;
    }).join('');

    // Y-axis labels
    const yLabels = [];
    const ySteps = 4;
    for (let i = 0; i <= ySteps; i++) {
        const value = Math.round((maxValue / ySteps) * (ySteps - i));
        const y = padding.top + (i / ySteps) * chartHeight;
        yLabels.push(`<text class="chart-label y-label" x="${padding.left - 10}" y="${y + 4}" text-anchor="end" fill="var(--text-secondary)" font-size="11">${formatNumber(value)}</text>`);
    }

    // Grid lines
    const gridLines = [];
    for (let i = 0; i <= ySteps; i++) {
        const y = padding.top + (i / ySteps) * chartHeight;
        gridLines.push(`<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="var(--border-color)" stroke-opacity="0.3" />`);
    }

    return `
        <svg class="mau-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
            <!-- Grid lines -->
            ${gridLines.join('')}

            <!-- Bars -->
            ${bars}

            <!-- Y-axis labels -->
            ${yLabels.join('')}

            <!-- X-axis labels -->
            ${xLabels}
        </svg>
    `;
}

function renderAdminDashboard(stats) {
    const mainContent = document.getElementById('mainContent');

    // Generate MAU chart
    const mauChartHTML = generateMAUChartSVG(stats.monthlyActiveUsers);

    mainContent.innerHTML = `
        <div class="admin-page">
            <div class="admin-header">
                <h1>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
                    </svg>
                    Admin Dashboard
                </h1>
            </div>

            <!-- Platform Overview -->
            <section class="admin-section">
                <h2>Platform Overview</h2>
                <div class="admin-stats-grid">
                    <div class="admin-stat-card">
                        <div class="stat-icon videos">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M18 4l2 4h-3l-2-4h-2l2 4h-3l-2-4H8l2 4H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.totalVideos)}</div>
                            <div class="stat-label">Total Videos</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon new">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.videosLast7Days)}</div>
                            <div class="stat-label">Videos (7 days)</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon month">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11zM9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.videosLast30Days)}</div>
                            <div class="stat-label">Videos (30 days)</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon creators">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.uniqueCreators)}</div>
                            <div class="stat-label">Unique Creators</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon likes">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.totalLikes)}</div>
                            <div class="stat-label">Likes (30 days)</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon dislikes">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.totalDislikes)}</div>
                            <div class="stat-label">Dislikes (30 days)</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Monthly Active Users Chart -->
            <section class="admin-section">
                <h2>Monthly Active Users</h2>
                <p class="admin-section-desc">Unique users who uploaded videos, reacted, or commented each month (last 6 months)</p>
                <div class="mau-chart-container">
                    ${mauChartHTML}
                </div>
            </section>

            <!-- Boost Revenue -->
            <section class="admin-section">
                <h2>Boost Revenue (Last 30 Days)</h2>
                <div class="admin-stats-grid boost-revenue">
                    <div class="admin-stat-card highlight">
                        <div class="stat-icon boosts">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatSats(stats.totalBoostSats)} sats</div>
                            <div class="stat-label">Total Boost Revenue</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon count">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.boostCount)}</div>
                            <div class="stat-label">Total Boosts</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Blocklist Management -->
            <section class="admin-section">
                <h2>Blocklist Management</h2>
                <p class="admin-section-desc">Block specific videos or users from appearing on the platform. Use this for DMCA compliance or removing illegal content.</p>

                <div class="blocklist-summary">
                    <div class="blocklist-stat">
                        <span class="blocklist-count">${stats.blockedEvents}</span>
                        <span class="blocklist-label">Blocked Videos</span>
                    </div>
                    <div class="blocklist-stat">
                        <span class="blocklist-count">${stats.blockedPubkeys}</span>
                        <span class="blocklist-label">Blocked Users</span>
                    </div>
                </div>

                <!-- Block Event ID -->
                <div class="blocklist-section">
                    <h3>Block Video by Event ID</h3>
                    <div class="blocklist-input-group">
                        <input type="text" id="blockEventInput" placeholder="${t('placeholder.eventId')}" class="blocklist-input">
                        <button class="action-btn danger" onclick="addBlockedEvent()">Block Video</button>
                    </div>
                </div>

                <!-- Block Pubkey -->
                <div class="blocklist-section">
                    <h3>Block User by Pubkey</h3>
                    <div class="blocklist-input-group">
                        <input type="text" id="blockPubkeyInput" placeholder="${t('placeholder.pubkey')}" class="blocklist-input">
                        <button class="action-btn danger" onclick="addBlockedPubkey()">Block User</button>
                    </div>
                </div>

                <!-- Current Blocked Events -->
                <div class="blocklist-section">
                    <h3>Blocked Videos (${stats.blockedEvents})</h3>
                    <div class="blocklist-items" id="blockedEventsList">
                        ${Array.from(adminBlocklist.events).map(eventId => `
                            <div class="blocklist-item">
                                <code>${eventId.slice(0, 16)}...${eventId.slice(-8)}</code>
                                <button class="remove-btn" onclick="removeBlockedEvent('${eventId}')" title="Unblock">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                                    </svg>
                                </button>
                            </div>
                        `).join('') || '<p class="empty-list">No blocked videos</p>'}
                    </div>
                </div>

                <!-- Current Blocked Pubkeys -->
                <div class="blocklist-section">
                    <h3>Blocked Users (${stats.blockedPubkeys})</h3>
                    <div class="blocklist-items" id="blockedPubkeysList">
                        ${Array.from(adminBlocklist.pubkeys).map(pubkey => `
                            <div class="blocklist-item">
                                <code>${pubkey.slice(0, 16)}...${pubkey.slice(-8)}</code>
                                <button class="remove-btn" onclick="removeBlockedPubkey('${pubkey}')" title="Unblock">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                                    </svg>
                                </button>
                            </div>
                        `).join('') || '<p class="empty-list">No blocked users</p>'}
                    </div>
                </div>
            </section>
        </div>
    `;
}

// Blocklist management functions
async function addBlockedEvent() {
    if (!isAdmin()) return;

    const input = document.getElementById('blockEventInput');
    let eventId = input.value.trim();

    if (!eventId) {
        showToast('Please enter an event ID', 'warning');
        return;
    }

    // Try to decode if it's nevent or note format
    if (eventId.startsWith('nevent1') || eventId.startsWith('note1')) {
        try {
            const decoded = window.NostrTools.nip19.decode(eventId);
            eventId = decoded.type === 'nevent' ? decoded.data.id : decoded.data;
        } catch (e) {
            showToast('Invalid event ID format', 'error');
            return;
        }
    }

    // Validate hex format
    if (!/^[a-f0-9]{64}$/i.test(eventId)) {
        showToast('Invalid event ID (must be 64 hex characters)', 'error');
        return;
    }

    eventId = eventId.toLowerCase();

    if (adminBlocklist.events.has(eventId)) {
        showToast('Event already blocked', 'warning');
        return;
    }

    adminBlocklist.events.add(eventId);

    // Publish to Nostr
    showToast('Publishing blocklist to Nostr...', 'info');
    const success = await publishAdminBlocklist();

    if (success) {
        input.value = '';
        showToast('Video blocked and published to Nostr', 'success');
        loadAdminPage();
    } else {
        // Revert on failure
        adminBlocklist.events.delete(eventId);
        showToast('Failed to publish blocklist', 'error');
    }
}

async function removeBlockedEvent(eventId) {
    if (!isAdmin()) return;

    adminBlocklist.events.delete(eventId);

    // Publish to Nostr
    showToast('Publishing blocklist to Nostr...', 'info');
    const success = await publishAdminBlocklist();

    if (success) {
        showToast('Video unblocked and published to Nostr', 'success');
        loadAdminPage();
    } else {
        // Revert on failure
        adminBlocklist.events.add(eventId);
        showToast('Failed to publish blocklist', 'error');
    }
}

async function addBlockedPubkey() {
    if (!isAdmin()) return;

    const input = document.getElementById('blockPubkeyInput');
    let pubkey = input.value.trim();

    if (!pubkey) {
        showToast('Please enter a pubkey', 'warning');
        return;
    }

    // Try to decode if it's npub format
    if (pubkey.startsWith('npub1')) {
        try {
            const decoded = window.NostrTools.nip19.decode(pubkey);
            pubkey = decoded.data;
        } catch (e) {
            showToast('Invalid npub format', 'error');
            return;
        }
    }

    // Validate hex format
    if (!/^[a-f0-9]{64}$/i.test(pubkey)) {
        showToast('Invalid pubkey (must be 64 hex characters)', 'error');
        return;
    }

    pubkey = pubkey.toLowerCase();

    // Don't allow blocking yourself
    if (pubkey === ADMIN_PUBKEY) {
        showToast('Cannot block the admin account', 'error');
        return;
    }

    if (adminBlocklist.pubkeys.has(pubkey)) {
        showToast('User already blocked', 'warning');
        return;
    }

    adminBlocklist.pubkeys.add(pubkey);

    // Publish to Nostr
    showToast('Publishing blocklist to Nostr...', 'info');
    const success = await publishAdminBlocklist();

    if (success) {
        input.value = '';
        showToast('User blocked and published to Nostr', 'success');
        loadAdminPage();
    } else {
        // Revert on failure
        adminBlocklist.pubkeys.delete(pubkey);
        showToast('Failed to publish blocklist', 'error');
    }
}

async function removeBlockedPubkey(pubkey) {
    if (!isAdmin()) return;

    adminBlocklist.pubkeys.delete(pubkey);

    // Publish to Nostr
    showToast('Publishing blocklist to Nostr...', 'info');
    const success = await publishAdminBlocklist();

    if (success) {
        showToast('User unblocked and published to Nostr', 'success');
        loadAdminPage();
    } else {
        // Revert on failure
        adminBlocklist.pubkeys.add(pubkey);
        showToast('Failed to publish blocklist', 'error');
    }
}

// Function to handle boost button click
async function handleBoost(eventId) {
    if (!await ensureLoggedIn()) {
        return;
    }

    // Check if user is blocked
    if (isPubkeyBlocked(currentUser.pubkey)) {
        showToast('Your account has been restricted', 'error');
        return;
    }

    // Fixed 100 sats for boost
    showBoostAmountModal(eventId);
}

// Show boost amount selection modal (100 sats fixed)
function showBoostAmountModal(eventId) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        padding: 1rem;
    `;

    modal.innerHTML = `
    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center;">
        <h2 style="margin-bottom: 1.5rem; background: linear-gradient(135deg, #f7931a, #ff9500); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Boost This Video</h2>
        <p style="font-size: 1.2rem; margin-bottom: 1.5rem;">Use Bitcoin Lightning + Nostr Zap to Boost for <strong>100 sats</strong> to help this video trend!</p>
        <p style="font-size: 1.2rem; margin-bottom: 1.5rem;">Videos that are boosted will also be highlighted throughout the app and their highlight will grow brighter the more they're boosted.</p>
        
        <div style="display: flex; gap: 0.5rem; justify-content: center;">
            <button onclick="processBoost('${eventId}', 100); this.closest('div[style*=fixed]').remove();"
                    style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #f7931a, #ff9500);
                           color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;
                           display: flex; align-items: center; gap: 0.5rem;">
                Boost for 100 sats <svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg>
            </button>
            <button onclick="this.closest('div[style*=fixed]').remove();"
                    style="padding: 0.5rem 1.5rem; background: var(--bg-primary); color: var(--text-primary);
                           border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                Cancel
            </button>
        </div>
    </div>
`;

    document.body.appendChild(modal);
}

// Process the boost
async function processBoost(eventId, amount) {
    try {
        // Show generating invoice modal immediately
        showGeneratingInvoiceModal(amount, 'boost');

        // Create boost zap request
        const boostZapRequest = {
            kind: 9734,
            created_at: Math.floor(Date.now() / 1000),
            tags: [
                ['p', 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df'],
                ['amount', amount.toString()],
                ['relays', ...RELAY_URLS],
                ['e', eventId],
                ['purpose', 'boost']
            ],
            content: ''
        };

        // For live streams, also add the #a tag for persistence across stream updates
        const targetEvent = allEvents.get(eventId);
        if (targetEvent && targetEvent.kind === NIP53_LIVE_EVENT_KIND) {
            const liveData = parseLiveEvent(targetEvent);
            if (liveData) {
                const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${targetEvent.pubkey}:${liveData.dTag}`;
                boostZapRequest.tags.push(['a', aTagValue]);
            }
        }

        const signedZapRequest = await signEvent(boostZapRequest);

        // Fetch invoice from walletofsatoshi
        const lnurlResponse = await fetchBoostInvoice(amount, JSON.stringify(signedZapRequest));

        if (lnurlResponse.pr) {
            showBoostInvoice(lnurlResponse.pr, amount, eventId);

            // Poll for zap receipt
            pollForBoostReceipt(eventId, amount);

            if (window.webln) {
                try {
                    await window.webln.enable();
                    const result = await window.webln.sendPayment(lnurlResponse.pr);
                    if (result.preimage) {
                        // Payment successful through WebLN
                    }
                } catch (e) {
                    console.log('WebLN payment failed, waiting for manual payment');
                }
            }
        }
    } catch (error) {
        console.error('Failed to create boost:', error);
        // Remove generating invoice modal on error
        const generatingModal = document.getElementById('generating-invoice-modal');
        if (generatingModal) generatingModal.remove();
        showToast('Failed to create boost. Please try again.', 'error');
    }
}

// Fetch boost invoice from walletofsatoshi
async function fetchBoostInvoice(amount, zapRequest) {
    const url = `https://wallet.yakihonne.com/.well-known/lnurlp/69420`;

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.callback) {
            const invoiceUrl = new URL(data.callback);
            invoiceUrl.searchParams.set('amount', amount * 1000); // millisats
            invoiceUrl.searchParams.set('nostr', zapRequest);

            const invoiceResponse = await fetch(invoiceUrl.toString());
            return await invoiceResponse.json();
        }
    } catch (error) {
        console.error('Failed to fetch boost invoice:', error);
        throw error;
    }
}

// Show boost invoice modal
function showBoostInvoice(invoice, amount, eventId) {
    // Remove generating invoice modal
    const generatingModal = document.getElementById('generating-invoice-modal');
    if (generatingModal) generatingModal.remove();

    const modal = document.createElement('div');
    modal.id = 'boost-invoice-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        padding: 1rem;
    `;

    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center;">
            <h2 style="margin-bottom: 0.5rem; background: linear-gradient(135deg, #f7931a, #ff9500); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Lightning Invoice</h2>
            <p style="margin-bottom: 1rem; color: var(--text-secondary);">Boost ${amount} sats</p>
            <p style="margin-bottom: 1rem;">Scan with your Lightning wallet:</p>
            
            <div style="background: white; padding: 1rem; border-radius: 8px; margin: 1rem auto; display: inline-block;">
                <div id="boost-qrcode"></div>
            </div>
            
            <div style="margin: 1rem 0; color: var(--text-secondary); font-size: 0.875rem;">
                <div id="boost-payment-status">
                    <div class="spinner" style="width: 20px; height: 20px; margin: 0 auto 0.5rem;"></div>
                    Waiting for payment confirmation...
                </div>
            </div>
            
            <textarea readonly style="width: 100%; padding: 0.5rem; margin: 1rem 0; font-size: 0.75rem; word-break: break-all; 
                                     height: 100px; resize: none; background: var(--bg-primary); color: var(--text-primary); 
                                     border: 1px solid var(--border); border-radius: 4px;">${invoice}</textarea>
            
            <div style="display: flex; gap: 0.5rem; justify-content: center;">
                <button onclick="navigator.clipboard.writeText('${invoice}').then(() => {
                    const btn = event.target;
                    const originalText = btn.textContent;
                    btn.textContent = t('button.copied');
                    btn.style.background = 'linear-gradient(135deg, #f7931a, #ff9500)';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 2000);
                });" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #f7931a, #ff9500); color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Copy Invoice
                </button>
                <button onclick="document.getElementById('boost-invoice-modal').remove();" 
                        style="padding: 0.5rem 1rem; background: var(--bg-primary); color: var(--text-primary); 
                               border: 1px solid var(--border); border-radius: 4px; cursor: pointer;">
                    Close
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // Generate QR code
    if (window.QRCode) {
        new QRCode(document.getElementById("boost-qrcode"), {
            text: invoice.toUpperCase(),
            width: 256,
            height: 256,
            colorDark: "#000000",
            colorLight: "#FFFFFF",
            correctLevel: QRCode.CorrectLevel.L
        });
    }
}

// Poll for boost zap receipt
async function pollForBoostReceipt(eventId, amount) {
    const startTime = Date.now();
    const timeout = 60000; // 60 seconds
    const pollInterval = 2000; // 2 seconds

    // Check if this is a live stream to use #a tag for persistence
    const targetEvent = allEvents.get(eventId);
    let aTagValue = null;
    if (targetEvent && targetEvent.kind === NIP53_LIVE_EVENT_KIND) {
        const liveData = parseLiveEvent(targetEvent);
        if (liveData) {
            aTagValue = `${NIP53_LIVE_EVENT_KIND}:${targetEvent.pubkey}:${liveData.dTag}`;
        }
    }

    const checkForReceipt = async () => {
        if (Date.now() - startTime > timeout) {
            console.log('Boost receipt polling timeout');
            return;
        }

        // Use #a tag for live streams, #e tag for regular videos
        const filter = {
            kinds: [9735],
            since: Math.floor(startTime / 1000) - 10
        };
        if (aTagValue) {
            filter['#a'] = [aTagValue];
        } else {
            filter['#e'] = [eventId];
        }

        let foundReceipt = false;

        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                try {
                    // Check if this is a boost zap to walletofsatoshi
                    const pTag = event.tags.find(tag => tag[0] === 'p');
                    if (pTag && pTag[1] === 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df') {
                        const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                        if (bolt11Tag && bolt11Tag[1]) {
                            const receiptAmount = extractAmountFromBolt11(bolt11Tag[1]);

                            if (Math.abs(receiptAmount - amount) < 10) {
                                foundReceipt = true;

                                // Close invoice modal
                                const invoiceModal = document.getElementById('boost-invoice-modal');
                                if (invoiceModal) {
                                    invoiceModal.remove();
                                }

                                // Show success animation
                                showBoostSuccess(amount);

                                // Update boost cache
                                const currentBoosts = boostsCache.get(eventId) || 0;
                                const newBoostTotal = currentBoosts + amount;
                                boostsCache.set(eventId, newBoostTotal);

                                // Update boost button
                                updateBoostButton(eventId, newBoostTotal);

                                // Update video/live stream cards with new boost level and indicator
                                const newBoostLevel = getBoostLevel(newBoostTotal);
                                if (newBoostLevel > 0) {
                                    const boostIndicatorHTML = `
                                        <div class="boost-indicator">
                                            <svg viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                                            </svg>
                                            ${formatSats(newBoostTotal)}
                                        </div>
                                    `;

                                    // Update cards by data-live-event-id (live stream cards)
                                    document.querySelectorAll(`.video-card[data-live-event-id="${eventId}"]`).forEach(card => {
                                        card.classList.add('boosted', `boost-level-${newBoostLevel}`);
                                        for (let i = 1; i <= 4; i++) {
                                            if (i !== newBoostLevel) card.classList.remove(`boost-level-${i}`);
                                        }
                                        // Add or update boost indicator
                                        const thumbnail = card.querySelector('.video-thumbnail');
                                        let indicator = thumbnail?.querySelector('.boost-indicator');
                                        if (indicator) {
                                            indicator.remove();
                                        }
                                        if (thumbnail) {
                                            thumbnail.insertAdjacentHTML('beforeend', boostIndicatorHTML);
                                        }
                                    });
                                    // Update cards by data-event-id (regular video cards)
                                    document.querySelectorAll(`.video-card[data-event-id="${eventId}"]`).forEach(card => {
                                        card.classList.add('boosted', `boost-level-${newBoostLevel}`);
                                        for (let i = 1; i <= 4; i++) {
                                            if (i !== newBoostLevel) card.classList.remove(`boost-level-${i}`);
                                        }
                                        // Add or update boost indicator
                                        const thumbnail = card.querySelector('.video-thumbnail');
                                        let indicator = thumbnail?.querySelector('.boost-indicator');
                                        if (indicator) {
                                            indicator.remove();
                                        }
                                        if (thumbnail) {
                                            thumbnail.insertAdjacentHTML('beforeend', boostIndicatorHTML);
                                        }
                                    });
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error checking boost receipt:', e);
                }
            }, () => {
                resolve();
            });
        });

        if (!foundReceipt) {
            setTimeout(checkForReceipt, pollInterval);
        }
    };

    setTimeout(checkForReceipt, 2000);
}

// Show boost success animation
function showBoostSuccess(amount) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
    `;

    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 3rem; border-radius: 12px; text-align: center;">
            <div class="boost-success-animation">
                <svg width="120" height="120" viewBox="0 0 24 24" fill="url(#boostGradient)" style="margin-bottom: 1rem;">
                    <defs>
                        <linearGradient id="boostGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#f7931a;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff9500;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                </svg>
                <h2 style="background: linear-gradient(135deg, #f7931a, #ff9500); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 0.5rem;">Video Boosted!</h2>
                <p style="font-size: 1.5rem; font-weight: bold;">${amount} sats</p>
            </div>
        </div>
    `;

    const style = document.createElement('style');
    style.textContent = `
        .boost-success-animation {
            animation: boostPulse 0.5s ease-out;
        }
        
        @keyframes boostPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
    `;
    document.head.appendChild(style);

    document.body.appendChild(modal);

    setTimeout(() => {
        modal.style.opacity = '0';
        modal.style.transition = 'opacity 0.3s ease-out';
        setTimeout(() => {
            modal.remove();
            style.remove();
        }, 300);
    }, 2000);
}

// Update boost button UI
function updateBoostButton(eventId, totalBoosts) {
    const boostBtn = document.querySelector(`.action-btn.boost[data-event-id="${eventId}"]`);
    if (boostBtn) {
        boostBtn.querySelector('.count').textContent = totalBoosts > 0 ? formatSats(totalBoosts) : 'Boost';
        if (totalBoosts > 0) {
            boostBtn.classList.add('active');
        }
    }
}

// Update boost indicators on all video cards matching an event ID
function updateBoostIndicatorsOnCards(eventId, totalBoosts) {
    const boostLevel = getBoostLevel(totalBoosts);
    const isBoosted = boostLevel > 0;

    if (!isBoosted) return;

    const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;

    // Find cards by ID (regular video cards)
    const cardById = document.getElementById(`video-card-${eventId}`);
    if (cardById) {
        updateCardBoostClasses(cardById, boostLevel, indicatorHTML);
    }

    // Find cards by data-event-id (sidebar cards, etc.)
    document.querySelectorAll(`.video-card[data-event-id="${eventId}"]`).forEach(card => {
        updateCardBoostClasses(card, boostLevel, indicatorHTML);
    });

    // Find cards by data-live-event-id (live stream cards)
    document.querySelectorAll(`.video-card[data-live-event-id="${eventId}"]`).forEach(card => {
        updateCardBoostClasses(card, boostLevel, indicatorHTML);
    });
}

// Helper to update boost classes and indicator on a single card
function updateCardBoostClasses(card, boostLevel, indicatorHTML) {
    card.classList.add('boosted', `boost-level-${boostLevel}`);
    for (let i = 1; i <= 4; i++) {
        if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
    }
    const thumbnail = card.querySelector('.video-thumbnail');
    if (thumbnail) {
        const existingIndicator = thumbnail.querySelector('.boost-indicator');
        if (existingIndicator) {
            existingIndicator.outerHTML = indicatorHTML;
        } else {
            thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
        }
    }
}

// Load boosts for video
async function loadBoostsForVideo(eventId, onUpdate = null) {
    // Check if this is a live stream to use #a tag for persistence
    const targetEvent = allEvents.get(eventId);
    let filter;

    if (targetEvent && targetEvent.kind === NIP53_LIVE_EVENT_KIND) {
        const liveData = parseLiveEvent(targetEvent);
        if (liveData) {
            const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${targetEvent.pubkey}:${liveData.dTag}`;
            filter = {
                kinds: [9735],
                '#a': [aTagValue],
                '#p': ['d49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df']
            };
        }
    }

    // Fallback to #e tag for regular videos or if live data not available
    if (!filter) {
        filter = {
            kinds: [9735],
            '#e': [eventId],
            '#p': ['d49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df']
        };
    }

    let totalBoosts = 0;

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            try {
                // Check if this has the purpose=boost tag
                const description = event.tags.find(tag => tag[0] === 'description')?.[1];
                if (description) {
                    try {
                        const zapRequest = JSON.parse(description);
                        const hasBoostTag = zapRequest.tags?.some(tag =>
                            tag[0] === 'purpose' && tag[1] === 'boost'
                        );

                        if (hasBoostTag) {
                            const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                            if (bolt11Tag && bolt11Tag[1]) {
                                const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                if (amount > 0) {
                                    totalBoosts += amount;

                                    if (onUpdate) {
                                        onUpdate(totalBoosts);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        // If we can't parse description, skip this event
                    }
                }
            } catch (e) {
                console.error('Failed to parse boost:', e);
            }
        }, () => {
            boostsCache.set(eventId, totalBoosts);
            // Automatically update all cards with this event ID
            if (totalBoosts > 0) {
                updateBoostIndicatorsOnCards(eventId, totalBoosts);
            }
            resolve(totalBoosts);
        });
    });
}

// Load boosts for multiple videos (tracks per-video, not merged)
async function loadBoostsForVideos(eventIds, onUpdate = null) {
    if (!eventIds || eventIds.length === 0) {
        if (onUpdate) onUpdate(0);
        return 0;
    }

    const filter = {
        kinds: [9735],
        '#e': eventIds,
        '#p': ['d49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df']
    };

    const boostsByEvent = new Map(); // Track boosts per event ID
    const seenBoostIds = new Set(); // Prevent double-counting

    // Initialize all event IDs with 0
    eventIds.forEach(id => boostsByEvent.set(id, 0));

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            // Skip if we've already counted this boost
            if (seenBoostIds.has(event.id)) return;
            seenBoostIds.add(event.id);

            try {
                // Check if this has the purpose=boost tag
                const description = event.tags.find(tag => tag[0] === 'description')?.[1];
                if (description) {
                    try {
                        const zapRequest = JSON.parse(description);
                        const hasBoostTag = zapRequest.tags?.some(tag =>
                            tag[0] === 'purpose' && tag[1] === 'boost'
                        );

                        if (hasBoostTag) {
                            const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                            if (bolt11Tag && bolt11Tag[1]) {
                                const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                if (amount > 0) {
                                    // Find which event ID this boost belongs to
                                    const eTag = event.tags.find(tag => tag[0] === 'e' && eventIds.includes(tag[1]));
                                    if (eTag) {
                                        const targetEventId = eTag[1];
                                        const current = boostsByEvent.get(targetEventId) || 0;
                                        boostsByEvent.set(targetEventId, current + amount);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        // If we can't parse description, skip this event
                    }
                }
            } catch (e) {
                console.error('Failed to parse boost:', e);
            }
        }, () => {
            // Cache and update each event ID separately
            let totalBoosts = 0;
            boostsByEvent.forEach((amount, eventId) => {
                boostsCache.set(eventId, amount);
                totalBoosts += amount;
                if (amount > 0) {
                    updateBoostIndicatorsOnCards(eventId, amount);
                }
            });

            if (onUpdate) onUpdate(totalBoosts);
            resolve(totalBoosts);
        });
    });
}

// Calculate boost level for video card highlighting
function getBoostLevel(boostAmount) {
    if (boostAmount >= 10000) return 4;
    if (boostAmount >= 5000) return 3;
    if (boostAmount >= 1000) return 2;
    if (boostAmount >= 100) return 1;
    return 0;
}

// Function to handle zaps
async function handleZap(npub, amount, eventId = null) {
    if (!await ensureLoggedIn()) {
        return;
    }

    // Prevent self-zapping (to avoid gaming trending algorithm)
    try {
        const decoded = window.NostrTools.nip19.decode(npub);
        if (decoded.type === 'npub' && decoded.data === currentUser?.pubkey) {
            return; // Silently ignore self-zap attempts
        }
    } catch (e) {
        // If decoding fails, continue with the zap
    }

    showZapAmountModal(npub, eventId);
}

// Show zap amount selection modal
function showZapAmountModal(npub, eventId = null) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        padding: 1rem;
    `;

    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center;">
            <h2 style="margin-bottom: 1.5rem;">Select Zap Amount</h2>
            <p style="font-size: 1.2rem; margin-bottom: 1.5rem;">Use Bitcoin Lightning + Nostr Zap to send sats directly to the content creator!</p>
            
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-bottom: 1.5rem;">
                <button class="zap-amount-btn" data-amount="21">21 <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="69">69 <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="420">420 <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="1337">1337 <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="5000">5k <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="10000">10k <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="21000">21k <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="1000000">1M <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
            </div>
            
            <div style="margin-bottom: 1.5rem;">
                <input type="number" id="customZapAmount" placeholder="${t('placeholder.customAmount')}" min="1" 
                       style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border); 
                              border-radius: 8px; color: var(--text-primary); font-size: 1rem; text-align: center;">
            </div>
            
            <div style="display: flex; gap: 0.5rem; justify-content: center;">
                <button id="proceedZap" style="padding: 0.75rem 1.5rem; background: #f7931a; color: white; 
                                               border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
                    Continue with Custom Amount
                </button>
                <button onclick="this.closest('div[style*=fixed]').remove();" 
                        style="padding: 0.75rem 1.5rem; background: var(--bg-primary); color: var(--text-primary); 
                               border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                    Cancel
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    const style = document.createElement('style');
    style.textContent = `
        .zap-amount-btn {
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        .zap-amount-btn svg {
            flex-shrink: 0;
        }
        .zap-amount-btn:hover {
            background: #f7931a;
            color: white;
            transform: translateY(-2px);
        }
        .zap-amount-btn:hover svg {
            fill: white;
        }
    `;
    modal.appendChild(style);

    modal.querySelectorAll('.zap-amount-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
            const amount = parseInt(btn.getAttribute('data-amount'));
            modal.remove();
            await processZap(npub, amount, eventId);
        });
    });

    const customInput = modal.querySelector('#customZapAmount');
    const proceedBtn = modal.querySelector('#proceedZap');

    customInput.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        if (value > 0) {
            proceedBtn.textContent = `Zap ${value} sats`;
        } else {
            proceedBtn.textContent = t('button.continueCustomAmount');
        }
    });

    proceedBtn.addEventListener('click', async () => {
        const amount = parseInt(customInput.value);
        if (amount > 0) {
            modal.remove();
            await processZap(npub, amount, eventId);
        } else {
            showToast('Please enter a valid amount', 'warning');
        }
    });
}

// Process the actual zap
async function processZap(npub, amount, eventId = null) {
    // Show generating invoice modal immediately
    showGeneratingInvoiceModal(amount);

    try {
        const zapRequest = {
            kind: 9734,
            created_at: Math.floor(Date.now() / 1000),
            tags: [
                ['p', window.NostrTools.nip19.decode(npub).data],
                ['amount', amount.toString()],
                ['relays', ...RELAY_URLS]
            ],
            content: ''
        };

        if (eventId) {
            zapRequest.tags.push(['e', eventId]);

            // For live streams, also add the #a tag for persistence across stream updates
            const targetEvent = allEvents.get(eventId);
            if (targetEvent && targetEvent.kind === NIP53_LIVE_EVENT_KIND) {
                const liveData = parseLiveEvent(targetEvent);
                if (liveData) {
                    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${targetEvent.pubkey}:${liveData.dTag}`;
                    zapRequest.tags.push(['a', aTagValue]);
                }
            }
        }

        const signedZapRequest = await signEvent(zapRequest);

        const lnurlResponse = await fetchLightningInvoice(npub, amount, JSON.stringify(signedZapRequest));

        // Remove generating modal
        const generatingModal = document.getElementById('generating-invoice-modal');
        if (generatingModal) generatingModal.remove();

        if (lnurlResponse.pr) {
            showLightningInvoice(lnurlResponse.pr, amount, !!window.webln);

            const paymentHash = extractPaymentHash(lnurlResponse.pr);
            pollForZapReceipt(window.NostrTools.nip19.decode(npub).data, amount, eventId, paymentHash);

            if (window.webln) {
                try {
                    await window.webln.enable();
                    const result = await window.webln.sendPayment(lnurlResponse.pr);
                    if (result.preimage) {
                        // Payment successful through WebLN
                    }
                } catch (e) {
                    console.log('WebLN payment failed, waiting for manual payment');
                }
            }
        } else {
            showToast('Failed to generate invoice. User may not have Lightning enabled.', 'error');
        }
    } catch (error) {
        // Remove generating modal on error
        const generatingModal = document.getElementById('generating-invoice-modal');
        if (generatingModal) generatingModal.remove();

        console.error('Failed to create zap:', error);
        showToast('Failed to create zap. Please try again.', 'error');
    }
}

// Show modal while generating invoice
function showGeneratingInvoiceModal(amount, type = 'zap') {
    const modal = document.createElement('div');
    modal.id = 'generating-invoice-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        padding: 1rem;
    `;

    const typeLabel = type === 'boost' ? 'boost' : 'zap';
    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 12px; max-width: 400px; width: 90%; text-align: center;">
            <div class="spinner" style="width: 48px; height: 48px; margin: 0 auto 1.5rem;"></div>
            <h2 style="margin-bottom: 0.5rem;">Generating Invoice</h2>
            <p style="color: var(--text-secondary);">Preparing ${formatNumber(amount)} sat ${typeLabel}...</p>
        </div>
    `;

    document.body.appendChild(modal);
}

// Track processed zap receipts to avoid duplicate handling
const processedZapReceipts = new Set();

// Function to poll for zap receipts
async function pollForZapReceipt(recipientPubkey, amount, eventId, paymentHash) {
    const startTime = Date.now();
    const timeout = 60000; // 60 seconds
    const pollInterval = 2000; // 2 seconds

    const checkForReceipt = async () => {
        if (Date.now() - startTime > timeout) {
            console.log('Zap receipt polling timeout');
            return;
        }

        const filter = {
            kinds: [9735],
            '#p': [recipientPubkey],
            since: Math.floor(startTime / 1000) - 10
        };

        if (eventId) {
            filter['#e'] = [eventId];
        }

        let foundReceipt = false;

        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                try {
                    // Skip if we've already processed this receipt
                    if (processedZapReceipts.has(event.id)) {
                        foundReceipt = true; // Still mark as found to stop polling
                        return;
                    }

                    const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                    if (bolt11Tag && bolt11Tag[1]) {
                        const receiptAmount = extractAmountFromBolt11(bolt11Tag[1]);

                        if (Math.abs(receiptAmount - amount) < 10) {
                            // Mark as processed to prevent duplicate handling
                            processedZapReceipts.add(event.id);
                            foundReceipt = true;

                            const invoiceModal = document.getElementById('lightning-invoice-modal');
                            if (invoiceModal) {
                                invoiceModal.remove();
                            }

                            showZapSuccess(amount);

                            if (eventId) {
                                // Check what type of zap this is and update only the relevant UI
                                const chatZapCount = document.querySelector(`.chat-zap-count[data-event-id="${eventId}"]`);
                                const commentZapBtn = document.querySelector(`.comment-zap-btn[data-comment-id="${eventId}"]`);
                                const liveZapBtn = document.querySelector(`.action-btn.zap[data-event-id="${eventId}"]`);

                                if (chatZapCount) {
                                    // This is a chat message zap - only update chat zap count
                                    const current = parseInt(chatZapCount.textContent) || 0;
                                    chatZapCount.textContent = formatSats(current + amount);
                                } else if (commentZapBtn) {
                                    // This is a video comment zap
                                    if (!currentCommentsState.zaps.has(eventId)) {
                                        currentCommentsState.zaps.set(eventId, { totalSats: 0, count: 0 });
                                    }
                                    const commentZapData = currentCommentsState.zaps.get(eventId);
                                    commentZapData.totalSats += amount;
                                    commentZapData.count++;

                                    const zapCountEl = commentZapBtn.querySelector('.zap-count');
                                    if (zapCountEl) {
                                        zapCountEl.textContent = formatNumber(commentZapData.totalSats);
                                    }
                                } else {
                                    // This is a video or live stream zap - load full zap data
                                    setTimeout(async () => {
                                        const zapData = await loadZapsForVideo(eventId);
                                        updateZapButton(eventId, zapData.totalZaps);

                                        // Update live stream zap button if on live stream page
                                        if (liveZapBtn && currentView === 'live') {
                                            liveZapBtn.classList.add('active');
                                        }
                                    }, 500);
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error checking zap receipt:', e);
                }
            }, () => {
                resolve();
            });
        });

        if (!foundReceipt) {
            setTimeout(checkForReceipt, pollInterval);
        }
    };

    setTimeout(checkForReceipt, 2000);
}

// Helper to extract payment hash from bolt11
function extractPaymentHash(bolt11) {
    return bolt11.slice(-20);
}

// Fetch lightning invoice from LNURL service
async function fetchLightningInvoice(npub, amount, zapRequest) {
    const pubkey = window.NostrTools.nip19.decode(npub).data;
    const profile = await loadUserProfile(pubkey);

    if (!profile) {
        throw new Error('Could not load user profile');
    }

    if (profile.lud16) {
        const [name, domain] = profile.lud16.split('@');
        const url = `https://${domain}/.well-known/lnurlp/${name}`;

        try {
            const response = await fetch(url);
            const data = await response.json();

            if (data.callback) {
                const invoiceUrl = new URL(data.callback);
                invoiceUrl.searchParams.set('amount', amount * 1000);
                invoiceUrl.searchParams.set('nostr', zapRequest);

                const invoiceResponse = await fetch(invoiceUrl.toString());
                return await invoiceResponse.json();
            }
        } catch (error) {
            console.error('Failed to fetch from lightning address:', error);
        }
    }

    if (profile.lud06) {
        try {
            const decoded = window.NostrTools.nip19.decode(profile.lud06);
            const url = decoded.data;

            const response = await fetch(url);
            const data = await response.json();

            if (data.callback) {
                const invoiceUrl = new URL(data.callback);
                invoiceUrl.searchParams.set('amount', amount * 1000);
                invoiceUrl.searchParams.set('nostr', zapRequest);

                const invoiceResponse = await fetch(invoiceUrl.toString());
                return await invoiceResponse.json();
            }
        } catch (error) {
            console.error('Failed to fetch from LNURL:', error);
        }
    }

    throw new Error('User does not have Lightning support');
}

// Show lightning invoice modal
function showLightningInvoice(invoice, amount, isWebLN = false) {
    const modal = document.createElement('div');
    modal.id = 'lightning-invoice-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        padding: 1rem;
    `;

    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center;">
            <h2 style="margin-bottom: 0.5rem;">Lightning Invoice</h2>
            <p style="margin-bottom: 1rem; color: var(--text-secondary);">Zap ${amount} sats</p>
            <p style="margin-bottom: 1rem;">${isWebLN ? 'Processing payment...' : 'Scan with your Lightning wallet:'}</p>
            
            <div style="background: white; padding: 1rem; border-radius: 8px; margin: 1rem auto; display: inline-block;">
                <div id="qrcode"></div>
            </div>
            
            <div style="margin: 1rem 0; color: var(--text-secondary); font-size: 0.875rem;">
                <div id="payment-status">
                    <div class="spinner" style="width: 20px; height: 20px; margin: 0 auto 0.5rem;"></div>
                    Waiting for payment confirmation...
                </div>
            </div>
            
            <textarea readonly style="width: 100%; padding: 0.5rem; margin: 1rem 0; font-size: 0.75rem; word-break: break-all; 
                                     height: 100px; resize: none; background: var(--bg-primary); color: var(--text-primary); 
                                     border: 1px solid var(--border); border-radius: 4px;">${invoice}</textarea>
            
            <div style="display: flex; gap: 0.5rem; justify-content: center;">
                <button onclick="navigator.clipboard.writeText('${invoice}').then(() => {
                    const btn = event.target;
                    const originalText = btn.textContent;
                    btn.textContent = t('button.copied');
                    btn.style.background = 'var(--accent)';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#f7931a';
                    }, 2000);
                });" style="padding: 0.5rem 1rem; background: #f7931a; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Copy Invoice
                </button>
                <button onclick="document.getElementById('lightning-invoice-modal').remove();" 
                        style="padding: 0.5rem 1rem; background: var(--bg-primary); color: var(--text-primary); 
                               border: 1px solid var(--border); border-radius: 4px; cursor: pointer;">
                    Close
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    if (window.QRCode) {
        new QRCode(document.getElementById("qrcode"), {
            text: invoice.toUpperCase(),
            width: 256,
            height: 256,
            colorDark: "#000000",
            colorLight: "#FFFFFF",
            correctLevel: QRCode.CorrectLevel.L
        });
    }
}

// Show zap success animation
function showZapSuccess(amount) {
    const invoiceModal = document.getElementById('lightning-invoice-modal');
    if (invoiceModal) {
        invoiceModal.remove();
    }

    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
    `;

    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 3rem; border-radius: 12px; text-align: center;">
            <div class="zap-success-animation">
                <svg width="120" height="120" viewBox="0 0 24 24" fill="#f7931a" style="margin-bottom: 1rem;">
                    <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                </svg>
                <h2 style="color: #f7931a; margin-bottom: 0.5rem;">Zap Sent!</h2>
                <p style="font-size: 1.5rem; font-weight: bold;">${amount} sats</p>
            </div>
        </div>
    `;

    const style = document.createElement('style');
    style.textContent = `
        .zap-success-animation {
            animation: zapPulse 0.5s ease-out;
        }
        
        .zap-success-animation svg {
            animation: zapBolt 0.8s ease-out;
        }
        
        @keyframes zapPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes zapBolt {
            0% { transform: translateY(-20px) rotate(-10deg); opacity: 0; }
            50% { transform: translateY(0) rotate(5deg); opacity: 1; }
            100% { transform: translateY(0) rotate(0deg); }
        }
    `;
    document.head.appendChild(style);

    document.body.appendChild(modal);

    setTimeout(() => {
        modal.style.opacity = '0';
        modal.style.transition = 'opacity 0.3s ease-out';
        setTimeout(() => {
            modal.remove();
            style.remove();
        }, 300);
    }, 2000);
}

// Update the video player zap button
function updateZapButton(eventId, totalZaps) {
    const zapBtn = document.querySelector(`.action-btn.zap[data-event-id="${eventId}"]`);
    if (zapBtn) {
        zapBtn.querySelector('.count').textContent = totalZaps > 0 ? formatSats(totalZaps) : 'Zap';
        if (totalZaps > 0) {
            zapBtn.classList.add('active');
        }
    }
}

// Check NSFW preference
function shouldShowNSFW() {
    return localStorage.getItem('allowNSFW') === 'true' || sessionNSFWAllowed;
}

// Check community warning preference
function shouldSkipCommunityWarning() {
    return localStorage.getItem('allowCommunityWarning') === 'true';
}

// Allow ratioed/reported content to be shown (for comments)
function allowRatioedContent(eventId) {
    sessionRatioedAllowed.add(eventId);
}

// Unhide a reported/ratioed comment inline (without reloading all comments)
function unhideReportedComment(commentId) {
    sessionRatioedAllowed.add(commentId);

    // Find the placeholder
    const placeholder = document.querySelector(`.reported-comment-placeholder[data-event-id="${commentId}"], .ratioed-comment-placeholder[data-event-id="${commentId}"]`);
    if (!placeholder) return;

    // Find the comment in currentCommentsState
    const comment = currentCommentsState.comments.find(c => c.id === commentId);
    if (comment) {
        // Get depth from placeholder
        const depth = parseInt(placeholder.dataset.depth || '0', 10);
        const commentWithDepth = { ...comment, depth, children: [] };

        // Create the comment element
        const commentElement = createCommentElement(
            commentWithDepth,
            profileCache,
            currentCommentsState.reactions,
            currentCommentsState.zaps
        );

        // Replace placeholder with the actual comment
        placeholder.replaceWith(commentElement);
    }
}

// Scroll carousel
function scrollCarousel(direction) {
    const trendingGrid = document.getElementById('trendingGrid');
    if (!trendingGrid) return;

    const currentPage = parseInt(trendingGrid.dataset.currentPage || '0');
    const totalPages = parseInt(trendingGrid.dataset.totalPages || '1');
    const itemsPerPage = parseInt(trendingGrid.dataset.itemsPerPage || '3');

    const newPage = Math.max(0, Math.min(currentPage + direction, totalPages - 1));

    if (newPage !== currentPage) {
        goToPage(newPage);
    }
}

// Go to specific page
function goToPage(page) {
    const trendingGrid = document.getElementById('trendingGrid');
    const carouselDots = document.getElementById('carouselDots');
    if (!trendingGrid || !carouselDots) return;

    const cards = trendingGrid.querySelectorAll('.video-card');
    if (cards.length === 0) return;

    // Use stored card dimensions for precise scrolling
    const cardWidth = parseFloat(trendingGrid.dataset.cardWidth) || cards[0].offsetWidth;
    const gap = parseFloat(trendingGrid.dataset.gap) || 16;
    const itemsPerPage = parseInt(trendingGrid.dataset.itemsPerPage) || 3;
    const offset = page * itemsPerPage * (cardWidth + gap);

    trendingGrid.style.transform = `translateX(-${offset}px)`;
    trendingGrid.dataset.currentPage = page;

    carouselDots.querySelectorAll('.carousel-dot').forEach((dot, index) => {
        dot.classList.toggle('active', index === page);
    });

    updateCarouselButtons();
}

// Update carousel button states
function updateCarouselButtons() {
    const trendingGrid = document.getElementById('trendingGrid');
    const prevBtn = document.querySelector('.carousel-btn.prev');
    const nextBtn = document.querySelector('.carousel-btn.next');

    if (!trendingGrid || !prevBtn || !nextBtn) return;

    const currentPage = parseInt(trendingGrid.dataset.currentPage || '0');
    const totalPages = parseInt(trendingGrid.dataset.totalPages || '1');

    prevBtn.disabled = currentPage === 0;
    nextBtn.disabled = currentPage === totalPages - 1;
}

// Calculate if video is ratioed (uses PoW-validated reactions only to prevent spam manipulation)
function isVideoRatioed(reactions) {
    // Use PoW-validated counts for ratioed determination (spam-resistant)
    const likes = reactions.powLikes || 0;
    const dislikes = reactions.powDislikes || 0;
    const total = likes + dislikes;

    // Video is ratioed if:
    // 1. At least 10 total PoW-validated reactions
    // 2. Dislikes are at least 2x likes
    // 3. Dislikes make up at least 70% of total reactions
    if (total >= 10) {
        const dislikeRatio = dislikes / total;
        return dislikes >= likes * 2 && dislikeRatio >= 0.7;
    }
    return false;
}

// Connect to a relay
function connectToRelay(url) {
    return new Promise((resolve, reject) => {
        // Check if we have an open connection
        if (relayConnections[url] && relayConnections[url].readyState === WebSocket.OPEN) {
            resolve(relayConnections[url]);
            return;
        }

        // If there's a connection in progress, wait for it
        if (relayConnections[url] && relayConnections[url].readyState === WebSocket.CONNECTING) {
            const checkConnection = setInterval(() => {
                const ws = relayConnections[url];
                if (!ws) {
                    clearInterval(checkConnection);
                    // Connection was removed, try again
                    connectToRelay(url).then(resolve).catch(reject);
                } else if (ws.readyState === WebSocket.OPEN) {
                    clearInterval(checkConnection);
                    resolve(ws);
                } else if (ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
                    clearInterval(checkConnection);
                    delete relayConnections[url];
                    // Try to reconnect
                    connectToRelay(url).then(resolve).catch(reject);
                }
            }, 100);
            return;
        }

        // Create new connection
        try {
            const ws = new WebSocket(url);
            relayConnections[url] = ws;

            ws.onopen = () => {
                console.log(`Connected to ${url}`);
                relayStatus.set(url, 'connected');
                resolve(ws);
            };

            ws.onerror = (error) => {
                console.error(`Failed to connect to ${url}:`, error);
                relayStatus.set(url, 'error');
                delete relayConnections[url];
                reject(error);
            };

            ws.onclose = () => {
                console.log(`Disconnected from ${url}`);
                relayStatus.set(url, 'disconnected');
                delete relayConnections[url];

                // Attempt to reconnect after a delay (reduced from 5s to 3s)
                setTimeout(() => {
                    // Only reconnect if this URL is still in RELAY_URLS or WOT_RELAY_URLS
                    const isActiveRelay = RELAY_URLS.includes(url) || WOT_RELAY_URLS.includes(url) || PUBLISH_ONLY_RELAYS.includes(url);
                    if (isActiveRelay && !relayConnections[url]) {
                        console.log(`Attempting to reconnect to ${url}`);
                        connectToRelay(url).catch(err =>
                            console.error(`Reconnection to ${url} failed:`, err)
                        );
                    }
                }, 3000);
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleRelayMessage(url, message);
                } catch (error) {
                    console.error('Failed to parse message:', error);
                }
            };
        } catch (error) {
            console.error(`Failed to create WebSocket for ${url}:`, error);
            delete relayConnections[url];
            reject(error);
        }
    });
}

// Handle messages from relays
function handleRelayMessage(relayUrl, message) {
    if (message[0] === 'EVENT') {
        const subscriptionId = message[1];
        const event = message[2];

        allEvents.set(event.id, event);

        if (event.kind === 0) {
            try {
                const profile = JSON.parse(event.content);
                profileCache.set(event.pubkey, profile);
            } catch (e) {
                console.error('Failed to parse profile:', e);
            }
        }

        if (window.subscriptionHandlers && window.subscriptionHandlers[subscriptionId]) {
            window.subscriptionHandlers[subscriptionId](event);
        }
    }
}

// Get relays sorted by latency (fastest first)
function getRelaysSortedByLatency() {
    return [...RELAY_URLS].sort((a, b) => {
        const latencyA = relayLatency.get(a) || 1000;
        const latencyB = relayLatency.get(b) || 1000;
        return latencyA - latencyB;
    });
}

// Streaming request events (optimized with early delivery)
async function requestEventsStream(filter, onEvent, onComplete) {
    const subscriptionId = Math.random().toString(36).substring(7);
    const eventsMap = new Map();
    const seenEventIds = new Set();
    let completedRelays = 0;
    let earlyCompleteTriggered = false;
    const sortedRelays = getRelaysSortedByLatency();
    const totalRelays = sortedRelays.length;
    // Require more relays if we haven't found any data yet
    const minRelaysForEmptyResult = Math.min(3, totalRelays);
    const activeSubscriptions = new Set();
    const relayStartTimes = new Map();

    if (!window.subscriptionHandlers) {
        window.subscriptionHandlers = {};
    }

    window.subscriptionHandlers[subscriptionId] = (event) => {
        if (!eventsMap.has(event.id)) {
            eventsMap.set(event.id, event);
            if (onEvent && !seenEventIds.has(event.id)) {
                seenEventIds.add(event.id);
                onEvent(event);
            }
        }
    };

    // Trigger early completion when we have enough data
    const triggerEarlyComplete = () => {
        if (!earlyCompleteTriggered && onComplete) {
            earlyCompleteTriggered = true;
            onComplete(Array.from(eventsMap.values()));
        }
    };

    // Final cleanup when all relays complete
    const finalCleanup = () => {
        delete window.subscriptionHandlers[subscriptionId];
        // Trigger onComplete if not already done
        if (!earlyCompleteTriggered && onComplete) {
            onComplete(Array.from(eventsMap.values()));
        }
    };

    // Connect to all relays in parallel for faster initial response
    const connectionPromises = sortedRelays.map(async (url) => {
        try {
            relayStartTimes.set(url, Date.now());
            const ws = await connectToRelay(url);
            const req = JSON.stringify(['REQ', subscriptionId, filter]);
            ws.send(req);
            activeSubscriptions.add(url);

            // Create a dedicated message handler for EOSE
            const handleEOSE = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    if (message[0] === 'EOSE' && message[1] === subscriptionId) {
                        // Update relay latency tracking
                        const startTime = relayStartTimes.get(url);
                        if (startTime) {
                            const latency = Date.now() - startTime;
                            relayLatency.set(url, latency);
                        }

                        completedRelays++;
                        activeSubscriptions.delete(url);
                        ws.removeEventListener('message', handleEOSE);

                        // Send CLOSE command for this subscription
                        if (ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify(['CLOSE', subscriptionId]));
                        }

                        // Trigger early complete:
                        // - If we have events, complete after 2 relays (we found data)
                        // - If no events yet, wait for more relays before giving up
                        const hasEvents = eventsMap.size > 0;
                        const enoughRelays = hasEvents ? completedRelays >= 2 : completedRelays >= minRelaysForEmptyResult;
                        if (enoughRelays && !earlyCompleteTriggered) {
                            triggerEarlyComplete();
                        }

                        if (completedRelays === totalRelays) {
                            finalCleanup();
                        }
                    }
                } catch (error) {
                    // Ignore parse errors
                }
            };

            // Add EOSE handler
            ws.addEventListener('message', handleEOSE);

            // Clean up the EOSE handler after a timeout
            setTimeout(() => {
                ws.removeEventListener('message', handleEOSE);
                if (activeSubscriptions.has(url)) {
                    completedRelays++;
                    activeSubscriptions.delete(url);

                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify(['CLOSE', subscriptionId]));
                    }

                    if (completedRelays === totalRelays) {
                        finalCleanup();
                    }
                }
            }, 15000); // Reduced from 30s to 15s timeout

        } catch (error) {
            console.error(`Failed to connect to ${url}:`, error);
            completedRelays++;
            if (completedRelays === totalRelays) {
                finalCleanup();
            }
        }
    });

    // Wait for all connection attempts to start (not complete)
    await Promise.allSettled(connectionPromises);

    // Trigger early complete after 3 seconds if we have any events
    setTimeout(() => {
        if (!earlyCompleteTriggered && eventsMap.size > 0) {
            triggerEarlyComplete();
        }
    }, 3000);
}

// Persistent subscription that stays open for real-time updates (doesn't close after EOSE)
// Returns an object with an unsubscribe() method to clean up
function subscribePersistent(filter, onEvent) {
    const subscriptionId = 'live_' + Math.random().toString(36).substring(7);
    const seenEventIds = new Set();
    const activeConnections = new Map(); // url -> ws
    let isActive = true;

    if (!window.subscriptionHandlers) {
        window.subscriptionHandlers = {};
    }

    window.subscriptionHandlers[subscriptionId] = (event) => {
        if (!seenEventIds.has(event.id) && isActive) {
            seenEventIds.add(event.id);
            onEvent(event);
        }
    };

    // Connect to relays and keep subscriptions open
    const sortedRelays = getRelaysSortedByLatency();

    sortedRelays.forEach(async (url) => {
        try {
            const ws = await connectToRelay(url);
            if (!isActive) return; // Check if unsubscribed during connection

            activeConnections.set(url, ws);
            const req = JSON.stringify(['REQ', subscriptionId, filter]);
            ws.send(req);

            // Handle EOSE but DON'T close the subscription - keep it open for real-time
            const handleMessages = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    // We just acknowledge EOSE but don't close - subscription stays open
                    if (message[0] === 'EOSE' && message[1] === subscriptionId) {
                        // Subscription is now ready for real-time events
                        console.log(`Live subscription ${subscriptionId} ready on ${url}`);
                    }
                } catch (error) {
                    // Ignore parse errors
                }
            };

            ws.addEventListener('message', handleMessages);

            // Store cleanup function
            if (!ws._persistentHandlers) ws._persistentHandlers = new Map();
            ws._persistentHandlers.set(subscriptionId, handleMessages);

        } catch (error) {
            console.error(`Failed to set up persistent subscription on ${url}:`, error);
        }
    });

    // Return unsubscribe function
    return {
        unsubscribe: () => {
            isActive = false;
            delete window.subscriptionHandlers[subscriptionId];

            // Close subscriptions on all relays
            activeConnections.forEach((ws, url) => {
                try {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify(['CLOSE', subscriptionId]));
                    }
                    // Remove message handler
                    if (ws._persistentHandlers && ws._persistentHandlers.has(subscriptionId)) {
                        ws.removeEventListener('message', ws._persistentHandlers.get(subscriptionId));
                        ws._persistentHandlers.delete(subscriptionId);
                    }
                } catch (error) {
                    console.error(`Error closing subscription on ${url}:`, error);
                }
            });
            activeConnections.clear();
        }
    };
}

// Function to handle streaming video display
async function displayVideosStream(title, filter, clientFilter = null, container = null) {
    if (!container) {
        const mainContent = document.getElementById('mainContent');
        const cardsPerRow = getCardsPerRow();
        const skeletonCount = cardsPerRow * 10; // 10 rows of skeletons
        const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');

        mainContent.innerHTML = `
            <h2 style="margin-bottom: 1.5rem;">${title}</h2>
            <div class="video-grid" id="videoGrid">
                ${skeletons}
            </div>
        `;
        container = document.getElementById('videoGrid');
    }

    const videoGrid = container;
    const renderedVideos = new Map();
    const videoEvents = [];
    const profileQueue = new Set();
    const reactionQueue = new Set();
    const boostQueue = new Set();
    const viewsQueue = new Set();
    let profileTimer = null;
    let reactionTimer = null;
    let boostTimer = null;
    let viewsTimer = null;

    const updateCardBoosts = (eventId, boostAmount) => {
        const card = document.getElementById(`video-card-${eventId}`);
        if (!card) return;

        const boostLevel = getBoostLevel(boostAmount);
        const isBoosted = boostLevel > 0;

        // Update card classes
        if (isBoosted) {
            card.classList.add('boosted', `boost-level-${boostLevel}`);
            // Remove old boost levels
            for (let i = 1; i <= 4; i++) {
                if (i !== boostLevel) {
                    card.classList.remove(`boost-level-${i}`);
                }
            }
        } else {
            card.classList.remove('boosted', 'boost-level-1', 'boost-level-2', 'boost-level-3', 'boost-level-4');
        }

        // Update boost indicator
        const thumbnail = card.querySelector('.video-thumbnail');
        const existingIndicator = thumbnail.querySelector('.boost-indicator');

        if (isBoosted) {
            const indicatorHTML = `
                <div class="boost-indicator">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                    </svg>
                    ${formatSats(boostAmount)}
                </div>
            `;

            if (existingIndicator) {
                existingIndicator.outerHTML = indicatorHTML;
            } else {
                thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
            }
        } else if (existingIndicator) {
            existingIndicator.remove();
        }
    };

    const updateCardReactions = (eventId, reactions) => {
        const card = document.getElementById(`video-card-${eventId}`);
        if (!card) return;

        const thumbnail = card.querySelector('.video-thumbnail');
        const existingReactions = thumbnail.querySelector('.video-reactions');

        const newReactionsHTML = reactions && (reactions.likes > 0 || reactions.dislikes > 0) ? `
            ${reactions.likes > 0 ? `
                <span class="reaction-count likes">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                    ${formatNumber(reactions.likes)}
                </span>
            ` : ''}
            ${reactions.dislikes > 0 ? `
                <span class="reaction-count dislikes">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                    ${formatNumber(reactions.dislikes)}
                </span>
            ` : ''}
        ` : '';

        if (existingReactions) {
            if (newReactionsHTML) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = `<div class="video-reactions">${newReactionsHTML}</div>`;
                existingReactions.innerHTML = tempDiv.firstElementChild.innerHTML;
            } else {
                existingReactions.remove();
            }
        } else if (newReactionsHTML) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = `<div class="video-reactions">${newReactionsHTML}</div>`;
            thumbnail.appendChild(tempDiv.firstElementChild);
        }
    };

    const updateCardProfile = (eventId, profile) => {
        const card = document.getElementById(`video-card-${eventId}`);
        if (!card || !profile) return;

        const displayName = profile.name || profile.display_name || `User ${card.dataset.pubkey.slice(0, 8)}`;
        const avatarUrl = profile.picture || profile.avatar || '';
        const nip05 = profile.nip05 || '';

        const channelName = card.querySelector('.channel-name');
        if (channelName && channelName.textContent !== displayName) {
            channelName.textContent = displayName;
        }

        const channelDetails = card.querySelector('.channel-details');
        const existingNip05 = card.querySelector('.channel-nip05');

        if (nip05) {
            if (existingNip05) {
                if (existingNip05.textContent !== nip05) {
                    existingNip05.textContent = nip05;
                    existingNip05.dataset.nip05 = nip05;
                }
            } else {
                channelDetails.insertAdjacentHTML('beforeend',
                    `<div class="channel-nip05" data-nip05="${nip05}">${nip05}</div>`
                );
            }
        } else if (existingNip05) {
            existingNip05.remove();
        }

        const channelAvatar = card.querySelector('.channel-avatar');
        const existingImg = channelAvatar.querySelector('img');

        if (avatarUrl) {
            if (existingImg) {
                if (existingImg.getAttribute('data-avatar-url') !== avatarUrl) {
                    existingImg.src = avatarUrl;
                    existingImg.setAttribute('data-avatar-url', avatarUrl);
                }
            } else {
                channelAvatar.innerHTML = `<img src="${avatarUrl}" alt="${displayName}" data-avatar-url="${avatarUrl}">`;
            }
        } else if (existingImg) {
            existingImg.remove();
        }

        if ((avatarUrl || nip05) && card.dataset.validationDone !== 'true') {
            card.dataset.needsValidation = 'true';
            setTimeout(() => validateVideoCard(eventId, card.dataset.pubkey, profile, reactionsCache.get(eventId), false), 0);
        }
    };

    const renderVideoCard = (event, profile = null, reactions = null) => {
        const cardId = `video-card-${event.id}`;

        if (document.getElementById(cardId)) {
            if (profile) updateCardProfile(event.id, profile);
            if (reactions) updateCardReactions(event.id, reactions);
            return;
        }

        const cardHTML = createVideoCard(event, profile, reactions);
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = cardHTML;

        if (!tempDiv.firstElementChild) return;

        tempDiv.firstElementChild.id = cardId;

        let inserted = false;
        const cards = videoGrid.querySelectorAll('.video-card');

        for (let i = 0; i < cards.length; i++) {
            const cardEventId = cards[i].id.replace('video-card-', '');
            const cardEvent = renderedVideos.get(cardEventId);
            if (cardEvent && event.created_at > cardEvent.created_at) {
                cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                inserted = true;
                break;
            }
        }

        if (!inserted) {
            videoGrid.appendChild(tempDiv.firstElementChild);
        }

        renderedVideos.set(event.id, event);

        // Observe new card for lazy loading
        observeLazyCards();
    };

    const loadProfilesBatch = async () => {
        if (profileQueue.size === 0) return;

        const pubkeys = Array.from(profileQueue);
        profileQueue.clear();

        // Chunk profiles into batches of 25 to prevent relay timeouts
        const BATCH_SIZE = 25;
        const chunks = [];
        for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
            chunks.push(pubkeys.slice(i, i + BATCH_SIZE));
        }

        // Process all chunks in parallel
        await Promise.all(chunks.map(async (chunk) => {
            const filter = {
                kinds: [0],
                authors: chunk
            };

            await requestEventsStream(filter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);

                    videoEvents.forEach(event => {
                        if (event.pubkey === profileEvent.pubkey) {
                            updateCardProfile(event.id, profile);
                        }
                    });
                } catch (e) {
                    console.error('Failed to parse profile:', e);
                }
            });
        }));
    };

    const loadReactionsBatch = async () => {
        if (reactionQueue.size === 0) return;

        const videoIds = Array.from(reactionQueue);
        reactionQueue.clear();

        await loadReactionsForVideos(videoIds, (videoId, reactions) => {
            updateCardReactions(videoId, reactions);
        });
    };

    const loadBoostsBatch = async () => {
        if (boostQueue.size === 0) return;

        const videoIds = Array.from(boostQueue);
        boostQueue.clear();

        // Load boosts for all videos in parallel
        await Promise.all(videoIds.map(videoId =>
            loadBoostsForVideo(videoId, (totalBoosts) => {
                updateCardBoosts(videoId, totalBoosts);
            })
        ));
    };

    const loadViewsBatch = async () => {
        if (viewsQueue.size === 0) return;

        const videoIds = Array.from(viewsQueue);
        viewsQueue.clear();

        // Load views and update UI
        await loadViewsForVideos(videoIds, true);
    };

    await requestEventsStream(filter, (event) => {
        const tags = event.tags || [];
        if (!tags.some(tag => tag[0] === 'x')) return;

        if (clientFilter && !clientFilter(event)) return;

        if (videoEvents.some(e => e.id === event.id)) {
            return;
        }

        // Store event first so shouldSkipLegacyEvent can find NIP-71 counterparts
        allEvents.set(event.id, event);

        // Remove any legacy counterpart that was already added (handles race condition)
        removeLegacyCounterpart(event, videoEvents);

        // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
        if (shouldSkipLegacyEvent(event)) {
            return;
        }

        videoEvents.push(event);

        const spinner = videoGrid.querySelector('.spinner');
        if (spinner) spinner.remove();

        const cachedProfile = profileCache.get(event.pubkey);
        const cachedReactions = reactionsCache.get(event.id);
        renderVideoCard(event, cachedProfile, cachedReactions);

        if (!cachedProfile) {
            profileQueue.add(event.pubkey);
            clearTimeout(profileTimer);
            profileTimer = setTimeout(loadProfilesBatch, 100);
        }

        reactionQueue.add(event.id);
        clearTimeout(reactionTimer);
        reactionTimer = setTimeout(loadReactionsBatch, 200);

        boostQueue.add(event.id);
        clearTimeout(boostTimer);
        boostTimer = setTimeout(loadBoostsBatch, 300);

        viewsQueue.add(event.id);
        clearTimeout(viewsTimer);
        viewsTimer = setTimeout(loadViewsBatch, 400);

    }, (allEvents) => {
        // Remove any remaining skeleton loaders
        videoGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());

        if (videoEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosFound')}</p>`;
        }

        if (profileQueue.size > 0) {
            loadProfilesBatch();
        }
        if (reactionQueue.size > 0) {
            loadReactionsBatch();
        }
        if (boostQueue.size > 0) {
            loadBoostsBatch();
        }
        if (viewsQueue.size > 0) {
            loadViewsBatch();
        }

        // Make video cards keyboard accessible
        makeCardsKeyboardAccessible();

        // Enable lazy loading for new cards
        observeLazyCards();
    });
}

// Helper function to update all video cards with the same event ID
function updateAllVideoCardsReactions(eventId, reactions) {
    const cards = document.querySelectorAll(`[data-event-id="${eventId}"]`);
    cards.forEach(card => {
        const thumbnail = card.querySelector('.video-thumbnail');
        if (!thumbnail) return;

        const existingReactions = thumbnail.querySelector('.video-reactions');

        const newReactionsHTML = reactions && (reactions.likes > 0 || reactions.dislikes > 0) ? `
            <div class="video-reactions">
                ${reactions.likes > 0 ? `
                    <span class="reaction-count likes">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                        </svg>
                        ${formatNumber(reactions.likes)}
                    </span>
                ` : ''}
                ${reactions.dislikes > 0 ? `
                    <span class="reaction-count dislikes">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                        </svg>
                        ${formatNumber(reactions.dislikes)}
                    </span>
                ` : ''}
            </div>
        ` : '';

        if (existingReactions) {
            existingReactions.remove();
        }

        if (newReactionsHTML) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newReactionsHTML;
            thumbnail.appendChild(tempDiv.firstElementChild);
        }
    });
}

// Load reactions for videos with batching
async function loadReactionsForVideos(videoIds, onUpdate = null) {
    const BATCH_SIZE = 50;
    const userReactions = new Map();

    // Expand video IDs to include all linked events (for reaction merging)
    const primaryToLinked = new Map(); // Maps primary ID to all linked IDs
    const linkedToPrimary = new Map(); // Maps any linked ID back to primary ID
    const allLinkedIds = new Set();

    videoIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        primaryToLinked.set(id, linkedIds);
        linkedIds.forEach(linkedId => {
            linkedToPrimary.set(linkedId, id);
            allLinkedIds.add(linkedId);
        });
        userReactions.set(id, new Map());
    });

    const allIdsArray = Array.from(allLinkedIds);

    // Batch video IDs for reaction fetching
    const videoBatches = [];
    for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
        videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
    }

    // Fetch reactions in batches (no #t filter to include legacy reactions)
    await Promise.all(videoBatches.map(async (batch) => {
        const filter = {
            kinds: [7],
            '#e': batch
        };

        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                const reactionVideoId = event.tags.find(tag => tag[0] === 'e')?.[1];
                if (!reactionVideoId || !allLinkedIds.has(reactionVideoId)) return;

                // Map back to primary video ID
                const primaryId = linkedToPrimary.get(reactionVideoId);
                if (!primaryId) return;

                const videoReactionMap = userReactions.get(primaryId);
                if (!videoReactionMap) return;

                const userPubkey = event.pubkey;
                const timestamp = event.created_at;

                const existingReaction = videoReactionMap.get(userPubkey);
                if (!existingReaction || existingReaction.timestamp < timestamp) {
                    videoReactionMap.set(userPubkey, {
                        reaction: event.content,
                        timestamp: timestamp,
                        hasPoW: validateEventPoW(event)
                    });
                }
            }, resolve);
        });
    }));

    // Count ALL reactions for video page display (no PoW/NIP-05 filtering)
    // Also track PoW-validated counts separately for ratioed algorithm (spam prevention)
    const reactions = {};
    videoIds.forEach(id => {
        reactions[id] = { likes: 0, dislikes: 0, powLikes: 0, powDislikes: 0, userReaction: null };

        const videoReactionMap = userReactions.get(id);
        videoReactionMap.forEach((data, userPubkey) => {
            // Count ALL reactions for display (not filtered like trending)
            if (data.reaction === '👍') {
                reactions[id].likes++;
                // Track PoW-validated likes for ratioed algorithm
                if (data.hasPoW) {
                    reactions[id].powLikes++;
                }
                if (currentUser && userPubkey === currentUser.pubkey) {
                    reactions[id].userReaction = 'like';
                }
            } else if (data.reaction === '👎') {
                reactions[id].dislikes++;
                // Track PoW-validated dislikes for ratioed algorithm
                if (data.hasPoW) {
                    reactions[id].powDislikes++;
                }
                if (currentUser && userPubkey === currentUser.pubkey) {
                    reactions[id].userReaction = 'dislike';
                }
            }
        });

        reactionsCache.set(id, reactions[id]);

        // Update all linked event IDs with the same reactions
        const linkedIds = primaryToLinked.get(id) || [id];
        linkedIds.forEach(linkedId => {
            reactionsCache.set(linkedId, reactions[id]);
            updateAllVideoCardsReactions(linkedId, reactions[id]);
        });

        // Call the update callback if provided
        if (onUpdate) {
            onUpdate(id, reactions[id]);
        }
    });

    return reactions;
}

// Load zaps for videos (merges zaps from all linked events)
async function loadZapsForVideo(eventId, onUpdate = null) {
    // Expand to all linked event IDs for merging
    const allEventIds = getAllLinkedEventIds(eventId);

    const filter = {
        kinds: [9735],
        '#e': allEventIds
    };

    let totalZaps = 0;
    const zaps = [];

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            try {
                // Check if this is a boost zap (skip if it is)
                const pTag = event.tags.find(tag => tag[0] === 'p');
                if (pTag && pTag[1] === 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df') {
                    // This is a boost, check if it has the purpose tag
                    const description = event.tags.find(tag => tag[0] === 'description')?.[1];
                    if (description) {
                        try {
                            const zapRequest = JSON.parse(description);
                            const hasBoostTag = zapRequest.tags?.some(tag =>
                                tag[0] === 'purpose' && tag[1] === 'boost'
                            );
                            if (hasBoostTag) {
                                // Skip this boost zap
                                return;
                            }
                        } catch (e) {
                            // If we can't parse description, treat as regular zap
                        }
                    }
                }

                const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                if (bolt11Tag && bolt11Tag[1]) {
                    const amount = extractAmountFromBolt11(bolt11Tag[1]);
                    if (amount > 0) {
                        totalZaps += amount;
                        zaps.push({ amount, event });

                        if (onUpdate) {
                            onUpdate(totalZaps, zaps.length);
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to parse zap:', e);
            }
        }, () => {
            resolve({ totalZaps, zaps, count: zaps.length });
        });
    });
}

// Load zaps for multiple videos (for merging from linked events)
async function loadZapsForVideos(eventIds, onUpdate = null) {
    if (!eventIds || eventIds.length === 0) {
        if (onUpdate) onUpdate(0, 0);
        return { totalZaps: 0, zaps: [], count: 0 };
    }

    const filter = {
        kinds: [9735],
        '#e': eventIds
    };

    let totalZaps = 0;
    const zaps = [];
    const seenZapIds = new Set(); // Prevent double-counting

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            // Skip if we've already counted this zap
            if (seenZapIds.has(event.id)) return;
            seenZapIds.add(event.id);

            try {
                // Check if this is a boost zap (skip if it is)
                const pTag = event.tags.find(tag => tag[0] === 'p');
                if (pTag && pTag[1] === 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df') {
                    const description = event.tags.find(tag => tag[0] === 'description')?.[1];
                    if (description) {
                        try {
                            const zapRequest = JSON.parse(description);
                            const hasBoostTag = zapRequest.tags?.some(tag =>
                                tag[0] === 'purpose' && tag[1] === 'boost'
                            );
                            if (hasBoostTag) {
                                return;
                            }
                        } catch (e) {
                            // If we can't parse description, treat as regular zap
                        }
                    }
                }

                const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                if (bolt11Tag && bolt11Tag[1]) {
                    const amount = extractAmountFromBolt11(bolt11Tag[1]);
                    if (amount > 0) {
                        totalZaps += amount;
                        zaps.push({ amount, event });

                        if (onUpdate) {
                            onUpdate(totalZaps, zaps.length);
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to parse zap:', e);
            }
        }, () => {
            resolve({ totalZaps, zaps, count: zaps.length });
        });
    });
}

// Extract amount from bolt11 invoice
function extractAmountFromBolt11(bolt11) {
    try {
        const amountMatch = bolt11.match(/lnbc(\d+)([munp])/i);
        if (amountMatch) {
            const amount = parseInt(amountMatch[1]);
            const multiplier = amountMatch[2];
            switch (multiplier) {
                case 'm': return amount * 100000;
                case 'u': return amount * 100;
                case 'n': return amount * 0.1;
                case 'p': return amount * 0.0001;
                default: return amount * 100000000;
            }
        }
    } catch (e) {
        console.error('Failed to parse bolt11:', e);
    }
    return 0;
}

// Format sats amount
function formatSats(sats) {
    if (sats >= 1000000) {
        return `${(sats / 1000000).toFixed(1)}M`;
    } else if (sats >= 1000) {
        return `${(sats / 1000).toFixed(1)}K`;
    }
    return sats.toString();
}

// Format sats with exact number (for user-set values like zap goals)
function formatSatsExact(sats) {
    return sats.toLocaleString();
}

// Format counts amount
function formatNumber(num) {
    if (num >= 1000000) {
        return `${(num / 1000000).toFixed(1)}M`;
    } else if (num >= 1000) {
        return `${(num / 1000).toFixed(1)}K`;
    }
    return num.toString();
}

// Send reaction event
async function sendReaction(eventId, reaction) {
    if (!currentUser) {
        return false;
    }

    // Show a brief loading state on the button
    const actionBtn = document.querySelector(`.action-btn.${reaction === '👍' ? 'like' : 'dislike'}[data-event-id="${eventId}"]`);
    if (actionBtn) {
        actionBtn.disabled = true;
        actionBtn.classList.add('loading');
    }

    const reactionEvent = {
        kind: 7,
        pubkey: currentUser.pubkey, // Required for PoW calculation
        tags: [
            ['e', eventId],
            ['p', allEvents.get(eventId)?.pubkey || ''],
            ['t', 'pv69420']
        ],
        content: reaction,
        created_at: Math.floor(Date.now() / 1000)
    };

    try {
        // Generate proof of work (NIP-13) - this adds the nonce tag
        await generatePoW(reactionEvent, MIN_POW_DIFFICULTY);

        const signedEvent = await signEvent(reactionEvent);
        const published = await publishEvent(signedEvent);

        if (published) {
            const reactions = reactionsCache.get(eventId) || { likes: 0, dislikes: 0, userReaction: null };

            if (reactions.userReaction === 'like') reactions.likes--;
            if (reactions.userReaction === 'dislike') reactions.dislikes--;

            if (reaction === '👍') {
                reactions.likes++;
                reactions.userReaction = 'like';
            } else if (reaction === '👎') {
                reactions.dislikes++;
                reactions.userReaction = 'dislike';
            }

            reactionsCache.set(eventId, reactions);

            if (actionBtn) {
                actionBtn.disabled = false;
                actionBtn.classList.remove('loading');
            }
            return true;
        }
    } catch (error) {
        console.error('Failed to send reaction:', error);
    }

    if (actionBtn) {
        actionBtn.disabled = false;
        actionBtn.classList.remove('loading');
    }
    return false;
}

// Function to fetch a single profile
async function fetchUserProfile(pubkey) {
    if (profileCache.has(pubkey)) {
        return profileCache.get(pubkey);
    }

    return new Promise((resolve) => {
        let found = false;
        const filter = {
            kinds: [0],
            authors: [pubkey],
            limit: 1
        };

        // Returns immediately when profile is found on any relay
        // If not found, waits for 3+ relays before giving up
        requestEventsStream(filter, (event) => {
            if (!found && event.pubkey === pubkey) {
                found = true;
                try {
                    const profile = JSON.parse(event.content);
                    profileCache.set(event.pubkey, profile);
                    resolve(profile);
                } catch (e) {
                    console.error('Failed to parse profile:', e);
                    resolve(null);
                }
            }
        }, () => {
            if (!found) {
                // Mark as checked even if not found
                profileCache.set(pubkey, null);
                resolve(null);
            }
        });
    });
}

// Load user profile
async function loadUserProfile(pubkey) {
    return fetchUserProfile(pubkey);
}

// Load profile immediately and update all cards/comments for this pubkey when done
// This is fire-and-forget - doesn't block rendering
function loadProfileAndUpdateCards(pubkey) {
    // Skip if invalid or already loading
    if (!pubkey || pendingProfileLoads.has(pubkey)) {
        return;
    }

    // If already cached, still update cards to trigger validation (for NIP-05 checkmark)
    if (profileCache.has(pubkey)) {
        const profile = profileCache.get(pubkey);
        const cards = document.querySelectorAll(`[data-pubkey="${pubkey}"]`);
        cards.forEach(card => {
            const eventId = card.dataset.eventId || card.id?.replace('video-card-', '');
            if (eventId && card.dataset.validationDone !== 'true') {
                updateVideoCardInPlace(eventId, profile, reactionsCache.get(eventId));
            }
        });
        return;
    }

    pendingProfileLoads.add(pubkey);

    fetchUserProfile(pubkey).then(profile => {
        pendingProfileLoads.delete(pubkey);

        // Find all video cards for this pubkey and update them
        const cards = document.querySelectorAll(`[data-pubkey="${pubkey}"]`);
        cards.forEach(card => {
            const eventId = card.dataset.eventId || card.id?.replace('video-card-', '');
            if (eventId) {
                updateVideoCardInPlace(eventId, profile, reactionsCache.get(eventId));
            }
        });

        // Also update sidebar cards
        const sidebarCards = document.querySelectorAll(`.sidebar-video-card[data-pubkey="${pubkey}"]`);
        sidebarCards.forEach(card => {
            const eventId = card.dataset.eventId;
            if (eventId) {
                updateSidebarCardInPlace(eventId, profile);
                // Trigger validation for sidebar card if not already done for this pubkey
                if (!profileValidationCache.has(pubkey)) {
                    // If no video cards exist for this pubkey, we need to validate via sidebar
                    const hasVideoCards = document.querySelector(`.video-card[data-pubkey="${pubkey}"]`);
                    if (!hasVideoCards && profile) {
                        // Do validation directly for sidebar-only pubkeys
                        const avatarUrl = profile.picture || profile.avatar || '';
                        const nip05 = profile.nip05 || '';
                        Promise.all([
                            avatarUrl ? createImageValidationPromise(avatarUrl) : Promise.resolve(false),
                            nip05 ? validateNip05(nip05, pubkey) : Promise.resolve(false)
                        ]).then(([avatarValid, nip05Valid]) => {
                            const isSuspicious = !avatarValid || !nip05Valid;
                            profileValidationCache.set(pubkey, { isSuspicious, avatarValid, nip05Valid });
                            // Apply to all sidebar cards for this pubkey
                            document.querySelectorAll(`.sidebar-video-card[data-pubkey="${pubkey}"]`).forEach(c => {
                                applySidebarValidation(c, isSuspicious);
                            });
                        });
                    }
                } else {
                    // Use cached validation
                    const cached = profileValidationCache.get(pubkey);
                    applySidebarValidation(card, cached.isSuspicious);
                }
            }
        });

        // Also update comments for this pubkey
        if (profile && typeof updateCommentProfileInPlace === 'function') {
            updateCommentProfileInPlace(pubkey, profile);
        }
    }).catch(() => {
        pendingProfileLoads.delete(pubkey);
    });
}

// Load multiple user profiles
async function loadUserProfiles(pubkeys) {
    const uniquePubkeys = [...new Set(pubkeys)];
    const uncachedPubkeys = uniquePubkeys.filter(pk => !profileCache.has(pk));

    if (uncachedPubkeys.length > 0) {
        const filter = {
            kinds: [0],
            authors: uncachedPubkeys
        };

        // Query all relays for profiles - early completion triggers when:
        // - We have data AND 2+ relays responded, OR
        // - We have no data AND 3+ relays responded (give more chance to find)
        await new Promise((resolve) => {
            requestEventsStream(filter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);
                } catch (e) {
                    console.error('Failed to parse profile:', e);
                }
            }, resolve);
        });

        // Mark all looked-up pubkeys as "checked" even if no profile was found
        // This allows community warning logic to know a lookup was attempted
        uncachedPubkeys.forEach(pk => {
            if (!profileCache.has(pk)) {
                profileCache.set(pk, null); // null means "checked but not found"
            }
        });
    }

    const profiles = {};
    uniquePubkeys.forEach(pk => {
        profiles[pk] = profileCache.get(pk) || null;
    });

    return profiles;
}

// Publish event to relays (parallelized for faster publishing)
async function publishEvent(event) {
    const eventMessage = JSON.stringify(['EVENT', event]);
    const allPublishRelays = [...RELAY_URLS, ...PUBLISH_ONLY_RELAYS];

    // Publish to all relays in parallel for faster delivery
    const publishPromises = allPublishRelays.map(async (url) => {
        try {
            const ws = await connectToRelay(url);
            ws.send(eventMessage);
            console.log(`Published to ${url}`);
            return { url, success: true };
        } catch (error) {
            console.error(`Failed to publish to ${url}:`, error);
            return { url, success: false };
        }
    });

    const results = await Promise.all(publishPromises);
    const successCount = results.filter(r => r.success).length;

    return successCount > 0;
}

// Create note identifier from event
function createNote(event) {
    if (!window.NostrTools) {
        console.error('NostrTools not loaded');
        return null;
    }

    const { nip19 } = window.NostrTools;
    const note = nip19.noteEncode(event.id);

    return note;
}

// Initialize hover preview functionality using event delegation
// Supports both mouse hover and touch for mobile devices
// Shows/hides pre-loaded preview GIF images (no src swapping needed)
function initializeHoverPreview() {
    const mainContent = document.getElementById('mainContent');
    if (!mainContent) return;

    // Track touch state for mobile
    let touchActiveCard = null;

    // Helper function to show preview on a card
    const showPreview = (card) => {
        if (!card || card.dataset.hasPreview !== 'true') return;

        const thumbnailImg = card.querySelector('img.thumbnail-img');
        const previewImg = card.querySelector('img.preview-img');

        if (!thumbnailImg || !previewImg) return;

        // Only show if preview is loaded
        if (previewImg.classList.contains('loaded')) {
            thumbnailImg.style.display = 'none';
            previewImg.style.display = 'block';
            card.classList.add('preview-active');
        }
    };

    // Helper function to hide preview on a card
    const hidePreview = (card) => {
        if (!card) return;

        const thumbnailImg = card.querySelector('img.thumbnail-img');
        const previewImg = card.querySelector('img.preview-img');

        if (thumbnailImg) thumbnailImg.style.display = '';
        if (previewImg) previewImg.style.display = 'none';
        card.classList.remove('preview-active');
    };

    // Mouse hover events (desktop)
    mainContent.addEventListener('mouseenter', (e) => {
        const card = e.target.closest('.video-card[data-has-preview="true"], .short-card[data-has-preview="true"]');
        if (card) showPreview(card);
    }, true);

    mainContent.addEventListener('mouseleave', (e) => {
        const card = e.target.closest('.video-card[data-has-preview="true"], .short-card[data-has-preview="true"]');
        if (card) hidePreview(card);
    }, true);

    // Touch events (mobile)
    mainContent.addEventListener('touchstart', (e) => {
        const card = e.target.closest('.video-card[data-has-preview="true"], .short-card[data-has-preview="true"]');
        if (!card) return;

        // If touching a new card, hide preview on the previous one
        if (touchActiveCard && touchActiveCard !== card) {
            hidePreview(touchActiveCard);
        }

        touchActiveCard = card;
        showPreview(card);
    }, { passive: true });

    // Hide preview when scrolling starts
    mainContent.addEventListener('scroll', () => {
        if (touchActiveCard) {
            hidePreview(touchActiveCard);
            touchActiveCard = null;
        }
    }, { passive: true });

    // Also hide when touching outside video cards
    document.addEventListener('touchstart', (e) => {
        if (touchActiveCard) {
            const card = e.target.closest('.video-card[data-has-preview="true"], .short-card[data-has-preview="true"]');
            if (!card) {
                hidePreview(touchActiveCard);
                touchActiveCard = null;
            }
        }
    }, { passive: true });
}

// Initialize app on DOM load
document.addEventListener('DOMContentLoaded', () => {
    // Initialize language first
    initializeLanguage();
    applyTranslations();

    initializeApp().then(() => {
        // Start monitoring relay connections after initialization
        monitorRelayConnections();
        // Initialize performance optimizations
        initPerformanceOptimizations();
        // Initialize edit video form
        initEditVideoForm();
        // Initialize edit stream form
        initEditStreamForm();
        // Initialize hover preview for video cards
        initializeHoverPreview();
    });

    // Set up hash change listener for routing
    window.addEventListener('hashchange', handleRoute);

    // Set up resize listener for carousel
    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
            updateHeaderHeight();

            // Update carousel if needed
            const trendingGrid = document.getElementById('trendingGrid');
            if (trendingGrid && trendingGrid.querySelector('.video-card')) {
                initializeCarousel();
            }
        }, 250);
    });

    // Update on orientation change for mobile devices
    window.addEventListener('orientationchange', () => {
        setTimeout(updateHeaderHeight, 100);
    });

    updateHeaderHeight();

    // Set up signup form listeners
    const signupUsername = document.getElementById('signupUsername');
    const signupAbout = document.getElementById('signupAbout');
    const signupNostrAddress = document.getElementById('signupNostrAddress');

    if (signupUsername) {
        signupUsername.addEventListener('input', updateSignupPreview);
    }
    if (signupAbout) {
        signupAbout.addEventListener('input', updateSignupPreview);
    }
    if (signupNostrAddress) {
        signupNostrAddress.addEventListener('input', handleNostrAddressInput);
    }

    // Set up file input listeners
    const videoFile = document.getElementById('videoFile');
    const thumbnailFile = document.getElementById('thumbnailFile');

    if (videoFile) {
        videoFile.addEventListener('change', handleFileSelect);
    }
    if (thumbnailFile) {
        thumbnailFile.addEventListener('change', handleFileSelect);
    }

    // Set up upload form listener - now uses pre-uploaded files
    const uploadForm = document.getElementById('uploadForm');
    if (uploadForm) {
        uploadForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            if (!currentUser) {
                if (!await ensureLoggedIn()) {
                    return;
                }
            }

            // Check if video upload is complete
            if (uploadState.video.status !== 'complete') {
                showToast('Please wait for video upload to complete', 'warning');
                return;
            }

            const publishBtn = document.getElementById('publishButton');
            const publishText = document.getElementById('publishButtonText');
            if (publishBtn) {
                publishBtn.disabled = true;
                publishBtn.classList.remove('ready');
            }

            // Auto-generate thumbnail if not provided
            // Use the blob URL stored by showVideoPreview (same-origin, no CORS/tainted canvas issues)
            const localVideoUrl = uploadState.video.previewUrl || uploadState.video.url;
            console.log('Using video URL for thumbnail/preview generation:', localVideoUrl.startsWith('blob:') ? 'blob URL' : 'remote URL');

            if (uploadState.thumbnail.status !== 'complete') {
                if (publishText) {
                    publishText.textContent = t('status.generatingThumbnail');
                }

                try {
                    // Capture a frame from the video (2 seconds in)
                    const frameData = await captureVideoFrame(localVideoUrl, 2);

                    if (publishText) {
                        publishText.textContent = t('status.uploadingThumbnail');
                    }

                    // Upload the auto-generated thumbnail
                    const result = await uploadToBlossom(frameData.file, BLOSSOM_SERVERS, 'thumbnailServerStatus');

                    if (result.success && result.url) {
                        uploadState.thumbnail.status = 'complete';
                        uploadState.thumbnail.url = result.url;
                        uploadState.thumbnail.file = frameData.file;
                    } else {
                        throw new Error(result.error || 'Failed to upload auto-generated thumbnail');
                    }
                } catch (error) {
                    console.error('Auto-thumbnail generation failed:', error);
                    showToast('Failed to generate thumbnail. Please upload one manually.', 'error');
                    if (publishBtn) publishBtn.disabled = false;
                    if (publishText) publishText.textContent = t('publish.autoThumbnail');
                    return;
                }
            }

            // Generate animated GIF preview for hover effect
            if (uploadState.preview.status !== 'complete') {
                if (publishText) {
                    publishText.textContent = t('status.generatingPreview');
                }

                try {
                    // Generate GIF preview covering 6 seconds of video with 12 frames
                    const previewData = await generatePreviewGif(localVideoUrl, {
                        startTime: 0.5,
                        duration: 6,
                        frameCount: 12,
                        frameDelay: 120
                    });

                    if (publishText) {
                        publishText.textContent = t('status.uploadingPreview');
                    }

                    const result = await uploadToBlossom(previewData.file, BLOSSOM_SERVERS, 'thumbnailServerStatus');

                    if (result.success && result.url) {
                        uploadState.preview.status = 'complete';
                        uploadState.preview.url = result.url;
                        uploadState.preview.file = previewData.file;
                    } else {
                        // Preview is optional, continue without it
                        console.warn('Preview upload failed, continuing without preview');
                        uploadState.preview.status = 'error';
                    }
                } catch (error) {
                    // Preview generation is optional - don't block publishing
                    console.warn('Preview generation failed:', error);
                    uploadState.preview.status = 'error';
                }
            }

            if (publishText) {
                publishText.textContent = t('status.publishing');
            }

            const title = document.getElementById('videoTitle').value;
            const description = escapeHtml(document.getElementById('videoDescription').value);
            const tags = document.getElementById('videoTags').value.split(',').map(t => t.trim()).filter(t => t);
            const isNSFW = document.getElementById('nsfwCheckbox').checked;

            if (!title.trim()) {
                showToast('Please enter a title', 'warning');
                if (publishBtn) publishBtn.disabled = false;
                if (publishText) publishText.textContent = t('publish.video');
                return;
            }

            if (isNSFW && !tags.includes('nsfw')) {
                tags.push('nsfw');
            }

            try {
                // Use pre-uploaded file info from uploadState
                const videoUrl = uploadState.video.url;
                const videoHash = uploadState.video.hash;
                const thumbnailUrl = uploadState.thumbnail.url;
                const videoDuration = Math.floor(uploadState.video.duration || 0);
                const videoSize = uploadState.video.size;
                const videoType = uploadState.video.type || 'video/mp4';
                const videoDimensions = uploadState.video.dimensions || { width: 0, height: 0 };
                const videoMirrors = uploadState.video.mirrors || [];
                const previewUrl = uploadState.preview.url || null;

                if (publishText) publishText.textContent = t('status.publishingToNostr');

                // Prepare video data for NIP-71 event
                const videoData = {
                    title: title,
                    description: description,
                    url: videoUrl,
                    hash: videoHash,
                    thumbnail: thumbnailUrl,
                    preview: previewUrl,
                    duration: videoDuration,
                    size: videoSize,
                    type: videoType,
                    width: videoDimensions.width,
                    height: videoDimensions.height,
                    mirrors: videoMirrors,
                    tags: tags,
                    isNSFW: isNSFW
                };

                // Generate d-tag for parameterized replaceable event
                const dTag = generateVideoDTag();
                videoData.dTag = dTag;

                // Create addressable NIP-71 video event (kind 34235/34236 - primary, editable)
                const addressableEvent = createNip71VideoEvent(videoData);
                const signedAddressableEvent = await signEvent(addressableEvent);

                // Create legacy NIP-71 video event (kind 21/22 - for reach on other clients)
                const legacyNip71Event = createLegacyNip71VideoEvent(videoData);
                const signedLegacyNip71Event = await signEvent(legacyNip71Event);

                // Create kind 1 event for backwards compatibility (maximum reach)
                // Pass the addressable event ID so we can link to it on plebs.app
                const kind1Event = createKind1VideoEvent(videoData, signedAddressableEvent.id);
                const signedKind1Event = await signEvent(kind1Event);

                // Publish all three events in parallel for maximum reach
                if (publishText) publishText.textContent = t('status.publishingVideoToNostr');

                const [addressablePublished, legacyNip71Published, kind1Published] = await Promise.all([
                    publishEvent(signedAddressableEvent),
                    publishEvent(signedLegacyNip71Event),
                    publishEvent(signedKind1Event)
                ]);

                if (!addressablePublished && !legacyNip71Published && !kind1Published) {
                    throw new Error('Failed to publish to any relay');
                }

                finalizePublishedVideoEvents(signedAddressableEvent, signedLegacyNip71Event, signedKind1Event);

                const isShort = isVideoShort(videoDimensions.width, videoDimensions.height, videoDuration);
                if (publishText) {
                    publishText.textContent = `Published ${isShort ? 'Short' : 'Video'} successfully!`;
                }

                // Delete draft if this was published from a draft
                if (uploadState.draftId) {
                    const draft = getDraft(uploadState.draftId);
                    // Delete from Nostr if draft was synced there
                    const deleteFromNostr = !!(draft?.nostrEventId);
                    await deleteDraft(uploadState.draftId, deleteFromNostr);
                    uploadState.draftId = null;
                }

                setTimeout(() => {
                    hideUploadModal();
                    navigateTo('/my-videos');
                }, 1500);

            } catch (error) {
                console.error('Publish failed:', error);
                showToast(error.message || 'Failed to publish video', 'error');

                if (publishBtn) {
                    publishBtn.disabled = false;
                    publishBtn.classList.add('ready');
                }
                if (publishText) {
                    publishText.textContent = t('publish.video');
                }
            }
        });
    }

    // Set up drag and drop for file upload
    const fileUpload = document.getElementById('fileUpload');
    if (fileUpload) {
        fileUpload.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            fileUpload.classList.add('active');
        });

        fileUpload.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            fileUpload.classList.remove('active');
        });

        fileUpload.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            fileUpload.classList.remove('active');

            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                // Create a new FileList-like object for the input
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);

                const videoFileInput = document.getElementById('videoFile');
                videoFileInput.files = dataTransfer.files;

                // Trigger the file select handler
                handleFileSelect({ target: videoFileInput });
            } else if (file) {
                showToast('Please drop a video file', 'warning');
            }
        });
    }

    // Set up search input enter key listener
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchVideos();
            }
        });
    }

    // Set up sidebar link click listeners for mobile
    document.querySelectorAll('.sidebar-item').forEach(item => {
        item.addEventListener('click', () => {
            if (window.innerWidth <= 768) {
                toggleSidebar();
            }
        });
    });
});

// Function to calculate and update header height
function updateHeaderHeight() {
    const header = document.querySelector('header');
    if (header) {
        // Force a reflow to ensure accurate measurement
        header.offsetHeight;
        const headerHeight = header.getBoundingClientRect().height;
        document.documentElement.style.setProperty('--header-height', `${headerHeight}px`);
    }
}

// Clean up WebSocket connections on page unload
window.addEventListener('beforeunload', () => {
    Object.values(relayConnections).forEach(ws => {
        if (ws.readyState === WebSocket.OPEN) {
            ws.close();
        }
    });
});

// Function to load trending videos with streaming
async function loadTrendingVideos(period = 'today') {
    const now = Math.floor(Date.now() / 1000);
    const oneDay = 24 * 60 * 60;
    const oneWeek = 7 * oneDay;

    let since;
    if (period === 'today') {
        since = now - oneDay;
    } else if (period === 'week') {
        since = now - oneWeek;
    }

    const filter = {
        kinds: ALL_VIDEO_KINDS,
        '#t': ['pv69420'],
        since: since,
        limit: 100
    };

    return new Promise((resolve) => {
        const videoEvents = [];
        const videoScores = new Map();
        const globalReactions = new Map();
        const globalZaps = new Map();
        const globalBoosts = new Map();
        const globalComments = new Map(); // Track comment counts per video
        const globalViews = new Map(); // Track view counts per video
        const processedVideos = new Set();
        const validReactionAuthors = new Set();
        const powValidReactions = new Map(); // Track reactions that have PoW (regardless of NIP-05)
        const renderedVideoIds = new Set();
        let trendingVideos = [];
        let videosComplete = false;
        let reactionsComplete = false;
        let zapsComplete = false;
        let boostsComplete = false;
        let commentsComplete = false;
        let viewsComplete = false;
        let profilesComplete = false;
        let lastProcessTime = 0;
        let processTimer = null;
        let resolveTimer = null;
        let hasResolved = false;
        let lastRenderCount = 0;

        // Maps for linked event ID expansion
        const primaryToLinked = new Map(); // Maps primary video ID to all linked IDs
        const linkedToPrimary = new Map(); // Maps any linked ID back to primary ID

        const processTrending = (force = false) => {
            const now = Date.now();
            if (!force && now - lastProcessTime < 200) {
                clearTimeout(processTimer);
                processTimer = setTimeout(() => processTrending(true), 200);
                return;
            }
            lastProcessTime = now;

            const newTrendingVideos = [];
            const seenVideoHashes = new Set(); // Track video hashes to prevent duplicates

            videoEvents.forEach(event => {
                // Get video hash (x tag) to detect duplicate videos with different event IDs
                const videoHash = event.tags?.find(t => t[0] === 'x')?.[1];
                if (videoHash && seenVideoHashes.has(videoHash)) {
                    return; // Skip duplicate video
                }
                if (videoHash) {
                    seenVideoHashes.add(videoHash);
                }
                const reactions = { likes: 0, dislikes: 0 };
                const videoReactions = globalReactions.get(event.id);
                const videoPowReactions = powValidReactions.get(event.id);

                if (videoReactions) {
                    videoReactions.forEach((data, userPubkey) => {
                        // Count reactions that have EITHER NIP-05 validation OR PoW
                        const hasNip05 = validReactionAuthors.has(userPubkey);
                        const hasPow = videoPowReactions?.has(userPubkey);

                        if (hasNip05 || hasPow) {
                            if (data.reaction === '👍') {
                                reactions.likes++;
                            } else if (data.reaction === '👎') {
                                reactions.dislikes++;
                            }
                        }
                    });
                }

                reactionsCache.set(event.id, reactions);

                updateAllVideoCardsReactions(event.id, reactions);

                if (isVideoRatioed(reactions)) {
                    return;
                }

                const zapTotal = globalZaps.get(event.id) || 0;
                const boostTotal = globalBoosts.get(event.id) || 0;
                const commentCount = globalComments.get(event.id) || 0;
                const viewCount = globalViews.get(event.id) || 0;

                const ageHours = (now - event.created_at) / 3600;
                const timeWeight = Math.max(0, 24 - ageHours) / 24;

                // Updated scoring formula including comments and views
                // Zaps (cost money, goes to creator): highest weight
                // Likes (PoW or NIP-05 verified): medium weight
                // Comments (with PoW): engagement indicator
                // Views: cumulative value
                // Boosts (cost money, but goes to platform): lowest weight to prevent gaming
                const likeScore = reactions.likes * 0.5;
                const zapScore = (zapTotal / 1000) * 5;
                const commentScore = commentCount * 0.3;
                const viewScore = viewCount * 0.1;
                const boostScore = (boostTotal / 1000) * 0.1; // Minimal weight - prevents gaming trending
                const score = likeScore - (reactions.dislikes * 2) + zapScore + commentScore + viewScore + boostScore + (timeWeight * 10);

                if (score > 0) {
                    videoScores.set(event.id, score);
                    newTrendingVideos.push(event);
                }
            });

            newTrendingVideos.sort((a, b) => {
                const scoreA = videoScores.get(a.id) || 0;
                const scoreB = videoScores.get(b.id) || 0;
                return scoreB - scoreA;
            });

            trendingVideos = newTrendingVideos.slice(0, 12);

            const trendingGrid = document.getElementById('trendingGrid');
            if (trendingGrid && trendingVideos.length > 0) {
                const videosToRender = trendingVideos.filter(v => !renderedVideoIds.has(v.id));

                if (videosToRender.length > 0 || trendingVideos.length !== lastRenderCount) {
                    // Use optimized DOM-diffing render to avoid re-rendering existing cards
                    renderTrendingVideosOptimized(trendingVideos, renderedVideoIds);
                    lastRenderCount = trendingVideos.length;
                }
            }

            if (videosComplete && reactionsComplete && zapsComplete && boostsComplete && commentsComplete && viewsComplete && profilesComplete && !hasResolved) {
                clearTimeout(processTimer);
                clearTimeout(resolveTimer);
                hasResolved = true;
                resolve(trendingVideos);
            }
        };

        // Initialize linked event maps after videos are loaded
        const initializeLinkedEventMaps = () => {
            videoEvents.forEach(event => {
                const linkedIds = getAllLinkedEventIds(event.id);
                primaryToLinked.set(event.id, linkedIds);
                linkedIds.forEach(linkedId => {
                    linkedToPrimary.set(linkedId, event.id);
                });
            });
        };

        const loadReactionAuthorsProfiles = async (reactionAuthors) => {
            if (reactionAuthors.size === 0) {
                profilesComplete = true;
                processTrending(true);
                return;
            }

            // Batch profile fetching
            const BATCH_SIZE = 50;
            const authorsArray = Array.from(reactionAuthors);
            const authorBatches = [];
            for (let i = 0; i < authorsArray.length; i += BATCH_SIZE) {
                authorBatches.push(authorsArray.slice(i, i + BATCH_SIZE));
            }

            let profilesLoaded = 0;

            await Promise.all(authorBatches.map(async (batch) => {
                const profileFilter = {
                    kinds: [0],
                    authors: batch
                };

                await new Promise((resolve) => {
                    requestEventsStream(profileFilter, (profileEvent) => {
                        try {
                            const profile = JSON.parse(profileEvent.content);
                            profilesLoaded++;

                            if (profile.nip05) {
                                validateNip05(profile.nip05, profileEvent.pubkey).then(isValid => {
                                    if (isValid) {
                                        validReactionAuthors.add(profileEvent.pubkey);
                                        processTrending();
                                    }
                                });
                            }

                            if (profilesLoaded % 10 === 0) {
                                processTrending();
                            }
                        } catch (e) {
                            console.error('Failed to parse profile:', e);
                        }
                    }, resolve);
                });
            }));

            profilesComplete = true;
            processTrending(true);
        };

        const loadReactions = async () => {
            if (videoEvents.length === 0) {
                reactionsComplete = true;
                profilesComplete = true;
                processTrending(true);
                return;
            }

            // Expand video IDs to include all linked events (for reaction merging)
            const allLinkedIds = new Set();
            videoEvents.forEach(event => {
                const linkedIds = primaryToLinked.get(event.id) || [event.id];
                linkedIds.forEach(id => allLinkedIds.add(id));
            });
            const allIdsArray = Array.from(allLinkedIds);

            const reactionAuthorsToValidate = new Set();

            // Batch video IDs for reaction fetching
            const BATCH_SIZE = 50;
            const videoBatches = [];
            for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
                videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
            }

            await Promise.all(videoBatches.map(async (batch) => {
                const reactionFilter = {
                    kinds: [7],
                    '#e': batch,
                    since: since
                };

                await new Promise((resolve) => {
                    requestEventsStream(reactionFilter, (reactionEvent) => {
                        const reactionVideoId = reactionEvent.tags.find(tag => tag[0] === 'e')?.[1];
                        if (!reactionVideoId || !allLinkedIds.has(reactionVideoId)) return;

                        // Map back to primary video ID
                        const primaryId = linkedToPrimary.get(reactionVideoId);
                        if (!primaryId) return;

                        if (!globalReactions.has(primaryId)) {
                            globalReactions.set(primaryId, new Map());
                        }

                        const videoReactions = globalReactions.get(primaryId);
                        const userPubkey = reactionEvent.pubkey;
                        const timestamp = reactionEvent.created_at;

                        const existingReaction = videoReactions.get(userPubkey);
                        if (!existingReaction || existingReaction.timestamp < timestamp) {
                            videoReactions.set(userPubkey, {
                                reaction: reactionEvent.content,
                                timestamp: timestamp
                            });

                            // Check for PoW validation (NIP-13)
                            if (validateEventPoW(reactionEvent)) {
                                if (!powValidReactions.has(primaryId)) {
                                    powValidReactions.set(primaryId, new Set());
                                }
                                powValidReactions.get(primaryId).add(userPubkey);
                            }

                            // Also validate NIP-05 for authors without PoW
                            if (reactionEvent.content === '👍' && !validateEventPoW(reactionEvent)) {
                                reactionAuthorsToValidate.add(userPubkey);
                            }
                        }
                    }, resolve);
                });
            }));

            reactionsComplete = true;
            loadReactionAuthorsProfiles(reactionAuthorsToValidate);
        };

        const loadZaps = async () => {
            if (videoEvents.length === 0) {
                zapsComplete = true;
                processTrending(true);
                return;
            }

            // Expand video IDs to include all linked events (for zap merging)
            const allLinkedIds = new Set();
            videoEvents.forEach(event => {
                const linkedIds = primaryToLinked.get(event.id) || [event.id];
                linkedIds.forEach(id => allLinkedIds.add(id));
            });
            const allIdsArray = Array.from(allLinkedIds);

            // Batch video IDs for zap fetching
            const BATCH_SIZE = 50;
            const videoBatches = [];
            for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
                videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
            }

            await Promise.all(videoBatches.map(async (batch) => {
                const zapFilter = {
                    kinds: [9735],
                    '#e': batch,
                    since: since
                };

                await new Promise((resolve) => {
                    requestEventsStream(zapFilter, (zapEvent) => {
                        try {
                            const zapVideoId = zapEvent.tags.find(tag => tag[0] === 'e')?.[1];
                            if (!zapVideoId || !allLinkedIds.has(zapVideoId)) return;

                            // Map back to primary video ID
                            const primaryId = linkedToPrimary.get(zapVideoId);
                            if (!primaryId) return;

                            const pTag = zapEvent.tags.find(tag => tag[0] === 'p');
                            if (pTag && pTag[1] === 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df') {
                                const description = zapEvent.tags.find(tag => tag[0] === 'description')?.[1];
                                if (description) {
                                    try {
                                        const zapRequest = JSON.parse(description);
                                        const hasBoostTag = zapRequest.tags?.some(tag =>
                                            tag[0] === 'purpose' && tag[1] === 'boost'
                                        );
                                        if (hasBoostTag) {
                                            return;
                                        }
                                    } catch (e) { }
                                }
                            }

                            const bolt11Tag = zapEvent.tags.find(tag => tag[0] === 'bolt11');
                            if (bolt11Tag && bolt11Tag[1]) {
                                const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                if (amount > 0) {
                                    const currentTotal = globalZaps.get(primaryId) || 0;
                                    globalZaps.set(primaryId, currentTotal + amount);
                                    processTrending();
                                }
                            }
                        } catch (e) {
                            console.error('Failed to parse zap:', e);
                        }
                    }, resolve);
                });
            }));

            zapsComplete = true;
            processTrending(true);
        };

        const loadBoosts = async () => {
            if (videoEvents.length === 0) {
                boostsComplete = true;
                processTrending(true);
                return;
            }

            // Expand video IDs to include all linked events (for boost merging)
            const allLinkedIds = new Set();
            videoEvents.forEach(event => {
                const linkedIds = primaryToLinked.get(event.id) || [event.id];
                linkedIds.forEach(id => allLinkedIds.add(id));
            });
            const allIdsArray = Array.from(allLinkedIds);

            // Batch video IDs for boost fetching
            const BATCH_SIZE = 50;
            const videoBatches = [];
            for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
                videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
            }

            await Promise.all(videoBatches.map(async (batch) => {
                const boostFilter = {
                    kinds: [9735],
                    '#e': batch,
                    '#p': ['d49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df'],
                    since: since
                };

                await new Promise((resolve) => {
                    requestEventsStream(boostFilter, (boostEvent) => {
                        try {
                            const boostVideoId = boostEvent.tags.find(tag => tag[0] === 'e')?.[1];
                            if (!boostVideoId || !allLinkedIds.has(boostVideoId)) return;

                            // Map back to primary video ID
                            const primaryId = linkedToPrimary.get(boostVideoId);
                            if (!primaryId) return;

                            const description = boostEvent.tags.find(tag => tag[0] === 'description')?.[1];
                            if (description) {
                                try {
                                    const zapRequest = JSON.parse(description);
                                    const hasBoostTag = zapRequest.tags?.some(tag =>
                                        tag[0] === 'purpose' && tag[1] === 'boost'
                                    );

                                    if (hasBoostTag) {
                                        const bolt11Tag = boostEvent.tags.find(tag => tag[0] === 'bolt11');
                                        if (bolt11Tag && bolt11Tag[1]) {
                                            const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                            if (amount > 0) {
                                                const currentTotal = globalBoosts.get(primaryId) || 0;
                                                globalBoosts.set(primaryId, currentTotal + amount);
                                                boostsCache.set(primaryId, currentTotal + amount);
                                                processTrending();
                                            }
                                        }
                                    }
                                } catch (e) { }
                            }
                        } catch (e) {
                            console.error('Failed to parse boost:', e);
                        }
                    }, resolve);
                });
            }));

            boostsComplete = true;
            processTrending(true);
        };

        // Load comments with PoW validation for trending
        const loadComments = async () => {
            if (videoEvents.length === 0) {
                commentsComplete = true;
                processTrending(true);
                return;
            }

            // Expand video IDs to include all linked events (for comment merging)
            const allLinkedIds = new Set();
            videoEvents.forEach(event => {
                const linkedIds = primaryToLinked.get(event.id) || [event.id];
                linkedIds.forEach(id => allLinkedIds.add(id));
            });
            const allIdsArray = Array.from(allLinkedIds);

            // Batch video IDs for comment fetching
            const BATCH_SIZE = 50;
            const videoBatches = [];
            for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
                videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
            }

            await Promise.all(videoBatches.map(async (batch) => {
                const commentFilter = {
                    kinds: [1],
                    '#e': batch,
                    since: since
                };

                await new Promise((resolve) => {
                    requestEventsStream(commentFilter, (commentEvent) => {
                        const commentVideoId = commentEvent.tags.find(tag => tag[0] === 'e')?.[1];
                        if (!commentVideoId || !allLinkedIds.has(commentVideoId)) return;

                        // Map back to primary video ID
                        const primaryId = linkedToPrimary.get(commentVideoId);
                        if (!primaryId) return;

                        // Only count comments with PoW to prevent spam
                        if (validateEventPoW(commentEvent)) {
                            const currentCount = globalComments.get(primaryId) || 0;
                            globalComments.set(primaryId, currentCount + 1);
                        }
                    }, resolve);
                });
            }));

            commentsComplete = true;
            processTrending(true);
        };

        // Load view counts for trending
        const loadViews = async () => {
            if (videoEvents.length === 0) {
                viewsComplete = true;
                processTrending(true);
                return;
            }

            // Expand video IDs to include all linked events (for view merging)
            const allLinkedIds = new Set();
            videoEvents.forEach(event => {
                const linkedIds = primaryToLinked.get(event.id) || [event.id];
                linkedIds.forEach(id => allLinkedIds.add(id));
            });
            const allIdsArray = Array.from(allLinkedIds);

            const viewersByVideo = new Map(); // primaryId -> Set of viewer pubkeys

            // Batch video IDs for view fetching
            const BATCH_SIZE = 50;
            const videoBatches = [];
            for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
                videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
            }

            await Promise.all(videoBatches.map(async (batch) => {
                const viewFilter = {
                    kinds: [VIEW_EVENT_KIND],
                    '#e': batch,
                    '#t': ['video-view']
                };

                await new Promise((resolve) => {
                    requestEventsStream(viewFilter, (viewEvent) => {
                        const viewVideoId = viewEvent.tags.find(tag => tag[0] === 'e')?.[1];
                        if (!viewVideoId || !allLinkedIds.has(viewVideoId)) return;

                        // Map back to primary video ID
                        const primaryId = linkedToPrimary.get(viewVideoId);
                        if (!primaryId) return;

                        // Count unique viewers
                        if (!viewersByVideo.has(primaryId)) {
                            viewersByVideo.set(primaryId, new Set());
                        }
                        viewersByVideo.get(primaryId).add(viewEvent.pubkey);
                    }, resolve);
                });
            }));

            // Convert sets to counts and cache
            videoEvents.forEach(event => {
                const viewers = viewersByVideo.get(event.id);
                const count = viewers ? viewers.size : 0;

                globalViews.set(event.id, count);
                setCachedViewCount(event.id, count);
            });

            viewsComplete = true;
            processTrending(true);
        };

        let videoCount = 0;
        requestEventsStream(filter, (event) => {
            const tags = event.tags || [];
            if (tags.some(tag => tag[0] === 'x') && !processedVideos.has(event.id)) {
                processedVideos.add(event.id);
                allEvents.set(event.id, event);

                // Only include addressable video kinds (34235) and live streams (30311)
                // Filter out legacy kinds (1, 21, 22) entirely for trending
                if (event.kind !== NIP71_VIDEO_KIND && event.kind !== NIP53_LIVE_EVENT_KIND) {
                    return;
                }

                // Skip shorts - they're shown in the dedicated Shorts section
                if (isNip71ShortKind(event.kind)) {
                    return;
                }

                videoEvents.push(event);
                videoCount++;

                if (videoCount % 5 === 0) {
                    processTrending();
                }
            }
        }, () => {
            videosComplete = true;

            if (videoEvents.length > 0) {
                // Initialize linked event maps for merging
                initializeLinkedEventMaps();

                // Load all metrics in parallel
                loadReactions();
                loadZaps();
                loadBoosts();
                loadComments();
                loadViews();
            } else {
                reactionsComplete = true;
                zapsComplete = true;
                boostsComplete = true;
                commentsComplete = true;
                viewsComplete = true;
                profilesComplete = true;
                processTrending(true);
            }
        });

        setTimeout(() => {
            if (trendingVideos.length > 0 && !hasResolved) {
                processTrending(true);
            }
        }, 1000);

        setTimeout(() => {
            if (!hasResolved) {
                videosComplete = true;
                reactionsComplete = true;
                zapsComplete = true;
                boostsComplete = true;
                commentsComplete = true;
                viewsComplete = true;
                profilesComplete = true;
                processTrending(true);
                hasResolved = true;
                resolve(trendingVideos);
            }
        }, 15000);
    });
}

// Helper function for incremental rendering
// Progressive rendering for trending videos - renders immediately, updates profiles in-place
// Limits to max 4 videos on homepage initially, with View More for expansion
function renderTrendingVideosIncremental(trendingVideos, renderedVideoIds) {
    const trendingGrid = document.getElementById('trendingGrid');
    if (!trendingGrid) return;

    // Remove skeleton loaders
    const skeletons = trendingGrid.querySelectorAll('.skeleton-card');
    skeletons.forEach(s => s.remove());

    const spinner = trendingGrid.querySelector('.spinner');
    if (spinner) {
        spinner.remove();
    }

    // Limit cards on homepage - 3 on mobile/tablet, 4 on desktop
    const isMobile = window.innerWidth <= 480;
    const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;
    const maxInitialCards = (isMobile || isTablet) ? 3 : 4;
    const videosToRender = trendingVideos.slice(0, maxInitialCards);

    // Find videos that need profiles loaded
    const newVideos = videosToRender.filter(v => !renderedVideoIds.has(v.id));
    const uncachedPubkeys = [...new Set(newVideos.map(v => v.pubkey).filter(pk => !profileCache.has(pk)))];

    // Render immediately with available data
    trendingGrid.innerHTML = '';

    const renderedCards = videosToRender.map((event, index) => {
        const profile = profileCache.get(event.pubkey);
        const reactions = reactionsCache.get(event.id);
        renderedVideoIds.add(event.id);
        return createVideoCard(event, profile, reactions, true);
    }).filter(card => card !== '');

    if (renderedCards.length > 0) {
        trendingGrid.innerHTML = renderedCards.join('');
        observeLazyCards();
        initializeCarousel();

        // Load profiles immediately for rendered trending videos only
        videosToRender.forEach(event => loadProfileAndUpdateCards(event.pubkey));

        // Load boosts for rendered trending videos only
        videosToRender.forEach(event => {
            if (!boostsCache.has(event.id)) {
                loadBoostsForVideo(event.id, (totalBoosts) => {
                    const card = document.getElementById(`video-card-${event.id}`);
                    if (!card) return;
                    const boostLevel = getBoostLevel(totalBoosts);
                    const isBoosted = boostLevel > 0;
                    if (isBoosted) {
                        card.classList.add('boosted', `boost-level-${boostLevel}`);
                        for (let i = 1; i <= 4; i++) {
                            if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                        }
                        const thumbnail = card.querySelector('.video-thumbnail');
                        if (thumbnail) {
                            const existingIndicator = thumbnail.querySelector('.boost-indicator');
                            const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                            if (existingIndicator) {
                                existingIndicator.outerHTML = indicatorHTML;
                            } else {
                                thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                            }
                        }
                    }
                });
            }
        });

        // Load views for rendered trending videos only
        const trendingIds = videosToRender.map(e => e.id);
        if (trendingIds.length > 0) {
            loadViewsForVideos(trendingIds, true);
        }
    } else if (trendingVideos.length === 0) {
        const periodText = currentTrendingPeriod === 'today' ? 'today' : 'this week';
        trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No trending videos ${periodText}.</p>`;
    }
}

// Optimized DOM-diffing render for trending videos - reuses existing DOM nodes
// Prevents re-rendering of already loaded cards when new videos are inserted
function renderTrendingVideosOptimized(trendingVideos, renderedVideoIds) {
    const trendingGrid = document.getElementById('trendingGrid');
    if (!trendingGrid) return;

    // Remove skeleton loaders first
    const skeletons = trendingGrid.querySelectorAll('.skeleton-card');
    skeletons.forEach(s => s.remove());

    const spinner = trendingGrid.querySelector('.spinner');
    if (spinner) spinner.remove();

    // Filter out videos that were removed due to validation (suspicious/ratioed)
    const validVideos = trendingVideos.filter(v => !trendingRemovedIds.has(v.id));

    // Limit cards on homepage - 3 on mobile/tablet, 4 on desktop
    const isMobile = window.innerWidth <= 480;
    const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;
    const maxInitialCards = (isMobile || isTablet) ? 3 : 4;
    const videosToRender = validVideos.slice(0, maxInitialCards);

    // Handle empty state
    if (videosToRender.length === 0) {
        const periodText = currentTrendingPeriod === 'today' ? 'today' : 'this week';
        trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No trending videos ${periodText}.</p>`;
        return;
    }

    // Build map of currently rendered cards in the DOM
    const existingCards = new Map();
    trendingGrid.querySelectorAll('.video-card').forEach(card => {
        const eventId = card.dataset.eventId || card.id.replace('video-card-', '');
        if (eventId) existingCards.set(eventId, card);
    });

    // Track which cards we need to keep (in order)
    const targetOrder = videosToRender.map(v => v.id);
    const cardsToRemove = new Set(existingCards.keys());
    const newCards = [];
    const cardsToUpdate = [];

    // Determine what needs to be created vs updated
    videosToRender.forEach((event, index) => {
        if (existingCards.has(event.id)) {
            // Card exists - mark for keeping and potential update
            cardsToRemove.delete(event.id);
            cardsToUpdate.push({ event, index });
        } else {
            // New card - needs to be created
            newCards.push({ event, index });
            renderedVideoIds.add(event.id);
        }
    });

    // Remove cards that are no longer in the top list
    cardsToRemove.forEach(eventId => {
        const card = existingCards.get(eventId);
        if (card) card.remove();
        existingCards.delete(eventId);
    });

    // Update existing cards in place (profiles, reactions, boost indicators)
    cardsToUpdate.forEach(({ event }) => {
        const profile = profileCache.get(event.pubkey);
        const reactions = reactionsCache.get(event.id);
        updateVideoCardInPlace(event.id, profile, reactions);
    });

    // Create new cards using DocumentFragment for batch insertion
    if (newCards.length > 0) {
        const fragment = document.createDocumentFragment();
        const tempContainer = document.createElement('div');

        newCards.forEach(({ event, index }) => {
            const profile = profileCache.get(event.pubkey);
            const reactions = reactionsCache.get(event.id);
            const cardHTML = createVideoCard(event, profile, reactions, true);
            if (cardHTML) {
                tempContainer.innerHTML = cardHTML;
                const cardElement = tempContainer.firstElementChild;
                if (cardElement) {
                    cardElement.dataset.targetIndex = index;
                    fragment.appendChild(cardElement);
                }
            }
        });

        // Append all new cards at once
        trendingGrid.appendChild(fragment);
    }

    // Reorder cards to match target order (only if order changed)
    const currentCards = Array.from(trendingGrid.querySelectorAll('.video-card'));
    const currentOrder = currentCards.map(c => c.dataset.eventId || c.id.replace('video-card-', ''));

    // Check if reordering is needed
    const needsReorder = !targetOrder.every((id, i) => currentOrder[i] === id);

    if (needsReorder && currentCards.length > 0) {
        // Use insertBefore for efficient DOM reordering
        targetOrder.forEach((eventId, targetIndex) => {
            const card = trendingGrid.querySelector(`[data-event-id="${eventId}"], #video-card-${eventId}`);
            if (card) {
                const currentIndex = Array.from(trendingGrid.children).indexOf(card);
                if (currentIndex !== targetIndex) {
                    const referenceNode = trendingGrid.children[targetIndex];
                    if (referenceNode && referenceNode !== card) {
                        trendingGrid.insertBefore(card, referenceNode);
                    }
                }
            }
        });
    }

    // Initialize lazy loading and carousel for any new cards
    if (newCards.length > 0) {
        observeLazyCards();
        initializeCarousel();

        // Load profiles for new videos only
        newCards.forEach(({ event }) => loadProfileAndUpdateCards(event.pubkey));

        // Load boosts for new videos only
        newCards.forEach(({ event }) => {
            if (!boostsCache.has(event.id)) {
                loadBoostsForVideo(event.id, (totalBoosts) => {
                    const card = document.getElementById(`video-card-${event.id}`);
                    if (!card) return;
                    const boostLevel = getBoostLevel(totalBoosts);
                    const isBoosted = boostLevel > 0;
                    if (isBoosted) {
                        card.classList.add('boosted', `boost-level-${boostLevel}`);
                        for (let i = 1; i <= 4; i++) {
                            if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                        }
                        const thumbnail = card.querySelector('.video-thumbnail');
                        if (thumbnail) {
                            const existingIndicator = thumbnail.querySelector('.boost-indicator');
                            const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                            if (existingIndicator) {
                                existingIndicator.outerHTML = indicatorHTML;
                            } else {
                                thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                            }
                        }
                    }
                });
            }
        });

        // Load views for new videos only
        const newVideoIds = newCards.map(({ event }) => event.id);
        if (newVideoIds.length > 0) {
            loadViewsForVideos(newVideoIds, true);
        }
    }
}

// Calculate how many cards fit in one row based on viewport width
function getCardsPerRow() {
    // Get actual content width, accounting for sidebar
    const mainContent = document.getElementById('mainContent');
    const contentWidth = mainContent ? mainContent.clientWidth : window.innerWidth;

    // Based on video-grid minmax(250px, 1fr) with 1rem (16px) gap
    // Calculate how many 250px cards fit with gaps
    const minCardWidth = 250;
    const gap = 16;

    // Calculate cards that fit: (contentWidth + gap) / (minCardWidth + gap)
    const cardsPerRow = Math.floor((contentWidth + gap) / (minCardWidth + gap));

    // Ensure at least 1 card, max 4 cards
    return Math.max(1, Math.min(cardsPerRow, 4));
}

// Calculate cards per row for shorts grid (uses smaller card widths)
function getShortsCardsPerRow() {
    const mainContent = document.getElementById('mainContent');
    const contentWidth = mainContent ? mainContent.clientWidth : window.innerWidth;

    // Shorts use minmax(180px, 1fr) on desktop, minmax(140px, 1fr) on mobile
    const isMobile = window.innerWidth <= 480;
    const minCardWidth = isMobile ? 140 : 180;
    const gap = isMobile ? 8 : 16;

    const cardsPerRow = Math.floor((contentWidth + gap) / (minCardWidth + gap));

    // Ensure at least 2 cards on mobile, max 6 cards
    return Math.max(2, Math.min(cardsPerRow, 6));
}

// Available topics for featured sections - Music, Gaming, Bitcoin
const FEATURED_TOPICS = [
    { tag: 'music', nameKey: 'nav.music', icon: '<path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>' },
    { tag: 'gaming', nameKey: 'nav.gaming', icon: '<path d="M15 7.5V2H9v5.5l3 3 3-3zM7.5 9H2v6h5.5l3-3-3-3zM9 16.5V22h6v-5.5l-3-3-3 3zM16.5 9l-3 3 3 3H22V9h-5.5z"/>' },
    { tag: 'bitcoin', nameKey: 'nav.bitcoin', icon: '<path d="M17.06 11.57c.59-.69.94-1.59.94-2.57 0-1.86-1.27-3.43-3-3.87V3h-2v2h-2V3H9v2H6v2h1c.55 0 1 .45 1 1v8c0 .55-.45 1-1 1H6v2h3v2h2v-2h2v2h2v-2.13c2.39-.54 4-2.65 4-5.07 0-1.37-.53-2.62-1.4-3.55M10 7h4c1.1 0 2 .9 2 2s-.9 2-2 2h-4V7zm5 10h-5v-4h5c1.1 0 2 .9 2 2s-.9 2-2 2z"/>' }
];

// Storage for section videos (to support View More expansion)
let cachedTrendingVideos = [];
// Track trending video IDs that were removed due to validation (suspicious/ratioed)
let trendingRemovedIds = new Set();
let cachedRecommendedVideos = [];
let cachedShorts = [];
let cachedFeaturedVideos = [[], [], []]; // One array per featured topic
let cachedLatestVideos = [];

// Cached shorts for non-homepage sections
let cachedFollowingShorts = [];
let cachedMyVideosShorts = [];
let cachedMyVideosLiveStreams = [];
let cachedLikedShorts = [];
let cachedSearchShorts = [];
let cachedDrafts = [];

// Track expanded state for each section
let sectionExpanded = {
    trending: false,
    recommended: false,
    shorts: false,
    featured1: false,
    featured2: false,
    featured3: false,
    latest: false,
    followingShorts: false,
    myVideosShorts: false,
    likedShorts: false,
    searchShorts: false,
    drafts: false
};

// Expand section to show more rows
async function expandSection(sectionType, index = 0) {
    // Use appropriate cards per row calculation based on section type
    const isShortSection = ['shorts', 'followingShorts', 'myVideosShorts', 'likedShorts', 'searchShorts'].includes(sectionType);
    const cardsPerRow = isShortSection ? getShortsCardsPerRow() : getCardsPerRow();

    let videos, gridId, containerId, initialRows, maxRows;

    switch (sectionType) {
        case 'trending':
            videos = cachedTrendingVideos;
            gridId = 'trendingGrid';
            containerId = 'trendingViewMore';
            initialRows = 1;
            maxRows = 4;
            sectionExpanded.trending = true;
            break;
        case 'recommended':
            videos = cachedRecommendedVideos;
            gridId = 'recommendedGrid';
            containerId = 'recommendedViewMore';
            initialRows = 1;
            maxRows = 4;
            sectionExpanded.recommended = true;
            break;
        case 'shorts':
            videos = cachedShorts;
            gridId = 'shortsGrid';
            containerId = 'shortsViewMore';
            initialRows = 1;
            maxRows = 3;
            sectionExpanded.shorts = true;
            break;
        case 'featured':
            videos = cachedFeaturedVideos[index];
            gridId = `featuredTopic${index + 1}Grid`;
            containerId = `featuredTopic${index + 1}ViewMoreContainer`;
            initialRows = 3;
            maxRows = 6;
            sectionExpanded[`featured${index + 1}`] = true;
            break;
        case 'latest':
            videos = cachedLatestVideos;
            gridId = 'videoGrid';
            containerId = 'latestViewMore';
            initialRows = 5;
            maxRows = 10;
            sectionExpanded.latest = true;
            break;
        case 'followingShorts':
            videos = cachedFollowingShorts;
            gridId = 'followingShortsGrid';
            containerId = 'followingShortsViewMore';
            initialRows = 1;
            maxRows = 3;
            sectionExpanded.followingShorts = true;
            break;
        case 'myVideosShorts':
            videos = cachedMyVideosShorts;
            gridId = 'myVideosShortsGrid';
            containerId = 'myVideosShortsViewMore';
            initialRows = 1;
            maxRows = 3;
            sectionExpanded.myVideosShorts = true;
            break;
        case 'likedShorts':
            videos = cachedLikedShorts;
            gridId = 'likedShortsGrid';
            containerId = 'likedShortsViewMore';
            initialRows = 1;
            maxRows = 3;
            sectionExpanded.likedShorts = true;
            break;
        case 'searchShorts':
            videos = cachedSearchShorts;
            gridId = 'searchShortsGrid';
            containerId = 'searchShortsViewMore';
            initialRows = 1;
            maxRows = 3;
            sectionExpanded.searchShorts = true;
            break;
        case 'drafts':
            videos = cachedDrafts;
            gridId = 'draftsGrid';
            containerId = 'draftsViewMore';
            initialRows = 1;
            maxRows = 4;
            sectionExpanded.drafts = true;
            break;
        case 'liveNow':
            // Handle live streams specially
            await expandLiveNowSection();
            return;
        default:
            return;
    }

    const grid = document.getElementById(gridId);
    const container = document.getElementById(containerId);

    if (!grid || !videos || videos.length === 0) return;

    // Get IDs of already displayed cards to avoid duplicates
    const displayedCards = grid.querySelectorAll('.video-card:not(.skeleton-card), .short-card:not(.skeleton-card), .draft-card:not(.skeleton-card)');
    const displayedIds = new Set();
    displayedCards.forEach(card => {
        const eventId = card.dataset.eventId || card.id.replace('video-card-', '').replace('draft-', '');
        if (eventId) displayedIds.add(eventId);
    });

    const totalToShow = cardsPerRow * maxRows;

    // Get videos that should be shown (up to totalToShow) but aren't displayed yet
    const videosToConsider = videos.slice(0, totalToShow);
    const newVideos = videosToConsider.filter(v => !displayedIds.has(v.id));

    if (newVideos.length === 0) {
        // No new videos to show, just hide the button
        if (container) container.style.display = 'none';
        return;
    }

    // Find uncached profile pubkeys
    const uncachedPubkeys = [...new Set(newVideos.map(v => v.pubkey).filter(pk => !profileCache.has(pk)))];

    // Create cards immediately with available profile data
    const newCards = newVideos.map((event, idx) => {
        // Handle drafts specially - they have different structure
        if (sectionType === 'drafts') {
            const draftId = event.id;
            return createDraftCard(draftId, event);
        }

        const profile = profileCache.get(event.pubkey);
        const reactions = reactionsCache.get(event.id);
        // Use createShortCard for shorts sections, createVideoCard for others
        const shortsTypes = ['shorts', 'followingShorts', 'myVideosShorts', 'likedShorts', 'searchShorts'];
        if (shortsTypes.includes(sectionType)) {
            // Show owner actions for myVideosShorts
            const showOwnerActions = sectionType === 'myVideosShorts';
            return createShortCard(event, profile, reactions, showOwnerActions);
        }
        return createVideoCard(event, profile, reactions, sectionType === 'trending');
    }).filter(card => card !== '');

    // Append new cards to the grid (don't replace existing ones)
    if (newCards.length > 0) {
        grid.insertAdjacentHTML('beforeend', newCards.join(''));
        observeLazyCards();

        // Load profiles immediately for new cards
        newVideos.forEach(event => loadProfileAndUpdateCards(event.pubkey));

        // Load boosts for new cards
        newVideos.forEach(event => {
            if (!boostsCache.has(event.id)) {
                loadBoostsForVideo(event.id, (totalBoosts) => {
                    const card = document.getElementById(`video-card-${event.id}`);
                    if (!card) return;
                    const boostLevel = getBoostLevel(totalBoosts);
                    const isBoosted = boostLevel > 0;
                    if (isBoosted) {
                        card.classList.add('boosted', `boost-level-${boostLevel}`);
                        for (let i = 1; i <= 4; i++) {
                            if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                        }
                        const thumbnail = card.querySelector('.video-thumbnail');
                        if (thumbnail) {
                            const existingIndicator = thumbnail.querySelector('.boost-indicator');
                            const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                            if (existingIndicator) {
                                existingIndicator.outerHTML = indicatorHTML;
                            } else {
                                thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                            }
                        }
                    }
                });
            }
        });
    }

    // Hide the View More container after expanding
    if (container) {
        container.style.display = 'none';
    }
}

// Load home feed with grid-based sections
async function loadHomeFeed() {
    currentView = 'home';

    // Reset caches and expanded state for fresh load
    cachedTrendingVideos = [];
    trendingRemovedIds = new Set();
    cachedRecommendedVideos = [];
    cachedShorts = [];
    cachedFeaturedVideos = [[], [], []];
    cachedLatestVideos = [];
    sectionExpanded = {
        trending: false,
        recommended: false,
        shorts: false,
        featured1: false,
        featured2: false,
        featured3: false,
        latest: false
    };

    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const shortsCardsPerRow = getShortsCardsPerRow();

    // Generate skeleton loaders
    // Trending section has a max of 4 cards on desktop, 3 on mobile/tablet
    const isMobile = window.innerWidth <= 480;
    const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;
    const trendingSkeletonCount = (isMobile || isTablet) ? 3 : 4;
    const trendingSkeletons = Array(trendingSkeletonCount).fill(createSkeletonCard()).join('');
    const oneRowSkeletons = Array(cardsPerRow).fill(createSkeletonCard()).join('');
    const threeRowSkeletons = Array(cardsPerRow * 3).fill(createSkeletonCard()).join('');
    const fiveRowSkeletons = Array(cardsPerRow * 5).fill(createSkeletonCard()).join('');
    const shortSkeletons = Array(shortsCardsPerRow).fill(createShortSkeletonCard()).join('');

    mainContent.innerHTML = `
        <!-- Trending Section - 1 row -->
        <div class="home-section" id="trendingSection">
            <div class="home-section-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.48,12.35c-1.57-4.08-7.16-4.3-5.81-10.23c0.1-0.44-0.37-0.78-0.75-0.55C9.29,3.71,6.68,8,8.87,13.62 c0.18,0.46-0.36,0.89-0.75,0.59c-1.81-1.37-2-3.34-1.84-4.75c0.06-0.52-0.62-0.77-0.91-0.34C4.69,10.16,4,11.84,4,14.37 c0.38,5.6,5.11,7.32,6.81,7.54c2.43,0.31,5.06-0.14,6.95-1.87C19.84,18.11,20.6,15.03,19.48,12.35z"/>
                    </svg>
                    ${t('section.trending')}
                </h2>
                <div class="trending-tabs">
                    <button class="trending-tab ${currentTrendingPeriod === 'week' ? 'active' : ''}"
                            onclick="switchTrendingPeriod('week')">${t('trending.thisWeek')}</button>
                    <button class="trending-tab ${currentTrendingPeriod === 'today' ? 'active' : ''}"
                            onclick="switchTrendingPeriod('today')">${t('trending.today')}</button>
                </div>
            </div>
            <div class="video-grid" id="trendingGrid">
                ${trendingSkeletons}
            </div>
            <div class="view-more-container" id="trendingViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('trending')">${t('button.viewMore')}</button>
            </div>
        </div>

        <!-- Recommended Section - 1 row -->
        <div class="home-section" id="recommendedSection" style="display: none;">
            <div class="home-section-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    ${t('section.recommended')}
                </h2>
            </div>
            <div class="video-grid" id="recommendedGrid">
                <div class="spinner"></div>
            </div>
            <div class="view-more-container" id="recommendedViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('recommended')">${t('button.viewMore')}</button>
            </div>
        </div>

        <!-- Shorts Section - 1 row of vertical videos -->
        <div class="home-section" id="shortsSection" style="display: none;">
            <div class="home-section-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                        <path d="M10 8l6 4-6 4V8z"/>
                    </svg>
                    ${t('section.shorts')}
                </h2>
            </div>
            <div class="shorts-grid" id="shortsGrid">
                ${shortSkeletons}
            </div>
            <div class="view-more-container" id="shortsViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('shorts')">${t('button.viewMore')}</button>
            </div>
        </div>

        <!-- Live Section - 1 row (moved below Shorts) -->
        <div class="home-section" id="liveNowSection" style="display: none;">
            <div class="home-section-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <circle cx="12" cy="12" r="4" fill="#f44336"/>
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                    </svg>
                    ${t('section.live')}
                </h2>
            </div>
            <div class="video-grid" id="liveNowGrid">
                <div class="spinner"></div>
            </div>
            <div class="view-more-container" id="liveNowViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('liveNow')">${t('button.viewMore')}</button>
            </div>
        </div>

        <!-- Featured Topic 1 (Music) - 3 rows -->
        <div class="home-section" id="featuredTopic1Section" style="display: none;">
            <div class="home-section-header">
                <h2 id="featuredTopic1Title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="featuredTopic1Icon"></svg>
                    <span id="featuredTopic1Name"></span>
                </h2>
            </div>
            <div class="video-grid" id="featuredTopic1Grid">
                ${threeRowSkeletons}
            </div>
            <div class="view-more-container" id="featuredTopic1ViewMoreContainer" style="display: none;">
                <button class="action-btn view-more-btn" id="featuredTopic1ViewMore">${t('button.viewMore')}</button>
            </div>
        </div>

        <!-- Featured Topic 2 (Gaming) - 3 rows -->
        <div class="home-section" id="featuredTopic2Section" style="display: none;">
            <div class="home-section-header">
                <h2 id="featuredTopic2Title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="featuredTopic2Icon"></svg>
                    <span id="featuredTopic2Name"></span>
                </h2>
            </div>
            <div class="video-grid" id="featuredTopic2Grid">
                ${threeRowSkeletons}
            </div>
            <div class="view-more-container" id="featuredTopic2ViewMoreContainer" style="display: none;">
                <button class="action-btn view-more-btn" id="featuredTopic2ViewMore">${t('button.viewMore')}</button>
            </div>
        </div>

        <!-- Featured Topic 3 (Bitcoin) - 3 rows -->
        <div class="home-section" id="featuredTopic3Section" style="display: none;">
            <div class="home-section-header">
                <h2 id="featuredTopic3Title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="featuredTopic3Icon"></svg>
                    <span id="featuredTopic3Name"></span>
                </h2>
            </div>
            <div class="video-grid" id="featuredTopic3Grid">
                ${threeRowSkeletons}
            </div>
            <div class="view-more-container" id="featuredTopic3ViewMoreContainer" style="display: none;">
                <button class="action-btn view-more-btn" id="featuredTopic3ViewMore">${t('button.viewMore')}</button>
            </div>
        </div>

        <!-- Latest Videos - 5 rows -->
        <div class="home-section">
            <div class="home-section-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                    </svg>
                    ${t('section.latestVideos')}
                </h2>
            </div>
            <div class="video-grid" id="videoGrid">
                ${fiveRowSkeletons}
            </div>
            <div class="view-more-container" id="latestViewMore">
                <button class="action-btn view-more-btn" onclick="expandSection('latest')">${t('button.viewMore')}</button>
            </div>
        </div>
    `;

    // Load all sections
    loadTrendingSectionGrid();
    refreshRecommendedSectionGrid();
    loadShortsSection();
    loadLiveNowSection(); // After Shorts section
    loadFeaturedTopics();
    loadLatestVideosSection();
}

// Load trending section as a grid (1 row, max 4 cards)
// Note: loadTrendingVideos uses renderTrendingVideosOptimized for DOM-diffing updates
// This function just needs to handle caching and view more button
async function loadTrendingSectionGrid() {
    const trendingGrid = document.getElementById('trendingGrid');
    const viewMoreBtn = document.getElementById('trendingViewMore');
    // Limit cards on homepage - 3 on mobile, 4 on desktop
    const isMobile = window.innerWidth <= 480;
    const maxTrendingCards = isMobile ? 3 : 4;

    try {
        // loadTrendingVideos already renders progressively as data arrives
        const trendingVideos = await loadTrendingVideos(currentTrendingPeriod);

        if (trendingVideos.length === 0) {
            // Only show message if not already rendered by progressive rendering
            // Use :not(.skeleton-card) to exclude skeleton loaders from the check
            if (!trendingGrid.querySelector('.video-card:not(.skeleton-card)')) {
                const periodText = currentTrendingPeriod === 'today' ? 'today' : 'this week';
                trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No trending videos ${periodText}.</p>`;
            }
            return;
        }

        // Cache all trending videos for View More expansion
        cachedTrendingVideos = trendingVideos;

        // Show View More if there are more videos than max cards shown
        if (trendingVideos.length > maxTrendingCards && viewMoreBtn) {
            viewMoreBtn.style.display = 'block';
        }
    } catch (error) {
        console.error('Failed to load trending videos:', error);
        if (!trendingGrid.querySelector('.video-card')) {
            trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.failedLoadTrending')}</p>`;
        }
    }
}

// Cache for live streams for View More expansion
let cachedLiveStreams = [];

// Load Live section for homepage - shows active live streams
async function loadLiveNowSection() {
    const liveNowSection = document.getElementById('liveNowSection');
    const liveNowGrid = document.getElementById('liveNowGrid');
    const viewMoreBtn = document.getElementById('liveNowViewMore');

    if (!liveNowSection || !liveNowGrid) return;

    const cardsPerRow = getCardsPerRow();
    const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;
    // Show 3 cards on tablet, 4 on desktop
    const maxInitialCards = isTablet ? 3 : 4;

    const filter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        '#t': ['pv69420'],
        limit: 50
    };

    const liveStreams = [];

    requestEventsStream(filter, (event) => {
        const liveData = parseLiveEvent(event);
        if (liveData && isLiveStreamActive(liveData)) {
            liveStreams.push({ event, liveData });
            allEvents.set(event.id, event);
        }
    }, async () => {
        if (liveStreams.length === 0) {
            liveNowSection.style.display = 'none';
            return;
        }

        // Show section and render live stream cards
        liveNowSection.style.display = 'block';
        liveNowGrid.innerHTML = '';

        // Sort by viewer count (most viewers first)
        liveStreams.sort((a, b) => (b.liveData.currentParticipants || 0) - (a.liveData.currentParticipants || 0));

        // Cache for View More
        cachedLiveStreams = liveStreams;

        // Show up to maxInitialCards live streams initially
        const streamsToShow = liveStreams.slice(0, maxInitialCards);
        const liveEventIds = [];

        for (const { event, liveData } of streamsToShow) {
            const profile = await fetchUserProfile(event.pubkey);
            const card = createLiveStreamCard(event, liveData, profile);
            liveNowGrid.insertAdjacentHTML('beforeend', card);
            liveEventIds.push(event.id);
        }

        // Load actual viewer counts for live streams
        if (liveEventIds.length > 0) {
            loadLiveStreamCardsViewers(liveEventIds);
            // Load boosts for live streams
            liveEventIds.forEach(id => {
                if (!boostsCache.has(id)) {
                    loadBoostsForVideo(id);
                }
            });
        }

        // Show View More button if there are more streams
        if (liveStreams.length > maxInitialCards && viewMoreBtn) {
            viewMoreBtn.style.display = 'block';
        }
    });
}

// Expand Live section to show more streams
async function expandLiveNowSection() {
    const liveNowGrid = document.getElementById('liveNowGrid');
    const viewMoreBtn = document.getElementById('liveNowViewMore');
    const cardsPerRow = getCardsPerRow();

    if (!liveNowGrid || !cachedLiveStreams || cachedLiveStreams.length === 0) return;

    const initialCount = cardsPerRow;
    const maxCount = cardsPerRow * 3; // Show up to 3 rows

    // Get streams to add (skip already displayed)
    const streamsToAdd = cachedLiveStreams.slice(initialCount, maxCount);
    const liveEventIds = [];

    for (const { event, liveData } of streamsToAdd) {
        const profile = await fetchUserProfile(event.pubkey);
        const card = createLiveStreamCard(event, liveData, profile);
        liveNowGrid.insertAdjacentHTML('beforeend', card);
        liveEventIds.push(event.id);
    }

    // Load actual viewer counts for newly added streams
    if (liveEventIds.length > 0) {
        loadLiveStreamCardsViewers(liveEventIds);
        // Load boosts for live streams
        liveEventIds.forEach(id => {
            if (!boostsCache.has(id)) {
                loadBoostsForVideo(id);
            }
        });
    }

    // Hide View More button after expanding
    if (viewMoreBtn) {
        viewMoreBtn.style.display = 'none';
    }

    sectionExpanded.liveNow = true;
}

// Refresh recommended section as a grid (1 row)
// Uses progressive rendering - displays videos as they arrive
async function refreshRecommendedSectionGrid() {
    const history = getWatchHistory();
    const recommendedSection = document.getElementById('recommendedSection');
    const recommendedGrid = document.getElementById('recommendedGrid');
    const viewMoreBtn = document.getElementById('recommendedViewMore');
    const cardsPerRow = getCardsPerRow();

    if (history.length < RECOMMENDATION_THRESHOLD) {
        recommendedSection.style.display = 'none';
        return;
    }

    // Don't show section yet - wait until we know we have recommendations
    try {
        const recommendedIds = await getRecommendations(cardsPerRow * 2);

        if (recommendedIds.length === 0) {
            recommendedSection.style.display = 'none';
            return;
        }

        // Keep section hidden until we have actual videos to show
        // (some recommended IDs may be legacy events that get filtered)

        const videoFilter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            ids: recommendedIds
        };

        const videos = [];
        const renderedIds = new Set();
        let hasCleared = false;
        let renderTimeout = null;
        let firstRenderDone = false;

        // Order map for sorting by recommendation order
        const orderMap = new Map(recommendedIds.map((id, i) => [id, i]));

        // Progressive render function
        const renderProgressively = () => {
            if (videos.length === 0) return;

            // Sort by recommendation order
            const sortedVideos = [...videos].sort((a, b) =>
                (orderMap.get(a.id) ?? 999) - (orderMap.get(b.id) ?? 999)
            );
            const videosToShow = sortedVideos.slice(0, cardsPerRow);

            // Show section and clear spinner on first render
            if (!hasCleared && videosToShow.length > 0) {
                hasCleared = true;
                recommendedSection.style.display = 'block';
                recommendedGrid.innerHTML = '';
            }

            // Render new cards
            videosToShow.forEach(event => {
                if (renderedIds.has(event.id)) return;
                renderedIds.add(event.id);

                const profile = profileCache.get(event.pubkey);
                const reactions = reactionsCache.get(event.id);
                // First row loads immediately (non-lazy)
                const isFirstRow = renderedIds.size <= cardsPerRow;
                const cardHtml = createVideoCard(event, profile, reactions, false, null, !isFirstRow);

                if (cardHtml) {
                    recommendedGrid.insertAdjacentHTML('beforeend', cardHtml);

                    // Load profile immediately if not cached
                    loadProfileAndUpdateCards(event.pubkey);
                }
            });

            observeLazyCards();
            firstRenderDone = true;
        };

        // Debounced render (immediate on first event)
        const scheduleRender = () => {
            if (renderTimeout) clearTimeout(renderTimeout);
            if (!firstRenderDone) {
                renderProgressively();
            } else {
                renderTimeout = setTimeout(renderProgressively, 50);
            }
        };

        // Stream events and render progressively
        requestEventsStream(videoFilter, (event) => {
            allEvents.set(event.id, event);

            // Remove any legacy counterpart that was already added (handles race condition)
            removeLegacyCounterpart(event, videos, renderedIds);

            // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
            if (shouldSkipLegacyEvent(event)) return;

            // Skip shorts - they're shown in the dedicated Shorts section
            if (isNip71ShortKind(event.kind)) return;

            // Never show logged-in user's own videos in recommendations
            if (currentUser && event.pubkey === currentUser.pubkey) return;

            // Skip videos that match content filter packs or custom keywords
            const videoData = parseNip71VideoEvent(event) || parseVideoEvent(event);
            if (videoData) {
                const filterResult = shouldFilterVideoContent(event, videoData);
                if (filterResult.filtered) return;
            }

            videos.push(event);
            scheduleRender();
        }, () => {
            // On completion
            clearTimeout(renderTimeout);
            renderProgressively();

            if (videos.length === 0) {
                recommendedSection.style.display = 'none';
                return;
            }

            // Sort and cache all videos
            videos.sort((a, b) => (orderMap.get(a.id) ?? 999) - (orderMap.get(b.id) ?? 999));
            cachedRecommendedVideos = videos;

            // Load views for recommended videos
            const recommendedIds = videos.map(e => e.id);
            if (recommendedIds.length > 0) {
                loadViewsForVideos(recommendedIds, true);
            }

            // Show View More if more videos available
            if (videos.length > cardsPerRow && viewMoreBtn) {
                viewMoreBtn.style.display = 'block';
            }
        });
    } catch (error) {
        console.error('Error loading recommendations:', error);
        recommendedSection.style.display = 'none';
    }
}

// Load shorts section (kind 22 vertical videos)
async function loadShortsSection() {
    const shortsSection = document.getElementById('shortsSection');
    const shortsGrid = document.getElementById('shortsGrid');
    const viewMoreBtn = document.getElementById('shortsViewMore');
    const cardsPerRow = getShortsCardsPerRow();
    const isMobile = window.innerWidth <= 480;
    const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;

    if (!shortsSection || !shortsGrid) return;

    const filter = {
        kinds: [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY],
        '#t': ['pv69420'],
        limit: cardsPerRow * 3 // Fetch enough for 3 rows
    };

    const videos = [];
    let renderedCount = 0;
    // Show 4 shorts on mobile/tablet, 6 on desktop
    const maxInitialDisplay = (isMobile || isTablet) ? 4 : 6;

    // Queue for batch loading reactions and boosts
    const reactionQueue = new Set();
    const boostQueue = new Set();
    let reactionTimer = null;
    let boostTimer = null;

    const loadReactionsBatch = async () => {
        if (reactionQueue.size === 0) return;
        const videoIds = Array.from(reactionQueue);
        reactionQueue.clear();
        await loadReactionsForVideos(videoIds);
    };

    const loadBoostsBatch = async () => {
        if (boostQueue.size === 0) return;
        const videoIds = Array.from(boostQueue);
        boostQueue.clear();
        await loadBoostsForVideos(videoIds);
    };

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            // Parse the event
            const videoData = parseNip71VideoEvent(event);
            if (!videoData) return;

            allEvents.set(event.id, event);

            // Remove any legacy counterpart that was already added (handles race condition)
            // Count rendered cards that will be removed so we can decrement renderedCount
            if (event.kind === NIP71_SHORT_KIND) {
                const dTag = event.tags?.find(t => t[0] === 'd')?.[1];
                if (dTag) {
                    // Check for kind 22 legacy event
                    const legacyEvent = videos.find(v =>
                        v.kind === NIP71_SHORT_KIND_LEGACY &&
                        v.pubkey === event.pubkey &&
                        v.tags?.find(t => t[0] === 'd')?.[1] === dTag
                    );
                    if (legacyEvent && document.getElementById(`video-card-${legacyEvent.id}`)) {
                        renderedCount--;
                    }
                    // Check for kind 1 event with nip71-d tag
                    const kind1Event = videos.find(v =>
                        v.kind === 1 &&
                        v.pubkey === event.pubkey &&
                        v.tags?.find(t => t[0] === 'nip71-d')?.[1] === dTag
                    );
                    if (kind1Event && document.getElementById(`video-card-${kind1Event.id}`)) {
                        renderedCount--;
                    }
                }
            }
            removeLegacyCounterpart(event, videos);

            // Skip legacy events (kind 1/22) if addressable counterpart (kind 34236) exists
            if (shouldSkipLegacyEvent(event)) return;

            videos.push(event);

            // Progressive rendering for first row
            if (renderedCount < maxInitialDisplay) {
                // Clear skeletons on first video
                if (renderedCount === 0) {
                    shortsGrid.innerHTML = '';
                    shortsSection.style.display = 'block';
                }

                const profile = profileCache.get(event.pubkey);
                const reactions = reactionsCache.get(event.id);
                const card = createShortCard(event, profile, reactions);

                if (card) {
                    shortsGrid.insertAdjacentHTML('beforeend', card);
                    renderedCount++;
                    loadProfileAndUpdateCards(event.pubkey);

                    // Queue reactions and boosts loading
                    reactionQueue.add(event.id);
                    boostQueue.add(event.id);
                    clearTimeout(reactionTimer);
                    clearTimeout(boostTimer);
                    reactionTimer = setTimeout(loadReactionsBatch, 200);
                    boostTimer = setTimeout(loadBoostsBatch, 200);
                }
            }
        }, () => {
            // EOSE - finalize
            if (videos.length === 0) {
                // No shorts found, hide section
                shortsSection.style.display = 'none';
                resolve();
                return;
            }

            // Sort by newest first
            videos.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            cachedShorts = videos;

            // Show View More if there are more shorts
            if (videos.length > cardsPerRow && viewMoreBtn) {
                viewMoreBtn.style.display = 'block';
            }

            // Final batch load for any remaining queued items
            if (reactionQueue.size > 0) loadReactionsBatch();
            if (boostQueue.size > 0) loadBoostsBatch();

            // Load views for shorts
            const shortIds = videos.map(e => e.id);
            if (shortIds.length > 0) {
                loadViewsForVideos(shortIds, true);
            }

            observeLazyCards();
            resolve();
        });
    });
}

// Create a short card (vertical video format)
function createShortCard(event, profile, reactions, showOwnerActions = false) {
    const videoData = parseNip71VideoEvent(event);
    if (!videoData) return '';

    // Check if content from this user should be hidden (muted)
    if (shouldHideMutedContent(event.pubkey)) {
        return '';
    }

    // Check if content matches enabled filter packs
    const filterResult = shouldFilterVideoContent(event, videoData);
    if (filterResult.filtered) {
        return createFilteredContentPlaceholder(event, filterResult, 'video');
    }

    const title = videoData.title || 'Untitled Short';
    const thumbnailUrl = videoData.thumbnail || '';
    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';

    // Check NSFW and community warning states
    const isNSFW = videoData.isNSFW || false;
    const isRatioed = isVideoRatioed(reactions || {});

    // Track whether profile has been checked
    const profileChecked = profileCache.has(event.pubkey);
    const isSuspiciousProfile = profileChecked && (!profile || !avatarUrl || !nip05);

    // Get boost data from cache
    const boostAmount = boostsCache.get(event.id) || 0;
    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;

    // Determine what type of overlay to show (skip for own videos)
    const isOwnVideo = currentUser?.pubkey === event.pubkey;
    const showNSFWOverlay = !isOwnVideo && isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own videos)
    const isReportedByFollowsCheck = !isOwnVideo && isReportedByFollowsSync(event.id, event.pubkey);
    const showCommunityWarning = !isOwnVideo && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning();
    const showBlurred = showNSFWOverlay || showCommunityWarning;
    const overlayType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    const cardId = `video-card-${event.id}`;

    return `
        <div class="video-card short-card ${isBoosted ? `boosted boost-level-${boostLevel}` : ''}" id="${cardId}" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-validation-pending="${avatarUrl || nip05 ? 'true' : 'false'}"${videoData.preview ? ' data-has-preview="true"' : ''}>
            <div class="video-thumbnail short-thumbnail ${showBlurred ? overlayType : ''}"
                 onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${event.id}')` : `showRatioedModal('${event.id}')`) : `navigateTo('/video/${event.id}')`}">
                ${thumbnailUrl ? `<img class="thumbnail-img" src="${thumbnailUrl}" data-original-src="${thumbnailUrl}" alt="${escapeHtml(title)}" loading="lazy" onload="cacheLoadedImage(this)">` : '<div class="thumbnail-placeholder"></div>'}
                ${videoData.preview ? `<img class="preview-img" src="${videoData.preview}" data-original-src="${videoData.preview}" alt="${escapeHtml(title)} preview" style="display:none;" onload="this.classList.add('loaded'); cacheLoadedImage(this)">` : ''}
                ${showBlurred ? `
                    <div class="${overlayType}-overlay">
                        <div class="${overlayType}-badge">${overlayType === 'nsfw' ? t('badge.nsfw') : t('badge.communityWarning')}</div>
                        <div>Click to view</div>
                    </div>
                ` : ''}
                ${isBoosted ? `
                    <div class="boost-indicator">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                        </svg>
                        ${formatSats(boostAmount)}
                    </div>
                ` : ''}
                ${!showBlurred && videoData.duration ? `<span class="video-duration">${formatDuration(videoData.duration)}</span>` : ''}
                ${reactions && (reactions.likes > 0 || reactions.dislikes > 0) ? `
                    <div class="video-reactions">
                        ${reactions.likes > 0 ? `
                            <span class="reaction-count likes">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                                </svg>
                                ${formatNumber(reactions.likes)}
                            </span>
                        ` : ''}
                        ${reactions.dislikes > 0 ? `
                            <span class="reaction-count dislikes">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                                </svg>
                                ${formatNumber(reactions.dislikes)}
                            </span>
                        ` : ''}
                    </div>
                ` : ''}
                ${showOwnerActions ? `
                    <div class="video-owner-actions">
                        ${(event.kind === NIP71_VIDEO_KIND || event.kind === NIP71_SHORT_KIND) ? `
                            <button class="owner-edit-btn" onclick="event.stopPropagation(); showEditVideoModal('${event.id}')" title="${t('button.editShort')}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                                </svg>
                            </button>
                        ` : ''}
                        <button class="owner-delete-btn" onclick="event.stopPropagation(); handleDelete('${event.id}')" title="${t('button.deleteShort')}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                        </button>
                    </div>
                ` : ''}
            </div>
            <div class="video-info">
                <a href="#/profile/${event.pubkey}" class="channel-info">
                    <div class="channel-avatar">
                        ${avatarUrl ? `<img src="${escapeHtml(avatarUrl)}" alt="${escapeHtml(displayName)}" loading="lazy"
                             onerror="this.style.display='none'"
                             data-avatar-url="${escapeHtml(avatarUrl)}">` : ''}
                    </div>
                    <div class="channel-details">
                        <div class="channel-name">${escapeHtml(displayName)}</div>
                        ${nip05 ? `<div class="channel-nip05" data-nip05="${nip05}">${nip05}</div>` : ''}
                    </div>
                </a>
                <h3 class="video-title" onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${event.id}')` : `showRatioedModal('${event.id}')`) : `navigateTo('/video/${event.id}')`}">${escapeHtml(title)}</h3>
                <div class="video-meta">
                    ${formatTimestamp(event.created_at)}
                    <span class="video-views" data-event-id="${event.id}">${(() => { const c = getCachedViewCount(event.id); return c !== null ? ` • ${formatNumber(c)} ${t('stat.views')}` : ''; })()}</span>
                    ${isNSFW ? ' • <span style="color: #ff0000;">NSFW</span>' : ''}
                    <span class="community-warning-indicator" style="${showCommunityWarning && !showNSFWOverlay ? '' : 'display: none;'}"> • <span style="color: #ff9800;">Community Warning</span></span>
                </div>
            </div>
        </div>
    `;
}

// Load featured topics (Gaming, Music, Podcasts)
// Uses progressive rendering - loads all topics in parallel and displays as videos arrive
async function loadFeaturedTopics() {
    const cardsPerRow = getCardsPerRow();
    const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;
    // Show 12 cards per topic on desktop, 9 on tablet, dynamic on mobile
    const videosPerTopic = isTablet ? 9 : (window.innerWidth <= 480 ? cardsPerRow * 3 : 12);

    // Load a single featured topic with progressive rendering
    const loadFeaturedTopic = (topic, index) => {
        const sectionId = `featuredTopic${index + 1}Section`;
        const gridId = `featuredTopic${index + 1}Grid`;
        const iconId = `featuredTopic${index + 1}Icon`;
        const nameId = `featuredTopic${index + 1}Name`;
        const viewMoreId = `featuredTopic${index + 1}ViewMore`;
        const viewMoreContainerId = `featuredTopic${index + 1}ViewMoreContainer`;

        const section = document.getElementById(sectionId);
        const grid = document.getElementById(gridId);
        const iconEl = document.getElementById(iconId);
        const nameEl = document.getElementById(nameId);
        const viewMoreBtn = document.getElementById(viewMoreId);
        const viewMoreContainer = document.getElementById(viewMoreContainerId);

        if (!section || !grid) return;

        // Set topic info
        iconEl.innerHTML = topic.icon;
        nameEl.textContent = t(topic.nameKey);
        // Set up View More to expand section
        viewMoreBtn.onclick = () => expandSection('featured', index);

        const videos = [];
        const renderedIds = new Set();
        let hasCleared = false;
        let renderTimeout = null;
        let firstRenderDone = false;

        // Progressive render function
        const renderProgressively = () => {
            const minVideos = Math.min(4, videosPerTopic);
            if (videos.length < minVideos) return; // Wait for minimum videos

            // Sort by timestamp (newest first)
            const sortedVideos = [...videos].sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            const videosToShow = sortedVideos.slice(0, videosPerTopic);

            // Clear skeleton loaders on first render
            if (!hasCleared && videosToShow.length >= minVideos) {
                hasCleared = true;
                grid.innerHTML = '';
                section.style.display = 'block';
            }

            if (!hasCleared) return;

            // Render new cards
            videosToShow.forEach(event => {
                if (renderedIds.has(event.id)) return;
                renderedIds.add(event.id);

                const profile = profileCache.get(event.pubkey);
                const reactions = reactionsCache.get(event.id);
                // First row loads immediately (non-lazy)
                const isFirstRow = renderedIds.size <= videosPerTopic;
                const cardHtml = createVideoCard(event, profile, reactions, false, null, !isFirstRow);

                if (cardHtml) {
                    // Insert in sorted position
                    const existingCards = grid.querySelectorAll('.video-card');
                    let inserted = false;

                    for (const existingCard of existingCards) {
                        const existingEventId = existingCard.id.replace('video-card-', '');
                        const existingEvent = allEvents.get(existingEventId);
                        if (existingEvent && (event.created_at || 0) > (existingEvent.created_at || 0)) {
                            existingCard.insertAdjacentHTML('beforebegin', cardHtml);
                            inserted = true;
                            break;
                        }
                    }

                    if (!inserted) {
                        grid.insertAdjacentHTML('beforeend', cardHtml);
                    }

                    // Load profile immediately if not cached
                    loadProfileAndUpdateCards(event.pubkey);

                    // Load boosts if not cached (fire-and-forget)
                    if (!boostsCache.has(event.id)) {
                        loadBoostsForVideo(event.id, (totalBoosts) => {
                            const card = document.getElementById(`video-card-${event.id}`);
                            if (!card) return;
                            const boostLevel = getBoostLevel(totalBoosts);
                            const isBoosted = boostLevel > 0;
                            if (isBoosted) {
                                card.classList.add('boosted', `boost-level-${boostLevel}`);
                                for (let i = 1; i <= 4; i++) {
                                    if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                                }
                                const thumbnail = card.querySelector('.video-thumbnail');
                                if (thumbnail) {
                                    const existingIndicator = thumbnail.querySelector('.boost-indicator');
                                    const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                                    if (existingIndicator) {
                                        existingIndicator.outerHTML = indicatorHTML;
                                    } else {
                                        thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                                    }
                                }
                            }
                        });
                    }
                }
            });

            observeLazyCards();
            firstRenderDone = true;
        };

        // Debounced render (immediate on first event with enough videos)
        const scheduleRender = () => {
            if (renderTimeout) clearTimeout(renderTimeout);
            if (!firstRenderDone && videos.length >= 4) {
                renderProgressively();
            } else {
                renderTimeout = setTimeout(renderProgressively, 50);
            }
        };

        const filter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            limit: 200
        };

        // Stream events and render progressively
        requestEventsStream(filter, (event) => {
            // Check if video has this tag
            const tags = event.tags || [];
            const hasTag = tags.some(t => t[0] === 't' && t[1].toLowerCase() === topic.tag);
            if (hasTag) {
                allEvents.set(event.id, event);

                // Remove any legacy counterpart that was already added (handles race condition)
                removeLegacyCounterpart(event, videos, renderedIds);

                // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
                if (shouldSkipLegacyEvent(event)) return;

                // Skip shorts - they're shown in the dedicated Shorts section
                if (isNip71ShortKind(event.kind)) return;

                videos.push(event);
                scheduleRender();
            }
        }, () => {
            // On completion
            clearTimeout(renderTimeout);
            renderProgressively();

            const minVideos = Math.min(4, videosPerTopic);
            if (videos.length < minVideos) {
                section.style.display = 'none';
                return;
            }

            // Sort and cache all videos
            videos.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            cachedFeaturedVideos[index] = videos;

            // Load views for featured videos
            const featuredIds = videos.map(e => e.id);
            if (featuredIds.length > 0) {
                loadViewsForVideos(featuredIds, true);
            }

            // Show View More if more videos available
            if (videos.length > videosPerTopic && viewMoreContainer) {
                viewMoreContainer.style.display = 'block';
            }
        });
    };

    // Load all featured topics in parallel
    FEATURED_TOPICS.forEach((topic, index) => {
        loadFeaturedTopic(topic, index);
    });
}

// Load latest videos section (5 rows initially, expandable to 10)
// Uses progressive rendering - displays videos as they arrive
async function loadLatestVideosSection() {
    const videoGrid = document.getElementById('videoGrid');
    const viewMoreBtn = document.getElementById('latestViewMore');
    const cardsPerRow = getCardsPerRow();
    const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;
    const initialRows = 5;
    // Show 9 cards on tablet, 20 on desktop
    const videosToDisplay = isTablet ? 9 : 20;

    // Include both videos AND live streams
    const filter = {
        kinds: [...ALL_VIDEO_KINDS, NIP53_LIVE_EVENT_KIND],
        limit: 200, // Load more for expansion
        '#t': ['pv69420']
    };

    const videos = [];
    const liveStreamData = new Map(); // Map event.id -> parsed liveData
    const renderedIds = new Set();
    let hasCleared = false;
    let renderTimeout = null;
    let firstRenderDone = false;

    // Progressive render function - called as videos arrive
    const renderProgressively = async () => {
        if (videos.length === 0) return;

        // Sort videos by timestamp (newest first)
        const sortedVideos = [...videos].sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
        const videosToShow = sortedVideos.slice(0, videosToDisplay);

        // Clear skeleton loaders on first render
        if (!hasCleared && videosToShow.length > 0) {
            hasCleared = true;
            videoGrid.innerHTML = '';
        }

        // Render new cards that haven't been rendered yet
        for (const event of videosToShow) {
            if (renderedIds.has(event.id)) continue;
            renderedIds.add(event.id);

            const profile = profileCache.get(event.pubkey) || await fetchUserProfile(event.pubkey);
            const reactions = reactionsCache.get(event.id);
            // First row loads thumbnails immediately (non-lazy) for faster display
            const isFirstRow = renderedIds.size <= cardsPerRow;

            let cardHtml;
            let isLiveStream = false;
            // Check if this is a live stream
            if (event.kind === NIP53_LIVE_EVENT_KIND) {
                const liveData = liveStreamData.get(event.id);
                if (liveData && isLiveStreamActive(liveData)) {
                    cardHtml = createLiveStreamCard(event, liveData, profile);
                    isLiveStream = true;
                } else {
                    continue; // Skip non-active live streams
                }
            } else {
                cardHtml = createVideoCard(event, profile, reactions, false, null, !isFirstRow);
            }

            if (cardHtml) {
                // Load actual viewer count for live streams
                if (isLiveStream) {
                    loadLiveStreamCardViewers(event.id);
                }
                // Insert in sorted position
                const existingCards = videoGrid.querySelectorAll('.video-card');
                let inserted = false;

                for (const existingCard of existingCards) {
                    const existingEventId = existingCard.id.replace('video-card-', '');
                    const existingEvent = allEvents.get(existingEventId);
                    if (existingEvent && (event.created_at || 0) > (existingEvent.created_at || 0)) {
                        existingCard.insertAdjacentHTML('beforebegin', cardHtml);
                        inserted = true;
                        break;
                    }
                }

                if (!inserted) {
                    videoGrid.insertAdjacentHTML('beforeend', cardHtml);
                }

                // Load profile immediately if not cached (fire-and-forget)
                loadProfileAndUpdateCards(event.pubkey);

                // Load boosts if not cached (fire-and-forget)
                if (!boostsCache.has(event.id)) {
                    loadBoostsForVideo(event.id, (totalBoosts) => {
                        // Use a local helper since we're inside the function
                        const card = document.getElementById(`video-card-${event.id}`);
                        if (!card) return;
                        const boostLevel = getBoostLevel(totalBoosts);
                        const isBoosted = boostLevel > 0;
                        if (isBoosted) {
                            card.classList.add('boosted', `boost-level-${boostLevel}`);
                            for (let i = 1; i <= 4; i++) {
                                if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                            }
                            const thumbnail = card.querySelector('.video-thumbnail');
                            if (thumbnail) {
                                const existingIndicator = thumbnail.querySelector('.boost-indicator');
                                const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                                if (existingIndicator) {
                                    existingIndicator.outerHTML = indicatorHTML;
                                } else {
                                    thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                                }
                            }
                        }
                    });
                }
            }
        }

        // Observe lazy cards after rendering
        observeLazyCards();
        firstRenderDone = true;
    };

    // Debounced render to batch rapid updates (but render immediately on first event)
    const scheduleRender = () => {
        if (renderTimeout) clearTimeout(renderTimeout);
        // Render immediately on first event, then debounce subsequent updates
        if (!firstRenderDone) {
            renderProgressively();
        } else {
            renderTimeout = setTimeout(renderProgressively, 50);
        }
    };

    // Stream events and render progressively
    requestEventsStream(filter, (event) => {
        allEvents.set(event.id, event);

        // Remove any legacy counterpart that was already added (handles race condition)
        removeLegacyCounterpart(event, videos, renderedIds);

        // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
        if (shouldSkipLegacyEvent(event)) return;

        // Skip shorts - they're shown in the dedicated Shorts section
        if (isNip71ShortKind(event.kind)) return;

        // Handle live streams specially
        if (event.kind === NIP53_LIVE_EVENT_KIND) {
            const liveData = parseLiveEvent(event);
            if (liveData && isLiveStreamActive(liveData)) {
                liveStreamData.set(event.id, liveData);
                videos.push(event);
                scheduleRender();
            }
            return;
        }

        videos.push(event);
        scheduleRender();
    }, () => {
        // On completion, do final render and cache
        clearTimeout(renderTimeout);
        renderProgressively();

        if (videos.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosFound')}</p>`;
            return;
        }

        // Sort and cache all videos for View More expansion
        videos.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
        cachedLatestVideos = videos;

        // Show View More button if there are more videos
        if (videos.length > videosToDisplay && viewMoreBtn) {
            viewMoreBtn.style.display = 'block';
        }
    });
}

// Initialize carousel functionality
function initializeCarousel() {
    const trendingGrid = document.getElementById('trendingGrid');
    const carouselDots = document.getElementById('carouselDots');
    const container = trendingGrid?.parentElement;

    if (!trendingGrid || !carouselDots || !container) return;

    const cards = trendingGrid.querySelectorAll('.video-card');
    const totalCards = cards.length;

    if (totalCards === 0) return;

    let itemsPerPage;
    if (window.innerWidth <= 480) {
        itemsPerPage = 2; // 2 on mobile
    } else if (window.innerWidth <= 768) {
        itemsPerPage = 3; // 3 on tablet
    } else {
        itemsPerPage = 4; // 4 on desktop
    }

    itemsPerPage = Math.min(itemsPerPage, totalCards);

    const totalPages = Math.ceil(totalCards / itemsPerPage);

    // Calculate card width in pixels to fit exactly itemsPerPage cards
    const gap = 16; // 1rem gap
    const containerWidth = container.clientWidth;
    const totalGapWidth = (itemsPerPage - 1) * gap;
    const cardWidth = (containerWidth - totalGapWidth) / itemsPerPage;

    cards.forEach(card => {
        card.style.flex = `0 0 ${cardWidth}px`;
        card.style.maxWidth = `${cardWidth}px`;
        card.style.width = `${cardWidth}px`;
    });

    carouselDots.innerHTML = '';
    for (let i = 0; i < totalPages; i++) {
        const dot = document.createElement('div');
        dot.className = `carousel-dot ${i === 0 ? 'active' : ''}`;
        dot.onclick = () => goToPage(i);
        carouselDots.appendChild(dot);
    }

    trendingGrid.dataset.currentPage = '0';
    trendingGrid.dataset.totalPages = totalPages;
    trendingGrid.dataset.itemsPerPage = itemsPerPage;
    trendingGrid.dataset.cardWidth = cardWidth;
    trendingGrid.dataset.gap = gap;

    updateCarouselButtons();
    goToPage(0);
}

// Function to load trending section asynchronously
async function loadTrendingSection() {
    const trendingGrid = document.getElementById('trendingGrid');
    let hasRendered = false;

    try {
        const trendingPromise = loadTrendingVideos(currentTrendingPeriod);

        const checkInterval = setInterval(async () => {
            const trendingVideos = await Promise.race([
                trendingPromise,
                new Promise(resolve => setTimeout(() => resolve(null), 10))
            ]);

            if (trendingVideos && trendingVideos.length > 0 && !hasRendered) {
                hasRendered = true;
                clearInterval(checkInterval);
                await renderTrendingVideos(trendingVideos);
            }
        }, 500);

        const trendingVideos = await trendingPromise;
        clearInterval(checkInterval);

        if (trendingVideos.length > 0) {
            await renderTrendingVideos(trendingVideos);
        } else if (!hasRendered) {
            trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noTrendingVideos')}</p>`;
        }
    } catch (error) {
        console.error('Failed to load trending videos:', error);
        const trendingSection = document.getElementById('trendingSection');
        if (trendingSection) {
            trendingSection.style.display = 'none';
        }
    }
}

// Helper function to render trending videos - non-blocking profile loading
function renderTrendingVideos(trendingVideos) {
    const trendingGrid = document.getElementById('trendingGrid');

    // Find uncached profile pubkeys
    const uncachedPubkeys = [...new Set(trendingVideos.map(v => v.pubkey).filter(pk => !profileCache.has(pk)))];

    // Render immediately with available profile data
    const renderedCards = trendingVideos.map((event, index) => {
        const profile = profileCache.get(event.pubkey);
        const reactions = reactionsCache.get(event.id);
        return createVideoCard(event, profile, reactions, true, index + 1);
    }).filter(card => card !== '');

    if (renderedCards.length > 0) {
        trendingGrid.innerHTML = renderedCards.join('');
        observeLazyCards();
        initializeCarousel();

        // Load profiles immediately
        trendingVideos.forEach(event => loadProfileAndUpdateCards(event.pubkey));
    } else {
        trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noTrendingVideos')}</p>`;
    }
}

// Function to switch trending period
async function switchTrendingPeriod(period) {
    currentTrendingPeriod = period;

    document.querySelectorAll('.trending-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    event.target.classList.add('active');

    const trendingGrid = document.getElementById('trendingGrid');
    if (trendingGrid) {
        // Trending section shows max 4 cards on desktop, 3 on mobile/tablet
        const isMobile = window.innerWidth <= 480;
        const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;
        const maxTrendingCards = (isMobile || isTablet) ? 3 : 4;
        trendingGrid.innerHTML = Array(maxTrendingCards).fill(createSkeletonCard()).join('');
    }

    await loadTrendingSectionGrid();
}

// Load following
async function loadFollowing() {
    if (!currentUser) {
        await checkStoredLogin(); // Wait for login check
        if (!currentUser) {
            document.getElementById('mainContent').innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.loginToViewFollowing')}</p>`;
            return;
        }
    }

    currentView = 'following';

    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = '<div class="spinner"></div>';

    try {
        const followingFilter = {
            kinds: [3],
            authors: [currentUser.pubkey],
            limit: 1
        };

        let followingList = [];
        await new Promise((resolve) => {
            requestEventsStream(followingFilter, (event) => {
                const pTags = event.tags.filter(tag => tag[0] === 'p');
                followingList = pTags.map(tag => tag[1]);
            }, resolve);
        });

        if (followingList.length === 0) {
            mainContent.innerHTML = `
                <h2 style="margin-bottom: 1.5rem;">${t('pageTitle.following')}</h2>
                <p style="text-align: center; color: var(--text-secondary);">${t('following.noFollowingYet')}</p>
            `;
            return;
        }

        // Create the page layout with users section and videos section
        const cardsPerRow = getCardsPerRow();
        const userSkeletonCount = cardsPerRow * 2; // 2 rows of user skeletons
        const videoSkeletonCount = cardsPerRow * 10; // 10 rows of video skeletons
        const userSkeletons = Array(userSkeletonCount).fill(createSkeletonFollowingUserCard()).join('');
        const videoSkeletons = Array(videoSkeletonCount).fill(createSkeletonCard()).join('');
        const liveSkeletons = Array(cardsPerRow).fill(createLiveStreamSkeletonCard()).join('');
        const shortSkeletons = Array(getShortsCardsPerRow()).fill(createShortSkeletonCard()).join('');

        mainContent.innerHTML = `
            <h2 style="margin-bottom: 1.5rem;">${t('pageTitle.following')}</h2>
            <div class="following-users-section">
                <div class="following-users-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.75rem;">
                    <h3 style="margin: 0; color: var(--text-secondary);">${t('section.usersYouFollow')}</h3>
                    <div class="following-search-container" style="position: relative;">
                        <input type="text" id="followingUserSearch" placeholder="${t('placeholder.searchUsers')}"
                               style="padding: 0.5rem 0.75rem 0.5rem 2.25rem; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-secondary); color: var(--text-primary); width: 200px; font-size: 0.875rem;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); color: var(--text-secondary);">
                            <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                        </svg>
                    </div>
                </div>
                <div class="following-users-grid" id="followingUsersGrid">
                    ${userSkeletons}
                </div>
                <div id="viewMoreUsersContainer" style="display: none; text-align: center; margin-top: 1rem;">
                    <button id="viewMoreUsersBtn" class="action-btn view-more-btn">
                        View More
                    </button>
                </div>
            </div>
            <hr class="section-divider">
            <!-- Live Streams Section -->
            <div id="followingLiveSection" style="margin-bottom: 2rem;">
                <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                        <circle cx="12" cy="12" r="4" fill="#f44336"/>
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                    </svg>
                    ${t('pageTitle.liveStreams')}
                </h3>
                <div class="video-grid" id="followingLiveGrid">${liveSkeletons}</div>
            </div>
            <!-- Shorts Section -->
            <div id="followingShortsSection" style="margin-bottom: 2rem;">
                <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                        <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                        <path d="M10 8l6 4-6 4V8z"/>
                    </svg>
                    ${t('section.shorts')}
                </h3>
                <div class="shorts-grid" id="followingShortsGrid">${shortSkeletons}</div>
                <div class="view-more-container" id="followingShortsViewMore" style="display: none;">
                    <button class="action-btn view-more-btn" onclick="expandSection('followingShorts')">${t('button.viewMore')}</button>
                </div>
            </div>
            <!-- Videos Section -->
            <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                </svg>
                ${t('section.latestVideos')}
            </h3>
            <div class="video-grid" id="followingVideoGrid">
                ${videoSkeletons}
            </div>
        `;

        const followingUsersGrid = document.getElementById('followingUsersGrid');
        const videoGrid = document.getElementById('followingVideoGrid');
        const shortsGrid = document.getElementById('followingShortsGrid');
        const shortsSection = document.getElementById('followingShortsSection');
        const shortsViewMore = document.getElementById('followingShortsViewMore');
        const liveGrid = document.getElementById('followingLiveGrid');
        const liveSection = document.getElementById('followingLiveSection');
        const viewMoreContainer = document.getElementById('viewMoreUsersContainer');
        const viewMoreBtn = document.getElementById('viewMoreUsersBtn');
        const searchInput = document.getElementById('followingUserSearch');
        const renderedVideos = new Map();
        const renderedShorts = new Map();
        const renderedLiveStreams = new Map();
        const videoEvents = [];
        const shortEvents = [];
        const liveEvents = [];
        const reactionQueue = new Set();
        let reactionTimer = null;
        let shortsRenderedCount = 0;
        const maxInitialShorts = getShortsCardsPerRow(); // Show one row initially

        // Reset cached following shorts
        cachedFollowingShorts = [];
        sectionExpanded.followingShorts = false;

        // Store all user data for filtering
        const allFollowedUsers = [];
        let showingAllUsers = false;

        // Calculate dynamic user limit based on grid width (show 2 rows)
        const calculateUserLimit = () => {
            const gridWidth = followingUsersGrid.offsetWidth;
            const minCardWidth = window.innerWidth <= 768 ? 150 : 200; // Match CSS minmax values
            const gap = 16; // 1rem gap
            const cardsPerRow = Math.floor((gridWidth + gap) / (minCardWidth + gap)) || 1;
            return cardsPerRow * 2; // Show 2 rows
        };

        let INITIAL_USER_LIMIT = calculateUserLimit();

        // Recalculate on resize
        let resizeTimeout;
        const handleResize = () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (!showingAllUsers && !searchInput.value.trim()) {
                    INITIAL_USER_LIMIT = calculateUserLimit();
                    displayUsers(allFollowedUsers, INITIAL_USER_LIMIT);
                }
            }, 150);
        };
        window.addEventListener('resize', handleResize);

        // Create a user card for the following section
        const createFollowingUserCard = (pubkey, profile) => {
            const displayName = profile?.name || profile?.display_name || `User ${pubkey.slice(0, 8)}`;
            const avatarUrl = profile?.picture || profile?.avatar || '';
            const nip05 = profile?.nip05 || '';

            return `
                <a href="#/profile/${pubkey}" class="following-user-card" data-pubkey="${pubkey}">
                    <div class="following-user-avatar">
                        ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}" onerror="this.style.display='none'">` : ''}
                    </div>
                    <div class="following-user-name">${displayName}</div>
                    ${nip05 ? `<div class="following-user-nip05">${nip05}</div>` : ''}
                </a>
            `;
        };

        // Track rendered user pubkeys to avoid re-rendering
        const renderedUserPubkeys = new Set();

        // Display users with limit (only renders new users, doesn't replace existing)
        const displayUsers = (users, limit = null, forceRerender = false) => {
            // Remove skeleton cards on first render
            const skeletons = followingUsersGrid.querySelectorAll('.skeleton-user-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            if (users.length === 0) {
                if (followingUsersGrid.children.length === 0) {
                    followingUsersGrid.innerHTML = `<p style="color: var(--text-secondary); grid-column: 1/-1; text-align: center;">${t('empty.noMatchingUsers')}</p>`;
                }
                viewMoreContainer.style.display = 'none';
                return;
            }

            const usersToShow = limit ? users.slice(0, limit) : users;

            if (forceRerender) {
                // For search filtering, we need to re-render
                renderedUserPubkeys.clear();
                followingUsersGrid.innerHTML = '';
            }

            // Only render users that haven't been rendered yet
            const newUsers = usersToShow.filter(user => !renderedUserPubkeys.has(user.pubkey));

            if (newUsers.length > 0) {
                const cardsHTML = newUsers.map(user => {
                    renderedUserPubkeys.add(user.pubkey);
                    return createFollowingUserCard(user.pubkey, user.profile);
                }).join('');
                followingUsersGrid.insertAdjacentHTML('beforeend', cardsHTML);
            }

            // Show/hide "View More" button
            if (limit && users.length > limit) {
                viewMoreContainer.style.display = 'block';
                viewMoreBtn.textContent = `View More (${users.length - limit} more)`;
            } else {
                viewMoreContainer.style.display = 'none';
            }
        };

        // Expand users to show all (appends new users without re-rendering existing)
        const expandUsers = () => {
            const currentCount = renderedUserPubkeys.size;
            const usersToAdd = allFollowedUsers.slice(currentCount);

            if (usersToAdd.length > 0) {
                const cardsHTML = usersToAdd.map(user => {
                    renderedUserPubkeys.add(user.pubkey);
                    return createFollowingUserCard(user.pubkey, user.profile);
                }).join('');
                followingUsersGrid.insertAdjacentHTML('beforeend', cardsHTML);
            }

            viewMoreContainer.style.display = 'none';
        };

        // Fetch profiles in batches to handle relay limits
        const BATCH_SIZE = 50;
        const loadedPubkeys = new Set();

        const fetchProfileBatch = async (pubkeyBatch) => {
            const profileFilter = {
                kinds: [0],
                authors: pubkeyBatch
            };

            await new Promise((resolve) => {
                requestEventsStream(profileFilter, (profileEvent) => {
                    try {
                        const profile = JSON.parse(profileEvent.content);
                        profileCache.set(profileEvent.pubkey, profile);

                        if (!loadedPubkeys.has(profileEvent.pubkey)) {
                            loadedPubkeys.add(profileEvent.pubkey);
                            allFollowedUsers.push({ pubkey: profileEvent.pubkey, profile });

                            // Render new user if not searching and within limit
                            if (!searchInput.value.trim() && !showingAllUsers) {
                                if (allFollowedUsers.length <= INITIAL_USER_LIMIT) {
                                    displayUsers(allFollowedUsers, INITIAL_USER_LIMIT);
                                } else if (renderedUserPubkeys.size < INITIAL_USER_LIMIT) {
                                    displayUsers(allFollowedUsers, INITIAL_USER_LIMIT);
                                } else {
                                    // Just update the View More button count
                                    viewMoreContainer.style.display = 'block';
                                    viewMoreBtn.textContent = `View More (${allFollowedUsers.length - INITIAL_USER_LIMIT} more)`;
                                }
                            }
                        }
                    } catch (e) {
                        // Ignore invalid profile JSON
                    }
                }, resolve);
            });
        };

        // Split followingList into batches and fetch all
        const profileBatches = [];
        for (let i = 0; i < followingList.length; i += BATCH_SIZE) {
            profileBatches.push(followingList.slice(i, i + BATCH_SIZE));
        }

        // Fetch all batches in parallel
        const profilesPromise = Promise.all(profileBatches.map(batch => fetchProfileBatch(batch))).then(() => {
            // After all batches complete, add any remaining users without profiles
            followingList.forEach(pubkey => {
                if (!loadedPubkeys.has(pubkey)) {
                    loadedPubkeys.add(pubkey);
                    const profile = profileCache.get(pubkey) || null;
                    allFollowedUsers.push({ pubkey, profile });
                }
            });

            // Final display
            if (!searchInput.value.trim()) {
                displayUsers(allFollowedUsers, showingAllUsers ? null : INITIAL_USER_LIMIT);
            }

            // If no users were loaded, show a message
            if (allFollowedUsers.length === 0) {
                followingUsersGrid.innerHTML = `<p style="color: var(--text-secondary);">${t('empty.unableLoadProfiles')}</p>`;
            }
        });

        // View More button handler - append new users without re-rendering
        viewMoreBtn.addEventListener('click', () => {
            showingAllUsers = true;
            const query = searchInput.value.toLowerCase().trim();
            if (query) {
                const filteredUsers = filterUsers(query);
                displayUsers(filteredUsers, null, true);
            } else {
                expandUsers();
            }
        });

        // Filter users by search query
        const filterUsers = (query) => {
            return allFollowedUsers.filter(user => {
                const name = (user.profile?.name || '').toLowerCase();
                const displayName = (user.profile?.display_name || '').toLowerCase();
                const nip05 = (user.profile?.nip05 || '').toLowerCase();
                const about = (user.profile?.about || '').toLowerCase();
                const pubkeyShort = user.pubkey.slice(0, 8).toLowerCase();

                return name.includes(query) ||
                    displayName.includes(query) ||
                    nip05.includes(query) ||
                    about.includes(query) ||
                    pubkeyShort.includes(query);
            });
        };

        // Search functionality
        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            const query = e.target.value.toLowerCase().trim();

            searchTimeout = setTimeout(() => {
                if (!query) {
                    // Reset to initial state
                    showingAllUsers = false;
                    displayUsers(allFollowedUsers, INITIAL_USER_LIMIT);
                    return;
                }

                const filteredUsers = filterUsers(query);
                // Show all matching users when searching (no limit)
                displayUsers(filteredUsers, null);
            }, 300);
        });

        // Helper functions for video cards
        const updateVideoCard = (event, profile, reactions) => {
            // Use in-place update to prevent image flickering
            updateVideoCardInPlace(event.id, profile, reactions);
        };

        const renderVideoCard = (event, profile = null, reactions = null) => {
            const cardId = `video-card-${event.id}`;

            if (document.getElementById(cardId)) {
                // Use in-place update to prevent image flickering
                updateVideoCardInPlace(event.id, profile, reactions);
                return;
            }

            // Remove skeleton cards on first video
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            const cardHTML = createVideoCard(event, profile, reactions);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHTML;

            if (!tempDiv.firstElementChild) return;

            tempDiv.firstElementChild.id = cardId;

            let inserted = false;
            const cards = videoGrid.querySelectorAll('.video-card');

            for (let i = 0; i < cards.length; i++) {
                const cardEventId = cards[i].id.replace('video-card-', '');
                const cardEvent = renderedVideos.get(cardEventId);
                if (cardEvent && event.created_at > cardEvent.created_at) {
                    cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) {
                videoGrid.appendChild(tempDiv.firstElementChild);
            }

            renderedVideos.set(event.id, event);
            observeLazyCards();
        };

        const renderShortCard = (event, profile = null, reactions = null) => {
            const cardId = `video-card-${event.id}`;

            if (document.getElementById(cardId)) {
                updateVideoCardInPlace(event.id, profile, reactions);
                return;
            }

            // Only render up to maxInitialShorts initially
            if (shortsRenderedCount >= maxInitialShorts) {
                return;
            }

            // Remove skeleton cards on first short
            const skeletons = shortsGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            // Show shorts section
            shortsSection.style.display = 'block';

            const cardHTML = createShortCard(event, profile, reactions);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHTML;

            if (!tempDiv.firstElementChild) return;

            tempDiv.firstElementChild.id = cardId;

            let inserted = false;
            const cards = shortsGrid.querySelectorAll('.short-card');

            for (let i = 0; i < cards.length; i++) {
                const cardEventId = cards[i].id.replace('video-card-', '');
                const cardEvent = renderedShorts.get(cardEventId);
                if (cardEvent && event.created_at > cardEvent.created_at) {
                    cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) {
                shortsGrid.appendChild(tempDiv.firstElementChild);
            }

            renderedShorts.set(event.id, event);
            shortsRenderedCount++;
            observeLazyCards();
        };

        const renderLiveStreamCard = (event, profile = null) => {
            const cardId = `live-card-${event.id}`;

            if (document.getElementById(cardId) || renderedLiveStreams.has(event.id)) {
                return;
            }

            // Remove skeleton cards on first live stream
            const skeletons = liveGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            const liveData = parseLiveEvent(event);
            if (!liveData) return;

            const isEnded = liveData.status === 'ended';
            const cardHTML = createLiveStreamCard(event, liveData, profile, isEnded);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHTML;

            if (!tempDiv.firstElementChild) return;

            // Insert sorted by created_at (newest first)
            let inserted = false;
            const cards = liveGrid.querySelectorAll('.video-card');

            for (let i = 0; i < cards.length; i++) {
                const cardEventId = cards[i].dataset.liveEventId;
                const cardEvent = renderedLiveStreams.get(cardEventId);
                if (cardEvent && event.created_at > cardEvent.created_at) {
                    cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) {
                liveGrid.appendChild(tempDiv.firstElementChild);
            }

            renderedLiveStreams.set(event.id, event);
            liveEvents.push(event);
            observeLazyCards();
        };

        const loadReactionsBatch = async () => {
            if (reactionQueue.size === 0) return;

            const videoIds = Array.from(reactionQueue);
            reactionQueue.clear();

            await loadReactionsForVideos(videoIds, (videoId, reactions) => {
                const event = videoEvents.find(e => e.id === videoId);
                if (event) {
                    const profile = profileCache.get(event.pubkey);
                    updateVideoCard(event, profile, reactions);
                }
            });
        };

        // Fetch videos from followed users in batches
        const VIDEO_BATCH_SIZE = 50;
        const seenVideoIds = new Set();

        const fetchVideoBatch = async (authorBatch) => {
            const videoFilter = {
                kinds: ALL_VIDEO_KINDS,
                authors: authorBatch,
                '#t': ['pv69420'],
                limit: 100
            };

            await new Promise((resolve) => {
                requestEventsStream(videoFilter, (event) => {
                    const tags = event.tags || [];
                    if (!tags.some(tag => tag[0] === 'x')) return;

                    if (seenVideoIds.has(event.id)) return;
                    seenVideoIds.add(event.id);

                    allEvents.set(event.id, event);

                    // Remove any legacy counterpart that was already added (handles race condition)
                    // Check both video and short arrays based on event type
                    if (event.kind === NIP71_VIDEO_KIND) {
                        removeLegacyCounterpart(event, videoEvents);
                    } else if (event.kind === NIP71_SHORT_KIND) {
                        removeLegacyCounterpart(event, shortEvents);
                    }

                    // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
                    if (shouldSkipLegacyEvent(event)) return;

                    // Separate shorts from videos
                    const isShort = isNip71ShortKind(event.kind);

                    if (isShort) {
                        shortEvents.push(event);
                    } else {
                        videoEvents.push(event);
                    }

                    const spinner = videoGrid.querySelector('.spinner');
                    if (spinner) spinner.remove();

                    const cachedProfile = profileCache.get(event.pubkey);
                    const cachedReactions = reactionsCache.get(event.id);

                    if (isShort) {
                        renderShortCard(event, cachedProfile, cachedReactions);
                    } else {
                        renderVideoCard(event, cachedProfile, cachedReactions);
                    }

                    reactionQueue.add(event.id);
                    clearTimeout(reactionTimer);
                    reactionTimer = setTimeout(loadReactionsBatch, 200);
                }, resolve);
            });
        };

        // Split followingList into batches for video fetching
        const videoBatches = [];
        for (let i = 0; i < followingList.length; i += VIDEO_BATCH_SIZE) {
            videoBatches.push(followingList.slice(i, i + VIDEO_BATCH_SIZE));
        }

        // Live stream fetching function
        const seenLiveIds = new Set();
        const liveStreamsByDTag = new Map(); // Deduplicate by d-tag

        const fetchLiveStreamBatch = async (authorBatch) => {
            const liveFilter = {
                kinds: [NIP53_LIVE_EVENT_KIND],
                authors: authorBatch,
                '#t': ['pv69420'],
                limit: 50
            };

            await new Promise((resolve) => {
                requestEventsStream(liveFilter, (event) => {
                    if (seenLiveIds.has(event.id)) return;
                    seenLiveIds.add(event.id);

                    const liveData = parseLiveEvent(event);
                    if (!liveData) return;

                    allEvents.set(event.id, event);

                    // Deduplicate by d-tag (keep most recent version)
                    const dTagKey = `${event.pubkey}:${liveData.dTag}`;
                    const existing = liveStreamsByDTag.get(dTagKey);
                    if (existing && existing.created_at >= event.created_at) return;
                    liveStreamsByDTag.set(dTagKey, event);

                    const cachedProfile = profileCache.get(event.pubkey);
                    renderLiveStreamCard(event, cachedProfile);
                }, resolve);
            });
        };

        // Fetch all video and live stream batches in parallel
        await Promise.all([
            ...videoBatches.map(batch => fetchVideoBatch(batch)),
            ...videoBatches.map(batch => fetchLiveStreamBatch(batch))
        ]);

        // Final cleanup after all batches complete
        // Clear remaining skeletons
        liveGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());
        shortsGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());

        // Hide sections if no content
        if (liveEvents.length === 0) {
            liveSection.style.display = 'none';
        } else {
            // Load viewer counts and boosts for live streams
            const activeLiveIds = liveEvents
                .filter(e => {
                    const liveData = parseLiveEvent(e);
                    return liveData && isLiveStreamActive(liveData);
                })
                .map(e => e.id);
            if (activeLiveIds.length > 0) {
                loadLiveStreamCardsViewers(activeLiveIds);
            }
            liveEvents.forEach(e => {
                if (!boostsCache.has(e.id)) {
                    loadBoostsForVideo(e.id);
                }
            });
        }

        if (shortEvents.length === 0) {
            shortsSection.style.display = 'none';
        }

        if (videoEvents.length === 0 && shortEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFollowingVideos')}</p>`;
        } else if (videoEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthFollowing')}</p>`;
        }

        // Sort and cache shorts, show View More if needed
        if (shortEvents.length > 0) {
            shortEvents.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            cachedFollowingShorts = shortEvents;

            // Show View More if there are more shorts than initially displayed
            if (shortEvents.length > maxInitialShorts && shortsViewMore) {
                shortsViewMore.style.display = 'block';
            }
        }

        if (reactionQueue.size > 0) {
            loadReactionsBatch();
        }

        // Load views for all videos and shorts
        const allVideoIds = [...videoEvents.map(e => e.id), ...shortEvents.map(e => e.id)];
        if (allVideoIds.length > 0) {
            loadViewsForVideos(allVideoIds, true);
        }

        // Wait for profiles to finish loading
        await profilesPromise;

    } catch (error) {
        console.error('Failed to load following:', error);
        mainContent.innerHTML = `<div class="error-message">${t('empty.failedLoadFollowing')}</div>`;
    }
}

// Load my videos with streaming
async function loadMyVideos() {
    if (!currentUser) {
        await checkStoredLogin(); // Wait for login check
        if (!currentUser) {
            document.getElementById('mainContent').innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.loginToViewVideos')}</p>`;
            return;
        }
    }

    currentView = 'my-videos';

    // Include all video kinds (kind 1 legacy, NIP-71 addressable, and NIP-71 legacy)
    const filter = {
        kinds: ALL_VIDEO_KINDS,
        authors: [currentUser.pubkey],
        '#t': ['pv69420']
    };

    await displayVideosStreamWithDrafts(t('pageTitle.myVideos'), filter);
}

// Load user's live streams for My Videos page
async function loadMyLiveStreams() {
    if (!currentUser) return [];

    const liveSection = document.getElementById('myVideosLiveSection');
    const liveGrid = document.getElementById('myVideosLiveGrid');
    if (!liveSection || !liveGrid) return [];

    const filter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        authors: [currentUser.pubkey],
        '#t': ['pv69420'],
        limit: 50
    };

    // Use a Map to deduplicate by d-tag (replaceable events)
    const streamsByDTag = new Map();
    const profile = profileCache.get(currentUser.pubkey) || await fetchUserProfile(currentUser.pubkey);

    await new Promise(resolve => {
        requestEventsStream(filter, (event) => {
            const liveData = parseLiveEvent(event);
            if (liveData) {
                const dTag = liveData.dTag;
                const existing = streamsByDTag.get(dTag);
                // Keep the most recent version (highest created_at)
                if (!existing || event.created_at > existing.event.created_at) {
                    streamsByDTag.set(dTag, { event, liveData });
                    allEvents.set(event.id, event);
                }
            }
        }, resolve);
    });

    const liveStreams = Array.from(streamsByDTag.values());

    // Cache live streams for search functionality
    cachedMyVideosLiveStreams = liveStreams;

    if (liveStreams.length === 0) {
        // Hide section if no live streams found
        liveSection.style.display = 'none';
        return [];
    }

    // Sort by created_at (newest first)
    liveStreams.sort((a, b) => b.event.created_at - a.event.created_at);

    // Render cards
    liveGrid.innerHTML = '';
    const liveEventIds = [];

    for (const { event, liveData } of liveStreams) {
        const card = createMyLiveStreamCard(event, liveData, profile);
        liveGrid.insertAdjacentHTML('beforeend', card);
        if (isLiveStreamActive(liveData)) {
            liveEventIds.push(event.id);
        }
    }

    // Load actual viewer counts for active live streams
    if (liveEventIds.length > 0) {
        loadLiveStreamCardsViewers(liveEventIds);
    }

    // Load boosts for all live streams (active and ended)
    const allLiveEventIds = liveStreams.map(({ event }) => event.id);
    allLiveEventIds.forEach(id => {
        if (!boostsCache.has(id)) {
            loadBoostsForVideo(id);
        }
    });

    return liveStreams;
}

// Create a live stream card for My Videos page (shows status including ended)
function createMyLiveStreamCard(event, liveData, profile) {
    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';
    const isEnded = isLiveStreamEnded(liveData);
    const isScheduled = isLiveStreamScheduled(liveData);
    const isActive = isLiveStreamActive(liveData);

    // Check boost level
    const boostAmount = boostsCache.get(event.id) || 0;
    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;
    const boostClasses = isBoosted ? `boosted boost-level-${boostLevel}` : '';

    // Check if NIP-05 is validated (from cache)
    const validationCached = profileValidationCache.get(event.pubkey);
    const nip05Valid = validationCached?.nip05Valid || false;

    let statusBadge = '';
    let statusClass = '';
    if (isActive) {
        statusBadge = '<div class="live-badge">LIVE</div>';
        statusClass = '';
    } else if (isScheduled) {
        statusBadge = '<div class="live-badge scheduled">SCHEDULED</div>';
        statusClass = 'scheduled';
    } else if (isEnded) {
        statusBadge = '<div class="live-badge ended">ENDED</div>';
        statusClass = 'ended';
    }

    const timeAgo = isEnded
        ? `Ended ${formatTimestamp(liveData.ends || event.created_at)}`
        : isScheduled
            ? `Scheduled for ${new Date(liveData.starts * 1000).toLocaleDateString()}`
            : `Started ${formatTimestamp(liveData.starts)}`;

    // Validate nip05 async if not cached and has nip05
    if (nip05 && !validationCached) {
        setTimeout(() => {
            validateNip05(nip05, event.pubkey).then(isValid => {
                if (isValid) {
                    const card = document.querySelector(`.live-stream-card[data-event-id="${event.id}"] .channel-nip05`);
                    if (card) applyNip05Checkmark(card, true);
                }
            });
        }, 0);
    }

    return `
        <div class="video-card live-stream-card ${statusClass} ${boostClasses}" data-event-id="${event.id}" data-live-event-id="${event.id}" data-pubkey="${event.pubkey}" onclick="navigateTo('/live/${event.id}')">
            <div class="video-thumbnail">
                ${liveData.thumbnail
            ? `<img src="${liveData.thumbnail}" data-original-src="${liveData.thumbnail}" alt="${escapeHtml(liveData.title)}" loading="lazy" onload="cacheLoadedImage(this)">`
            : '<div style="width:100%; height:100%; background: var(--bg-secondary); display: flex; align-items: center; justify-content: center;"><svg width="48" height="48" viewBox="0 0 24 24" fill="var(--text-secondary)"><circle cx="12" cy="12" r="4"/><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg></div>'
        }
                ${statusBadge}
                ${isActive ? `
                    <div class="live-viewers" data-event-id="${event.id}">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <span class="viewer-count">-</span>
                    </div>
                ` : ''}
                ${isBoosted ? `
                    <div class="boost-indicator">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                        </svg>
                        ${formatSats(boostAmount)}
                    </div>
                ` : ''}
                <div class="video-owner-actions">
                    <button class="owner-edit-btn" onclick="event.stopPropagation(); showEditStreamModal('${event.id}')" title="${t('button.editStream')}">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                        </svg>
                    </button>
                    ${isActive ? `
                        <button class="owner-delete-btn" onclick="event.stopPropagation(); endLiveStream('${event.id}')" title="${t('button.endStream')}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M6 6h12v12H6z"/>
                            </svg>
                        </button>
                    ` : ''}
                </div>
            </div>
            <div class="video-info">
                <a href="#/profile/${event.pubkey}" class="channel-info" onclick="event.stopPropagation()">
                    <div class="channel-avatar">
                        ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}" loading="lazy">` : ''}
                    </div>
                    <div class="channel-details">
                        <div class="channel-name">${escapeHtml(displayName)}</div>
                        ${nip05 ? `<div class="channel-nip05">${nip05}${nip05Valid ? getNip05CheckmarkSVG(12) : ''}</div>` : ''}
                    </div>
                </a>
                <h3 class="video-title">${escapeHtml(liveData.title)}</h3>
                <div class="video-meta">
                    ${timeAgo}
                    ${liveData.isNSFW ? ' • <span style="color: #f44336;">NSFW</span>' : ''}
                </div>
            </div>
        </div>
    `;
}

// Display videos stream with drafts section for My Videos page
async function displayVideosStreamWithDrafts(title, filter) {
    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const skeletonCount = cardsPerRow * 5;
    const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');
    const liveSkeletons = Array(cardsPerRow).fill(createLiveStreamSkeletonCard()).join('');
    const shortSkeletons = Array(getShortsCardsPerRow()).fill(createShortSkeletonCard()).join('');

    // Load and merge drafts from Nostr (if logged in) with localStorage
    let drafts;
    if (currentUser) {
        try {
            drafts = await loadDraftsFromNostr();
        } catch (e) {
            console.error('Failed to load drafts from Nostr:', e);
            drafts = getDrafts();
        }
    } else {
        drafts = getDrafts();
    }
    const draftEntries = Object.entries(drafts);
    const hasDrafts = draftEntries.length > 0;

    // Calculate how many drafts to show initially (one row)
    const maxInitialDrafts = cardsPerRow;
    const sortedDraftEntries = draftEntries.sort((a, b) => (b[1].updatedAt || 0) - (a[1].updatedAt || 0));

    // Cache drafts for View More expansion
    cachedDrafts = sortedDraftEntries.map(([draftId, draft]) => ({ id: draftId, ...draft }));
    sectionExpanded.drafts = false;

    let draftsHTML = '';
    if (hasDrafts) {
        const initialDrafts = sortedDraftEntries.slice(0, maxInitialDrafts);
        const draftCards = initialDrafts
            .map(([draftId, draft]) => createDraftCard(draftId, draft))
            .join('');

        const showDraftsViewMore = draftEntries.length > maxInitialDrafts;

        draftsHTML = `
            <div class="drafts-section" style="margin-bottom: 2rem;">
                <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                    </svg>
                    Drafts (${draftEntries.length})
                </h3>
                <div class="video-grid draft-grid" id="draftsGrid">
                    ${draftCards}
                </div>
                <div class="view-more-container" id="draftsViewMore" style="display: ${showDraftsViewMore ? 'block' : 'none'};">
                    <button class="action-btn view-more-btn" onclick="expandSection('drafts')">View More</button>
                </div>
            </div>
        `;
    }

    mainContent.innerHTML = `
        <div class="my-videos-header" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem;">
            <h2 style="margin: 0;">${title}</h2>
            <div style="display: flex; gap: 0.75rem; align-items: center;">
                <div class="my-videos-search-container" style="position: relative;">
                    <input type="text" id="myVideosSearch" placeholder="${t('placeholder.searchMyVideos')}"
                           style="padding: 0.5rem 0.75rem 0.5rem 2.25rem; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-secondary); color: var(--text-primary); width: 200px; font-size: 0.875rem;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); color: var(--text-secondary);">
                        <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                    </svg>
                </div>
                <button class="action-btn analytics-btn" onclick="navigateTo('/analytics')" title="${t('button.viewAnalytics')}">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 13h2v8H3v-8zm4-5h2v13H7V8zm4-5h2v18h-2V3zm4 8h2v10h-2V11zm4-3h2v13h-2V8z"/>
                    </svg>
                    ${t('button.viewAnalytics')}
                </button>
            </div>
        </div>
        ${draftsHTML}
        <!-- Live Streams Section -->
        <div id="myVideosLiveSection" style="margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <circle cx="12" cy="12" r="4" fill="#f44336"/>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                </svg>
                ${t('pageTitle.liveStreams')}
            </h3>
            <div class="video-grid" id="myVideosLiveGrid">${liveSkeletons}</div>
        </div>
        <!-- Shorts Section -->
        <div id="myVideosShortsSection" style="margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M10 8l6 4-6 4V8z"/>
                </svg>
                ${t('section.shorts')}
            </h3>
            <div class="shorts-grid" id="myVideosShortsGrid">${shortSkeletons}</div>
            <div class="view-more-container" id="myVideosShortsViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('myVideosShorts')">${t('button.viewMore')}</button>
            </div>
        </div>
        <!-- Videos Section -->
        <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                </svg>
                ${t('section.videos')}
            </h3>
        <div class="video-grid" id="videoGrid">
            ${skeletons}
        </div>
    `;

    // Load user's live streams
    loadMyLiveStreams();

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('myVideosShortsGrid');
    const shortsSection = document.getElementById('myVideosShortsSection');
    const shortsViewMore = document.getElementById('myVideosShortsViewMore');

    const videoEvents = [];
    const shortEvents = [];
    const profileQueue = new Set();
    const reactionQueue = new Set();
    let profileTimer = null;
    let reactionTimer = null;
    let shortsRenderedCount = 0;
    const maxInitialShorts = getShortsCardsPerRow();

    // Reset cached my videos shorts and live streams
    cachedMyVideosShorts = [];
    cachedMyVideosLiveStreams = [];
    sectionExpanded.myVideosShorts = false;

    const loadProfilesBatch = async () => {
        if (profileQueue.size === 0) return;
        const pubkeys = Array.from(profileQueue);
        profileQueue.clear();

        const BATCH_SIZE = 25;
        const chunks = [];
        for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
            chunks.push(pubkeys.slice(i, i + BATCH_SIZE));
        }

        await Promise.all(chunks.map(async (chunk) => {
            const filter = { kinds: [0], authors: chunk };
            await requestEventsStream(filter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);
                    [...videoEvents, ...shortEvents].forEach(event => {
                        if (event.pubkey === profileEvent.pubkey) {
                            updateVideoCardInPlace(event.id, profile, reactionsCache.get(event.id));
                        }
                    });
                } catch (e) { }
            });
        }));
    };

    const loadReactionsBatch = async () => {
        if (reactionQueue.size === 0) return;
        const videoIds = Array.from(reactionQueue);
        reactionQueue.clear();
        await loadReactionsForVideos(videoIds);
    };

    await requestEventsStream(filter, (event) => {
        const tags = event.tags || [];
        if (!tags.some(tag => tag[0] === 'x')) return;

        allEvents.set(event.id, event);

        // Remove any legacy counterpart that was already added (handles race condition)
        if (event.kind === NIP71_VIDEO_KIND) {
            removeLegacyCounterpart(event, videoEvents);
        } else if (event.kind === NIP71_SHORT_KIND) {
            removeLegacyCounterpart(event, shortEvents);
        }

        if (shouldSkipLegacyEvent(event)) return;

        const isShort = isNip71ShortKind(event.kind);
        const targetEvents = isShort ? shortEvents : videoEvents;

        targetEvents.push(event);

        // Remove skeleton cards
        if (isShort) {
            const skeletons = shortsGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }
        } else {
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }
        }

        const cachedProfile = profileCache.get(event.pubkey);
        const cachedReactions = reactionsCache.get(event.id);

        // For shorts, only render up to maxInitialShorts initially
        if (isShort) {
            if (shortsRenderedCount < maxInitialShorts) {
                // Pass showOwnerActions=true for My Videos page
                const cardHTML = createShortCard(event, cachedProfile, cachedReactions, true);
                if (cardHTML) {
                    shortsGrid.insertAdjacentHTML('beforeend', cardHTML);
                    shortsRenderedCount++;
                }
            }
        } else {
            // Pass showOwnerActions=true for My Videos page (isTrending=false, trendingRank=null, lazy=true, showOwnerActions=true)
            const cardHTML = createVideoCard(event, cachedProfile, cachedReactions, false, null, true, true);
            if (cardHTML) {
                videoGrid.insertAdjacentHTML('beforeend', cardHTML);
            }
        }

        if (!cachedProfile) {
            profileQueue.add(event.pubkey);
            clearTimeout(profileTimer);
            profileTimer = setTimeout(loadProfilesBatch, 100);
        }

        reactionQueue.add(event.id);
        clearTimeout(reactionTimer);
        reactionTimer = setTimeout(loadReactionsBatch, 200);

    }, () => {
        // Remove remaining skeletons
        videoGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());
        shortsGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());

        // Sort and cache shorts, show View More if needed
        if (shortEvents.length > 0) {
            shortEvents.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            cachedMyVideosShorts = shortEvents;

            if (shortEvents.length > maxInitialShorts && shortsViewMore) {
                shortsViewMore.style.display = 'block';
            }
        } else {
            // Hide shorts section if no shorts found
            shortsSection.style.display = 'none';
        }

        if (videoEvents.length === 0 && shortEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosUploadFirst')}</p>`;
        } else if (videoEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthVideos')}</p>`;
        }

        if (profileQueue.size > 0) loadProfilesBatch();
        if (reactionQueue.size > 0) loadReactionsBatch();

        // Load views for all my videos and shorts
        const allMyVideoIds = [...videoEvents.map(e => e.id), ...shortEvents.map(e => e.id)];
        if (allMyVideoIds.length > 0) {
            loadViewsForVideos(allMyVideoIds, true);
        }

        observeLazyCards();

        // Setup search functionality
        setupMyVideosSearch(videoEvents, shortEvents);
    });
}

// Setup search functionality for My Videos page
function setupMyVideosSearch(videoEvents, shortEvents) {
    const searchInput = document.getElementById('myVideosSearch');
    if (!searchInput) return;

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('myVideosShortsGrid');
    const shortsSection = document.getElementById('myVideosShortsSection');
    const shortsViewMore = document.getElementById('myVideosShortsViewMore');
    const liveSection = document.getElementById('myVideosLiveSection');
    const liveGrid = document.getElementById('myVideosLiveGrid');
    const maxInitialShorts = getShortsCardsPerRow();

    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.toLowerCase().trim();

        searchTimeout = setTimeout(() => {
            // Filter videos
            const filteredVideos = query ? videoEvents.filter(event => {
                const videoData = parseAnyVideoEvent(event);
                if (!videoData) return false;

                const title = (videoData.title || '').toLowerCase();
                const description = (videoData.description || '').toLowerCase();
                const tags = (videoData.tags || []).map(t => t.toLowerCase());

                return title.includes(query) ||
                    description.includes(query) ||
                    tags.some(tag => tag.includes(query));
            }) : videoEvents;

            // Filter shorts
            const filteredShorts = query ? shortEvents.filter(event => {
                const videoData = parseAnyVideoEvent(event);
                if (!videoData) return false;

                const title = (videoData.title || '').toLowerCase();
                const description = (videoData.description || '').toLowerCase();
                const tags = (videoData.tags || []).map(t => t.toLowerCase());

                return title.includes(query) ||
                    description.includes(query) ||
                    tags.some(tag => tag.includes(query));
            }) : shortEvents;

            // Filter live streams
            const liveStreams = cachedMyVideosLiveStreams;
            const filteredLiveStreams = query ? liveStreams.filter(({ liveData }) => {
                const title = (liveData.title || '').toLowerCase();
                const summary = (liveData.summary || '').toLowerCase();
                const tags = (liveData.tags || []).map(t => t.toLowerCase());

                return title.includes(query) ||
                    summary.includes(query) ||
                    tags.some(tag => tag.includes(query));
            }) : liveStreams;

            // Re-render live streams
            if (liveGrid && liveSection) {
                liveGrid.innerHTML = '';
                if (filteredLiveStreams.length > 0) {
                    liveSection.style.display = 'block';
                    const profile = profileCache.get(currentUser?.pubkey);
                    for (const { event, liveData } of filteredLiveStreams) {
                        const card = createMyLiveStreamCard(event, liveData, profile);
                        liveGrid.insertAdjacentHTML('beforeend', card);
                    }
                } else {
                    liveSection.style.display = query ? 'block' : (liveStreams.length > 0 ? 'block' : 'none');
                    if (query && liveStreams.length > 0) {
                        liveGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noMatchingLiveStreams')}</p>`;
                    }
                }
            }

            // Re-render videos
            videoGrid.innerHTML = '';
            if (filteredVideos.length > 0) {
                for (const event of filteredVideos) {
                    const profile = profileCache.get(event.pubkey);
                    const reactions = reactionsCache.get(event.id);
                    const cardHTML = createVideoCard(event, profile, reactions, false, null, true, true);
                    if (cardHTML) {
                        videoGrid.insertAdjacentHTML('beforeend', cardHTML);
                    }
                }
            } else {
                videoGrid.innerHTML = query
                    ? `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noMatchingVideos')}</p>`
                    : `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthVideos')}</p>`;
            }

            // Re-render shorts
            shortsGrid.innerHTML = '';
            if (filteredShorts.length > 0) {
                shortsSection.style.display = 'block';
                const displayShorts = query ? filteredShorts : filteredShorts.slice(0, maxInitialShorts);
                for (const event of displayShorts) {
                    const profile = profileCache.get(event.pubkey);
                    const reactions = reactionsCache.get(event.id);
                    const cardHTML = createShortCard(event, profile, reactions, true);
                    if (cardHTML) {
                        shortsGrid.insertAdjacentHTML('beforeend', cardHTML);
                    }
                }
                // Show/hide View More based on search and count
                if (shortsViewMore) {
                    shortsViewMore.style.display = (!query && filteredShorts.length > maxInitialShorts) ? 'block' : 'none';
                }
            } else {
                shortsSection.style.display = query ? 'block' : 'none';
                if (query) {
                    shortsGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noMatchingShorts')}</p>`;
                }
            }

            observeLazyCards();

            // Load views for filtered content
            const filteredIds = [...filteredVideos.map(e => e.id), ...filteredShorts.map(e => e.id), ...filteredLiveStreams.map(({ event }) => event.id)];
            if (filteredIds.length > 0) {
                loadViewsForVideos(filteredIds, true);
            }
        }, 300);
    });
}

// ===== Analytics Page Functions =====

// Load analytics page
// Store current analytics data for re-rendering with different time periods
let currentAnalyticsContent = null;

async function loadAnalytics(periodDays = 30) {
    if (!currentUser) {
        await checkStoredLogin();
        if (!currentUser) {
            document.getElementById('mainContent').innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.loginToViewAnalytics')}</p>`;
            return;
        }
    }

    currentView = 'analytics';
    const mainContent = document.getElementById('mainContent');

    // Show loading state
    mainContent.innerHTML = `
        <div class="analytics-page">
            <div class="analytics-header">
                <button class="back-btn" onclick="navigateTo('/my-videos')" title="${t('button.backToMyVideos')}">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                    </svg>
                </button>
                <h1>${t('analytics.title')}</h1>
            </div>
            <div class="analytics-loading">
                <div class="spinner"></div>
                <p>${t('analytics.loading')}</p>
            </div>
        </div>
    `;

    try {
        // Fetch all user's content (videos, shorts, live streams)
        const [videos, shorts, liveStreams] = await Promise.all([
            fetchUserVideos(currentUser.pubkey),
            fetchUserShorts(currentUser.pubkey),
            fetchUserLiveStreams(currentUser.pubkey)
        ]);

        const allContent = [...videos, ...shorts, ...liveStreams];

        // Store content for re-rendering with different time periods
        currentAnalyticsContent = { videos, shorts, liveStreams, allContent };

        // Fetch engagement data and follower growth in parallel
        const [analyticsData, followerData] = await Promise.all([
            fetchAnalyticsData(allContent, periodDays),
            fetchFollowerGrowthData(currentUser.pubkey, periodDays)
        ]);

        // Render analytics page
        renderAnalyticsPage(videos, shorts, liveStreams, analyticsData, followerData);
    } catch (error) {
        console.error('Failed to load analytics:', error);
        mainContent.innerHTML = `
            <div class="analytics-page">
                <div class="analytics-header">
                    <button class="back-btn" onclick="navigateTo('/my-videos')" title="${t('button.backToMyVideos')}">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                        </svg>
                    </button>
                    <h1>${t('analytics.title')}</h1>
                </div>
                <p style="text-align: center; color: var(--text-secondary); margin-top: 2rem;">${t('analytics.loadFailed')}</p>
            </div>
        `;
    }
}

// Fetch user's videos (excluding shorts)
async function fetchUserVideos(pubkey) {
    const filter = {
        kinds: ALL_VIDEO_KINDS,
        authors: [pubkey],
        '#t': ['pv69420'],
        limit: 500
    };

    const videos = [];
    const seenDTags = new Set();

    await new Promise(resolve => {
        requestEventsStream(filter, (event) => {
            // Skip shorts
            if (isNip71ShortKind(event.kind)) return;
            if (!event.tags?.some(tag => tag[0] === 'x')) return;

            // Deduplicate by d-tag for addressable events
            const dTag = event.tags?.find(t => t[0] === 'd')?.[1];
            if (dTag) {
                if (seenDTags.has(dTag)) return;
                seenDTags.add(dTag);
            }

            allEvents.set(event.id, event);
            if (!shouldSkipLegacyEvent(event)) {
                videos.push(event);
            }
        }, resolve);
    });

    return videos.sort((a, b) => b.created_at - a.created_at);
}

// Fetch user's shorts
async function fetchUserShorts(pubkey) {
    const filter = {
        kinds: [NIP71_SHORT_KIND],
        authors: [pubkey],
        '#t': ['pv69420'],
        limit: 500
    };

    const shorts = [];
    const seenDTags = new Set();

    await new Promise(resolve => {
        requestEventsStream(filter, (event) => {
            if (!event.tags?.some(tag => tag[0] === 'x')) return;

            const dTag = event.tags?.find(t => t[0] === 'd')?.[1];
            if (dTag) {
                if (seenDTags.has(dTag)) return;
                seenDTags.add(dTag);
            }

            allEvents.set(event.id, event);
            shorts.push(event);
        }, resolve);
    });

    return shorts.sort((a, b) => b.created_at - a.created_at);
}

// Fetch user's live streams
async function fetchUserLiveStreams(pubkey) {
    const filter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        authors: [pubkey],
        '#t': ['pv69420'],
        limit: 100
    };

    const streamsByDTag = new Map();

    await new Promise(resolve => {
        requestEventsStream(filter, (event) => {
            const liveData = parseLiveEvent(event);
            if (liveData) {
                const dTag = liveData.dTag;
                const existing = streamsByDTag.get(dTag);
                if (!existing || event.created_at > existing.created_at) {
                    streamsByDTag.set(dTag, event);
                    allEvents.set(event.id, event);
                }
            }
        }, resolve);
    });

    return Array.from(streamsByDTag.values()).sort((a, b) => b.created_at - a.created_at);
}

// Fetch analytics data for all content
async function fetchAnalyticsData(events, periodDays = 30) {
    const eventIds = events.map(e => e.id);
    const periodStart = Math.floor(Date.now() / 1000) - (periodDays * 24 * 60 * 60);

    // Fetch all engagement metrics in parallel with time filtering
    const [viewsResult, reactionsData, zapsData, boostsData, sharesData, commentsData] = await Promise.all([
        fetchBatchViewCountsWithTimestamps(eventIds, periodStart, periodDays),
        fetchBatchReactionsWithTime(eventIds, periodStart),
        fetchBatchZapsWithTime(eventIds, periodStart),
        fetchBatchBoostsWithTime(eventIds, periodStart),
        fetchBatchSharesWithTime(eventIds, periodStart),
        fetchBatchCommentsWithTime(eventIds, periodStart)
    ]);

    const { viewCounts: viewsData, viewsByDay } = viewsResult;

    // Calculate totals
    let totalViews = 0;
    let totalLikes = 0;
    let totalDislikes = 0;
    let totalZapAmount = 0;
    let totalZapCount = 0;
    let totalBoostCount = 0;
    let totalShares = 0;
    let totalComments = 0;

    const perVideoData = new Map();

    for (const event of events) {
        const views = viewsData.get(event.id) || 0;
        const reactions = reactionsData.get(event.id) || { likes: 0, dislikes: 0 };
        const zaps = zapsData.get(event.id) || { amount: 0, count: 0 };
        const boostAmount = boostsData.get(event.id) || 0;
        const boostCount = Math.floor(boostAmount / 100); // Each boost is 100 sats
        const shares = sharesData.get(event.id) || 0;
        const comments = commentsData.get(event.id) || 0;

        totalViews += views;
        totalLikes += reactions.likes;
        totalDislikes += reactions.dislikes;
        totalZapAmount += zaps.amount;
        totalZapCount += zaps.count;
        totalBoostCount += boostCount;
        totalShares += shares;
        totalComments += comments;

        perVideoData.set(event.id, {
            views,
            likes: reactions.likes,
            dislikes: reactions.dislikes,
            zapAmount: zaps.amount,
            zapCount: zaps.count,
            boosts: boostCount,
            shares,
            comments,
            engagementScore: views + (reactions.likes * 2) + (zaps.count * 5) + (shares * 3) + (comments * 2)
        });
    }

    return {
        totals: {
            views: totalViews,
            likes: totalLikes,
            dislikes: totalDislikes,
            zapAmount: totalZapAmount,
            zapCount: totalZapCount,
            boostCount: totalBoostCount,
            shares: totalShares,
            comments: totalComments
        },
        perVideo: perVideoData,
        viewsByDay,
        periodDays
    };
}

// Batch fetch view counts with timestamps for chart
async function fetchBatchViewCountsWithTimestamps(eventIds, sinceTimestamp, periodDays = 30) {
    const viewCounts = new Map();
    const viewsByDay = new Map(); // date string -> count

    if (eventIds.length === 0) return { viewCounts, viewsByDay };

    // Initialize days for the period (limit chart to 365 days max for performance)
    const chartDays = Math.min(periodDays, 365);
    const now = new Date();
    for (let i = chartDays - 1; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        viewsByDay.set(dateStr, 0);
    }

    // Process in batches with pagination
    const BATCH_SIZE = 50;
    const EVENTS_PER_REQUEST = 500;

    for (let i = 0; i < eventIds.length; i += BATCH_SIZE) {
        const batch = eventIds.slice(i, i + BATCH_SIZE);
        const allLinkedIds = [];
        const linkedToPrimary = new Map();

        batch.forEach(id => {
            const linkedIds = getAllLinkedEventIds(id);
            linkedIds.forEach(linkedId => {
                allLinkedIds.push(linkedId);
                linkedToPrimary.set(linkedId, id);
            });
        });

        // Paginate through results
        let until = Math.floor(Date.now() / 1000);
        let hasMore = true;
        const seenEvents = new Set();
        const viewers = new Map();

        while (hasMore) {
            const filter = {
                kinds: [VIEW_EVENT_KIND],
                '#e': allLinkedIds,
                '#t': ['video-view'],
                since: sinceTimestamp,
                until: until,
                limit: EVENTS_PER_REQUEST
            };

            let eventCount = 0;
            let oldestTimestamp = until;

            await new Promise(resolve => {
                requestEventsStream(filter, (event) => {
                    if (seenEvents.has(event.id)) return;
                    seenEvents.add(event.id);
                    eventCount++;

                    if (event.created_at < oldestTimestamp) {
                        oldestTimestamp = event.created_at;
                    }

                    const eTag = event.tags?.find(t => t[0] === 'e')?.[1];
                    if (eTag && linkedToPrimary.has(eTag)) {
                        const primaryId = linkedToPrimary.get(eTag);

                        // Track unique viewers per video
                        if (!viewers.has(primaryId)) {
                            viewers.set(primaryId, new Set());
                        }
                        const viewerKey = event.pubkey;
                        if (!viewers.get(primaryId).has(viewerKey)) {
                            viewers.get(primaryId).add(viewerKey);

                            // Track views by day
                            const viewDate = new Date(event.created_at * 1000).toISOString().split('T')[0];
                            if (viewsByDay.has(viewDate)) {
                                viewsByDay.set(viewDate, viewsByDay.get(viewDate) + 1);
                            }
                        }
                    }
                }, resolve);
            });

            // Check if we need to paginate more
            if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
                hasMore = false;
            } else {
                until = oldestTimestamp - 1;
            }
        }

        viewers.forEach((viewerSet, id) => {
            viewCounts.set(id, viewerSet.size);
        });
    }

    return { viewCounts, viewsByDay };
}

// Batch fetch reactions with time filter
async function fetchBatchReactionsWithTime(eventIds, sinceTimestamp) {
    const reactions = new Map();

    if (eventIds.length === 0) return reactions;

    eventIds.forEach(id => reactions.set(id, { likes: 0, dislikes: 0 }));

    const allLinkedIds = [];
    const linkedToPrimary = new Map();

    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => {
            allLinkedIds.push(linkedId);
            linkedToPrimary.set(linkedId, id);
        });
    });

    // Paginate through results
    const EVENTS_PER_REQUEST = 1000;
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenEvents = new Set();
    const userReactions = new Map();

    while (hasMore) {
        const filter = {
            kinds: [7],
            '#e': allLinkedIds,
            since: sinceTimestamp,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenEvents.has(event.id)) return;
                seenEvents.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const eTag = event.tags?.find(t => t[0] === 'e')?.[1];
                if (eTag && linkedToPrimary.has(eTag)) {
                    const primaryId = linkedToPrimary.get(eTag);
                    const key = `${primaryId}:${event.pubkey}`;
                    const existing = userReactions.get(key);
                    if (!existing || existing.timestamp < event.created_at) {
                        userReactions.set(key, {
                            reaction: event.content,
                            timestamp: event.created_at,
                            primaryId
                        });
                    }
                }
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    // Count final reactions
    userReactions.forEach(({ reaction, primaryId }) => {
        const data = reactions.get(primaryId);
        if (data) {
            if (reaction === '👍') data.likes++;
            else if (reaction === '👎') data.dislikes++;
        }
    });

    return reactions;
}

// Batch fetch zaps with time filter
async function fetchBatchZapsWithTime(eventIds, sinceTimestamp) {
    const zaps = new Map();

    if (eventIds.length === 0) return zaps;

    eventIds.forEach(id => zaps.set(id, { amount: 0, count: 0 }));

    // Build map of all linked IDs (including legacy events) to primary IDs
    const allLinkedIds = [];
    const linkedToPrimary = new Map();
    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => {
            allLinkedIds.push(linkedId);
            linkedToPrimary.set(linkedId, id);
        });
    });

    // Paginate through results
    const EVENTS_PER_REQUEST = 1000;
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenZaps = new Set();

    while (hasMore) {
        const filter = {
            kinds: [9735],
            '#e': allLinkedIds,
            since: sinceTimestamp,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenZaps.has(event.id)) return;
                seenZaps.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                // Skip boost zaps
                const pTag = event.tags?.find(tag => tag[0] === 'p');
                if (pTag && pTag[1] === 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df') {
                    const description = event.tags?.find(tag => tag[0] === 'description')?.[1];
                    if (description) {
                        try {
                            const zapRequest = JSON.parse(description);
                            if (zapRequest.tags?.some(tag => tag[0] === 'purpose' && tag[1] === 'boost')) {
                                return;
                            }
                        } catch (e) { }
                    }
                }

                const eTag = event.tags?.find(t => t[0] === 'e' && linkedToPrimary.has(t[1]))?.[1];
                if (eTag) {
                    const primaryId = linkedToPrimary.get(eTag);
                    const bolt11 = event.tags?.find(t => t[0] === 'bolt11')?.[1];
                    if (bolt11) {
                        const amount = extractAmountFromBolt11(bolt11);
                        if (amount > 0) {
                            const data = zaps.get(primaryId);
                            if (data) {
                                data.amount += amount;
                                data.count++;
                            }
                        }
                    }
                }
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    return zaps;
}

// Batch fetch boosts with time filter
async function fetchBatchBoostsWithTime(eventIds, sinceTimestamp) {
    const boosts = new Map();

    if (eventIds.length === 0) return boosts;

    eventIds.forEach(id => boosts.set(id, 0));

    // Build map of all linked IDs (including legacy events) to primary IDs
    const allLinkedIds = [];
    const linkedToPrimary = new Map();
    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => {
            allLinkedIds.push(linkedId);
            linkedToPrimary.set(linkedId, id);
        });
    });

    // Paginate through results
    const EVENTS_PER_REQUEST = 1000;
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenBoosts = new Set();

    while (hasMore) {
        const filter = {
            kinds: [9735],
            '#e': allLinkedIds,
            '#p': ['d49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df'],
            since: sinceTimestamp,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenBoosts.has(event.id)) return;
                seenBoosts.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const description = event.tags?.find(tag => tag[0] === 'description')?.[1];
                if (description) {
                    try {
                        const zapRequest = JSON.parse(description);
                        if (zapRequest.tags?.some(tag => tag[0] === 'purpose' && tag[1] === 'boost')) {
                            const eTag = event.tags?.find(t => t[0] === 'e' && linkedToPrimary.has(t[1]))?.[1];
                            if (eTag) {
                                const primaryId = linkedToPrimary.get(eTag);
                                const bolt11 = event.tags?.find(t => t[0] === 'bolt11')?.[1];
                                if (bolt11) {
                                    const amount = extractAmountFromBolt11(bolt11);
                                    if (amount > 0) {
                                        boosts.set(primaryId, (boosts.get(primaryId) || 0) + amount);
                                    }
                                }
                            }
                        }
                    } catch (e) { }
                }
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    return boosts;
}

// Batch fetch shares with time filter
async function fetchBatchSharesWithTime(eventIds, sinceTimestamp) {
    const shares = new Map();

    if (eventIds.length === 0) return shares;

    eventIds.forEach(id => shares.set(id, 0));

    // Build map of all linked IDs (including legacy events) to primary IDs
    const allLinkedIds = [];
    const linkedToPrimary = new Map();
    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => {
            allLinkedIds.push(linkedId);
            linkedToPrimary.set(linkedId, id);
        });
    });

    // Paginate through results
    const EVENTS_PER_REQUEST = 1000;
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenShares = new Set();

    while (hasMore) {
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#e': allLinkedIds,
            '#t': ['video-share'],
            since: sinceTimestamp,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const eTag = event.tags?.find(t => t[0] === 'e' && linkedToPrimary.has(t[1]))?.[1];
                if (eTag) {
                    const primaryId = linkedToPrimary.get(eTag);
                    const key = `${primaryId}:${event.pubkey}`;
                    if (!seenShares.has(key)) {
                        seenShares.add(key);
                        shares.set(primaryId, (shares.get(primaryId) || 0) + 1);
                    }
                }
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    return shares;
}

// Batch fetch comments with time filter
async function fetchBatchCommentsWithTime(eventIds, sinceTimestamp) {
    const comments = new Map();

    if (eventIds.length === 0) return comments;

    eventIds.forEach(id => comments.set(id, 0));

    // Expand to include all linked event IDs
    const allLinkedIds = [];
    const linkedToPrimary = new Map();

    // Also track live stream 'a' tags for chat messages
    const liveStreamATags = [];
    const aTagToPrimary = new Map();

    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => {
            allLinkedIds.push(linkedId);
            linkedToPrimary.set(linkedId, id);
        });

        // Check if this is a live stream and build 'a' tag for chat lookup
        const event = allEvents.get(id);
        if (event && event.kind === NIP53_LIVE_EVENT_KIND) {
            const liveData = parseLiveEvent(event);
            if (liveData && liveData.dTag) {
                const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${event.pubkey}:${liveData.dTag}`;
                liveStreamATags.push(aTagValue);
                aTagToPrimary.set(aTagValue, id);
            }
        }
    });

    // Paginate through regular comments (kind 1)
    const EVENTS_PER_REQUEST = 1000;
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenComments = new Set();

    while (hasMore) {
        const filter = {
            kinds: [1],
            '#e': allLinkedIds,
            since: sinceTimestamp,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenComments.has(event.id)) return;
                seenComments.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const eTag = event.tags?.find(t => t[0] === 'e' && linkedToPrimary.has(t[1]))?.[1];
                if (eTag) {
                    const primaryId = linkedToPrimary.get(eTag);
                    if (primaryId) {
                        comments.set(primaryId, (comments.get(primaryId) || 0) + 1);
                    }
                }
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    // Also fetch live chat messages (kind 1311) for live streams
    if (liveStreamATags.length > 0) {
        until = Math.floor(Date.now() / 1000);
        hasMore = true;

        while (hasMore) {
            const chatFilter = {
                kinds: [NIP53_LIVE_CHAT_KIND],
                '#a': liveStreamATags,
                since: sinceTimestamp,
                until: until,
                limit: EVENTS_PER_REQUEST
            };

            let eventCount = 0;
            let oldestTimestamp = until;

            await new Promise(resolve => {
                requestEventsStream(chatFilter, (event) => {
                    if (seenComments.has(event.id)) return;
                    seenComments.add(event.id);
                    eventCount++;

                    if (event.created_at < oldestTimestamp) {
                        oldestTimestamp = event.created_at;
                    }

                    // Find the 'a' tag that matches one of our live streams
                    const aTag = event.tags?.find(t => t[0] === 'a' && aTagToPrimary.has(t[1]))?.[1];
                    if (aTag) {
                        const primaryId = aTagToPrimary.get(aTag);
                        if (primaryId) {
                            comments.set(primaryId, (comments.get(primaryId) || 0) + 1);
                        }
                    }
                }, resolve);
            });

            if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
                hasMore = false;
            } else {
                until = oldestTimestamp - 1;
            }
        }
    }

    return comments;
}

// Fetch follower growth/degrowth data for analytics
async function fetchFollowerGrowthData(channelPubkey, periodDays = 30) {
    const periodStart = Math.floor(Date.now() / 1000) - (periodDays * 24 * 60 * 60);
    const EVENTS_PER_REQUEST = 500;

    // Initialize days for the period (limit chart to 365 days max for performance)
    const chartDays = Math.min(periodDays, 365);
    const subscribersByDay = new Map();
    const now = new Date();
    for (let i = chartDays - 1; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        subscribersByDay.set(dateStr, { follows: 0, unfollows: 0 });
    }

    let totalNewFollowers = 0;
    let totalUnfollows = 0;

    // Fetch follow events
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenFollows = new Set();

    while (hasMore) {
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#p': [channelPubkey],
            '#t': ['channel-follow'],
            since: periodStart,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenFollows.has(event.id)) return;
                seenFollows.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const date = new Date(event.created_at * 1000).toISOString().split('T')[0];
                if (subscribersByDay.has(date)) {
                    subscribersByDay.get(date).follows++;
                }
                totalNewFollowers++;
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= periodStart) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    // Fetch unfollow events
    until = Math.floor(Date.now() / 1000);
    hasMore = true;
    const seenUnfollows = new Set();

    while (hasMore) {
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#p': [channelPubkey],
            '#t': ['channel-unfollow'],
            since: periodStart,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenUnfollows.has(event.id)) return;
                seenUnfollows.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const date = new Date(event.created_at * 1000).toISOString().split('T')[0];
                if (subscribersByDay.has(date)) {
                    subscribersByDay.get(date).unfollows++;
                }
                totalUnfollows++;
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= periodStart) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    return {
        subscribersByDay,
        totalNewFollowers,
        totalUnfollows,
        netGrowth: totalNewFollowers - totalUnfollows
    };
}

// Generate subscribers chart SVG (shows net gain/loss per day)
function generateSubscribersChartSVG(subscribersByDay, periodDays = 30) {
    const days = Array.from(subscribersByDay.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    const values = days.map(d => d[1].follows - d[1].unfollows); // Net change per day
    const maxValue = Math.max(...values.map(Math.abs), 1);

    const width = 800;
    const height = 200;
    const padding = { top: 20, right: 20, bottom: 40, left: 50 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;
    const zeroY = padding.top + chartHeight / 2;

    // Generate bars for positive/negative values
    const barWidth = chartWidth / values.length - 2;
    const bars = values.map((v, i) => {
        const x = padding.left + (i / values.length) * chartWidth + 1;
        const barHeight = (Math.abs(v) / maxValue) * (chartHeight / 2);
        const y = v >= 0 ? zeroY - barHeight : zeroY;
        const color = v >= 0 ? 'var(--accent)' : '#ef4444';
        const date = new Date(days[i][0]);
        const dateLabel = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

        return `<rect class="chart-bar" x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${color}" data-value="${v}" data-date="${dateLabel}" rx="2" />`;
    }).join('');

    // Y-axis labels
    const yLabels = [];
    const ySteps = 4;
    for (let i = 0; i <= ySteps; i++) {
        const value = Math.round(maxValue - (2 * maxValue / ySteps) * i);
        const y = padding.top + (i / ySteps) * chartHeight;
        yLabels.push({ value: value >= 0 ? `+${value}` : value, y });
    }

    // X-axis labels (show every nth day)
    const xLabels = [];
    const labelInterval = Math.ceil(days.length / 6);
    for (let i = 0; i < days.length; i += labelInterval) {
        const x = padding.left + (i / days.length) * chartWidth + barWidth / 2;
        const date = new Date(days[i][0]);
        const label = `${date.getMonth() + 1}/${date.getDate()}`;
        xLabels.push({ label, x });
    }

    return `
        <svg class="subscribers-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
            <!-- Grid lines -->
            ${yLabels.map(l => `<line class="chart-grid" x1="${padding.left}" y1="${l.y}" x2="${width - padding.right}" y2="${l.y}" />`).join('')}

            <!-- Zero line -->
            <line class="chart-zero-line" x1="${padding.left}" y1="${zeroY}" x2="${width - padding.right}" y2="${zeroY}" stroke="var(--text-secondary)" stroke-width="1" />

            <!-- Bars -->
            ${bars}

            <!-- Y-axis labels -->
            ${yLabels.map(l => `<text class="chart-label y-label" x="${padding.left - 10}" y="${l.y + 4}" text-anchor="end">${l.value}</text>`).join('')}

            <!-- X-axis labels -->
            ${xLabels.map(l => `<text class="chart-label x-label" x="${l.x}" y="${height - 10}" text-anchor="middle">${l.label}</text>`).join('')}
        </svg>
    `;
}

// Generate views chart SVG
function generateViewsChartSVG(viewsByDay, periodDays = 30) {
    const days = Array.from(viewsByDay.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    const values = days.map(d => d[1]);
    const maxValue = Math.max(...values, 1);

    const width = 800;
    const height = 200;
    const padding = { top: 20, right: 20, bottom: 40, left: 50 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;

    // Generate path for the area chart
    const points = values.map((v, i) => {
        const x = padding.left + (i / (values.length - 1 || 1)) * chartWidth;
        const y = padding.top + chartHeight - (v / maxValue) * chartHeight;
        return { x, y, value: v, date: days[i][0] };
    });

    // Create smooth path
    let pathD = `M ${points[0]?.x || padding.left} ${points[0]?.y || padding.top + chartHeight}`;
    for (let i = 1; i < points.length; i++) {
        pathD += ` L ${points[i].x} ${points[i].y}`;
    }

    // Area fill path
    const areaPath = pathD + ` L ${points[points.length - 1]?.x || padding.left + chartWidth} ${padding.top + chartHeight} L ${padding.left} ${padding.top + chartHeight} Z`;

    // Y-axis labels
    const yLabels = [];
    const ySteps = 4;
    for (let i = 0; i <= ySteps; i++) {
        const value = Math.round((maxValue / ySteps) * (ySteps - i));
        const y = padding.top + (i / ySteps) * chartHeight;
        yLabels.push({ value: formatNumber(value), y });
    }

    // X-axis labels (show every 5th day)
    const xLabels = [];
    const labelInterval = Math.ceil(days.length / 6);
    for (let i = 0; i < days.length; i += labelInterval) {
        const x = padding.left + (i / (days.length - 1 || 1)) * chartWidth;
        const date = new Date(days[i][0]);
        const label = `${date.getMonth() + 1}/${date.getDate()}`;
        xLabels.push({ label, x });
    }

    // Hover points
    const hoverPoints = points.map((p, i) => {
        const date = new Date(days[i][0]);
        const dateLabel = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        return `<circle class="chart-point" cx="${p.x}" cy="${p.y}" r="4" data-value="${p.value}" data-date="${dateLabel}" />`;
    }).join('');

    return `
        <svg class="views-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
            <defs>
                <linearGradient id="areaGradient" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0%" stop-color="var(--accent)" stop-opacity="0.3"/>
                    <stop offset="100%" stop-color="var(--accent)" stop-opacity="0.05"/>
                </linearGradient>
            </defs>

            <!-- Grid lines -->
            ${yLabels.map(l => `<line class="chart-grid" x1="${padding.left}" y1="${l.y}" x2="${width - padding.right}" y2="${l.y}" />`).join('')}

            <!-- Area fill -->
            <path class="chart-area" d="${areaPath}" fill="url(#areaGradient)" />

            <!-- Line -->
            <path class="chart-line" d="${pathD}" fill="none" stroke="var(--accent)" stroke-width="2" />

            <!-- Y-axis labels -->
            ${yLabels.map(l => `<text class="chart-label y-label" x="${padding.left - 10}" y="${l.y + 4}" text-anchor="end">${l.value}</text>`).join('')}

            <!-- X-axis labels -->
            ${xLabels.map(l => `<text class="chart-label x-label" x="${l.x}" y="${height - 10}" text-anchor="middle">${l.label}</text>`).join('')}

            <!-- Hover points -->
            ${hoverPoints}
        </svg>
    `;
}

// Render analytics page
function renderAnalyticsPage(videos, shorts, liveStreams, analyticsData, followerData = null) {
    const mainContent = document.getElementById('mainContent');
    const { totals, perVideo, viewsByDay, periodDays } = analyticsData;

    // Get top performing content
    const allContent = [...videos, ...shorts, ...liveStreams];
    const sortedByViews = [...allContent].sort((a, b) => {
        const aData = perVideo.get(a.id) || { views: 0 };
        const bData = perVideo.get(b.id) || { views: 0 };
        return bData.views - aData.views;
    }).slice(0, 5);

    const sortedByEngagement = [...allContent].sort((a, b) => {
        const aData = perVideo.get(a.id) || { engagementScore: 0 };
        const bData = perVideo.get(b.id) || { engagementScore: 0 };
        return bData.engagementScore - aData.engagementScore;
    }).slice(0, 5);

    const likeRatio = totals.likes + totals.dislikes > 0
        ? Math.round((totals.likes / (totals.likes + totals.dislikes)) * 100)
        : 0;

    // Generate views chart
    const viewsChartHTML = generateViewsChartSVG(viewsByDay, periodDays);

    // Generate subscribers chart if data available
    const subscribersChartHTML = followerData ? generateSubscribersChartSVG(followerData.subscribersByDay, periodDays) : '';

    // Time period options
    const periodOptions = [
        { value: 7, label: t('analytics.last7days') },
        { value: 30, label: t('analytics.last30days') },
        { value: 90, label: t('analytics.last90days') },
        { value: 365, label: t('analytics.lastYear') },
        { value: 0, label: t('analytics.allTime') }
    ];

    mainContent.innerHTML = `
        <div class="analytics-page">
            <div class="analytics-header">
                <button class="back-btn" onclick="navigateTo('/my-videos')" title="${t('button.backToMyVideos')}">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                    </svg>
                </button>
                <h1>${t('analytics.title')}</h1>
                <div class="analytics-period-selector">
                    <select id="analyticsPeriodSelect" onchange="changeAnalyticsPeriod(this.value)">
                        ${periodOptions.map(opt => `<option value="${opt.value}" ${opt.value === periodDays ? 'selected' : ''}>${opt.label}</option>`).join('')}
                    </select>
                </div>
            </div>

            <!-- Overview Stats -->
            <section class="analytics-section">
                <div class="section-header-row">
                    <h2>${t('analytics.overview')}</h2>
                    <span class="period-label">${periodDays === 0 ? t('analytics.allTime') : t('analytics.lastNDays', { n: periodDays })}</span>
                </div>
                <div class="analytics-stats-grid">
                    <div class="analytics-stat-card">
                        <div class="stat-icon views">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.views)}</div>
                            <div class="stat-label">${t('analytics.totalViews')}</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon likes">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.likes)}</div>
                            <div class="stat-label">${t('analytics.likesRatio', { ratio: likeRatio })}</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon dislikes">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.dislikes)}</div>
                            <div class="stat-label">${t('analytics.dislikes')}</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon zaps">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatSats(totals.zapAmount)} sats</div>
                            <div class="stat-label">${t('analytics.zapsReceived', { count: totals.zapCount })}</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon boosts">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.boostCount)}</div>
                            <div class="stat-label">${t('analytics.boostsReceived')}</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon shares">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.shares)}</div>
                            <div class="stat-label">${t('analytics.shares')}</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon comments">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.comments)}</div>
                            <div class="stat-label">${t('analytics.comments')}</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon content">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8 12.5v-9l6 4.5-6 4.5z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${videos.length + shorts.length + liveStreams.length}</div>
                            <div class="stat-label">${t('analytics.contentCount', { videos: videos.length, shorts: shorts.length, streams: liveStreams.length })}</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Views Chart -->
            <section class="analytics-section">
                <div class="section-header-row">
                    <h2>${t('analytics.views')}</h2>
                    <span class="period-label">${periodDays === 0 ? t('analytics.allTime') : t('analytics.lastNDays', { n: periodDays })}</span>
                </div>
                <div class="views-chart-container">
                    ${viewsChartHTML}
                    <div class="chart-tooltip" id="chartTooltip"></div>
                </div>
            </section>

            ${followerData ? `
            <!-- Followers Chart -->
            <section class="analytics-section">
                <div class="section-header-row">
                    <h2>${t('analytics.followers')}</h2>
                    <span class="period-label">${periodDays === 0 ? t('analytics.allTime') : t('analytics.lastNDays', { n: periodDays })}</span>
                </div>
                <div class="subscribers-summary">
                    <div class="subscriber-stat ${followerData.netGrowth >= 0 ? 'positive' : 'negative'}">
                        <span class="subscriber-value">${followerData.netGrowth >= 0 ? '+' : ''}${formatNumber(followerData.netGrowth)}</span>
                        <span class="subscriber-label">${t('analytics.netGrowth')}</span>
                    </div>
                    <div class="subscriber-stat positive">
                        <span class="subscriber-value">+${formatNumber(followerData.totalNewFollowers)}</span>
                        <span class="subscriber-label">${t('analytics.newFollowers')}</span>
                    </div>
                    <div class="subscriber-stat negative">
                        <span class="subscriber-value">-${formatNumber(followerData.totalUnfollows)}</span>
                        <span class="subscriber-label">${t('analytics.unfollowed')}</span>
                    </div>
                </div>
                <div class="views-chart-container">
                    ${subscribersChartHTML}
                    <div class="chart-tooltip" id="subscribersTooltip"></div>
                </div>
            </section>
            ` : ''}

            <!-- Top Performing Content -->
            ${sortedByViews.length > 0 ? `
            <section class="analytics-section">
                <h2>${t('analytics.topByViews')}</h2>
                <div class="analytics-video-list">
                    ${sortedByViews.map((event, index) => createAnalyticsVideoRow(event, perVideo.get(event.id), index + 1)).join('')}
                </div>
            </section>
            ` : ''}

            ${sortedByEngagement.length > 0 ? `
            <section class="analytics-section">
                <h2>${t('analytics.topByEngagement')}</h2>
                <div class="analytics-video-list">
                    ${sortedByEngagement.map((event, index) => createAnalyticsVideoRow(event, perVideo.get(event.id), index + 1)).join('')}
                </div>
            </section>
            ` : ''}

            <!-- All Content Performance -->
            <section class="analytics-section">
                <h2>${t('analytics.allContent')}</h2>
                <div class="analytics-tabs">
                    <button class="analytics-tab active" data-tab="videos" onclick="switchAnalyticsTab('videos')">
                        ${t('analytics.videosTab', { count: videos.length })}
                    </button>
                    <button class="analytics-tab" data-tab="shorts" onclick="switchAnalyticsTab('shorts')">
                        ${t('analytics.shortsTab', { count: shorts.length })}
                    </button>
                    <button class="analytics-tab" data-tab="streams" onclick="switchAnalyticsTab('streams')">
                        ${t('analytics.streamsTab', { count: liveStreams.length })}
                    </button>
                </div>
                <div class="analytics-tab-content" id="analyticsVideosTab">
                    ${videos.length > 0 ? `
                        <div class="analytics-video-list">
                            ${videos.map((event, index) => createAnalyticsVideoRow(event, perVideo.get(event.id), index + 1)).join('')}
                        </div>
                    ` : `<p class="empty-message">${t('analytics.noVideosYet')}</p>`}
                </div>
                <div class="analytics-tab-content" id="analyticsShortsTab" style="display: none;">
                    ${shorts.length > 0 ? `
                        <div class="analytics-video-list">
                            ${shorts.map((event, index) => createAnalyticsVideoRow(event, perVideo.get(event.id), index + 1)).join('')}
                        </div>
                    ` : `<p class="empty-message">${t('analytics.noShortsYet')}</p>`}
                </div>
                <div class="analytics-tab-content" id="analyticsStreamsTab" style="display: none;">
                    ${liveStreams.length > 0 ? `
                        <div class="analytics-video-list">
                            ${liveStreams.map((event, index) => createAnalyticsLiveStreamRow(event, perVideo.get(event.id), index + 1)).join('')}
                        </div>
                    ` : `<p class="empty-message">${t('analytics.noStreamsYet')}</p>`}
                </div>
            </section>
        </div>
    `;

    // Setup chart tooltip interactivity
    setupChartTooltips();
}

// Setup chart tooltip interactions
function setupChartTooltips() {
    // Views chart tooltips
    const chartPoints = document.querySelectorAll('.chart-point');
    const viewsTooltip = document.getElementById('chartTooltip');

    if (viewsTooltip) {
        chartPoints.forEach(point => {
            point.addEventListener('mouseenter', (e) => {
                const value = point.getAttribute('data-value');
                const date = point.getAttribute('data-date');
                viewsTooltip.innerHTML = `
                    <div class="chart-tooltip-date">${date}</div>
                    <div class="chart-tooltip-value">${t('analytics.viewsTooltip', { count: formatNumber(parseInt(value)) })}</div>
                `;
                viewsTooltip.classList.add('visible');

                // Position tooltip near the point
                const rect = point.getBoundingClientRect();
                const container = viewsTooltip.parentElement.getBoundingClientRect();
                viewsTooltip.style.left = `${rect.left - container.left + rect.width / 2}px`;
                viewsTooltip.style.top = `${rect.top - container.top - 40}px`;
                viewsTooltip.style.transform = 'translateX(-50%)';
            });

            point.addEventListener('mouseleave', () => {
                viewsTooltip.classList.remove('visible');
            });
        });
    }

    // Subscribers chart tooltips
    const chartBars = document.querySelectorAll('.chart-bar');
    const subscribersTooltip = document.getElementById('subscribersTooltip');

    if (subscribersTooltip) {
        chartBars.forEach(bar => {
            bar.addEventListener('mouseenter', (e) => {
                const value = parseInt(bar.getAttribute('data-value'));
                const date = bar.getAttribute('data-date');
                subscribersTooltip.innerHTML = `
                    <div class="chart-tooltip-date">${date}</div>
                    <div class="chart-tooltip-value">${value >= 0 ? '+' : ''}${t('analytics.subscribersTooltip', { count: formatNumber(value) })}</div>
                `;
                subscribersTooltip.classList.add('visible');

                // Position tooltip near the bar
                const rect = bar.getBoundingClientRect();
                const container = subscribersTooltip.parentElement.getBoundingClientRect();
                subscribersTooltip.style.left = `${rect.left - container.left + rect.width / 2}px`;
                subscribersTooltip.style.top = `${Math.min(rect.top, rect.bottom) - container.top - 40}px`;
                subscribersTooltip.style.transform = 'translateX(-50%)';
            });

            bar.addEventListener('mouseleave', () => {
                subscribersTooltip.classList.remove('visible');
            });
        });
    }
}

// Change analytics time period
async function changeAnalyticsPeriod(periodValue) {
    const periodDays = parseInt(periodValue);
    // Use a very large number for "all time" to effectively get all data
    const effectivePeriod = periodDays === 0 ? 36500 : periodDays; // ~100 years for all time

    const mainContent = document.getElementById('mainContent');

    // Show loading state (same as initial load)
    mainContent.innerHTML = `
        <div class="analytics-page">
            <div class="analytics-header">
                <button class="back-btn" onclick="navigateTo('/my-videos')" title="${t('button.backToMyVideos')}">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                    </svg>
                </button>
                <h1>Channel Analytics</h1>
            </div>
            <div class="analytics-loading">
                <div class="spinner"></div>
                <p>Loading your analytics...</p>
            </div>
        </div>
    `;

    try {
        if (!currentAnalyticsContent) {
            // Fallback to full reload
            await loadAnalytics(effectivePeriod);
            return;
        }

        const { videos, shorts, liveStreams, allContent } = currentAnalyticsContent;

        // Fetch new data for the selected period
        const [analyticsData, followerData] = await Promise.all([
            fetchAnalyticsData(allContent, effectivePeriod),
            fetchFollowerGrowthData(currentUser.pubkey, effectivePeriod)
        ]);

        // Override periodDays in analytics data for display
        analyticsData.periodDays = periodDays;

        // Re-render with new data
        renderAnalyticsPage(videos, shorts, liveStreams, analyticsData, followerData);
    } catch (error) {
        console.error('Failed to change analytics period:', error);
        showToast('Failed to update analytics. Please try again.', 'error');
        // Reload the page on error
        await loadAnalytics(effectivePeriod);
    }
}

// Create analytics video row
function createAnalyticsVideoRow(event, data, rank) {
    const videoData = parseAnyVideoEvent(event);
    if (!videoData) return '';

    const stats = data || { views: 0, likes: 0, dislikes: 0, zapAmount: 0, zapCount: 0, boosts: 0, shares: 0, comments: 0 };
    const isShort = isNip71ShortKind(event.kind);

    return `
        <div class="analytics-video-row" onclick="navigateTo('/video/${event.id}')">
            <div class="analytics-rank">#${rank}</div>
            <div class="analytics-thumbnail">
                ${videoData.thumbnail ? `<img src="${videoData.thumbnail}" alt="">` : '<div class="no-thumb"></div>'}
                ${isShort ? '<span class="content-type-badge short">Short</span>' : ''}
            </div>
            <div class="analytics-video-info">
                <div class="analytics-video-title">${escapeHtml(videoData.title || 'Untitled')}</div>
                <div class="analytics-video-date">${formatTimestamp(event.created_at)}</div>
            </div>
            <div class="analytics-video-stats">
                <div class="stat-item">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/>
                    </svg>
                    <span>${formatNumber(stats.views)}</span>
                </div>
                <div class="stat-item likes">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                    <span>${formatNumber(stats.likes)}</span>
                </div>
                <div class="stat-item dislikes">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                    <span>${formatNumber(stats.dislikes)}</span>
                </div>
                <div class="stat-item zaps">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                    </svg>
                    <span>${formatSats(stats.zapAmount)}</span>
                </div>
                <div class="stat-item comments">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                    </svg>
                    <span>${formatNumber(stats.comments || 0)}</span>
                </div>
                <div class="stat-item shares">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/>
                    </svg>
                    <span>${formatNumber(stats.shares)}</span>
                </div>
            </div>
        </div>
    `;
}

// Create analytics live stream row
function createAnalyticsLiveStreamRow(event, data, rank) {
    const liveData = parseLiveEvent(event);
    if (!liveData) return '';

    const stats = data || { views: 0, likes: 0, dislikes: 0, zapAmount: 0, zapCount: 0, boosts: 0, shares: 0, comments: 0 };
    const isEnded = isLiveStreamEnded(liveData);
    const isActive = isLiveStreamActive(liveData);

    let statusBadge = '';
    if (isActive) statusBadge = '<span class="content-type-badge live">LIVE</span>';
    else if (isEnded) statusBadge = '<span class="content-type-badge ended">ENDED</span>';
    else statusBadge = '<span class="content-type-badge scheduled">SCHEDULED</span>';

    return `
        <div class="analytics-video-row" onclick="navigateTo('/live/${event.id}')">
            <div class="analytics-rank">#${rank}</div>
            <div class="analytics-thumbnail">
                ${liveData.thumbnail ? `<img src="${liveData.thumbnail}" alt="">` : '<div class="no-thumb"></div>'}
                ${statusBadge}
            </div>
            <div class="analytics-video-info">
                <div class="analytics-video-title">${escapeHtml(liveData.title || 'Untitled Stream')}</div>
                <div class="analytics-video-date">${formatTimestamp(event.created_at)}</div>
            </div>
            <div class="analytics-video-stats">
                <div class="stat-item">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/>
                    </svg>
                    <span>${formatNumber(stats.views)}</span>
                </div>
                <div class="stat-item likes">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                    <span>${formatNumber(stats.likes)}</span>
                </div>
                <div class="stat-item dislikes">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                    <span>${formatNumber(stats.dislikes)}</span>
                </div>
                <div class="stat-item zaps">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                    </svg>
                    <span>${formatSats(stats.zapAmount)}</span>
                </div>
                <div class="stat-item comments">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                    </svg>
                    <span>${formatNumber(stats.comments || 0)}</span>
                </div>
            </div>
        </div>
    `;
}

// Switch analytics tab
function switchAnalyticsTab(tab) {
    // Update tab buttons
    document.querySelectorAll('.analytics-tab').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tab);
    });

    // Update tab content
    document.getElementById('analyticsVideosTab').style.display = tab === 'videos' ? 'block' : 'none';
    document.getElementById('analyticsShortsTab').style.display = tab === 'shorts' ? 'block' : 'none';
    document.getElementById('analyticsStreamsTab').style.display = tab === 'streams' ? 'block' : 'none';
}

// Create a draft card for display
function createDraftCard(draftId, draft) {
    const thumbnailUrl = draft.thumbnailUrl || '';
    const title = draft.title || 'Untitled Draft';
    const updatedAt = draft.updatedAt ? new Date(draft.updatedAt).toLocaleDateString() : '';

    return `
        <div class="video-card draft-card" data-draft-id="${draftId}">
            <div class="video-thumbnail draft-thumbnail" onclick="editDraft('${draftId}')">
                ${thumbnailUrl ? `<img src="${thumbnailUrl}" alt="${escapeHtml(title)}">` : `
                    <div class="draft-placeholder">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor" style="opacity: 0.5;">
                            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                        </svg>
                    </div>
                `}
                <div class="draft-badge">DRAFT</div>
            </div>
            <div class="video-info">
                <div class="video-details">
                    <div class="video-title">${escapeHtml(title)}</div>
                    <div class="channel-details">
                        <span class="channel-name" style="color: var(--text-secondary);">Last updated: ${updatedAt}</span>
                    </div>
                </div>
            </div>
            <div class="draft-actions">
                <button class="draft-edit-btn" onclick="editDraft('${draftId}')" title="${t('button.editDraft')}">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                    </svg>
                </button>
                <button class="draft-delete-btn" onclick="confirmDeleteDraft('${draftId}')" title="${t('button.deleteDraft')}">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                    </svg>
                </button>
            </div>
        </div>
    `;
}

// Edit a draft
function editDraft(draftId) {
    const draft = getDraft(draftId);
    if (!draft) {
        showToast('Draft not found', 'error');
        return;
    }

    // Open upload modal with draft data populated
    showUploadModal();

    // Populate form with draft data after a short delay for modal to render
    setTimeout(() => {
        const titleInput = document.getElementById('videoTitle');
        const descInput = document.getElementById('videoDescription');
        const tagsInput = document.getElementById('videoTags');
        const nsfwCheckbox = document.getElementById('nsfwCheckbox');
        const syncToNostrCheckbox = document.getElementById('saveDraftToNostr');

        if (titleInput) titleInput.value = draft.title || '';
        if (descInput) descInput.value = draft.description || '';
        if (tagsInput) tagsInput.value = (draft.tags || []).join(', ');
        if (nsfwCheckbox) nsfwCheckbox.checked = draft.isNSFW || false;
        if (syncToNostrCheckbox) syncToNostrCheckbox.checked = draft.syncToNostr || draft.nostrEventId ? true : false;

        // Store draft ID for when publishing
        uploadState.draftId = draftId;

        // Restore video preview if draft has video URL
        if (draft.videoUrl) {
            uploadState.video = {
                file: null,
                status: 'complete',
                progress: 100,
                url: draft.videoUrl,
                hash: draft.videoHash || null,
                error: null,
                size: draft.videoSize || 0,
                type: draft.videoType || 'video/mp4',
                duration: draft.videoDuration || 0,
                dimensions: draft.videoDimensions || null,
                mirrors: draft.mirrors || []
            };

            // Show video preview
            const videoPreview = document.getElementById('videoPreview');
            const videoPlayer = document.getElementById('videoPreviewPlayer');
            const videoUploadProgress = document.getElementById('videoUploadProgress');
            const videoUpload = document.getElementById('videoUpload');

            if (videoPlayer) videoPlayer.src = draft.videoUrl;
            if (videoPreview) videoPreview.style.display = 'block';
            if (videoUploadProgress) videoUploadProgress.style.display = 'block';
            if (videoUpload) videoUpload.style.display = 'none';

            // Update status text
            const videoUploadStatus = document.getElementById('videoUploadStatus');
            if (videoUploadStatus) videoUploadStatus.textContent = t('status.fromDraft');
        }

        // Restore thumbnail preview if draft has thumbnail URL
        if (draft.thumbnailUrl) {
            uploadState.thumbnail = {
                file: null,
                status: 'complete',
                progress: 100,
                url: draft.thumbnailUrl,
                error: null
            };

            // Show thumbnail preview
            const thumbnailPreview = document.getElementById('thumbnailPreview');
            const thumbnailImage = document.getElementById('thumbnailPreviewImage');
            const thumbnailUploadProgress = document.getElementById('thumbnailUploadProgress');
            const thumbnailUpload = document.getElementById('thumbnailUpload');

            if (thumbnailImage) thumbnailImage.src = draft.thumbnailUrl;
            if (thumbnailPreview) thumbnailPreview.style.display = 'block';
            if (thumbnailUploadProgress) thumbnailUploadProgress.style.display = 'block';
            if (thumbnailUpload) thumbnailUpload.style.display = 'none';

            // Update status text
            const thumbnailUploadStatus = document.getElementById('thumbnailUploadStatus');
            if (thumbnailUploadStatus) thumbnailUploadStatus.textContent = t('status.fromDraft');
        }

        // Update publish button state
        updatePublishButton();

        showToast('Draft loaded. Complete your upload and publish.', 'info');
    }, 100);
}

// Confirm and delete a draft
async function confirmDeleteDraft(draftId) {
    showConfirmModal(
        'Delete Draft',
        'Are you sure you want to delete this draft?',
        async () => {
            // Delete from both localStorage and Nostr (if the user is logged in)
            const deleteFromNostr = currentUser;
            await deleteDraft(draftId, deleteFromNostr);
            showToast('Draft deleted', 'info');
            loadMyVideos(); // Refresh the page
        },
        { confirmText: 'Delete', danger: true }
    );
}

// Save current upload form as a draft
async function saveCurrentAsDraft() {
    const title = document.getElementById('videoTitle')?.value || '';
    const description = document.getElementById('videoDescription')?.value || '';
    const tagsInput = document.getElementById('videoTags')?.value || '';
    const tags = tagsInput.split(',').map(t => t.trim()).filter(t => t);
    const isNSFW = document.getElementById('nsfwCheckbox')?.checked || false;

    // Get video and thumbnail URLs if uploaded
    const videoUrl = uploadState.video?.url || null;
    const videoHash = uploadState.video?.hash || null;
    const thumbnailUrl = uploadState.thumbnail?.url || null;

    if (!title.trim() && !description.trim() && !videoUrl) {
        showToast('Nothing to save - add a title or upload a video first', 'warning');
        return;
    }

    const draftData = {
        id: uploadState.draftId || null, // Use existing draft ID if editing
        title: title,
        description: description,
        tags: tags,
        isNSFW: isNSFW,
        videoUrl: videoUrl,
        videoHash: videoHash,
        thumbnailUrl: thumbnailUrl,
        videoDuration: uploadState.video?.duration || 0,
        videoSize: uploadState.video?.size || 0,
        videoType: uploadState.video?.type || null,
        videoDimensions: uploadState.video?.dimensions || null,
        mirrors: uploadState.video?.mirrors || [],
        syncToNostr: true // Always sync drafts to Nostr
    };

    // Always sync drafts to Nostr (user must be logged in to access upload page)
    const draftId = await saveDraft(draftData, true);

    // Update the uploadState with the draft ID so future saves update the same draft
    uploadState.draftId = draftId;

    showToast('Draft saved! You can continue later from My Videos.', 'success');
}

// Load videos by tag with streaming
async function loadTag(tag) {
    const normalizedTag = tag.toLowerCase();
    currentView = `tag-${normalizedTag}`;

    const displayTag = normalizedTag.charAt(0).toUpperCase() + normalizedTag.slice(1);

    // Setup page with shorts section and video grid
    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const skeletonCount = cardsPerRow * 5;
    const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');

    mainContent.innerHTML = `
        <h2 style="margin-bottom: 1.5rem;">${displayTag} ${t('section.videos')}</h2>
        <!-- Shorts Section -->
        <div id="tagShortsSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M10 8l6 4-6 4V8z"/>
                </svg>
                ${t('section.shorts')}
            </h3>
            <div class="shorts-grid" id="tagShortsGrid"></div>
        </div>
        <!-- Videos Section -->
        <div class="video-grid" id="videoGrid">
            ${skeletons}
        </div>
    `;

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('tagShortsGrid');
    const shortsSection = document.getElementById('tagShortsSection');

    // Fetch all videos and live streams for this tag
    const filter = {
        kinds: [...ALL_VIDEO_KINDS, NIP53_LIVE_EVENT_KIND],
        '#t': ['pv69420'],
        limit: 500
    };

    // Store live stream data for rendering
    const liveStreamData = new Map();

    const tagFilter = (event) => {
        const tags = event.tags || [];
        // For NSFW tag page, also include events with content-warning: nsfw (case-insensitive)
        if (normalizedTag === 'nsfw') {
            return tags.some(t => t[0] === 't' && t[1].toLowerCase() === 'nsfw') ||
                tags.some(t => t[0] === 'content-warning' && t[1]?.toLowerCase() === 'nsfw');
        }
        return tags.some(t => t[0] === 't' && t[1].toLowerCase() === normalizedTag);
    };

    const videoEvents = [];
    const shortEvents = [];
    const profileQueue = new Set();
    const reactionQueue = new Set();
    let profileTimer = null;
    let reactionTimer = null;

    const loadProfilesBatch = async () => {
        if (profileQueue.size === 0) return;
        const pubkeys = Array.from(profileQueue);
        profileQueue.clear();

        const BATCH_SIZE = 25;
        const chunks = [];
        for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
            chunks.push(pubkeys.slice(i, i + BATCH_SIZE));
        }

        await Promise.all(chunks.map(async (chunk) => {
            const profileFilter = { kinds: [0], authors: chunk };
            await requestEventsStream(profileFilter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);
                    [...videoEvents, ...shortEvents].forEach(event => {
                        if (event.pubkey === profileEvent.pubkey) {
                            updateVideoCardInPlace(event.id, profile, reactionsCache.get(event.id));
                        }
                    });
                } catch (e) { }
            });
        }));
    };

    const loadReactionsBatch = async () => {
        if (reactionQueue.size === 0) return;
        const videoIds = Array.from(reactionQueue);
        reactionQueue.clear();
        await loadReactionsForVideos(videoIds);
    };

    await requestEventsStream(filter, (event) => {
        const tags = event.tags || [];

        // Handle live streams separately
        if (event.kind === NIP53_LIVE_EVENT_KIND) {
            if (!tagFilter(event)) return;

            const liveData = parseLiveEvent(event);
            if (!liveData || !isLiveStreamActive(liveData)) return;

            allEvents.set(event.id, event);
            liveStreamData.set(event.id, liveData);
            videoEvents.push(event);

            // Remove skeleton cards
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            const cachedProfile = profileCache.get(event.pubkey);
            const cardHTML = createLiveStreamCard(event, liveData, cachedProfile);

            if (cardHTML) {
                // Insert live streams at the beginning (they're more time-sensitive)
                videoGrid.insertAdjacentHTML('afterbegin', cardHTML);
                // Load boosts for live stream
                if (!boostsCache.has(event.id)) {
                    loadBoostsForVideo(event.id);
                }
            }

            if (!cachedProfile) {
                profileQueue.add(event.pubkey);
                clearTimeout(profileTimer);
                profileTimer = setTimeout(loadProfilesBatch, 100);
            }
            return;
        }

        // Regular video handling
        if (!tags.some(tag => tag[0] === 'x')) return;
        if (!tagFilter(event)) return;

        allEvents.set(event.id, event);

        // Remove any legacy counterpart that was already added (handles race condition)
        if (event.kind === NIP71_VIDEO_KIND) {
            removeLegacyCounterpart(event, videoEvents);
        } else if (event.kind === NIP71_SHORT_KIND) {
            removeLegacyCounterpart(event, shortEvents);
        }

        if (shouldSkipLegacyEvent(event)) return;

        const isShort = isNip71ShortKind(event.kind);
        const targetGrid = isShort ? shortsGrid : videoGrid;
        const targetEvents = isShort ? shortEvents : videoEvents;

        targetEvents.push(event);

        if (isShort && shortsSection) {
            shortsSection.style.display = 'block';
        }

        // Remove skeleton cards
        if (!isShort) {
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }
        }

        const cachedProfile = profileCache.get(event.pubkey);
        const cachedReactions = reactionsCache.get(event.id);
        const cardHTML = isShort
            ? createShortCard(event, cachedProfile, cachedReactions)
            : createVideoCard(event, cachedProfile, cachedReactions);

        if (cardHTML) {
            targetGrid.insertAdjacentHTML('beforeend', cardHTML);
        }

        if (!cachedProfile) {
            profileQueue.add(event.pubkey);
            clearTimeout(profileTimer);
            profileTimer = setTimeout(loadProfilesBatch, 100);
        }

        reactionQueue.add(event.id);
        clearTimeout(reactionTimer);
        reactionTimer = setTimeout(loadReactionsBatch, 200);

    }, () => {
        // Remove remaining skeletons
        videoGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());

        if (videoEvents.length === 0 && shortEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosForTag')}</p>`;
        } else if (videoEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthForTag')}</p>`;
        }

        if (profileQueue.size > 0) loadProfilesBatch();
        if (reactionQueue.size > 0) loadReactionsBatch();

        // Load views for tag page videos
        const tagVideoIds = [...videoEvents.map(e => e.id), ...shortEvents.map(e => e.id)];
        if (tagVideoIds.length > 0) {
            loadViewsForVideos(tagVideoIds, true);
        }

        observeLazyCards();
    });
}

// Handle deleting video
async function handleDelete(eventId) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to delete videos', 'warning');
            return;
        }
    }

    showConfirmModal(
        'Delete Video',
        'Are you sure you want to delete this video? This action cannot be undone.',
        async () => {
            try {
                // Get the event to check if it has a linked NIP-71 event
                const event = allEvents.get(eventId);
                const linkedEventId = videoEventLinks.get(eventId);

                // Create deletion tags for both events if linked
                const deletionTags = [['e', eventId], ['t', 'pv69420']];
                if (linkedEventId) {
                    deletionTags.push(['e', linkedEventId]);
                }

                // If this is a NIP-71 event with a d-tag, add an 'a' tag for the addressable deletion
                if (event && isNip71Kind(event.kind)) {
                    const dTag = event.tags?.find(t => t[0] === 'd')?.[1];
                    if (dTag) {
                        deletionTags.push(['a', `${event.kind}:${event.pubkey}:${dTag}`]);
                    }
                }

                const deleteEvent = {
                    kind: 5,
                    tags: deletionTags,
                    content: 'Deletion request',
                    created_at: Math.floor(Date.now() / 1000)
                };

                const signedEvent = await signEvent(deleteEvent);
                const published = await publishEvent(signedEvent);

                if (published) {
                    // Remove the card from DOM if it exists on the current page
                    const card = document.getElementById(`video-card-${eventId}`);
                    if (card) {
                        // Animate removal
                        card.style.transition = 'opacity 0.3s, transform 0.3s';
                        card.style.opacity = '0';
                        card.style.transform = 'scale(0.9)';
                        setTimeout(() => {
                            card.remove();

                            // Check if we need to show empty state messages
                            const videoGrid = document.getElementById('videoGrid');
                            const shortsGrid = document.getElementById('myVideosShortsGrid');
                            const shortsSection = document.getElementById('myVideosShortsSection');

                            // Check if videos grid is empty (excluding empty state messages)
                            if (videoGrid && videoGrid.querySelectorAll('.video-card').length === 0) {
                                const existingMsg = videoGrid.querySelector('p');
                                if (!existingMsg) {
                                    videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosUploadFirst')}</p>`;
                                }
                            }

                            // Check if shorts grid is empty
                            if (shortsGrid && shortsGrid.querySelectorAll('.short-card, .video-card').length === 0) {
                                if (shortsSection) {
                                    shortsSection.style.display = 'none';
                                }
                            }
                        }, 300);

                        // Remove from allEvents cache
                        allEvents.delete(eventId);
                        if (linkedEventId) {
                            allEvents.delete(linkedEventId);
                        }

                        showToast('Video deleted successfully', 'success');
                    } else {
                        // Card not on current page, navigate to my-videos
                        showToast('Deletion request sent to relays. The video may take some time to be removed.', 'info');
                        navigateTo('/my-videos');
                    }
                } else {
                    showToast('Failed to send deletion request. Please try again.', 'error');
                }
            } catch (error) {
                console.error('Failed to delete video:', error);
                showToast('Failed to delete video: ' + error.message, 'error');
            }
        },
        { confirmText: 'Delete', danger: true }
    );
}

// ===== VIDEO EDITING FUNCTIONS =====

// Current edit state
let editVideoState = {
    eventId: null,
    event: null,
    videoData: null,
    newThumbnailUrl: null
};

// Show the edit video modal
async function showEditVideoModal(eventId) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to edit videos', 'warning');
            return;
        }
    }

    const event = allEvents.get(eventId);
    if (!event) {
        showToast('Video not found', 'error');
        return;
    }

    // Verify ownership
    if (event.pubkey !== currentUser.pubkey) {
        showToast('You can only edit your own videos', 'error');
        return;
    }

    // Parse video data
    const videoData = parseAnyVideoEvent(event);
    if (!videoData) {
        showToast('Could not parse video data', 'error');
        return;
    }

    // Store edit state
    editVideoState = {
        eventId: eventId,
        event: event,
        videoData: videoData,
        newThumbnailUrl: null
    };

    // Populate the form
    document.getElementById('editVideoTitle').value = videoData.title || '';
    document.getElementById('editVideoDescription').value = videoData.description || '';
    document.getElementById('editVideoTags').value = (videoData.tags || []).join(', ');
    document.getElementById('editNsfwCheckbox').checked = videoData.isNSFW || false;

    // Set hidden fields
    document.getElementById('editVideoEventId').value = eventId;
    // Get d-tag from parsed data or directly from event tags
    const dTag = videoData.dTag || event.tags?.find(t => t[0] === 'd')?.[1] || '';
    document.getElementById('editVideoDTag').value = dTag;
    document.getElementById('editVideoHash').value = videoData.hash || '';
    document.getElementById('editVideoUrl').value = videoData.url || '';
    document.getElementById('editVideoType').value = videoData.type || 'video/mp4';
    document.getElementById('editVideoSize').value = videoData.size || 0;
    document.getElementById('editVideoDuration').value = videoData.duration || 0;
    document.getElementById('editVideoWidth').value = videoData.width || 0;
    document.getElementById('editVideoHeight').value = videoData.height || 0;
    document.getElementById('editVideoPublishedAt').value = videoData.publishedAt || event.created_at;
    document.getElementById('editNewThumbnailUrl').value = '';

    // Set video preview
    const videoPreview = document.getElementById('editVideoPreview');
    if (videoPreview && videoData.url) {
        videoPreview.src = videoData.url;
    }

    // Set thumbnail preview
    const thumbnailPreview = document.getElementById('editThumbnailPreview');
    if (thumbnailPreview && videoData.thumbnail) {
        thumbnailPreview.src = videoData.thumbnail;
        thumbnailPreview.style.display = 'block';
    }

    // Show the modal
    const modal = document.getElementById('editVideoModal');
    if (modal) {
        modal.classList.add('active');
    }
}

// Hide the edit video modal
function hideEditVideoModal() {
    const modal = document.getElementById('editVideoModal');
    if (modal) {
        modal.classList.remove('active');
    }

    // Pause video preview
    const videoPreview = document.getElementById('editVideoPreview');
    if (videoPreview) {
        videoPreview.pause();
        videoPreview.src = '';
    }

    // Reset edit state
    editVideoState = {
        eventId: null,
        event: null,
        videoData: null,
        newThumbnailUrl: null
    };
}

// Handle edit form submission
async function handleEditVideoSubmit(e) {
    e.preventDefault();

    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to edit videos', 'warning');
            return;
        }
    }

    const saveBtn = document.getElementById('saveEditButton');
    const originalText = saveBtn.textContent;
    saveBtn.textContent = t('status.saving');
    saveBtn.disabled = true;

    try {
        const title = document.getElementById('editVideoTitle').value.trim();
        const description = document.getElementById('editVideoDescription').value.trim();
        const tagsInput = document.getElementById('editVideoTags').value;
        const tags = tagsInput.split(',').map(t => t.trim()).filter(t => t);
        const isNSFW = document.getElementById('editNsfwCheckbox').checked;

        if (!title) {
            showToast('Please enter a title', 'warning');
            saveBtn.textContent = originalText;
            saveBtn.disabled = false;
            return;
        }

        // Add nsfw tag if checked
        if (isNSFW && !tags.includes('nsfw')) {
            tags.push('nsfw');
        }

        // Get video data from hidden fields
        const videoHash = document.getElementById('editVideoHash').value;
        const videoUrl = document.getElementById('editVideoUrl').value;
        const videoType = document.getElementById('editVideoType').value;
        const videoSize = parseInt(document.getElementById('editVideoSize').value) || 0;
        const videoDuration = parseInt(document.getElementById('editVideoDuration').value) || 0;
        const videoWidth = parseInt(document.getElementById('editVideoWidth').value) || 0;
        const videoHeight = parseInt(document.getElementById('editVideoHeight').value) || 0;
        const publishedAt = parseInt(document.getElementById('editVideoPublishedAt').value) || Math.floor(Date.now() / 1000);
        const originalDTag = document.getElementById('editVideoDTag').value;

        // Ensure we have a d-tag for replacement - without it, we'd create a new video
        if (!originalDTag) {
            showToast('This video cannot be edited because it lacks a replacement identifier (d-tag). This may be a legacy video.', 'warning', 5000);
            saveBtn.textContent = originalText;
            saveBtn.disabled = false;
            return;
        }

        // Check if video was replaced
        const videoReplaced = document.getElementById('editVideoReplaced').value === 'true';
        const newVideoMirrorsJson = document.getElementById('editNewVideoMirrors').value;

        // Use new thumbnail if uploaded, otherwise keep original
        const newThumbnailUrl = document.getElementById('editNewThumbnailUrl').value;
        const thumbnailUrl = newThumbnailUrl || editVideoState.videoData?.thumbnail || '';

        // Get mirrors - use new ones if video was replaced, otherwise use original fallbacks
        let mirrors = [];
        if (videoReplaced && newVideoMirrorsJson) {
            try {
                mirrors = JSON.parse(newVideoMirrorsJson);
            } catch (e) {
                console.warn('Failed to parse new video mirrors:', e);
            }
        } else if (editVideoState.videoData?.fallbackUrls) {
            mirrors = editVideoState.videoData.fallbackUrls.map(url => ({ url }));
        }

        // Prepare video data for republishing
        const videoData = {
            title: title,
            description: description,
            url: videoUrl,
            hash: videoHash,
            thumbnail: thumbnailUrl,
            duration: videoDuration,
            size: videoSize,
            type: videoType,
            width: videoWidth,
            height: videoHeight,
            mirrors: mirrors,
            tags: tags,
            isNSFW: isNSFW,
            dTag: originalDTag, // Use existing d-tag for replacement (validated above)
            publishedAt: publishedAt,
            originalKind: editVideoState.event?.kind // Preserve original kind to ensure proper replacement
        };

        saveBtn.textContent = t('status.publishingChanges');

        // Create NIP-71 video event (kind 21 or 22 depending on orientation)
        const nip71Event = createNip71VideoEvent(videoData);
        const signedNip71Event = await signEvent(nip71Event);

        // Publish the new event first
        const published = await publishEvent(signedNip71Event);

        if (!published) {
            throw new Error('Failed to publish to any relay');
        }

        // Handle old event cleanup based on event kind
        const oldEventId = editVideoState.eventId;
        const oldEvent = editVideoState.event;

        // For addressable events (34235/34236), the new event replaces the old one automatically
        // For legacy events (21/22), we need to explicitly delete the old version
        const isAddressableKind = oldEvent && (oldEvent.kind === NIP71_VIDEO_KIND || oldEvent.kind === NIP71_SHORT_KIND);
        const isLegacyKind = oldEvent && (oldEvent.kind === NIP71_VIDEO_KIND_LEGACY || oldEvent.kind === NIP71_SHORT_KIND_LEGACY);

        if (isLegacyKind && oldEventId && oldEventId !== signedNip71Event.id) {
            saveBtn.textContent = t('status.removingOldVersion');

            const deletionTags = [['e', oldEventId], ['t', 'pv69420']];

            const dTag = oldEvent.tags?.find(t => t[0] === 'd')?.[1];
            if (dTag) {
                deletionTags.push(['a', `${oldEvent.kind}:${oldEvent.pubkey}:${dTag}`]);
            }

            const deleteEvent = {
                kind: 5,
                tags: deletionTags,
                content: 'Replaced by updated version',
                created_at: Math.floor(Date.now() / 1000)
            };

            const signedDeleteEvent = await signEvent(deleteEvent);
            await publishEvent(signedDeleteEvent);
        }

        // Remove old event from cache (for both addressable and legacy)
        if (oldEventId && oldEventId !== signedNip71Event.id) {
            allEvents.delete(oldEventId);
        }

        // Update the event in our cache
        allEvents.set(signedNip71Event.id, signedNip71Event);

        saveBtn.textContent = t('status.saved');
        showToast('Video updated successfully', 'success');

        setTimeout(() => {
            hideEditVideoModal();
            // Reload the video page to show updated content
            playVideo(signedNip71Event.id);
        }, 1000);

    } catch (error) {
        console.error('Edit failed:', error);
        showToast(error.message || 'Failed to save changes', 'error');
        saveBtn.textContent = originalText;
        saveBtn.disabled = false;
    }
}

// Handle thumbnail change in edit modal
async function handleEditThumbnailChange(file) {
    if (!file || !file.type.startsWith('image/')) {
        showToast('Please select an image file', 'warning');
        return;
    }

    const progressDiv = document.getElementById('editThumbnailUploadProgress');
    const statusEl = document.getElementById('editThumbnailStatus');
    const progressFill = document.getElementById('editThumbnailProgressFill');

    if (progressDiv) progressDiv.style.display = 'block';
    if (statusEl) statusEl.textContent = t('status.validatingThumbnail');
    if (progressFill) progressFill.style.width = '0%';

    try {
        // Validate thumbnail orientation matches the original video type
        if (editVideoState && editVideoState.event) {
            const thumbnailDimensions = await getImageDimensions(file);
            const originalIsShort = isNip71ShortKind(editVideoState.event.kind);

            if (!isThumbnailOrientationValid(thumbnailDimensions.width, thumbnailDimensions.height, originalIsShort)) {
                if (progressDiv) progressDiv.style.display = 'none';

                if (originalIsShort) {
                    showToast('Thumbnail must be vertical (portrait) to match your Short video', 'error');
                } else {
                    showToast('Thumbnail must be horizontal (landscape) to match your video', 'error');
                }
                return;
            }
        }

        if (statusEl) statusEl.textContent = t('status.uploadingThumbnail');
        const result = await uploadToBlossom(file, BLOSSOM_SERVERS);

        if (result.success && result.url) {
            // Update preview
            const thumbnailPreview = document.getElementById('editThumbnailPreview');
            if (thumbnailPreview) {
                thumbnailPreview.src = result.url;
                thumbnailPreview.style.display = 'block';
            }

            // Store new thumbnail URL
            document.getElementById('editNewThumbnailUrl').value = result.url;
            editVideoState.newThumbnailUrl = result.url;

            if (statusEl) statusEl.textContent = t('status.thumbnailUploaded');
            if (progressFill) progressFill.style.width = '100%';

            showToast('Thumbnail updated', 'success');

            setTimeout(() => {
                if (progressDiv) progressDiv.style.display = 'none';
            }, 1500);
        } else {
            throw new Error(result.error || 'Upload failed');
        }
    } catch (error) {
        console.error('Thumbnail upload failed:', error);
        if (statusEl) statusEl.textContent = `Upload failed: ${error.message}`;
        showToast('Failed to upload thumbnail', 'error');
    }
}

// Handle video replacement in edit modal
async function handleEditVideoChange(file) {
    if (!file || !file.type.startsWith('video/')) {
        showToast('Please select a video file', 'warning');
        return;
    }

    const progressDiv = document.getElementById('editVideoUploadProgress');
    const statusEl = document.getElementById('editVideoStatus');
    const progressFill = document.getElementById('editVideoProgressFill');
    const saveBtn = document.getElementById('saveEditButton');
    const noteEl = document.getElementById('editVideoReplaceNote');

    if (progressDiv) progressDiv.style.display = 'block';
    if (statusEl) statusEl.textContent = t('status.processingVideo');
    if (progressFill) progressFill.style.width = '0%';
    if (saveBtn) saveBtn.disabled = true;
    if (noteEl) noteEl.style.display = 'none';

    try {
        // Get video metadata
        const metadata = await VideoCompressor.getVideoMetadata(file);
        const videoDimensions = { width: metadata.width, height: metadata.height };

        // Validate that the new video type matches the original video type
        // (prevent swapping a Short for a regular video or vice versa)
        if (editVideoState && editVideoState.event) {
            const originalIsShort = isNip71ShortKind(editVideoState.event.kind);
            const newIsShort = isVideoShort(metadata.width, metadata.height, metadata.duration);

            if (originalIsShort && !newIsShort) {
                if (progressDiv) progressDiv.style.display = 'none';
                if (saveBtn) saveBtn.disabled = false;
                if (noteEl) noteEl.style.display = 'block';
                showToast('Cannot replace a Short with a regular video. Please upload a vertical video (60 seconds or less).', 'error');
                return;
            }

            if (!originalIsShort && newIsShort) {
                if (progressDiv) progressDiv.style.display = 'none';
                if (saveBtn) saveBtn.disabled = false;
                if (noteEl) noteEl.style.display = 'block';
                showToast('Cannot replace a regular video with a Short. Please upload a horizontal/landscape video.', 'error');
                return;
            }
        }

        // Check if compression is needed
        let fileToUpload = file;
        const MAX_SIZE = 100 * 1024 * 1024; // 100MB

        if (file.size > MAX_SIZE) {
            if (statusEl) statusEl.textContent = t('status.compressingVideo');

            // Compress the video
            fileToUpload = await VideoCompressor.compressVideo(file, {
                maxSizeMB: 95,
                onProgress: (progress) => {
                    if (progressFill) progressFill.style.width = `${progress * 50}%`;
                    if (statusEl) statusEl.textContent = `Compressing: ${Math.round(progress * 100)}%`;
                }
            });
        }

        if (statusEl) statusEl.textContent = t('status.uploadingVideo');
        if (progressFill) progressFill.style.width = '0%';

        // Upload to blossom servers with progress callback
        const result = await uploadToBlossom(
            fileToUpload,
            BLOSSOM_SERVERS,
            'editVideoServerStatus',
            (progress, completed, total) => {
                if (progressFill) progressFill.style.width = `${progress}%`;
                if (statusEl) statusEl.textContent = `Uploading video... (${completed}/${total} servers)`;
            }
        );

        if (result.success && result.url) {
            // Update preview
            const videoPreview = document.getElementById('editVideoPreview');
            if (videoPreview) {
                videoPreview.src = result.url;
            }

            // Store new video data in hidden fields
            document.getElementById('editNewVideoUrl').value = result.url;
            document.getElementById('editNewVideoHash').value = result.hash;
            document.getElementById('editNewVideoMirrors').value = JSON.stringify(result.mirrors || []);
            document.getElementById('editVideoReplaced').value = 'true';

            // Update the existing fields with new video data
            document.getElementById('editVideoUrl').value = result.url;
            document.getElementById('editVideoHash').value = result.hash;
            document.getElementById('editVideoType').value = fileToUpload.type || 'video/mp4';
            document.getElementById('editVideoSize').value = fileToUpload.size;
            document.getElementById('editVideoDuration').value = Math.floor(metadata.duration || 0);
            document.getElementById('editVideoWidth').value = videoDimensions.width;
            document.getElementById('editVideoHeight').value = videoDimensions.height;

            // Update edit state
            editVideoState.newVideoUrl = result.url;
            editVideoState.newVideoHash = result.hash;
            editVideoState.newVideoMirrors = result.mirrors || [];
            editVideoState.videoDimensions = videoDimensions;

            if (statusEl) statusEl.textContent = t('status.videoUploaded');
            if (progressFill) progressFill.style.width = '100%';
            if (saveBtn) saveBtn.disabled = false;

            showToast('Video replaced successfully', 'success');

            setTimeout(() => {
                if (progressDiv) progressDiv.style.display = 'none';
            }, 1500);
        } else {
            throw new Error(result.error || 'Upload failed');
        }
    } catch (error) {
        console.error('Video upload failed:', error);
        if (statusEl) statusEl.textContent = `Upload failed: ${error.message}`;
        if (saveBtn) saveBtn.disabled = false;
        if (noteEl) noteEl.style.display = 'block';
        showToast('Failed to upload video', 'error');
    }
}

// Initialize edit video form listeners
function initEditVideoForm() {
    const editForm = document.getElementById('editVideoForm');
    if (editForm) {
        editForm.addEventListener('submit', handleEditVideoSubmit);
    }

    const editThumbnailFile = document.getElementById('editThumbnailFile');
    if (editThumbnailFile) {
        editThumbnailFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleEditThumbnailChange(file);
            }
        });
    }

    const editVideoFile = document.getElementById('editVideoFile');
    if (editVideoFile) {
        editVideoFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleEditVideoChange(file);
            }
        });
    }
}

// Get cached author stats (video count and follower count)
async function getAuthorStats(pubkey) {
    const cached = authorStatsCache.get(pubkey);
    if (cached && Date.now() - cached.timestamp < AUTHOR_STATS_CACHE_TTL) {
        return cached.stats;
    }

    // Fetch video count and follower count sequentially to reduce relay load
    try {
        const videoCount = await fetchAuthorVideoCount(pubkey);
        const followerCount = await fetchAuthorFollowerCount(pubkey);

        const stats = { videoCount, followerCount };
        authorStatsCache.set(pubkey, { stats, timestamp: Date.now() });
        return stats;
    } catch (error) {
        console.error('Failed to fetch author stats:', error);
        // Return cached data even if expired, or zeros
        if (cached) {
            return cached.stats;
        }
        return { videoCount: 0, followerCount: 0 };
    }
}

// Fetch author's video count from relays with pagination
async function fetchAuthorVideoCount(pubkey) {
    const videoIds = new Set();
    let oldestTimestamp = Math.floor(Date.now() / 1000);
    let hasMore = true;
    let batchCount = 0;
    const maxBatches = 10; // Safety limit
    const batchSize = 100;

    // Overall timeout for the entire operation
    const startTime = Date.now();
    const maxTime = 15000; // 15 seconds max

    while (hasMore && batchCount < maxBatches && (Date.now() - startTime) < maxTime) {
        const filter = {
            kinds: ALL_VIDEO_KINDS,
            authors: [pubkey],
            '#t': ['pv69420'],
            until: oldestTimestamp,
            limit: batchSize
        };

        let batchEvents = [];

        try {
            await new Promise((resolve) => {
                const timeout = setTimeout(() => resolve(), 5000); // 5s per batch

                requestEventsStream(filter, (event) => {
                    const tags = event.tags || [];
                    if (tags.some(tag => tag[0] === 'x') && !videoIds.has(event.id)) {
                        videoIds.add(event.id);
                        batchEvents.push(event);
                    }
                }, () => {
                    clearTimeout(timeout);
                    resolve();
                });
            });
        } catch (error) {
            console.warn('Video count batch failed:', error);
            break;
        }

        batchCount++;

        // Check if we got fewer events than limit - means no more data
        if (batchEvents.length < batchSize / 2) {
            hasMore = false;
        } else {
            // Get oldest timestamp for next batch
            const oldestEvent = batchEvents.reduce((oldest, e) =>
                e.created_at < oldest.created_at ? e : oldest, batchEvents[0]);
            if (oldestEvent && oldestEvent.created_at < oldestTimestamp) {
                oldestTimestamp = oldestEvent.created_at - 1;
            } else {
                hasMore = false;
            }
        }
    }

    return videoIds.size;
}

// Fetch author's follower count from relays with pagination
async function fetchAuthorFollowerCount(pubkey) {
    const followers = new Set();
    let oldestTimestamp = Math.floor(Date.now() / 1000);
    let hasMore = true;
    let batchCount = 0;
    const maxBatches = 10; // Safety limit
    const batchSize = 200;

    // Overall timeout for the entire operation
    const startTime = Date.now();
    const maxTime = 20000; // 20 seconds max for followers (can be larger)

    while (hasMore && batchCount < maxBatches && (Date.now() - startTime) < maxTime) {
        const filter = {
            kinds: [3],
            '#p': [pubkey],
            until: oldestTimestamp,
            limit: batchSize
        };

        let batchEvents = [];
        const prevSize = followers.size;

        try {
            await new Promise((resolve) => {
                const timeout = setTimeout(() => resolve(), 8000); // 8s per batch

                requestEventsStream(filter, (event) => {
                    if (!followers.has(event.pubkey)) {
                        followers.add(event.pubkey);
                        batchEvents.push(event);
                    }
                }, () => {
                    clearTimeout(timeout);
                    resolve();
                });
            });
        } catch (error) {
            console.warn('Follower count batch failed:', error);
            break;
        }

        batchCount++;

        // Check if we got fewer new followers than expected - means no more data
        if (batchEvents.length < batchSize / 3 || followers.size === prevSize) {
            hasMore = false;
        } else {
            // Get oldest timestamp for next batch
            const oldestEvent = batchEvents.reduce((oldest, e) =>
                e.created_at < oldest.created_at ? e : oldest, batchEvents[0]);
            if (oldestEvent && oldestEvent.created_at < oldestTimestamp) {
                oldestTimestamp = oldestEvent.created_at - 1;
            } else {
                hasMore = false;
            }
        }
    }

    return followers.size;
}

// Load and display channel stats on video page
async function loadChannelStats(pubkey) {
    const statsEl = document.getElementById(`channel-stats-${pubkey}`);
    const actionsEl = document.getElementById(`channel-actions-${pubkey}`);

    try {
        // Load stats and follow status in parallel
        const [stats, isFollowingUser] = await Promise.all([
            getAuthorStats(pubkey),
            currentUser ? isFollowing(pubkey) : Promise.resolve(false)
        ]);

        // Update stats display
        if (statsEl) {
            const videoCountEl = statsEl.querySelector('.channel-stat:first-child');
            const followerCountEl = statsEl.querySelector('.channel-stat:last-child');

            if (videoCountEl) {
                videoCountEl.classList.remove('loading');
                videoCountEl.innerHTML = `<span class="stat-value">${formatNumber(stats.videoCount)}</span> video${stats.videoCount !== 1 ? 's' : ''}`;
            }
            if (followerCountEl) {
                followerCountEl.classList.remove('loading');
                followerCountEl.innerHTML = `<span class="stat-value">${formatNumber(stats.followerCount)}</span> follower${stats.followerCount !== 1 ? 's' : ''}`;
            }
        }

        // Update follow button
        if (actionsEl && currentUser && currentUser.pubkey !== pubkey) {
            const existingBtn = actionsEl.querySelector('.channel-follow-btn');
            if (existingBtn) {
                existingBtn.classList.remove('loading');
                existingBtn.disabled = false;
                existingBtn.innerHTML = isFollowingUser ? t('button.unfollow') : t('button.follow');
                existingBtn.classList.toggle('following', isFollowingUser);
                existingBtn.onclick = () => handleChannelFollow(pubkey, isFollowingUser);
            }

            // Update mute button
            const muteBtn = actionsEl.querySelector('.channel-mute-btn');
            if (muteBtn) {
                const isMuted = isUserMuted(pubkey);
                muteBtn.classList.remove('loading');
                muteBtn.disabled = false;
                muteBtn.classList.toggle('muted', isMuted);
                muteBtn.innerHTML = `${getMuteIconSVG()} ${isMuted ? t('button.unmute') : t('button.mute')}`;
                muteBtn.title = isMuted ? 'Unmute this user' : 'Mute this user';
                muteBtn.onclick = () => handleMute(pubkey, isMuted);
            }
        }
    } catch (error) {
        console.error('Failed to load channel stats:', error);
        // Remove loading states on error
        if (statsEl) {
            statsEl.querySelectorAll('.channel-stat.loading').forEach(el => {
                el.classList.remove('loading');
            });
        }
        if (actionsEl) {
            const btn = actionsEl.querySelector('.channel-follow-btn.loading');
            if (btn) {
                btn.classList.remove('loading');
                btn.disabled = false;
                btn.innerHTML = 'Follow';
            }
            // Also handle mute button error state
            const muteBtn = actionsEl.querySelector('.channel-mute-btn.loading');
            if (muteBtn) {
                muteBtn.classList.remove('loading');
                muteBtn.disabled = false;
                muteBtn.innerHTML = `${getMuteIconSVG()} Mute`;
            }
        }
    }
}

// Handle follow/unfollow from video channel info
async function handleChannelFollow(pubkey, isCurrentlyFollowing) {
    const actionsEl = document.getElementById(`channel-actions-${pubkey}`);
    const button = actionsEl?.querySelector('.channel-follow-btn');

    if (!button) return;

    button.disabled = true;
    button.innerHTML = '<span class="spinner-small"></span>';

    let success;
    if (isCurrentlyFollowing) {
        success = await unfollowUser(pubkey);
    } else {
        success = await followUser(pubkey);
    }

    if (success) {
        const newFollowState = !isCurrentlyFollowing;
        button.classList.toggle('following', newFollowState);
        button.innerHTML = newFollowState ? t('button.unfollow') : t('button.follow');
        button.onclick = () => handleChannelFollow(pubkey, newFollowState);

        // Update the cached follower count
        const cached = authorStatsCache.get(pubkey);
        if (cached) {
            cached.stats.followerCount += newFollowState ? 1 : -1;
            const statsEl = document.getElementById(`channel-stats-${pubkey}`);
            if (statsEl) {
                const followerCountEl = statsEl.querySelector('.channel-stat:last-child');
                if (followerCountEl) {
                    const count = cached.stats.followerCount;
                    followerCountEl.innerHTML = `<span class="stat-value">${formatNumber(count)}</span> follower${count !== 1 ? 's' : ''}`;
                }
            }
        }
    } else {
        button.innerHTML = isCurrentlyFollowing ? t('button.unfollow') : t('button.follow');
        showToast('Failed to update follow status. Please try again.', 'error');
    }

    button.disabled = false;
}

// Check if current user is following a pubkey
async function isFollowing(pubkey) {
    if (!currentUser) return false;

    const filter = {
        kinds: [3],
        authors: [currentUser.pubkey],
        limit: 1
    };

    let following = false;
    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            const pTags = event.tags.filter(tag => tag[0] === 'p');
            following = pTags.some(tag => tag[1] === pubkey);
        }, resolve);
    });

    return following;
}

// Follow a user
async function followUser(pubkey) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to follow users', 'warning');
            return false;
        }
    }

    try {
        const followingFilter = {
            kinds: [3],
            authors: [currentUser.pubkey],
            limit: 1
        };

        let currentFollowingTags = [];
        let currentRelayTags = [];

        await new Promise((resolve) => {
            requestEventsStream(followingFilter, (event) => {
                currentFollowingTags = event.tags.filter(tag => tag[0] === 'p');
                currentRelayTags = event.tags.filter(tag => tag[0] === 'r');
            }, resolve);
        });

        if (!currentFollowingTags.some(tag => tag[1] === pubkey)) {
            currentFollowingTags.push(['p', pubkey]);
        }

        const contactListEvent = {
            kind: 3,
            tags: [...currentFollowingTags, ...currentRelayTags],
            content: '',
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(contactListEvent);
        const published = await publishEvent(signedEvent);

        // Record follow event for analytics (non-blocking)
        if (published) {
            recordChannelFollow(pubkey);
        }

        return published;
    } catch (error) {
        console.error('Failed to follow user:', error);
        return false;
    }
}

// Unfollow a user
async function unfollowUser(pubkey) {
    if (!currentUser) {
        showToast('Please login to unfollow users', 'warning');
        return false;
    }

    try {
        const followingFilter = {
            kinds: [3],
            authors: [currentUser.pubkey],
            limit: 1
        };

        let currentFollowingTags = [];
        let currentRelayTags = [];

        await new Promise((resolve) => {
            requestEventsStream(followingFilter, (event) => {
                currentFollowingTags = event.tags.filter(tag => tag[0] === 'p');
                currentRelayTags = event.tags.filter(tag => tag[0] === 'r');
            }, resolve);
        });

        currentFollowingTags = currentFollowingTags.filter(tag => tag[1] !== pubkey);

        const contactListEvent = {
            kind: 3,
            tags: [...currentFollowingTags, ...currentRelayTags],
            content: '',
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(contactListEvent);
        const published = await publishEvent(signedEvent);

        // Record unfollow event for analytics (non-blocking)
        if (published) {
            recordChannelUnfollow(pubkey);
        }

        return published;
    } catch (error) {
        console.error('Failed to unfollow user:', error);
        return false;
    }
}

// Handle follow/unfollow button click
async function handleFollow(pubkey, isCurrentlyFollowing) {
    const button = event.target;
    button.disabled = true;
    button.textContent = t('status.processing');

    let success;
    if (isCurrentlyFollowing) {
        success = await unfollowUser(pubkey);
    } else {
        success = await followUser(pubkey);
    }

    if (success) {
        button.classList.toggle('following');
        button.textContent = isCurrentlyFollowing ? t('button.follow') : t('button.unfollow');
        button.setAttribute('onclick', `handleFollow('${pubkey}', ${!isCurrentlyFollowing})`);
    } else {
        button.textContent = isCurrentlyFollowing ? t('button.unfollow') : t('button.follow');
        showToast('Failed to update follow status. Please try again.', 'error');
    }

    button.disabled = false;
}

// ===== MUTE LIST MANAGEMENT (NIP-51 Kind 10000) =====

// Fetch user's mute list from relays
async function fetchMuteList() {
    if (!currentUser) {
        mutedUsersCache.clear();
        muteListLoaded = false;
        return;
    }

    const filter = {
        kinds: [10000],
        authors: [currentUser.pubkey],
        limit: 1
    };

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            mutedUsersCache.clear();
            const pTags = event.tags.filter(tag => tag[0] === 'p');
            pTags.forEach(tag => mutedUsersCache.add(tag[1]));
        }, resolve);
    });

    muteListLoaded = true;

    // Re-filter live chat messages if currently on live stream page
    if (currentView === 'live') {
        filterMutedChatMessages();
    }
}

// Re-filter chat messages to hide any from newly-identified muted users
function filterMutedChatMessages() {
    if (!currentUser || mutedUsersCache.size === 0) return;

    const container = document.getElementById('live-chat-messages');
    if (!container) return;

    // Find all chat messages from muted users that aren't already hidden
    mutedUsersCache.forEach(mutedPubkey => {
        if (sessionUnhiddenMutedUsers.has(mutedPubkey)) return;

        const messages = container.querySelectorAll(`.chat-message[data-pubkey="${mutedPubkey}"]:not(.muted-chat-message)`);
        messages.forEach(msgEl => {
            const eventId = msgEl.dataset.eventId;
            const timestamp = msgEl.dataset.timestamp;

            // Replace with placeholder
            const placeholderHTML = `
                <div class="chat-message muted-chat-message" data-event-id="${eventId}" data-pubkey="${mutedPubkey}" data-timestamp="${timestamp}">
                    <div class="chat-hidden-placeholder">
                        ${getMuteIconSVG(12)}
                        <span>Message from muted user</span>
                        <button class="chat-unhide-btn" onclick="unhideChatMessage('${eventId}', '${mutedPubkey}')">Show</button>
                    </div>
                </div>
            `;
            msgEl.outerHTML = placeholderHTML;
        });
    });
}

// Check if a user is muted
function isUserMuted(pubkey) {
    if (!currentUser || !muteListLoaded) return false;
    return mutedUsersCache.has(pubkey);
}

// Check if muted content should be shown (temporarily unhidden)
function shouldShowMutedContent(pubkey) {
    return sessionUnhiddenMutedUsers.has(pubkey);
}

// Temporarily unhide a muted user's content for this session
function unhideMutedUser(pubkey) {
    sessionUnhiddenMutedUsers.add(pubkey);
}

// Handle mute from live chat (wrapper to provide feedback)
async function handleChatMute(pubkey) {
    const success = await muteUser(pubkey);
    if (success) {
        showToast('User muted', 'success');
    } else {
        showToast('Failed to mute user', 'error');
    }
}

// Hide all comments and chat messages from a muted user immediately
function hideContentFromMutedUser(pubkey) {
    // Hide video comments from this user
    const comments = document.querySelectorAll(`.comment[data-pubkey="${pubkey}"]:not(.muted-comment-placeholder)`);
    comments.forEach(comment => {
        const depth = comment.dataset.depth || 0;
        const commentId = comment.dataset.commentId;
        const placeholderHTML = `
            <div class="muted-placeholder-content muted-comment">
                <span class="muted-icon-small">${getMuteIconSVG(14)}</span>
                <span>Comment from muted user hidden</span>
                <button class="unhide-muted-btn-small" onclick="unhideMutedComment('${commentId}', '${pubkey}')">
                    Show
                </button>
            </div>
        `;
        comment.className = 'comment muted-comment-placeholder';
        comment.dataset.commentId = commentId;
        comment.dataset.pubkey = pubkey;
        comment.dataset.depth = Math.min(depth, 3);
        comment.innerHTML = placeholderHTML;
    });

    // Hide live chat messages from this user
    const chatMessages = document.querySelectorAll(`.chat-message[data-pubkey="${pubkey}"]:not(.muted-chat-message)`);
    chatMessages.forEach(msg => {
        const eventId = msg.dataset.eventId;
        const timestamp = msg.dataset.timestamp;
        const placeholderHTML = `
            <div class="chat-hidden-placeholder">
                ${getMuteIconSVG(12)}
                <span>Message from muted user</span>
                <button class="chat-unhide-btn" onclick="unhideChatMessage('${eventId}', '${pubkey}')">Show</button>
            </div>
        `;
        msg.className = 'chat-message muted-chat-message';
        msg.dataset.eventId = eventId;
        msg.dataset.pubkey = pubkey;
        msg.dataset.timestamp = timestamp;
        msg.innerHTML = placeholderHTML;
    });
}

// Unhide a specific muted comment inline (without reloading all comments)
function unhideMutedComment(commentId, pubkey) {
    sessionUnhiddenMutedUsers.add(pubkey);
    showToast('Showing content from this user for this session', 'info');

    // Find the placeholder
    const placeholder = document.querySelector(`.muted-comment-placeholder[data-comment-id="${commentId}"]`);
    if (!placeholder) return;

    // Find the comment in currentCommentsState
    const comment = currentCommentsState.comments.find(c => c.id === commentId);
    if (comment) {
        // Get depth from placeholder
        const depth = parseInt(placeholder.dataset.depth || '0', 10);
        const commentWithDepth = { ...comment, depth, children: [] };

        // Create the comment element
        const commentElement = createCommentElement(
            commentWithDepth,
            profileCache,
            currentCommentsState.reactions,
            currentCommentsState.zaps
        );

        // Replace placeholder with the actual comment
        placeholder.replaceWith(commentElement);
    }
}

// Mute a user (add to mute list)
async function muteUser(pubkey) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to mute users', 'warning');
            return false;
        }
    }

    try {
        // Fetch current mute list (kind 10000)
        const muteFilter = {
            kinds: [10000],
            authors: [currentUser.pubkey],
            limit: 1
        };

        let currentMuteTags = [];

        await new Promise((resolve) => {
            requestEventsStream(muteFilter, (event) => {
                currentMuteTags = event.tags.filter(tag => tag[0] === 'p');
            }, resolve);
        });

        // Check if already muted
        if (!currentMuteTags.some(tag => tag[1] === pubkey)) {
            currentMuteTags.push(['p', pubkey]);
        } else {
            return true; // Already muted
        }

        // Create new mute list event
        const muteListEvent = {
            kind: 10000,
            tags: currentMuteTags,
            content: '',
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(muteListEvent);
        const published = await publishEvent(signedEvent);

        if (published) {
            mutedUsersCache.add(pubkey);
            // Remove from temporarily unhidden if present
            sessionUnhiddenMutedUsers.delete(pubkey);
            // Immediately hide comments and chat messages from this user
            hideContentFromMutedUser(pubkey);
        }

        return published;
    } catch (error) {
        console.error('Failed to mute user:', error);
        return false;
    }
}

// Unmute a user (remove from mute list)
async function unmuteUser(pubkey) {
    if (!currentUser) {
        showToast('Please login to unmute users', 'warning');
        return false;
    }

    try {
        // Fetch current mute list
        const muteFilter = {
            kinds: [10000],
            authors: [currentUser.pubkey],
            limit: 1
        };

        let currentMuteTags = [];

        await new Promise((resolve) => {
            requestEventsStream(muteFilter, (event) => {
                currentMuteTags = event.tags.filter(tag => tag[0] === 'p');
            }, resolve);
        });

        // Remove the pubkey
        currentMuteTags = currentMuteTags.filter(tag => tag[1] !== pubkey);

        // Create updated mute list event
        const muteListEvent = {
            kind: 10000,
            tags: currentMuteTags,
            content: '',
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(muteListEvent);
        const published = await publishEvent(signedEvent);

        if (published) {
            mutedUsersCache.delete(pubkey);
            sessionUnhiddenMutedUsers.delete(pubkey);
        }

        return published;
    } catch (error) {
        console.error('Failed to unmute user:', error);
        return false;
    }
}

// Handle mute/unmute button click
async function handleMute(pubkey, isCurrentlyMuted) {
    const button = event.target.closest('.mute-btn, .profile-mute-btn, .channel-mute-btn, .comment-mute-btn');
    if (!button) return;

    button.disabled = true;
    const originalContent = button.innerHTML;
    button.innerHTML = '<span class="spinner-small"></span>';

    let success;
    if (isCurrentlyMuted) {
        success = await unmuteUser(pubkey);
    } else {
        success = await muteUser(pubkey);
    }

    if (success) {
        const newMutedState = !isCurrentlyMuted;
        button.classList.toggle('muted', newMutedState);

        // Update button content based on type
        if (button.classList.contains('comment-mute-btn')) {
            button.innerHTML = `${getMuteIconSVG(14)}<span>${newMutedState ? t('button.unmute') : t('button.mute')}</span>`;
            button.title = newMutedState ? 'Unmute user' : 'Mute user';
        } else {
            button.innerHTML = `${getMuteIconSVG()} ${newMutedState ? t('button.unmute') : t('button.mute')}`;
        }
        button.setAttribute('onclick', `handleMute('${pubkey}', ${newMutedState})`);

        // Show toast notification
        showToast(newMutedState ? 'User muted' : 'User unmuted', 'success');

        // If we just muted, reload the page to filter out their content
        if (newMutedState && (currentView.startsWith('home') || currentView === 'home')) {
            setTimeout(() => handleRoute(), 500);
        }
    } else {
        button.innerHTML = originalContent;
        showToast('Failed to update mute status. Please try again.', 'error');
    }

    button.disabled = false;
}

// ===== FOLLOWS-BASED REPORT WARNINGS (NIP-56) =====

// Minimum number of follows who must report for warning to show
const REPORT_WARNING_THRESHOLD = 5;

// Fetch user's follow list (kind 3)
async function fetchUserFollows() {
    if (!currentUser) {
        userFollowsCache.clear();
        userFollowsLoaded = false;
        return;
    }

    const filter = {
        kinds: [3],
        authors: [currentUser.pubkey],
        limit: 1
    };

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            userFollowsCache.clear();
            const pTags = event.tags.filter(tag => tag[0] === 'p');
            pTags.forEach(tag => userFollowsCache.add(tag[1]));
        }, resolve);
    });

    userFollowsLoaded = true;
}

// Fetch reports for a specific event (video/comment)
async function fetchReportsForEvent(eventId) {
    // Return empty set for null/undefined eventId
    if (!eventId) {
        return new Set();
    }

    if (reportsCache.loadedEvents.has(eventId)) {
        return reportsCache.eventReports.get(eventId) || new Set();
    }

    const filter = {
        kinds: [1984],
        '#e': [eventId]
    };

    const reporters = new Set();

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            reporters.add(event.pubkey);
        }, resolve);
    });

    reportsCache.eventReports.set(eventId, reporters);
    reportsCache.loadedEvents.add(eventId);

    return reporters;
}

// Fetch reports for a specific pubkey (user)
async function fetchReportsForPubkey(pubkey) {
    if (reportsCache.loadedPubkeys.has(pubkey)) {
        return reportsCache.pubkeyReports.get(pubkey) || new Set();
    }

    const filter = {
        kinds: [1984],
        '#p': [pubkey]
    };

    const reporters = new Set();

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            // Only count reports that specifically target this pubkey (not just mentions)
            const pTags = event.tags.filter(t => t[0] === 'p' && t[1] === pubkey);
            if (pTags.length > 0) {
                reporters.add(event.pubkey);
            }
        }, resolve);
    });

    reportsCache.pubkeyReports.set(pubkey, reporters);
    reportsCache.loadedPubkeys.add(pubkey);

    return reporters;
}

// Check if event has been reported by enough follows to trigger warning
async function isReportedByFollows(eventId, authorPubkey = null) {
    if (!currentUser || !userSettings.showFollowsReportWarnings) {
        return false;
    }

    // Ensure follows are loaded
    if (!userFollowsLoaded) {
        await fetchUserFollows();
    }

    if (userFollowsCache.size === 0) {
        return false;
    }

    let followsWhoReported = 0;

    // Check event reports only if eventId is provided
    if (eventId) {
        const eventReporters = await fetchReportsForEvent(eventId);
        for (const reporter of eventReporters) {
            if (userFollowsCache.has(reporter)) {
                followsWhoReported++;
                if (followsWhoReported >= REPORT_WARNING_THRESHOLD) {
                    return true;
                }
            }
        }
    }

    // Also check author reports if provided
    if (authorPubkey) {
        const authorReporters = await fetchReportsForPubkey(authorPubkey);
        for (const reporter of authorReporters) {
            if (userFollowsCache.has(reporter)) {
                followsWhoReported++;
                if (followsWhoReported >= REPORT_WARNING_THRESHOLD) {
                    return true;
                }
            }
        }
    }

    return false;
}

// Synchronous check using cached data (for render-time checks)
function isReportedByFollowsSync(eventId, authorPubkey = null) {
    if (!currentUser || !userSettings.showFollowsReportWarnings || !userFollowsLoaded) {
        return false;
    }

    if (userFollowsCache.size === 0) {
        return false;
    }

    let followsWhoReported = 0;

    // Check event reports from cache only if eventId is provided
    if (eventId) {
        const eventReporters = reportsCache.eventReports.get(eventId);
        if (eventReporters) {
            for (const reporter of eventReporters) {
                if (userFollowsCache.has(reporter)) {
                    followsWhoReported++;
                    if (followsWhoReported >= REPORT_WARNING_THRESHOLD) {
                        return true;
                    }
                }
            }
        }
    }

    // Check author reports from cache
    if (authorPubkey) {
        const authorReporters = reportsCache.pubkeyReports.get(authorPubkey);
        if (authorReporters) {
            for (const reporter of authorReporters) {
                if (userFollowsCache.has(reporter)) {
                    followsWhoReported++;
                    if (followsWhoReported >= REPORT_WARNING_THRESHOLD) {
                        return true;
                    }
                }
            }
        }
    }

    return false;
}

// Batch fetch reports for multiple events (for efficiency)
async function fetchReportsForEvents(eventIds) {
    const unfetchedIds = eventIds.filter(id => !reportsCache.loadedEvents.has(id));

    if (unfetchedIds.length === 0) return;

    const filter = {
        kinds: [1984],
        '#e': unfetchedIds
    };

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            const eTags = event.tags.filter(t => t[0] === 'e');
            eTags.forEach(tag => {
                const eventId = tag[1];
                if (!reportsCache.eventReports.has(eventId)) {
                    reportsCache.eventReports.set(eventId, new Set());
                }
                reportsCache.eventReports.get(eventId).add(event.pubkey);
            });
        }, resolve);
    });

    // Mark all as loaded
    unfetchedIds.forEach(id => reportsCache.loadedEvents.add(id));
}

// Batch fetch reports for multiple pubkeys (for efficiency)
async function fetchReportsForPubkeys(pubkeys) {
    const unfetchedPubkeys = pubkeys.filter(pk => !reportsCache.loadedPubkeys.has(pk));

    if (unfetchedPubkeys.length === 0) return;

    const filter = {
        kinds: [1984],
        '#p': unfetchedPubkeys
    };

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            const pTags = event.tags.filter(t => t[0] === 'p');
            pTags.forEach(tag => {
                const pubkey = tag[1];
                if (!reportsCache.pubkeyReports.has(pubkey)) {
                    reportsCache.pubkeyReports.set(pubkey, new Set());
                }
                reportsCache.pubkeyReports.get(pubkey).add(event.pubkey);
            });
        }, resolve);
    });

    // Mark all as loaded
    unfetchedPubkeys.forEach(pk => reportsCache.loadedPubkeys.add(pk));
}

// Get mute icon SVG
function getMuteIconSVG(size = 16) {
    return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z"/>
    </svg>`;
}

// Check if content from a pubkey should be completely hidden (muted and not temporarily shown)
function shouldHideMutedContent(pubkey) {
    if (!currentUser || !muteListLoaded) return false;
    return isUserMuted(pubkey) && !shouldShowMutedContent(pubkey);
}

// Create hidden content placeholder for muted users
function createMutedContentPlaceholder(pubkey, type = 'video', eventId = null) {
    const profile = profileCache.get(pubkey);
    const displayName = profile?.name || profile?.display_name || `User ${pubkey.slice(0, 8)}`;

    if (type === 'video') {
        return `
            <div class="video-card muted-content-placeholder" data-pubkey="${pubkey}" data-event-id="${eventId || ''}">
                <div class="muted-placeholder-content">
                    <div class="muted-icon">${getMuteIconSVG(32)}</div>
                    <p>Content from <strong>${escapeHtml(displayName)}</strong> is hidden</p>
                    <button class="unhide-muted-btn" onclick="handleUnhideMutedContent('${pubkey}', 'video', '${eventId || ''}')">
                        Show anyway
                    </button>
                </div>
            </div>
        `;
    } else if (type === 'comment') {
        return `
            <div class="comment muted-comment-placeholder" data-pubkey="${pubkey}">
                <div class="muted-placeholder-content muted-comment">
                    <span class="muted-icon-small">${getMuteIconSVG(14)}</span>
                    <span>Comment from muted user hidden</span>
                    <button class="unhide-muted-btn-small" onclick="handleUnhideMutedContent('${pubkey}', 'comment')">
                        Show
                    </button>
                </div>
            </div>
        `;
    }
    return '';
}

// Handle unhide muted content button click
function handleUnhideMutedContent(pubkey, type, eventId = null) {
    unhideMutedUser(pubkey);
    showToast('Showing content from this user for this session', 'info');

    // Replace placeholders in-place instead of reloading
    if (type === 'video') {
        // Find all video placeholders for this pubkey and replace with actual content
        const placeholders = document.querySelectorAll(`.muted-content-placeholder[data-pubkey="${pubkey}"]`);
        let replacedCount = 0;

        placeholders.forEach(placeholder => {
            const placeholderEventId = placeholder.dataset.eventId || eventId;
            if (placeholderEventId) {
                const event = allEvents.get(placeholderEventId);
                if (event) {
                    const profile = profileCache.get(event.pubkey);
                    const reactions = reactionsCache.get(event.id);
                    const cardHTML = createVideoCard(event, profile, reactions, false, null, true);

                    if (cardHTML) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = cardHTML;
                        if (tempDiv.firstElementChild) {
                            placeholder.replaceWith(tempDiv.firstElementChild);
                            replacedCount++;
                            observeLazyCards();
                        }
                    }
                }
            }
        });

        // If we couldn't replace any (missing event data), fall back to reload
        if (placeholders.length > 0 && replacedCount === 0) {
            handleRoute();
        }
    } else if (type === 'comment') {
        // For comments, reload just the comments section
        const commentsContainer = document.getElementById('comments-container');
        if (commentsContainer) {
            // Get the video event ID from the current URL
            const hash = window.location.hash;
            const videoMatch = hash.match(/#\/video\/([a-f0-9]+)/);
            if (videoMatch) {
                commentsContainer.innerHTML = '<div class="spinner"></div>';
                loadComments([videoMatch[1]]);
            }
        }
    } else if (type === 'chat') {
        // For live chat, find muted messages from this user and re-render them
        const chatContainer = document.getElementById('liveChatMessages');
        if (chatContainer && currentLiveChat?.messages) {
            const mutedMessages = chatContainer.querySelectorAll(`.muted-chat-message[data-pubkey="${pubkey}"]`);
            mutedMessages.forEach(placeholder => {
                const eventId = placeholder.dataset.eventId;
                const event = currentLiveChat.messages.find(m => m.id === eventId);
                if (event) {
                    // Re-render the chat message
                    placeholder.remove();
                    renderChatMessage(event, chatContainer);
                }
            });
        }
    }
}

// Load user profile page
async function loadProfile(pubkey) {
    currentView = `profile-${pubkey}`;

    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = '<div class="spinner"></div>';

    try {
        const profile = await fetchUserProfile(pubkey);
        const displayName = profile?.name || profile?.display_name || `User ${pubkey.slice(0, 8)}`;
        const avatarUrl = profile?.picture || profile?.avatar || '';
        const nip05 = profile?.nip05 || '';
        const about = profile?.about || '';
        const website = profile?.website || '';

        const npub = window.NostrTools.nip19.npubEncode(pubkey);

        const isFollowingPromise = isFollowing(pubkey);
        const isOwnProfile = currentUser && currentUser.pubkey === pubkey;

        const cardsPerRow = getCardsPerRow();
        const skeletonCount = cardsPerRow * 10; // 10 rows of skeletons
        const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');

        // Format website URL for display
        const websiteDisplay = website ? website.replace(/^https?:\/\//, '').replace(/\/$/, '') : '';
        const websiteHref = website && !website.startsWith('http') ? `https://${website}` : website;

        mainContent.innerHTML = `
            <div class="profile-header">
                <div class="profile-avatar">
                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                </div>
                <div class="profile-info">
                    <h1 class="profile-name">${displayName}</h1>
                    ${nip05 ? `<div class="profile-nip05">${nip05}</div>` : ''}
                    <div class="profile-stats" id="profile-stats-${pubkey}">
                        <span class="profile-stat loading">
                            <span class="stat-value">-</span> videos
                        </span>
                        <span class="profile-stat-separator">•</span>
                        <span class="profile-stat loading">
                            <span class="stat-value">-</span> followers
                        </span>
                    </div>
                    ${website ? `
                        <div class="profile-website">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                            </svg>
                            <a href="${websiteHref}" target="_blank" rel="noopener noreferrer">${websiteDisplay}</a>
                        </div>
                    ` : ''}
                    ${about ? `
                        <div class="profile-bio-container">
                            <div id="profile-bio" class="profile-bio ${about.length > 300 ? 'collapsed' : ''}">
                                <p style="white-space: pre-wrap; margin: 0;">${processTextWithLinks(about)}</p>
                            </div>
                            ${about.length > 300 ? `
                                <button id="bio-toggle" class="bio-toggle-btn" onclick="toggleBio()">
                                    Show More
                                </button>
                            ` : ''}
                        </div>
                    ` : ''}
                </div>
                <div class="profile-actions" id="profile-actions-${pubkey}">
                    ${isOwnProfile ? `
                        <button class="profile-edit-btn" onclick="showEditProfileModal()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                            </svg>
                            Edit
                        </button>
                    ` : ''}
                    <button class="profile-zap-btn ${isOwnProfile ? 'self-content' : ''}"
                            onclick="${isOwnProfile ? '' : `handleZap('${npub}', 1000)`}"
                            ${isOwnProfile ? `title="${t('zap.cannotZapYourself')}"` : ''}>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                        </svg>
                        Zap
                    </button>
                </div>
            </div>
            <!-- Live Streams Section -->
            <div id="profileLiveSection" style="display: none; margin-bottom: 2rem;">
                <h2 style="margin-bottom: 1rem;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                        <circle cx="12" cy="12" r="4" fill="#f44336"/>
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>
                    </svg>
                    Live Streams
                </h2>
                <div class="video-grid" id="profileLiveGrid"></div>
            </div>
            <!-- Shorts Section -->
            <div id="profileShortsSection" style="display: none; margin-bottom: 2rem;">
                <h2 style="margin-bottom: 1rem;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                        <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                        <path d="M10 8l6 4-6 4V8z"/>
                    </svg>
                    Shorts
                </h2>
                <div class="shorts-grid" id="profileShortsGrid"></div>
            </div>
            <!-- Videos Section -->
            <h2 style="margin-bottom: 1.5rem;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                </svg>
                Videos
            </h2>
            <div class="video-grid" id="profileVideoGrid">
                ${skeletons}
            </div>
        `;

        // Check if profile is reported by follows (async, show banner after load)
        if (!isOwnProfile && currentUser && userSettings.showFollowsReportWarnings) {
            isReportedByFollows(null, pubkey).then(isReported => {
                if (isReported && !sessionRatioedAllowed.has(pubkey)) {
                    const profileHeader = document.querySelector('.profile-header');
                    if (profileHeader) {
                        const warningBanner = document.createElement('div');
                        warningBanner.className = 'profile-warning-banner';
                        warningBanner.style.cssText = 'background: rgba(255, 152, 0, 0.15); border: 1px solid #ff9800; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.75rem;';
                        warningBanner.innerHTML = `
                            <span style="color: #ff9800; font-size: 1.5rem;">⚠</span>
                            <div style="flex: 1;">
                                <strong style="color: #ff9800;">Community Warning</strong>
                                <p style="margin: 0.25rem 0 0 0; font-size: 0.875rem; color: var(--text-secondary);">
                                    This user has been reported by multiple people you follow.
                                </p>
                            </div>
                            <button onclick="this.parentElement.remove(); sessionRatioedAllowed.add('${pubkey}');"
                                    style="background: none; border: 1px solid var(--text-secondary); color: var(--text-primary); padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">
                                Dismiss
                            </button>
                        `;
                        profileHeader.parentElement.insertBefore(warningBanner, profileHeader);
                    }
                }
            });
        }

        // Validate NIP-05 and add checkmark if valid
        if (nip05) {
            // Check cache first
            if (profileValidationCache.has(pubkey)) {
                const cached = profileValidationCache.get(pubkey);
                if (cached.nip05Valid) {
                    const profileNip05 = document.querySelector('.profile-nip05');
                    applyNip05Checkmark(profileNip05, true, 16);
                }
            } else {
                // Validate and cache
                validateNip05(nip05, pubkey).then(isValid => {
                    if (isValid) {
                        const profileNip05 = document.querySelector('.profile-nip05');
                        applyNip05Checkmark(profileNip05, true, 16);
                    }
                    // Update or create cache entry
                    if (!profileValidationCache.has(pubkey)) {
                        const avatarValid = avatarUrl ? true : false; // Simplified for profile page
                        profileValidationCache.set(pubkey, {
                            isSuspicious: !avatarValid || !isValid,
                            avatarValid,
                            nip05Valid: isValid
                        });
                    }
                });
            }
        }

        // Defer profile stats loading to not block video grid loading
        setTimeout(() => {
            getAuthorStats(pubkey).then(stats => {
                const statsEl = document.getElementById(`profile-stats-${pubkey}`);
                if (statsEl) {
                    const videoCountEl = statsEl.querySelector('.profile-stat:first-child');
                    const followerCountEl = statsEl.querySelector('.profile-stat:last-child');

                    if (videoCountEl) {
                        videoCountEl.classList.remove('loading');
                        videoCountEl.innerHTML = `<span class="stat-value">${formatNumber(stats.videoCount)}</span> video${stats.videoCount !== 1 ? 's' : ''}`;
                    }
                    if (followerCountEl) {
                        followerCountEl.classList.remove('loading');
                        followerCountEl.innerHTML = `<span class="stat-value">${formatNumber(stats.followerCount)}</span> follower${stats.followerCount !== 1 ? 's' : ''}`;
                    }
                }
            }).catch(error => {
                console.error('Failed to load profile stats:', error);
                const statsEl = document.getElementById(`profile-stats-${pubkey}`);
                if (statsEl) {
                    statsEl.querySelectorAll('.profile-stat.loading').forEach(el => {
                        el.classList.remove('loading');
                    });
                }
            });
        }, 1000); // Wait 1 second for videos to start loading first

        isFollowingPromise.then(isFollowingUser => {
            const actionsDiv = document.getElementById(`profile-actions-${pubkey}`);
            if (actionsDiv && !isOwnProfile && currentUser) {
                // Add follow button
                const followBtn = document.createElement('button');
                followBtn.className = `profile-follow-btn ${isFollowingUser ? 'following' : ''}`;
                followBtn.onclick = () => handleFollow(pubkey, isFollowingUser);
                followBtn.textContent = isFollowingUser ? t('button.unfollow') : t('button.follow');
                actionsDiv.insertBefore(followBtn, actionsDiv.firstChild);

                // Add mute button
                const isMuted = isUserMuted(pubkey);
                const muteBtn = document.createElement('button');
                muteBtn.className = `profile-mute-btn ${isMuted ? 'muted' : ''}`;
                muteBtn.onclick = () => handleMute(pubkey, isMuted);
                muteBtn.innerHTML = `${getMuteIconSVG()} ${isMuted ? t('button.unmute') : t('button.mute')}`;
                muteBtn.title = isMuted ? 'Unmute this user' : 'Mute this user';
                actionsDiv.insertBefore(muteBtn, followBtn.nextSibling);

                // Add report button
                const reportBtn = document.createElement('button');
                reportBtn.className = 'profile-report-btn';
                reportBtn.onclick = () => showReportModal(null, pubkey, 'user');
                reportBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"/></svg> Report`;
                reportBtn.title = 'Report this user';
                actionsDiv.insertBefore(reportBtn, muteBtn.nextSibling);
            }
        });

        const filter = {
            kinds: ALL_VIDEO_KINDS,
            authors: [pubkey],
            '#t': ['pv69420']
        };

        const videoGrid = document.getElementById('profileVideoGrid');
        const shortsGrid = document.getElementById('profileShortsGrid');
        const shortsSection = document.getElementById('profileShortsSection');
        const videoEvents = [];
        const shortEvents = [];
        const reactionQueue = new Set();
        let reactionTimer = null;

        await requestEventsStream(filter, (event) => {
            const tags = event.tags || [];
            if (!tags.some(tag => tag[0] === 'x')) return;

            allEvents.set(event.id, event);

            // Remove any legacy counterpart that was already added (handles race condition)
            if (event.kind === NIP71_VIDEO_KIND) {
                removeLegacyCounterpart(event, videoEvents);
            } else if (event.kind === NIP71_SHORT_KIND) {
                removeLegacyCounterpart(event, shortEvents);
            }

            // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
            if (shouldSkipLegacyEvent(event)) return;

            // Separate shorts from regular videos
            const isShort = isNip71ShortKind(event.kind);
            const targetGrid = isShort ? shortsGrid : videoGrid;
            const targetEvents = isShort ? shortEvents : videoEvents;

            targetEvents.push(event);

            // Show shorts section if we have shorts
            if (isShort && shortsSection) {
                shortsSection.style.display = 'block';
            }

            // Remove skeleton cards on first video
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            const cachedReactions = reactionsCache.get(event.id);
            const cardHTML = isShort
                ? createShortCard(event, profile, cachedReactions)
                : createVideoCard(event, profile, cachedReactions);

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHTML;

            if (tempDiv.firstElementChild) {
                let inserted = false;
                const existingCards = targetGrid.querySelectorAll('.video-card, .short-card');

                for (let i = 0; i < existingCards.length; i++) {
                    const cardEvent = targetEvents.find(e =>
                        existingCards[i].innerHTML.includes(e.id)
                    );
                    if (cardEvent && event.created_at > cardEvent.created_at) {
                        existingCards[i].parentNode.insertBefore(tempDiv.firstElementChild, existingCards[i]);
                        inserted = true;
                        break;
                    }
                }

                if (!inserted) {
                    targetGrid.appendChild(tempDiv.firstElementChild);
                }

                // Observe new card for lazy loading
                observeLazyCards();
            }

            reactionQueue.add(event.id);
            clearTimeout(reactionTimer);
            reactionTimer = setTimeout(async () => {
                if (reactionQueue.size > 0) {
                    const videoIds = Array.from(reactionQueue);
                    reactionQueue.clear();

                    await loadReactionsForVideos(videoIds, (videoId, reactions) => {
                        // Use in-place update to prevent image flickering
                        updateVideoCardInPlace(videoId, profile, reactions);
                    });
                }
            }, 200);

        }, () => {
            if (videoEvents.length === 0) {
                videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noUploadedVideos')}</p>`;
            }
        });

        // Load live streams for this user
        const liveFilter = {
            kinds: [NIP53_LIVE_EVENT_KIND],
            authors: [pubkey],
            '#t': ['pv69420'],
            limit: 50
        };

        const liveGrid = document.getElementById('profileLiveGrid');
        const liveSection = document.getElementById('profileLiveSection');
        const liveEvents = [];

        await requestEventsStream(liveFilter, (event) => {
            const liveData = parseLiveEvent(event);
            if (!liveData) return;

            allEvents.set(event.id, event);
            liveEvents.push({ event, liveData });

            // Show live section
            if (liveSection) {
                liveSection.style.display = 'block';
            }

            // Check if active (live) or ended
            const isActive = isLiveStreamActive(liveData);
            const isEnded = isLiveStreamEnded(liveData);

            // Create and insert card
            const cardHTML = createLiveStreamCard(event, liveData, profile, isEnded);

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHTML;

            if (tempDiv.firstElementChild) {
                // Sort: active streams first, then by date
                let inserted = false;
                const existingCards = liveGrid.querySelectorAll('.video-card');

                for (let i = 0; i < existingCards.length; i++) {
                    const existingCard = existingCards[i];
                    const existingIsLive = existingCard.classList.contains('is-live') &&
                        existingCard.querySelector('.live-badge');

                    // Active streams go before ended ones
                    if (isActive && !existingIsLive) {
                        existingCard.parentNode.insertBefore(tempDiv.firstElementChild, existingCard);
                        inserted = true;
                        break;
                    }

                    // Among same status, sort by date
                    if (isActive === !!existingIsLive) {
                        const existingEventId = existingCard.dataset.liveEventId;
                        const existingEvent = allEvents.get(existingEventId);
                        if (existingEvent && event.created_at > existingEvent.created_at) {
                            existingCard.parentNode.insertBefore(tempDiv.firstElementChild, existingCard);
                            inserted = true;
                            break;
                        }
                    }
                }

                if (!inserted) {
                    liveGrid.appendChild(tempDiv.firstElementChild);
                }
            }
        }, () => {
            // Live streams loaded - load viewer counts for active streams
            const activeLiveIds = liveEvents
                .filter(({ liveData }) => isLiveStreamActive(liveData))
                .map(({ event }) => event.id);

            if (activeLiveIds.length > 0) {
                loadLiveStreamCardsViewers(activeLiveIds);
            }
        });

    } catch (error) {
        console.error('Failed to load profile:', error);
        mainContent.innerHTML = `<div class="error-message">${t('empty.failedLoadProfile')}</div>`;
    }
}

// Search videos
async function searchVideos() {
    const query = document.getElementById('searchInput').value.trim();
    if (!query) return;

    navigateTo(`/search/${encodeURIComponent(query)}`);
}

async function performSearch(query) {
    const decodedQuery = decodeURIComponent(query).toLowerCase();
    currentView = `search-${decodedQuery}`;

    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const videoSkeletonCount = cardsPerRow * 10; // 10 rows of video skeletons
    const videoSkeletons = Array(videoSkeletonCount).fill(createSkeletonCard()).join('');

    mainContent.innerHTML = `
        <h2 style="margin-bottom: 1.5rem;">Search Results for "${decodedQuery}"</h2>
        <!-- Shorts Section -->
        <div id="searchShortsSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M10 8l6 4-6 4V8z"/>
                </svg>
                Shorts
            </h3>
            <div class="shorts-grid" id="searchShortsGrid"></div>
            <div class="view-more-container" id="searchShortsViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('searchShorts')">View More</button>
            </div>
        </div>
        <!-- Videos Section -->
        <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
            </svg>
            Videos
        </h3>
        <div class="video-grid" id="videoGrid">
            ${videoSkeletons}
        </div>
        <!-- Users Section -->
        <div id="usersSection" style="display: none; margin-top: 2rem;">
            <hr class="section-divider" style="margin-bottom: 1.5rem;">
            <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">Users</h3>
            <div class="user-results-grid" id="userResultsGrid"></div>
            <div id="viewMoreUsersSearchContainer" style="display: none; text-align: center; margin-top: 1rem; margin-bottom: 1rem;">
                <button id="viewMoreUsersSearchBtn" class="action-btn view-more-btn">
                    View More
                </button>
            </div>
        </div>
    `;

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('searchShortsGrid');
    const shortsSection = document.getElementById('searchShortsSection');
    const shortsViewMore = document.getElementById('searchShortsViewMore');
    const maxInitialShorts = getShortsCardsPerRow();
    const userResultsGrid = document.getElementById('userResultsGrid');
    const usersSection = document.getElementById('usersSection');

    // Reset cached search shorts
    cachedSearchShorts = [];
    sectionExpanded.searchShorts = false;
    const viewMoreUsersContainer = document.getElementById('viewMoreUsersSearchContainer');
    const viewMoreUsersBtn = document.getElementById('viewMoreUsersSearchBtn');
    const renderedVideos = new Map();
    const renderedShorts = new Map();
    const videoEvents = [];
    const shortEvents = [];
    const profileQueue = new Set();
    const reactionQueue = new Set();
    let profileTimer = null;
    let reactionTimer = null;
    let shortsRenderedCount = 0;

    // Store all matching users for "View More" functionality
    const allMatchingUsers = [];
    let showingAllUsers = false;

    // Track rendered user pubkeys to avoid re-rendering
    const renderedSearchUserPubkeys = new Set();

    // Calculate dynamic user limit based on grid width (show 1 row for search)
    const calculateUserLimit = () => {
        const gridWidth = userResultsGrid.offsetWidth || document.querySelector('.main-content')?.offsetWidth || 800;
        const minCardWidth = window.innerWidth <= 768 ? 280 : 300; // user-search-card min width
        const gap = 16; // 1rem gap
        const cardsPerRow = Math.floor((gridWidth + gap) / (minCardWidth + gap)) || 1;
        return Math.max(cardsPerRow, 3); // Show at least 3 users, or 1 full row
    };

    let INITIAL_USER_LIMIT = calculateUserLimit();

    // Helper to escape special regex characters
    const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    // Check if a user profile matches the search query
    const profileMatchesSearch = (profile, pubkey) => {
        const queryWords = decodedQuery.split(/\s+/).filter(w => w.length > 0);
        const name = (profile.name || '').toLowerCase();
        const displayName = (profile.display_name || '').toLowerCase();
        const nip05 = (profile.nip05 || '').toLowerCase();
        const about = (profile.about || '').toLowerCase();
        const pubkeyLower = pubkey.toLowerCase();

        // Check if any query word matches any of the profile fields
        return queryWords.every(word => {
            const wordLower = word.toLowerCase();
            return name.includes(wordLower) ||
                displayName.includes(wordLower) ||
                nip05.includes(wordLower) ||
                about.includes(wordLower) ||
                pubkeyLower.includes(wordLower);
        });
    };

    // Create a user card for search results
    const createUserSearchCard = (pubkey, profile) => {
        const displayName = profile?.name || profile?.display_name || `User ${pubkey.slice(0, 8)}`;
        const avatarUrl = profile?.picture || profile?.avatar || '';
        const nip05 = profile?.nip05 || '';
        const about = profile?.about || '';
        const truncatedAbout = about.length > 100 ? about.slice(0, 100) + '...' : about;

        return `
            <a href="#/profile/${pubkey}" class="user-search-card">
                <div class="user-search-avatar">
                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}" onerror="this.style.display='none'">` : ''}
                </div>
                <div class="user-search-info">
                    <div class="user-search-name">${displayName}</div>
                    ${nip05 ? `<div class="user-search-nip05">${nip05}</div>` : ''}
                    ${truncatedAbout ? `<div class="user-search-about">${truncatedAbout}</div>` : ''}
                </div>
            </a>
        `;
    };

    // Display users with limit (only renders new users, doesn't replace existing)
    const displayMatchingUsers = (limit = null) => {
        if (allMatchingUsers.length === 0) {
            usersSection.style.display = 'none';
            return;
        }

        usersSection.style.display = 'block';
        const usersToShow = limit ? allMatchingUsers.slice(0, limit) : allMatchingUsers;

        // Only render users that haven't been rendered yet
        const newUsers = usersToShow.filter(user => !renderedSearchUserPubkeys.has(user.pubkey));

        if (newUsers.length > 0) {
            const cardsHTML = newUsers.map(user => {
                renderedSearchUserPubkeys.add(user.pubkey);
                return createUserSearchCard(user.pubkey, user.profile);
            }).join('');
            userResultsGrid.insertAdjacentHTML('beforeend', cardsHTML);
        }

        // Show/hide "View More" button
        if (limit && allMatchingUsers.length > limit) {
            viewMoreUsersContainer.style.display = 'block';
            viewMoreUsersBtn.textContent = `View More (${allMatchingUsers.length - limit} more)`;
        } else {
            viewMoreUsersContainer.style.display = 'none';
        }
    };

    // Expand users to show all (appends new users without re-rendering existing)
    const expandSearchUsers = () => {
        const currentCount = renderedSearchUserPubkeys.size;
        const usersToAdd = allMatchingUsers.slice(currentCount);

        if (usersToAdd.length > 0) {
            const cardsHTML = usersToAdd.map(user => {
                renderedSearchUserPubkeys.add(user.pubkey);
                return createUserSearchCard(user.pubkey, user.profile);
            }).join('');
            userResultsGrid.insertAdjacentHTML('beforeend', cardsHTML);
        }

        viewMoreUsersContainer.style.display = 'none';
    };

    // View More button handler - append new users without re-rendering
    viewMoreUsersBtn.addEventListener('click', () => {
        showingAllUsers = true;
        expandSearchUsers();
    });

    const matchesSearch = (event) => {
        // Parse both kind 1 and NIP-71 events
        let videoData;
        if (isNip71Kind(event.kind)) {
            videoData = parseNip71VideoEvent(event);
        } else {
            videoData = parseVideoEvent(event);
        }
        if (!videoData) return false;

        // Split query into words for matching
        const queryWords = decodedQuery.split(/\s+/).filter(w => w.length > 0);

        // Combine all searchable text (title, description, tags)
        const tagsText = (videoData.tags || []).join(' ');
        const searchText = `${videoData.title || ''} ${videoData.description || ''} ${tagsText}`.toLowerCase();

        // All query words must match at word boundaries (start of words)
        // e.g., "bitcoin" matches "bitcoin", "bitcoiner", "bitcoiners"
        // but "coin" does NOT match "bitcoin" (only matches "coin", "coins", etc.)
        return queryWords.every(word => {
            const wordRegex = new RegExp(`\\b${escapeRegex(word)}`, 'i');
            return wordRegex.test(searchText);
        });
    };

    const updateVideoCard = (event, profile, reactions) => {
        // Use in-place update to prevent image flickering
        updateVideoCardInPlace(event.id, profile, reactions);
    };

    const renderVideoCard = (event, profile = null, reactions = null) => {
        const cardId = `video-card-${event.id}`;

        if (document.getElementById(cardId)) {
            // Use in-place update to prevent image flickering
            updateVideoCardInPlace(event.id, profile, reactions);
            return;
        }

        // Remove skeleton cards on first video
        const skeletons = videoGrid.querySelectorAll('.skeleton-card');
        if (skeletons.length > 0) {
            skeletons.forEach(s => s.remove());
        }

        const cardHTML = createVideoCard(event, profile, reactions);
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = cardHTML;

        if (!tempDiv.firstElementChild) return;

        tempDiv.firstElementChild.id = cardId;

        let inserted = false;
        const cards = videoGrid.querySelectorAll('.video-card');

        for (let i = 0; i < cards.length; i++) {
            const cardEventId = cards[i].id.replace('video-card-', '');
            const cardEvent = renderedVideos.get(cardEventId);
            if (cardEvent && event.created_at > cardEvent.created_at) {
                cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                inserted = true;
                break;
            }
        }

        if (!inserted) {
            videoGrid.appendChild(tempDiv.firstElementChild);
        }

        renderedVideos.set(event.id, event);

        // Observe new card for lazy loading
        observeLazyCards();
    };

    const renderShortCard = (event, profile = null, reactions = null) => {
        const cardId = `video-card-${event.id}`;

        if (document.getElementById(cardId)) {
            // Use in-place update to prevent image flickering
            updateVideoCardInPlace(event.id, profile, reactions);
            return;
        }

        // Only render up to maxInitialShorts initially
        if (shortsRenderedCount >= maxInitialShorts) {
            return;
        }

        // Show shorts section
        shortsSection.style.display = 'block';

        const cardHTML = createShortCard(event, profile, reactions);
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = cardHTML;

        if (!tempDiv.firstElementChild) return;

        tempDiv.firstElementChild.id = cardId;

        let inserted = false;
        const cards = shortsGrid.querySelectorAll('.short-card');

        for (let i = 0; i < cards.length; i++) {
            const cardEventId = cards[i].id.replace('video-card-', '');
            const cardEvent = renderedShorts.get(cardEventId);
            if (cardEvent && event.created_at > cardEvent.created_at) {
                cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                inserted = true;
                break;
            }
        }

        if (!inserted) {
            shortsGrid.appendChild(tempDiv.firstElementChild);
        }

        renderedShorts.set(event.id, event);
        shortsRenderedCount++;

        // Observe new card for lazy loading
        observeLazyCards();
    };

    const loadProfilesBatch = async () => {
        if (profileQueue.size === 0) return;

        const pubkeys = Array.from(profileQueue);
        profileQueue.clear();

        // Chunk profiles into batches to prevent relay limits
        const PROFILE_BATCH_SIZE = 25;
        const chunks = [];
        for (let i = 0; i < pubkeys.length; i += PROFILE_BATCH_SIZE) {
            chunks.push(pubkeys.slice(i, i + PROFILE_BATCH_SIZE));
        }

        // Process all chunks in parallel
        await Promise.all(chunks.map(async (chunk) => {
            const filter = {
                kinds: [0],
                authors: chunk
            };

            await requestEventsStream(filter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);

                    // Update video cards
                    videoEvents.forEach(event => {
                        if (event.pubkey === profileEvent.pubkey) {
                            const reactions = reactionsCache.get(event.id);
                            updateVideoCard(event, profile, reactions);
                        }
                    });

                    // Update short cards
                    shortEvents.forEach(event => {
                        if (event.pubkey === profileEvent.pubkey) {
                            const reactions = reactionsCache.get(event.id);
                            updateVideoCardInPlace(event.id, profile, reactions);
                        }
                    });
                } catch (e) {
                    console.error('Failed to parse profile:', e);
                }
            });
        }));
    };

    const loadReactionsBatch = async () => {
        if (reactionQueue.size === 0) return;

        const videoIds = Array.from(reactionQueue);
        reactionQueue.clear();

        await loadReactionsForVideos(videoIds, (videoId, reactions) => {
            // Check videos
            const videoEvent = videoEvents.find(e => e.id === videoId);
            if (videoEvent) {
                const profile = profileCache.get(videoEvent.pubkey);
                updateVideoCard(videoEvent, profile, reactions);
                return;
            }

            // Check shorts
            const shortEvent = shortEvents.find(e => e.id === videoId);
            if (shortEvent) {
                const profile = profileCache.get(shortEvent.pubkey);
                updateVideoCardInPlace(shortEvent.id, profile, reactions);
            }
        });
    };

    // Search for user profiles using NIP-50 search (kind 0)
    // Use the original query for search, not lowercased
    const originalQuery = decodeURIComponent(query);
    const userFilter = {
        kinds: [0],
        search: originalQuery,
        limit: 50
    };

    const seenPubkeys = new Set();

    // Fetch user profiles using NIP-50 search
    const userSearchPromise = requestEventsStream(userFilter, (profileEvent) => {
        try {
            if (seenPubkeys.has(profileEvent.pubkey)) return;
            seenPubkeys.add(profileEvent.pubkey);

            const profile = JSON.parse(profileEvent.content);
            profileCache.set(profileEvent.pubkey, profile);

            // Double-check profile matches (relay search may be fuzzy)
            if (profileMatchesSearch(profile, profileEvent.pubkey)) {
                allMatchingUsers.push({ pubkey: profileEvent.pubkey, profile });
                // Update display with limit
                displayMatchingUsers(showingAllUsers ? null : INITIAL_USER_LIMIT);
            }
        } catch (e) {
            // Ignore invalid profile JSON
        }
    }, () => {
        // Final display update when search completes
        displayMatchingUsers(showingAllUsers ? null : INITIAL_USER_LIMIT);
    });

    const filter = {
        kinds: [...ALL_VIDEO_KINDS, NIP53_LIVE_EVENT_KIND],
        '#t': ['pv69420'],
        limit: 200
    };

    // Store live stream data for rendering
    const liveStreamData = new Map();

    // Check if live stream matches search
    const liveStreamMatchesSearch = (event, liveData) => {
        if (!liveData) return false;
        const queryWords = decodedQuery.split(/\s+/).filter(w => w.length > 0);
        const tagsText = (liveData.tags || []).join(' ');
        const searchText = `${liveData.title || ''} ${liveData.summary || ''} ${tagsText}`.toLowerCase();
        return queryWords.every(word => {
            const wordRegex = new RegExp(`\\b${escapeRegex(word)}`, 'i');
            return wordRegex.test(searchText);
        });
    };

    await requestEventsStream(filter, (event) => {
        const tags = event.tags || [];

        // Handle live streams separately
        if (event.kind === NIP53_LIVE_EVENT_KIND) {
            const liveData = parseLiveEvent(event);
            if (!liveData || !isLiveStreamActive(liveData)) return;
            if (!liveStreamMatchesSearch(event, liveData)) return;

            if (videoEvents.some(e => e.id === event.id)) return;

            allEvents.set(event.id, event);
            liveStreamData.set(event.id, liveData);
            videoEvents.push(event);

            const spinner = videoGrid.querySelector('.spinner');
            if (spinner) spinner.remove();

            // Remove skeleton cards
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            const cachedProfile = profileCache.get(event.pubkey);
            const cardHTML = createLiveStreamCard(event, liveData, cachedProfile);

            if (cardHTML) {
                // Insert live streams at the beginning
                videoGrid.insertAdjacentHTML('afterbegin', cardHTML);
                // Load actual viewer count for this live stream
                loadLiveStreamCardViewers(event.id);
                // Load boosts for live stream
                if (!boostsCache.has(event.id)) {
                    loadBoostsForVideo(event.id);
                }
            }

            if (!cachedProfile) {
                profileQueue.add(event.pubkey);
                clearTimeout(profileTimer);
                profileTimer = setTimeout(loadProfilesBatch, 100);
            }
            return;
        }

        // Regular video handling
        if (!tags.some(tag => tag[0] === 'x')) return;

        if (!matchesSearch(event)) return;

        if (videoEvents.some(e => e.id === event.id)) {
            return;
        }

        allEvents.set(event.id, event);

        // Remove any legacy counterpart that was already added (handles race condition)
        if (event.kind === NIP71_VIDEO_KIND) {
            removeLegacyCounterpart(event, videoEvents);
        } else if (event.kind === NIP71_SHORT_KIND) {
            removeLegacyCounterpart(event, shortEvents);
        }

        // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
        if (shouldSkipLegacyEvent(event)) return;

        const isShort = isNip71ShortKind(event.kind);

        if (isShort) {
            if (shortEvents.some(e => e.id === event.id)) return;
            shortEvents.push(event);
        } else {
            videoEvents.push(event);
        }

        const spinner = videoGrid.querySelector('.spinner');
        if (spinner) spinner.remove();

        const cachedProfile = profileCache.get(event.pubkey);
        const cachedReactions = reactionsCache.get(event.id);

        if (isShort) {
            renderShortCard(event, cachedProfile, cachedReactions);
        } else {
            renderVideoCard(event, cachedProfile, cachedReactions);
        }

        if (!cachedProfile) {
            profileQueue.add(event.pubkey);
            clearTimeout(profileTimer);
            profileTimer = setTimeout(loadProfilesBatch, 100);
        }

        reactionQueue.add(event.id);
        clearTimeout(reactionTimer);
        reactionTimer = setTimeout(loadReactionsBatch, 200);

    }, (allEvts) => {
        // Sort and cache shorts, show View More if needed
        if (shortEvents.length > 0) {
            shortEvents.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            cachedSearchShorts = shortEvents;

            if (shortEvents.length > maxInitialShorts && shortsViewMore) {
                shortsViewMore.style.display = 'block';
            }
        }

        if (videoEvents.length === 0 && shortEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No videos found matching "${query}".</p>`;
        } else if (videoEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No full-length videos found matching "${query}".</p>`;
        }

        if (profileQueue.size > 0) {
            loadProfilesBatch();
        }
        if (reactionQueue.size > 0) {
            loadReactionsBatch();
        }

        // Load views for search results
        const searchVideoIds = [...videoEvents.map(e => e.id), ...shortEvents.map(e => e.id)];
        if (searchVideoIds.length > 0) {
            loadViewsForVideos(searchVideoIds, true);
        }
    });

    // Wait for user search to complete
    await userSearchPromise;
}

// Update sidebar active state
function updateSidebarActive() {
    const items = document.querySelectorAll('.sidebar-item');
    items.forEach(item => item.classList.remove('active'));

    const hash = window.location.hash;
    items.forEach(item => {
        if (item.getAttribute('href') === hash ||
            (hash === '' && item.getAttribute('href') === '#/')) {
            item.classList.add('active');
        }
    });
}

// Function to fetch a single video event and return immediately when found
// Supports both kind 1 (legacy) and NIP-71 (kind 21/22) video events
async function fetchVideoEvent(eventId) {
    return new Promise((resolve) => {
        let found = false;

        // First, try to fetch by ID (works for any kind)
        const idFilter = {
            ids: [eventId]
        };

        requestEventsStream(idFilter, (event) => {
            if (!found && event.id === eventId) {
                // Verify it's a video event
                if (isVideoEvent(event)) {
                    found = true;
                    allEvents.set(event.id, event);
                    resolve(event);
                }
            }
        }, () => {
            if (!found) {
                resolve(null);
            }
        });
    });
}

// Fetch video event by d-tag (for NIP-71 parameterized replaceable events)
async function fetchVideoEventByDTag(pubkey, dTag) {
    return new Promise((resolve) => {
        let found = false;
        const filter = {
            kinds: [NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY],
            authors: [pubkey],
            '#d': [dTag],
            '#t': ['pv69420']
        };

        requestEventsStream(filter, (event) => {
            if (!found) {
                found = true;
                allEvents.set(event.id, event);
                resolve(event);
            }
        }, () => {
            if (!found) {
                resolve(null);
            }
        });
    });
}

// Play video
async function playVideo(eventId, skipNSFWCheck = false, skipRatioedCheck = false) {
    // Clear any existing auto-play countdown and sticky scroll handler
    hideNextVideoOverlay();
    nextVideoData = null;
    if (stickyScrollHandler) {
        window.removeEventListener('scroll', stickyScrollHandler);
        window.removeEventListener('resize', stickyScrollHandler);
        stickyScrollHandler = null;
    }
    if (sidebarPlaceholder) {
        sidebarPlaceholder.remove();
        sidebarPlaceholder = null;
    }

    const mainContent = document.getElementById('mainContent');

    // Clean up any existing video element to prevent audio from continuing to play
    // when the video is replaced (fixes double audio bug)
    const existingVideo = mainContent.querySelector('video');
    if (existingVideo) {
        existingVideo.pause();
        existingVideo.src = '';
        existingVideo.load();
        existingVideo.remove();
    }

    if (!mainContent.querySelector('.spinner')) {
        mainContent.innerHTML = '<div class="spinner"></div>';
    }

    try {
        let event = allEvents.get(eventId);

        if (!event) {
            event = await fetchVideoEvent(eventId);
        }

        if (!event) {
            mainContent.innerHTML = `<div class="error-message">${t('error.videoNotFound')}</div>`;
            return;
        }

        // Check if video or user is blocked by admin
        if (isBlockedByAdmin(event.id, event.pubkey)) {
            mainContent.innerHTML = `<div class="error-message">${t('error.contentNotAvailable')}</div>`;
            return;
        }

        // Parse video data (supports both kind 1 and NIP-71 formats)
        const videoData = parseAnyVideoEvent(event);
        if (!videoData) {
            mainContent.innerHTML = `<div class="error-message">${t('error.invalidVideoData')}</div>`;
            return;
        }

        // Store event info for potential editing
        videoData.eventId = event.id;
        videoData.eventKind = event.kind;

        const profile = await fetchUserProfile(event.pubkey);
        const avatarUrl = profile?.picture || profile?.avatar || '';
        const nip05 = profile?.nip05 || '';

        // Validate profile first
        const [avatarValid, nip05Valid] = await Promise.all([
            avatarUrl ? createImageValidationPromise(avatarUrl) : Promise.resolve(false),
            nip05 ? validateNip05(nip05, event.pubkey) : Promise.resolve(false)
        ]);

        const isProfileSuspicious = !avatarValid || !nip05Valid;

        // Check NSFW independently from suspicious profile
        const isNSFW = isVideoNSFW(event);

        // Skip NSFW/Community Warning modals for own videos
        const isOwnVideo = currentUser?.pubkey === event.pubkey;

        // Check if NSFW should be shown first (separate from community warning, skip for own videos)
        if (!isOwnVideo && !skipNSFWCheck && isNSFW && !shouldShowNSFW()) {
            showNSFWModal('playVideo', eventId);
            return;
        }

        const cachedReactions = reactionsCache.get(eventId) || { likes: 0, dislikes: 0 };
        const isCachedRatioed = isVideoRatioed(cachedReactions);

        // Check if reported by follows (skip for own videos)
        const isReportedByFollowsCheck = !isOwnVideo && isReportedByFollowsSync(eventId, event.pubkey);

        // Only show community warning for suspicious profiles, ratioed videos, or reported by follows (skip for own videos)
        if (!isOwnVideo && !skipRatioedCheck && (isCachedRatioed || isProfileSuspicious || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning()) {
            showRatioedModal(eventId);
            return;
        }

        if (videoData && profile) {
            const authorName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;

            document.title = `${videoData.title} - Plebs`;

            const setMetaTag = (selector, attribute, value) => {
                let tag = document.querySelector(selector);
                if (tag) tag.setAttribute(attribute, value);
            };

            setMetaTag('meta[property="og:title"]', 'content', `${videoData.title} - Plebs`);
            setMetaTag('meta[property="og:description"]', 'content',
                videoData.description ? videoData.description.slice(0, 155) : `Watch "${videoData.title}" by ${authorName} on Plebs`);
            if (videoData.thumbnail) {
                setMetaTag('meta[property="og:image"]', 'content', videoData.thumbnail);
            }
        }

        const authorNpub = window.NostrTools.nip19.npubEncode(event.pubkey);

        // Add to watch history with video metadata for recommendations
        addToWatchHistory(eventId, videoData.tags || [], event.pubkey);

        const note = createNote(event);
        const userNpub = currentUser ? window.NostrTools.nip19.npubEncode(currentUser.pubkey) : '';

        const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;

        // Render page immediately with video loading state - video URL is resolved async
        mainContent.innerHTML = `
            <div class="video-player-container">
                <div class="video-player">
                    <div class="video-loading-state" id="video-loading-${eventId}">
                        <div class="spinner"></div>
                        <p>Loading video...</p>
                    </div>
                    <video controls playsinline>
                        Your browser does not support the video tag.
                    </video>
                </div>
                <div class="video-content-wrapper">
                    <div class="video-details">
                        <h1>${videoData.title}</h1>
                        <div class="video-meta">
                            ${formatTimestamp(event.created_at)}
                            • <span class="video-page-views" id="video-views-${event.id}">${videoViewsCache.has(event.id) ? `${formatNumber(videoViewsCache.get(event.id))} views` : 'Loading views...'}</span>
                            ${isNSFW ? ' • <span style="color: #ff0000;">NSFW</span>' : ''}
                            <span class="ratioed-indicator" style="${isProfileSuspicious || isCachedRatioed ? '' : 'display: none;'}"> • <span style="color: #ff9800;">Community Warning</span></span>
                            • <span class="report-flag" onclick="showReportModal('${event.id}', '${event.pubkey}')" title="${t('action.reportVideo')}">${t('action.report')}</span>
                        </div>
                        <div class="video-channel-info">
                            <a href="#/profile/${event.pubkey}" class="channel-info" style="text-decoration: none;">
                                <div class="channel-avatar">
                                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                                </div>
                                <div class="channel-details">
                                    <div class="channel-name">${displayName}</div>
                                    ${nip05 ? `<div class="channel-nip05">${nip05}</div>` : ''}
                                    <div class="channel-stats" id="channel-stats-${event.pubkey}">
                                        <span class="channel-stat loading">
                                            <span class="stat-value">-</span> videos
                                        </span>
                                        <span class="channel-stat-separator">•</span>
                                        <span class="channel-stat loading">
                                            <span class="stat-value">-</span> followers
                                        </span>
                                    </div>
                                </div>
                            </a>
                            <div class="channel-actions" id="channel-actions-${event.pubkey}">
                                ${currentUser && currentUser.pubkey !== event.pubkey ? `
                                    <button class="channel-follow-btn loading" disabled>
                                        <span class="spinner-small"></span>
                                    </button>
                                    <button class="channel-mute-btn loading" disabled>
                                        <span class="spinner-small"></span>
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                        <div class="video-actions" id="video-actions-${eventId}">
                            <button class="action-btn like ${cachedReactions.userReaction === 'like' ? 'active' : ''}"
                                    onclick="handleLike('${event.id}')"
                                    data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                                </svg>
                                <span class="count">${formatNumber(cachedReactions.likes || 0)}</span>
                            </button>
                            <button class="action-btn dislike ${cachedReactions.userReaction === 'dislike' ? 'active' : ''}"
                                    onclick="handleDislike('${event.id}')"
                                    data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                                </svg>
                                <span class="count">${formatNumber(cachedReactions.dislikes || 0)}</span>
                            </button>
                            <button class="action-btn zap ${currentUser && currentUser.pubkey === event.pubkey ? 'self-content' : ''}"
                                    onclick="${currentUser && currentUser.pubkey === event.pubkey ? '' : `handleZap('${authorNpub}', 1000, '${event.id}')`}"
                                    data-event-id="${event.id}"
                                    ${currentUser && currentUser.pubkey === event.pubkey ? `title="${t('zap.cannotZapOwnContent')}"` : ''}>
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                                </svg>
                                <span class="count">Zap</span>
                            </button>
                            <button class="action-btn boost"
                                    onclick="handleBoost('${event.id}')"
                                    data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                                </svg>
                                <span class="count">Boost</span>
                            </button>
                            <button class="action-btn" onclick="shareVideo('${event.id}')">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
                                </svg>
                                Share
                            </button>
                            <button class="action-btn" id="download-btn-${eventId}" disabled title="${t('status.loadingVideo')}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                                </svg>
                                Download
                            </button>
                            ${currentUser && currentUser.pubkey === event.pubkey ? `
                                <div class="video-owner-actions-row">
                                    ${(() => {
                    const editableId = getEditableEventId(event.id);
                    return editableId ? `
                                            <button class="action-btn edit" onclick="showEditVideoModal('${editableId}')">
                                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                                                </svg>
                                                Edit
                                            </button>
                                        ` : '';
                })()}
                                    <button class="action-btn delete" onclick="handleDelete('${event.id}')">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                                        </svg>
                                        Delete
                                    </button>
                                </div>
                            ` : ''}
                        </div>

                        <div style="margin-top: 1.5rem;">
                            <h3>Description</h3>
                            <div class="video-description-container">
                                <div id="video-description" class="video-description ${videoData.description && videoData.description.length > 300 ? 'collapsed' : ''}">
                                    <p style="white-space: pre-wrap; margin-top: 0.5rem;">${videoData.description ? processTextWithLinks(videoData.description) : t('video.noDescription')}</p>
                                </div>
                                ${videoData.description && videoData.description.length > 300 ? `
                                    <button id="description-toggle" class="description-toggle-btn" onclick="toggleDescription()">
                                        Show More
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                        ${videoData.tags.length > 0 ? `
                            <div class="tags">
                                ${videoData.tags.map(tag => `<span class="tag" onclick="navigateTo('/tag/${tag.toLowerCase()}')">#${tag}</span>`).join('')}
                            </div>
                        ` : ''}

                        <div class="recommendations-sidebar mobile-only" id="recommendationsSidebarMobile">
                            <div class="sidebar-header">
                                <h3>
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                                    </svg>
                                    Up Next
                                </h3>
                            </div>
                            <div class="sidebar-recommendations-grid">
                                <div class="spinner"></div>
                            </div>
                        </div>

                        <div class="comments-section">
                            <div class="comments-header">
                                <h3>Comments</h3>
                                <div class="comments-sort-dropdown">
                                    <select id="comments-sort" onchange="handleCommentSort(this.value)">
                                        <option value="newest">Newest</option>
                                        <option value="likes">Most Likes</option>
                                        <option value="zaps">Most Zaps</option>
                                    </select>
                                </div>
                            </div>
                            <div id="main-comment-input"></div>
                            <div id="comments-container">
                                <div class="spinner"></div>
                            </div>
                        </div>
                    </div>
                    <div class="recommendations-sidebar desktop-only" id="recommendationsSidebarDesktop">
                        <div class="sidebar-header">
                            <h3>
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                                </svg>
                                Up Next
                            </h3>
                        </div>
                        <div class="sidebar-recommendations-grid">
                            <div class="spinner"></div>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Validate NIP-05 and add checkmark if valid
        if (nip05) {
            // Check cache first
            if (profileValidationCache.has(event.pubkey)) {
                const cached = profileValidationCache.get(event.pubkey);
                if (cached.nip05Valid) {
                    const channelNip05 = mainContent.querySelector('.video-channel-info .channel-nip05');
                    applyNip05Checkmark(channelNip05, true);
                }
            } else {
                // Validate asynchronously
                validateNip05(nip05, event.pubkey).then(isValid => {
                    if (isValid) {
                        const channelNip05 = mainContent.querySelector('.video-channel-info .channel-nip05');
                        applyNip05Checkmark(channelNip05, true);
                    }
                });
            }
        }

        const video = mainContent.querySelector('video');
        const videoLoadingState = document.getElementById(`video-loading-${eventId}`);
        const downloadBtn = document.getElementById(`download-btn-${eventId}`);

        // Async video URL resolution - doesn't block page render
        (async () => {
            try {
                const videoUrl = await getVideoUrl(videoData.hash) || videoData.url;

                if (!videoUrl) {
                    if (videoLoadingState) {
                        videoLoadingState.innerHTML = `<p class="error-message">${t('error.videoNotAvailable')}</p>`;
                    }
                    return;
                }

                // Set up error handler before setting source
                video.onerror = async () => {
                    const fallbackUrl = await getVideoUrl(videoData.hash, BLOSSOM_SERVERS.slice(1));
                    if (fallbackUrl && fallbackUrl !== videoUrl) {
                        video.src = fallbackUrl;
                        // Update download button with fallback URL
                        if (downloadBtn) {
                            downloadBtn.onclick = () => downloadVideo(fallbackUrl, { title: videoData.title });
                            downloadBtn.disabled = false;
                            downloadBtn.title = '';
                        }
                    } else {
                        // Show error state - recreate loading state if it was removed
                        const videoPlayer = video.parentElement;
                        let errorState = videoLoadingState;
                        if (!errorState || !errorState.parentElement) {
                            errorState = document.createElement('div');
                            errorState.className = 'video-loading-state';
                            videoPlayer.insertBefore(errorState, video);
                        }
                        errorState.style.display = 'flex';
                        errorState.innerHTML = `<p class="error-message">${t('error.failedLoadVideo')}</p>`;
                    }
                };

                // Video loaded successfully - remove loading state from DOM entirely
                video.onloadeddata = () => {
                    if (videoLoadingState) {
                        videoLoadingState.remove();
                    }
                };

                // Show auto-play next video overlay when video ends
                video.onended = () => {
                    showNextVideoOverlay();
                };

                // Record view when video starts playing (works for both logged-in and anonymous)
                video.onplay = () => {
                    recordVideoView(eventId);
                };

                // Set the video source
                video.src = videoUrl;
                video.autoplay = true;
                video.playsInline = true;

                // Enable download button
                if (downloadBtn) {
                    downloadBtn.onclick = () => downloadVideo(videoUrl, { title: videoData.title });
                    downloadBtn.disabled = false;
                    downloadBtn.title = '';
                }
            } catch (error) {
                console.error('Failed to resolve video URL:', error);
                if (videoLoadingState) {
                    videoLoadingState.innerHTML = `<p class="error-message">${t('error.failedLoadVideoShort')}</p>`;
                }
            }
        })();

        const mainCommentInput = createCommentInput();
        document.getElementById('main-comment-input').replaceWith(mainCommentInput);

        // First, try to find linked events (for merging reactions/zaps/comments from legacy events)
        // We await this to ensure we have all linked IDs before loading data
        const additionalIds = await findLinkedVideoEvents(event);

        // Get all linked event IDs (includes any found by findLinkedVideoEvents)
        const linkedEventIds = getAllLinkedEventIds(eventId);
        const videoEventIds = linkedEventIds;

        loadComments(videoEventIds);

        // Load reactions from all linked events (merges kind 1 and kind 21/22)
        // Note: loadReactionsForVideos expands IDs internally via getAllLinkedEventIds
        loadReactionsForVideos([eventId], (videoId, reactions) => {
            updateReactionButtons(eventId, reactions);

            const isRatioed = isVideoRatioed(reactions);
            if ((isRatioed || isProfileSuspicious) && !skipRatioedCheck && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning()) {
                const indicator = mainContent.querySelector('.ratioed-indicator');
                if (indicator) {
                    indicator.style.display = 'inline';
                }
            }
        });

        // Load zaps from all linked events (merges kind 1 and kind 21/22)
        loadZapsForVideos(linkedEventIds, (totalZaps, count) => {
            updateZapButton(eventId, totalZaps);
        });

        // Load boosts from all linked events
        loadBoostsForVideos(linkedEventIds, (totalBoosts) => {
            updateBoostButton(eventId, totalBoosts);
        });

        // Load and display view count, then record this view
        loadVideoViews(eventId).then(viewCount => {
            const viewsElement = document.getElementById(`video-views-${eventId}`);
            if (viewsElement) {
                viewsElement.textContent = `${formatNumber(viewCount)} ${t('stat.views')}`;
            }
            // Update any video cards on the page with this video
            document.querySelectorAll(`.video-views[data-event-id="${eventId}"]`).forEach(el => {
                el.textContent = ` • ${formatNumber(viewCount)} ${t('stat.views')}`;
            });
        });

        // Note: View recording happens in video.onplay handler (supports both logged-in and anonymous)

        // Load sidebar recommendations (similar videos + personalized if enough history)
        loadSidebarRecommendations(event);

        // Load channel stats and follow button asynchronously - defer to not block other loading
        setTimeout(() => loadChannelStats(event.pubkey), 500);

    } catch (error) {
        console.error('Failed to play video:', error);
        mainContent.innerHTML = `<div class="error-message">${t('error.failedLoadVideoShort')}</div>`;
    }
}

// Handle description expand/collapse
function toggleDescription() {
    const descriptionDiv = document.getElementById('video-description');
    const toggleBtn = document.getElementById('description-toggle');

    if (descriptionDiv.classList.contains('collapsed')) {
        descriptionDiv.classList.remove('collapsed');
        toggleBtn.textContent = t('button.showLess');
    } else {
        descriptionDiv.classList.add('collapsed');
        toggleBtn.textContent = t('button.showMore');
    }
}

// Handle bio expand/collapse
function toggleBio() {
    const bioDiv = document.getElementById('profile-bio');
    const toggleBtn = document.getElementById('bio-toggle');

    if (bioDiv.classList.contains('collapsed')) {
        bioDiv.classList.remove('collapsed');
        toggleBtn.textContent = t('button.showLess');
    } else {
        bioDiv.classList.add('collapsed');
        toggleBtn.textContent = t('button.showMore');
    }
}

// Handle like button click
async function handleLike(eventId) {
    if (!await ensureLoggedIn()) {
        return;
    }

    // Check if user is blocked
    if (isPubkeyBlocked(currentUser.pubkey)) {
        showToast('Your account has been restricted', 'error');
        return;
    }

    const success = await sendReaction(eventId, '👍');
    if (success) {
        const reactions = reactionsCache.get(eventId);
        updateReactionButtons(eventId, reactions);
    }
}

// Handle dislike button click
async function handleDislike(eventId) {
    if (!await ensureLoggedIn()) {
        return;
    }

    // Check if user is blocked
    if (isPubkeyBlocked(currentUser.pubkey)) {
        showToast('Your account has been restricted', 'error');
        return;
    }

    const success = await sendReaction(eventId, '👎');
    if (success) {
        const reactions = reactionsCache.get(eventId);
        updateReactionButtons(eventId, reactions);
    }
}

// Handle download button click
async function downloadVideo(videoUrl, videoData) {
    try {
        if (videoUrl.startsWith('https://') && BLOSSOM_SERVERS.some(server => videoUrl.startsWith(server))) {
            const response = await fetch(videoUrl);
            const blob = await response.blob();

            const blobUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = videoData.title || 'video';
            a.click();
            URL.revokeObjectURL(blobUrl);
            a.remove();
        } else {
            const a = document.createElement('a');
            a.href = videoUrl;
            a.download = videoData.title || 'video';
            a.click();
            a.remove();
        }
    } catch (error) {
        console.error('Failed to download video:', error);
        showToast('Failed to download video. Please try again.', 'error');
    }
}

// Update reaction buttons UI
function updateReactionButtons(eventId, reactions) {
    const likeBtn = document.querySelector(`.action-btn.like[data-event-id="${eventId}"]`);
    const dislikeBtn = document.querySelector(`.action-btn.dislike[data-event-id="${eventId}"]`);

    if (likeBtn && dislikeBtn) {
        likeBtn.querySelector('.count').textContent = formatNumber(reactions.likes || 0);
        dislikeBtn.querySelector('.count').textContent = formatNumber(reactions.dislikes || 0);

        likeBtn.classList.toggle('active', reactions.userReaction === 'like');
        dislikeBtn.classList.toggle('active', reactions.userReaction === 'dislike');
    }
}

// Share video
// Current share state
let currentShareEventId = null;

function shareVideo(eventId) {
    currentShareEventId = eventId;
    const isLocal = window.location.protocol === 'file:';
    const baseUrl = isLocal ? window.location.href.split('#')[0] : window.location.origin;
    const shareUrl = `${baseUrl}/#/video/${eventId}`;
    document.getElementById('shareUrlInput').value = shareUrl;

    // Reset to link tab
    switchShareTab('link');

    // Generate embed code
    updateEmbedCode();

    // Show the fallback note for regular videos (uses blossom hosts)
    const fallbackNote = document.getElementById('embedFallbackNote');
    if (fallbackNote) fallbackNote.style.display = '';

    // Record share event for analytics
    recordVideoShare(eventId);

    document.getElementById('shareModal').classList.add('active');
}

// Switch between share tabs
function switchShareTab(tab) {
    // Update tab buttons
    document.querySelectorAll('.share-tab').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tab);
    });

    // Update tab content
    document.getElementById('shareLinkTab').classList.toggle('active', tab === 'link');
    document.getElementById('shareEmbedTab').classList.toggle('active', tab === 'embed');

    // Generate embed code when switching to embed tab
    if (tab === 'embed') {
        updateEmbedCode();
    }
}

// Update embed code based on selected size
function updateEmbedCode() {
    if (!currentShareEventId) return;

    const event = allEvents.get(currentShareEventId);
    if (!event) return;

    const videoData = parseAnyVideoEvent(event);
    if (!videoData) return;

    const sizeSelect = document.getElementById('embedSizeSelect');
    const selectedSize = sizeSelect.value;

    const isLocal = window.location.protocol === 'file:';
    const baseUrl = isLocal ? window.location.href.split('#')[0] : window.location.origin;
    const embedUrl = `${baseUrl}/embed.html?id=${currentShareEventId}`;

    let embedCode;
    if (selectedSize === 'responsive') {
        embedCode = `<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="${embedUrl}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;" allowfullscreen></iframe>
</div>`;
    } else {
        const [width, height] = selectedSize.split('x');
        embedCode = `<iframe width="${width}" height="${height}" src="${embedUrl}" frameborder="0" allowfullscreen></iframe>`;
    }

    document.getElementById('embedCodeInput').value = embedCode;
}

// Copy embed code
function copyEmbedCode() {
    const textarea = document.getElementById('embedCodeInput');
    textarea.select();
    document.execCommand('copy');

    document.getElementById('embedCopySuccess').style.display = 'block';
    setTimeout(() => {
        document.getElementById('embedCopySuccess').style.display = 'none';
    }, 2000);
}

// Copy share URL
function copyShareUrl() {
    const input = document.getElementById('shareUrlInput');
    input.select();
    document.execCommand('copy');

    document.getElementById('copySuccess').style.display = 'block';
    setTimeout(() => {
        document.getElementById('copySuccess').style.display = 'none';
    }, 2000);
}

// Hide share modal
function hideShareModal() {
    document.getElementById('shareModal').classList.remove('active');
    document.getElementById('copySuccess').style.display = 'none';
    document.getElementById('embedCopySuccess').style.display = 'none';
    currentShareEventId = null;
}

// Comment system functions
// Progressive comment loading - renders comments as they arrive
async function loadComments(eventIds) {
    const commentsContainer = document.getElementById('comments-container');
    if (!commentsContainer) return;

    commentsContainer.innerHTML = '<div class="spinner"></div>';

    // Expand event IDs to include all linked events (for comment merging)
    const allLinkedIds = new Set();
    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => allLinkedIds.add(linkedId));
    });
    const expandedEventIds = Array.from(allLinkedIds);

    // Reset comments state
    currentCommentsState = {
        comments: [],
        eventIds: eventIds,
        reactions: new Map(),
        zaps: new Map(),
        sortBy: 'newest'
    };

    // Reset sort dropdown to newest
    const sortDropdown = document.getElementById('comments-sort');
    if (sortDropdown) {
        sortDropdown.value = 'newest';
    }

    try {
        const filter = {
            kinds: [1],
            '#e': expandedEventIds,
            limit: 500
        };

        const comments = currentCommentsState.comments;
        const commentReactions = currentCommentsState.reactions;
        const commentZaps = currentCommentsState.zaps;
        const loadedPubkeys = new Set();
        let hasCleared = false;
        let renderTimeout = null;
        let lastRenderTime = 0;
        const RENDER_DEBOUNCE = 100; // ms

        // Progressive render function
        const renderProgressively = () => {
            if (comments.length === 0) return;

            const now = Date.now();
            if (now - lastRenderTime < RENDER_DEBOUNCE) {
                return;
            }
            lastRenderTime = now;

            // Clear spinner on first render
            if (!hasCleared) {
                hasCleared = true;
                commentsContainer.innerHTML = '';
            }

            // Build tree and render
            const commentTree = buildCommentTree(comments, eventIds, currentCommentsState.sortBy, commentReactions, commentZaps);
            renderComments(commentTree, profileCache, commentReactions, commentsContainer, commentZaps);

            // Load profiles immediately for any new pubkeys
            comments.forEach(c => {
                if (!loadedPubkeys.has(c.pubkey)) {
                    loadedPubkeys.add(c.pubkey);
                    loadProfileAndUpdateCards(c.pubkey);
                }
            });
        };

        // Debounced render scheduler
        const scheduleRender = () => {
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderProgressively, RENDER_DEBOUNCE);
        };

        // Stream comments and render progressively
        requestEventsStream(filter, (event) => {
            comments.push(event);
            allEvents.set(event.id, event);
            scheduleRender();
        }, () => {
            // On completion - do final render
            clearTimeout(renderTimeout);
            renderProgressively();

            if (comments.length === 0) {
                commentsContainer.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.noComments')}</p>`;
                return;
            }

            // Load reactions in background and update comments in-place
            const commentIds = comments.map(c => c.id);
            if (commentIds.length > 0) {
                const BATCH_SIZE = 50;
                const commentIdBatches = [];
                for (let i = 0; i < commentIds.length; i += BATCH_SIZE) {
                    commentIdBatches.push(commentIds.slice(i, i + BATCH_SIZE));
                }

                Promise.all(commentIdBatches.map(batch =>
                    new Promise(resolve => {
                        requestEventsStream({ kinds: [7], '#e': batch }, (event) => {
                            const targetId = event.tags.find(t => t[0] === 'e')?.[1];
                            if (targetId && commentIds.includes(targetId)) {
                                if (!commentReactions.has(targetId)) {
                                    commentReactions.set(targetId, new Map());
                                }
                                const reactions = commentReactions.get(targetId);
                                const existingReaction = reactions.get(event.pubkey);
                                if (!existingReaction || existingReaction.timestamp < event.created_at) {
                                    reactions.set(event.pubkey, {
                                        eventId: event.id,
                                        reaction: event.content,
                                        timestamp: event.created_at,
                                        pubkey: event.pubkey,
                                        hasPoW: validateEventPoW(event)
                                    });
                                    // Update comment reaction count in-place
                                    updateCommentReactionsInPlace(targetId, reactions);
                                }
                            }
                        }, resolve);
                    })
                ));

                // Load zaps for comments in background
                Promise.all(commentIdBatches.map(batch =>
                    new Promise(resolve => {
                        requestEventsStream({ kinds: [9735], '#e': batch }, (event) => {
                            try {
                                const targetId = event.tags.find(t => t[0] === 'e')?.[1];
                                if (targetId && commentIds.includes(targetId)) {
                                    const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                                    if (bolt11Tag && bolt11Tag[1]) {
                                        const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                        if (amount > 0) {
                                            if (!commentZaps.has(targetId)) {
                                                commentZaps.set(targetId, { totalSats: 0, count: 0 });
                                            }
                                            const zapData = commentZaps.get(targetId);
                                            zapData.totalSats += amount;
                                            zapData.count++;
                                            // Update comment zap count in-place
                                            updateCommentZapsInPlace(targetId, zapData);
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error('Failed to parse comment zap:', e);
                            }
                        }, resolve);
                    })
                ));
            }
        });

    } catch (error) {
        console.error('Failed to load comments:', error);
        commentsContainer.innerHTML = `<div class="error-message">${t('empty.failedLoadComments')}</div>`;
    }
}

// Update comment profile display in-place
function updateCommentProfileInPlace(pubkey, profile) {
    const commentElements = document.querySelectorAll(`.comment[data-pubkey="${pubkey}"]`);
    commentElements.forEach(el => {
        const displayName = profile.name || profile.display_name || `User ${pubkey.slice(0, 8)}`;
        const avatarUrl = profile.picture || profile.avatar || '';
        const nip05 = profile.nip05 || '';

        const nameEl = el.querySelector('.comment-author-name');
        if (nameEl) nameEl.textContent = displayName;

        const avatarEl = el.querySelector('.comment-avatar');
        if (avatarEl && avatarUrl) {
            avatarEl.innerHTML = `<img src="${avatarUrl}" alt="${displayName}">`;
        }

        const nip05El = el.querySelector('.comment-author-nip05');
        if (nip05El) {
            nip05El.textContent = nip05;
            nip05El.style.display = nip05 ? 'block' : 'none';
        } else if (nip05) {
            const authorInfo = el.querySelector('.comment-author-info');
            if (authorInfo) {
                const newNip05El = document.createElement('div');
                newNip05El.className = 'comment-author-nip05';
                newNip05El.textContent = nip05;
                authorInfo.appendChild(newNip05El);
            }
        }
    });
}

// Update comment reaction count in-place
function updateCommentReactionsInPlace(commentId, reactions) {
    const commentEl = document.querySelector(`.comment[data-comment-id="${commentId}"]`);
    if (!commentEl) return;

    let likes = 0;
    let dislikes = 0;
    let userReaction = null;

    reactions.forEach((data, pubkey) => {
        if (data.reaction === '👍' || data.reaction === '+') {
            likes++;
            if (currentUser && pubkey === currentUser.pubkey) {
                userReaction = 'like';
            }
        } else if (data.reaction === '👎' || data.reaction === '-') {
            dislikes++;
            if (currentUser && pubkey === currentUser.pubkey) {
                userReaction = 'dislike';
            }
        }
    });

    // Update like count and active state
    const likeBtn = commentEl.querySelector('.comment-like-btn');
    const likeCountEl = commentEl.querySelector('.like-count');
    if (likeCountEl) {
        likeCountEl.textContent = likes > 0 ? formatNumber(likes) : 'Like';
    }
    if (likeBtn) {
        likeBtn.classList.toggle('active', userReaction === 'like');
    }

    // Update dislike count and active state
    const dislikeBtn = commentEl.querySelector('.comment-dislike-btn');
    const dislikeCountEl = commentEl.querySelector('.dislike-count');
    if (dislikeCountEl) {
        dislikeCountEl.textContent = dislikes > 0 ? formatNumber(dislikes) : 'Dislike';
    }
    if (dislikeBtn) {
        dislikeBtn.classList.toggle('active', userReaction === 'dislike');
    }
}

// Update comment zap count in-place
function updateCommentZapsInPlace(commentId, zapData) {
    const commentEl = document.querySelector(`.comment[data-comment-id="${commentId}"]`);
    if (!commentEl) return;

    const zapCountEl = commentEl.querySelector('.zap-count');
    if (zapCountEl) {
        zapCountEl.textContent = zapData.totalSats > 0 ? formatNumber(zapData.totalSats) : 'Zap';
    }
}

// Build hierarchical comment structure
function buildCommentTree(comments, rootEventIds, sortBy = 'newest', reactions = new Map(), zaps = new Map()) {
    const commentMap = new Map();
    const rootComments = [];

    comments.forEach(comment => {
        commentMap.set(comment.id, {
            ...comment,
            children: [],
            depth: 0
        });
    });

    comments.forEach(comment => {
        const eTags = comment.tags.filter(t => t[0] === 'e');

        let parentId = null;
        for (let i = eTags.length - 1; i >= 0; i--) {
            const eventId = eTags[i][1];
            if (!rootEventIds.includes(eventId) && commentMap.has(eventId)) {
                parentId = eventId;
                break;
            }
        }

        const commentNode = commentMap.get(comment.id);

        if (parentId && commentMap.has(parentId)) {
            const parent = commentMap.get(parentId);
            parent.children.push(commentNode);
            commentNode.depth = parent.depth + 1;
        } else {
            rootComments.push(commentNode);
        }
    });

    // Helper to count likes for a comment
    const getLikeCount = (commentId) => {
        const commentReactions = reactions.get(commentId);
        if (!commentReactions) return 0;
        let likes = 0;
        commentReactions.forEach((data) => {
            if (data.reaction === '👍' || data.reaction === '+') {
                likes++;
            }
        });
        return likes;
    };

    // Helper to get zap amount for a comment
    const getZapAmount = (commentId) => {
        const zapData = zaps.get(commentId);
        return zapData ? zapData.totalSats : 0;
    };

    const sortComments = (comments) => {
        if (sortBy === 'likes') {
            comments.sort((a, b) => {
                const likesA = getLikeCount(a.id);
                const likesB = getLikeCount(b.id);
                if (likesB !== likesA) return likesB - likesA;
                return b.created_at - a.created_at; // Fallback to newest
            });
        } else if (sortBy === 'zaps') {
            comments.sort((a, b) => {
                const zapsA = getZapAmount(a.id);
                const zapsB = getZapAmount(b.id);
                if (zapsB !== zapsA) return zapsB - zapsA;
                return b.created_at - a.created_at; // Fallback to newest
            });
        } else {
            // Default: newest first
            comments.sort((a, b) => b.created_at - a.created_at);
        }
        comments.forEach(comment => sortComments(comment.children));
    };

    sortComments(rootComments);

    return rootComments;
}

// Handle comment sorting change
function handleCommentSort(sortBy) {
    currentCommentsState.sortBy = sortBy;

    const commentsContainer = document.getElementById('comments-container');
    if (!commentsContainer || currentCommentsState.comments.length === 0) return;

    const commentTree = buildCommentTree(
        currentCommentsState.comments,
        currentCommentsState.eventIds,
        sortBy,
        currentCommentsState.reactions,
        currentCommentsState.zaps
    );

    renderComments(
        commentTree,
        profileCache,
        currentCommentsState.reactions,
        commentsContainer,
        currentCommentsState.zaps
    );
}

// Render comment tree
function renderComments(comments, profiles, reactions, container, zaps = new Map()) {
    if (comments.length === 0) {
        container.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.noComments')}</p>`;
        return;
    }

    container.innerHTML = '';
    comments.forEach(comment => {
        const commentElement = createCommentElement(comment, profiles, reactions, zaps);
        container.appendChild(commentElement);
    });
}

// Create individual comment element
function createCommentElement(comment, profiles, reactions, zaps = new Map()) {
    // Check if comment is from a muted user
    if (shouldHideMutedContent(comment.pubkey)) {
        const placeholderDiv = document.createElement('div');
        placeholderDiv.className = 'comment muted-comment-placeholder';
        placeholderDiv.dataset.commentId = comment.id;
        placeholderDiv.dataset.pubkey = comment.pubkey;
        placeholderDiv.dataset.depth = Math.min(comment.depth, 3);
        placeholderDiv.innerHTML = `
            <div class="muted-placeholder-content muted-comment">
                <span class="muted-icon-small">${getMuteIconSVG(14)}</span>
                <span>Comment from muted user hidden</span>
                <button class="unhide-muted-btn-small" onclick="unhideMutedComment('${comment.id}', '${comment.pubkey}')">
                    Show
                </button>
            </div>
        `;
        return placeholderDiv;
    }

    // Check if comment matches enabled filter packs
    const filterResult = shouldFilterComment(comment.content);
    if (filterResult.filtered && !sessionFilteredAllowed.has(comment.id)) {
        const packNames = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.name || p.packName).join(', ');
        const packIcons = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.icon || '🚫').join(' ');

        const placeholderDiv = document.createElement('div');
        placeholderDiv.className = 'comment filtered-comment-placeholder';
        placeholderDiv.dataset.eventId = comment.id;
        placeholderDiv.dataset.depth = Math.min(comment.depth, 3);
        placeholderDiv.innerHTML = `
            <div class="filtered-placeholder-content filtered-comment">
                <span class="filtered-icon-small">${packIcons}</span>
                <span>Comment hidden (${escapeHtml(packNames)})</span>
                <button class="unhide-filtered-btn-small" onclick="handleUnhideFilteredContent('${comment.id}')">
                    Show
                </button>
            </div>
        `;
        return placeholderDiv;
    }

    // Check if comment has been reported by follows (skip for own comments)
    const isCommentReported = currentUser?.pubkey !== comment.pubkey &&
        isReportedByFollowsSync(comment.id, comment.pubkey) &&
        !sessionRatioedAllowed.has(comment.id) &&
        !shouldSkipCommunityWarning();

    if (isCommentReported) {
        const placeholderDiv = document.createElement('div');
        placeholderDiv.className = 'comment reported-comment-placeholder';
        placeholderDiv.dataset.eventId = comment.id;
        placeholderDiv.dataset.depth = Math.min(comment.depth, 3);
        placeholderDiv.innerHTML = `
            <div class="filtered-placeholder-content filtered-comment" style="border-color: #ff9800;">
                <span class="filtered-icon-small" style="color: #ff9800;">⚠</span>
                <span>Comment reported by people you follow</span>
                <button class="unhide-filtered-btn-small" onclick="unhideReportedComment('${comment.id}')">
                    Show
                </button>
            </div>
        `;
        return placeholderDiv;
    }

    const profile = profiles.get(comment.pubkey) || {};
    const displayName = profile.name || profile.display_name || `User ${comment.pubkey.slice(0, 8)}`;
    const avatarUrl = profile.picture || profile.avatar || '';
    const nip05 = profile.nip05 || '';

    // Check if NIP-05 is validated
    const validationCached = profileValidationCache.get(comment.pubkey);
    const nip05Valid = validationCached?.nip05Valid || false;

    const commentReactions = reactions.get(comment.id) || new Map();
    let likes = 0;
    let dislikes = 0;
    let powLikes = 0;
    let powDislikes = 0;
    let userReaction = null;

    commentReactions.forEach((data, pubkey) => {
        if (data.reaction === '👍' || data.reaction === '+') {
            likes++;
            if (data.hasPoW) powLikes++;
            if (currentUser && pubkey === currentUser.pubkey) {
                userReaction = 'like';
            }
        } else if (data.reaction === '👎' || data.reaction === '-') {
            dislikes++;
            if (data.hasPoW) powDislikes++;
            if (currentUser && pubkey === currentUser.pubkey) {
                userReaction = 'dislike';
            }
        }
    });

    // Check if comment is ratioed using PoW-validated reactions only (spam-resistant)
    const isCommentRatioed = powDislikes > powLikes && powDislikes >= 3;

    // Show warning for heavily ratioed comments (if community warnings enabled)
    if (isCommentRatioed && currentUser?.pubkey !== comment.pubkey &&
        !sessionRatioedAllowed.has(comment.id) && !shouldSkipCommunityWarning()) {
        const placeholderDiv = document.createElement('div');
        placeholderDiv.className = 'comment ratioed-comment-placeholder';
        placeholderDiv.dataset.eventId = comment.id;
        placeholderDiv.dataset.depth = Math.min(comment.depth, 3);
        placeholderDiv.innerHTML = `
            <div class="filtered-placeholder-content filtered-comment" style="border-color: #ff9800;">
                <span class="filtered-icon-small" style="color: #ff9800;">👎</span>
                <span>Comment heavily downvoted by community</span>
                <button class="unhide-filtered-btn-small" onclick="unhideReportedComment('${comment.id}')">
                    Show
                </button>
            </div>
        `;
        return placeholderDiv;
    }

    // Get zap count for this comment
    const commentZapData = zaps.get(comment.id) || { totalSats: 0, count: 0 };
    const zapCountText = commentZapData.totalSats > 0 ? formatNumber(commentZapData.totalSats) : 'Zap';
    const authorNpub = window.NostrTools.nip19.npubEncode(comment.pubkey);

    const visualDepth = Math.min(comment.depth, 3);

    const commentDiv = document.createElement('div');
    commentDiv.className = 'comment';
    commentDiv.dataset.depth = visualDepth;
    commentDiv.dataset.commentId = comment.id;
    commentDiv.dataset.pubkey = comment.pubkey;

    const depthIndicator = comment.depth > 3 ? `↳ ${comment.depth - 3} more` : '';

    const processedContent = processCommentContent(comment.content);

    const likeCountText = likes > 0 ? formatNumber(likes) : 'Like';
    const dislikeCountText = dislikes > 0 ? formatNumber(dislikes) : 'Dislike';

    commentDiv.innerHTML = `
        <div class="comment-thread-line"></div>
        <div class="comment-content">
            <div class="comment-header">
                <a href="#/profile/${comment.pubkey}" class="comment-author">
                    <div class="comment-avatar">
                        ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                    </div>
                    <div class="comment-author-info">
                        <div class="comment-author-name">${displayName}</div>
                        ${nip05 ? `<div class="comment-author-nip05" data-pubkey="${comment.pubkey}">${nip05}${nip05Valid ? getNip05CheckmarkSVG(12) : ''}</div>` : ''}
                    </div>
                </a>
                <div class="comment-timestamp">${formatTimestamp(comment.created_at)}</div>
            </div>
            ${depthIndicator ? `<div class="comment-depth-indicator">${depthIndicator}</div>` : ''}
            <div class="comment-body">${processedContent}</div>
            <div class="comment-actions">
                <button class="comment-action-btn comment-like-btn ${userReaction === 'like' ? 'active' : ''}"
                        onclick="likeComment('${comment.id}')"
                        ${currentUser ? '' : 'disabled'}
                        data-comment-id="${comment.id}">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                    <span class="like-count">${likeCountText}</span>
                </button>
                <button class="comment-action-btn comment-dislike-btn ${userReaction === 'dislike' ? 'active' : ''}"
                        onclick="dislikeComment('${comment.id}')"
                        ${currentUser ? '' : 'disabled'}
                        data-comment-id="${comment.id}">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                    <span class="dislike-count">${dislikeCountText}</span>
                </button>
                <button class="comment-action-btn comment-reply-btn"
                        onclick="replyToComment('${comment.id}', '${comment.pubkey}')"
                        ${currentUser ? '' : 'disabled'}>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/>
                    </svg>
                    Reply
                </button>
                <button class="comment-action-btn comment-zap-btn ${currentUser && currentUser.pubkey === comment.pubkey ? 'self-content' : ''}"
                        onclick="${currentUser && currentUser.pubkey === comment.pubkey ? '' : `handleZap('${authorNpub}', 1000, '${comment.id}')`}"
                        ${currentUser ? '' : 'disabled'}
                        data-comment-id="${comment.id}"
                        ${currentUser && currentUser.pubkey === comment.pubkey ? `title="${t('zap.cannotZapOwnComment')}"` : ''}>
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                    </svg>
                    <span class="zap-count">${zapCountText}</span>
                </button>
                ${currentUser && currentUser.pubkey !== comment.pubkey ? `
                    <button class="comment-action-btn comment-mute-btn ${isUserMuted(comment.pubkey) ? 'muted' : ''}"
                            onclick="handleMute('${comment.pubkey}', ${isUserMuted(comment.pubkey)})"
                            title="${isUserMuted(comment.pubkey) ? t('button.unmuteUser') : t('button.muteUser')}">
                        ${getMuteIconSVG(14)}
                        <span>${isUserMuted(comment.pubkey) ? t('button.unmute') : t('button.mute')}</span>
                    </button>
                    <button class="comment-action-btn comment-report-btn"
                            onclick="showReportModal('${comment.id}', '${comment.pubkey}', 'comment')"
                            title="${t('action.reportComment')}">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"/>
                        </svg>
                        <span>${t('action.report')}</span>
                    </button>
                ` : ''}
            </div>
        </div>
    `;

    if (comment.children.length > 0) {
        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'comment-children';

        // Count total replies recursively (including nested children)
        function countTotalReplies(children) {
            let count = children.length;
            children.forEach(child => {
                if (child.children && child.children.length > 0) {
                    count += countTotalReplies(child.children);
                }
            });
            return count;
        }

        const totalReplies = countTotalReplies(comment.children);
        const BATCH_SIZE = 5; // Direct children per batch

        // If 2 or more total replies, show in collapsed batches
        if (totalReplies >= 2) {
            let visibleDirectChildren = 0;
            const directChildren = comment.children;

            // Helper to create expand button with thread line wrapper
            function createExpandButtonWrapper(text, onClick) {
                const wrapper = document.createElement('div');
                wrapper.className = 'comment-expand-btn-wrapper';

                const btn = document.createElement('button');
                btn.className = 'comment-expand-btn';
                btn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                    </svg>
                    <span>${text}</span>
                `;
                btn.onclick = onClick;

                wrapper.appendChild(btn);
                return wrapper;
            }

            // Function to render a batch of direct children (with their nested replies)
            function renderBatch() {
                const nextBatch = directChildren.slice(visibleDirectChildren, visibleDirectChildren + BATCH_SIZE);
                nextBatch.forEach(child => {
                    // Use regular createCommentElement which handles nested children properly
                    const childElement = createCommentElement(child, profiles, reactions, zaps);
                    childrenContainer.appendChild(childElement);
                });
                visibleDirectChildren += nextBatch.length;

                // Update or remove the "show more" button wrapper
                const existingWrapper = childrenContainer.querySelector(':scope > .comment-expand-btn-wrapper');
                if (existingWrapper) {
                    existingWrapper.remove();
                }

                // Calculate remaining direct children (what will actually load on next click)
                const remainingDirectCount = directChildren.length - visibleDirectChildren;

                if (remainingDirectCount > 0) {
                    // Show how many direct replies will load (up to BATCH_SIZE)
                    const nextBatchCount = Math.min(BATCH_SIZE, remainingDirectCount);
                    const wrapper = createExpandButtonWrapper(
                        `View ${nextBatchCount} more ${nextBatchCount === 1 ? 'reply' : 'replies'}`,
                        (e) => {
                            e.stopPropagation();
                            renderBatch();
                        }
                    );
                    childrenContainer.appendChild(wrapper);
                }
            }

            // Create initial "show replies" button inside children container
            // Show how many direct replies will load on first click (up to BATCH_SIZE)
            const initialBatchCount = Math.min(BATCH_SIZE, directChildren.length);
            const initialWrapper = createExpandButtonWrapper(
                `View ${initialBatchCount} ${initialBatchCount === 1 ? 'reply' : 'replies'}`,
                (e) => {
                    e.stopPropagation();
                    renderBatch();
                }
            );
            childrenContainer.appendChild(initialWrapper);
        } else {
            // Less than 2 replies, show them all directly
            comment.children.forEach(child => {
                const childElement = createCommentElement(child, profiles, reactions);
                childrenContainer.appendChild(childElement);
            });
        }

        commentDiv.appendChild(childrenContainer);
    }

    return commentDiv;
}

// Process text to make URLs clickable (for descriptions and bios)
function processTextWithLinks(text) {
    if (!text) return '';

    // Escape HTML first
    let processedText = escapeHtml(text);

    // URL regex to match http/https URLs
    const urlRegex = /(https?:\/\/[^\s<]+)/g;

    // Replace URLs with clickable links
    processedText = processedText.replace(urlRegex, (url) => {
        // Clean up any trailing punctuation that shouldn't be part of the URL
        let cleanUrl = url;
        let trailing = '';
        const trailingPunctuation = /[.,;:!?)>\]]+$/;
        const match = cleanUrl.match(trailingPunctuation);
        if (match) {
            // Check if it's likely part of the URL (like query params) or just punctuation
            const beforeMatch = cleanUrl.slice(0, -match[0].length);
            // If the character before is alphanumeric or common URL chars, keep single trailing char
            if (match[0].length === 1 && /[=&]$/.test(beforeMatch)) {
                // Keep it as part of URL
            } else {
                cleanUrl = beforeMatch;
                trailing = match[0];
            }
        }
        return `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer" class="text-link">${cleanUrl}</a>${trailing}`;
    });

    return processedText;
}

function processCommentContent(content) {
    let processedContent = escapeHtml(content);

    const urlRegex = /(https?:\/\/[^\s<]+)/g;
    const imageRegex = /(https?:\/\/[^\s<]+\.(jpg|jpeg|png|gif|webp|svg)(\?[^\s<]*)?)/gi;
    const videoRegex = /(https?:\/\/[^\s<]+\.(mp4|webm|mov)(\?[^\s<]*)?)/gi;
    const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/g;

    const mediaUrls = new Set();

    let match;
    while ((match = imageRegex.exec(content)) !== null) {
        mediaUrls.add(match[1]);
    }

    while ((match = videoRegex.exec(content)) !== null) {
        mediaUrls.add(match[1]);
    }

    const youtubeIds = new Map();
    while ((match = youtubeRegex.exec(content)) !== null) {
        mediaUrls.add(match[0]);
        youtubeIds.set(match[0], match[1]);
    }

    processedContent = processedContent.replace(urlRegex, (url) => {
        if (mediaUrls.has(url)) {
            return url;
        }
        return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="comment-link">${url}</a>`;
    });

    const imageMatches = content.match(imageRegex);
    if (imageMatches) {
        const embedsHtml = imageMatches.map(url =>
            `<div class="comment-media">
                <img src="${url}" alt="Embedded image" loading="lazy" onclick="window.open('${url}', '_blank')">
            </div>`
        ).join('');
        processedContent += embedsHtml;
    }

    const videoMatches = content.match(videoRegex);
    if (videoMatches) {
        const embedsHtml = videoMatches.map(url =>
            `<div class="comment-media">
                <video controls playsinline preload="metadata">
                    <source src="${url}" type="video/mp4">
                    <source src="${url}" type="video/webm">
                </video>
            </div>`
        ).join('');
        processedContent += embedsHtml;
    }

    youtubeIds.forEach((videoId, url) => {
        const embedHtml = `<div class="comment-media youtube-embed">
            <iframe src="https://www.youtube.com/embed/${videoId}" 
                    frameborder="0" 
                    allowfullscreen
                    loading="lazy">
            </iframe>
        </div>`;
        processedContent += embedHtml;
    });

    return processedContent;
}

// Add comment input box
function createCommentInput(replyTo = null) {
    const inputDiv = document.createElement('div');
    inputDiv.className = 'comment-input-container';
    inputDiv.id = replyTo ? `reply-input-${replyTo.id}` : 'main-comment-input';

    const placeholder = replyTo ? 'Write a reply...' : 'Add a comment...';
    const buttonText = replyTo ? 'Reply' : 'Comment';

    inputDiv.innerHTML = `
        <div class="comment-input-box">
            ${replyTo ? `
                <div class="replying-to">
                    Replying to @${replyTo.name || `User ${replyTo.pubkey.slice(0, 8)}`}
                    <button onclick="cancelReply('${replyTo.id}')" class="cancel-reply">×</button>
                </div>
            ` : ''}
            <textarea 
                class="comment-textarea" 
                placeholder="${placeholder}"
                rows="3"
                ${currentUser ? '' : 'disabled'}
            ></textarea>
            <div class="comment-input-actions">
                <button 
                    class="comment-submit-btn" 
                    onclick="submitComment(${replyTo ? `'${replyTo.id}', '${replyTo.pubkey}'` : 'null, null'})"
                    ${currentUser ? '' : 'disabled'}
                >
                    ${buttonText}
                </button>
            </div>
            ${!currentUser ? '<p class="comment-login-prompt">Please <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">login</a> to comment</p>' : ''}
        </div>
    `;

    return inputDiv;
}

// Submit comment
async function submitComment(parentId, parentPubkey) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to comment', 'warning');
            return;
        }
    }

    // Check if user is blocked
    if (isPubkeyBlocked(currentUser.pubkey)) {
        showToast('Your account has been restricted', 'error');
        return;
    }

    const container = parentId ? document.getElementById(`reply-input-${parentId}`) : document.getElementById('main-comment-input');
    if (!container) return;

    const textarea = container.querySelector('.comment-textarea');
    const content = textarea.value.trim();

    if (!content) {
        showToast('Please write a comment', 'warning');
        return;
    }

    const button = container.querySelector('.comment-submit-btn');
    button.disabled = true;
    button.textContent = t('status.generatingPoW');

    try {
        const videoEventIds = [];
        const eventId = window.location.hash.split('/')[2];

        videoEventIds.push(eventId);

        const tags = [];

        videoEventIds.forEach(id => {
            tags.push(['e', id, '', 'root']);
        });

        if (parentId) {
            tags.push(['e', parentId, '', 'reply']);
            tags.push(['p', parentPubkey]);
        }

        const videoEvent = allEvents.get(eventId);
        if (videoEvent) {
            tags.push(['p', videoEvent.pubkey]);
        }

        const commentEvent = {
            kind: 1,
            pubkey: currentUser.pubkey, // Required for PoW calculation
            tags: tags,
            content: content,
            created_at: Math.floor(Date.now() / 1000)
        };

        // Generate proof of work (NIP-13) - this adds the nonce tag
        await generatePoW(commentEvent, MIN_POW_DIFFICULTY);

        button.textContent = t('status.posting');

        const signedEvent = await signEvent(commentEvent);
        const published = await publishEvent(signedEvent);

        if (published) {
            textarea.value = '';

            if (parentId) {
                cancelReply(parentId);
            }

            // Add the comment to the DOM immediately
            addCommentToDOM(signedEvent, parentId);
        } else {
            throw new Error('Failed to publish comment');
        }
    } catch (error) {
        console.error('Failed to post comment:', error);
        showToast('Failed to post comment. Please try again.', 'error');
    } finally {
        button.disabled = false;
        button.textContent = parentId ? 'Reply' : 'Comment';
    }
}

// Add comment to DOM without reloading
function addCommentToDOM(commentEvent, parentId = null) {
    // Store the event
    allEvents.set(commentEvent.id, commentEvent);

    // Get user profile
    const profile = profileCache.get(commentEvent.pubkey) || {};
    const displayName = profile.name || profile.display_name || `User ${commentEvent.pubkey.slice(0, 8)}`;
    const avatarUrl = profile.picture || profile.avatar || '';
    const nip05 = profile.nip05 || '';

    // Create comment node
    const commentNode = {
        ...commentEvent,
        children: [],
        depth: parentId ? 1 : 0
    };

    // Create the comment element
    const commentElement = createCommentElement(commentNode, profileCache, new Map());

    // Find where to insert the comment
    if (parentId) {
        // It's a reply - find the parent comment
        const parentComment = document.querySelector(`[data-comment-id="${parentId}"]`);
        if (parentComment) {
            let childrenContainer = parentComment.querySelector('.comment-children');
            if (!childrenContainer) {
                childrenContainer = document.createElement('div');
                childrenContainer.className = 'comment-children';
                parentComment.appendChild(childrenContainer);
            }

            // Update the depth if nested
            const parentDepth = parseInt(parentComment.dataset.depth || 0);
            commentElement.dataset.depth = Math.min(parentDepth + 1, 3);

            // Insert at the beginning of children (newest first)
            childrenContainer.insertBefore(commentElement, childrenContainer.firstChild);
        }
    } else {
        // It's a top-level comment
        const commentsContainer = document.getElementById('comments-container');
        if (commentsContainer) {
            // Remove "no comments" message if it exists
            const noCommentsMsg = commentsContainer.querySelector('p');
            if (noCommentsMsg && noCommentsMsg.textContent.includes('No comments yet')) {
                noCommentsMsg.remove();
            }

            // Insert at the beginning (newest first)
            commentsContainer.insertBefore(commentElement, commentsContainer.firstChild);
        }
    }

    // If profile is not cached, fetch it
    if (!profileCache.has(commentEvent.pubkey)) {
        fetchUserProfile(commentEvent.pubkey).then(profile => {
            if (profile) {
                updateCommentProfile(commentEvent.id, profile);
            }
        });
    }
}

// Update comment profile when fetched
function updateCommentProfile(commentId, profile) {
    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    if (!commentElement) return;

    const displayName = profile.name || profile.display_name || `User ${commentElement.querySelector('.comment-author-name').textContent}`;
    const avatarUrl = profile.picture || profile.avatar || '';
    const nip05 = profile.nip05 || '';

    // Update name
    const nameElement = commentElement.querySelector('.comment-author-name');
    if (nameElement) {
        nameElement.textContent = displayName;
    }

    // Update avatar
    const avatarElement = commentElement.querySelector('.comment-avatar');
    if (avatarElement && avatarUrl) {
        avatarElement.innerHTML = `<img src="${avatarUrl}" alt="${displayName}">`;
    }

    // Update nip05
    const authorInfo = commentElement.querySelector('.comment-author-info');
    if (authorInfo && nip05) {
        const existingNip05 = authorInfo.querySelector('.comment-author-nip05');
        if (!existingNip05) {
            const nip05Element = document.createElement('div');
            nip05Element.className = 'comment-author-nip05';
            nip05Element.textContent = nip05;
            authorInfo.appendChild(nip05Element);
        }
    }
}

// Reply to comment
function replyToComment(commentId, commentPubkey) {
    document.querySelectorAll('.comment-reply-box').forEach(box => box.remove());

    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    if (!commentElement) return;

    const authorName = commentElement.querySelector('.comment-author-name').textContent;

    const replyBox = document.createElement('div');
    replyBox.className = 'comment-reply-box';
    replyBox.id = `reply-box-${commentId}`;

    const replyInput = createCommentInput({
        id: commentId,
        pubkey: commentPubkey,
        name: authorName
    });

    replyBox.appendChild(replyInput);

    const commentContent = commentElement.querySelector('.comment-content');
    commentContent.appendChild(replyBox);

    replyBox.querySelector('.comment-textarea').focus();
}

// Cancel reply
function cancelReply(commentId) {
    const replyBox = document.getElementById(`reply-box-${commentId}`);
    if (replyBox) {
        replyBox.remove();
    }
}

// Like comment
async function likeComment(commentId) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to like comments', 'warning');
            return;
        }
    }

    const likeButton = document.querySelector(`.comment-like-btn[data-comment-id="${commentId}"]`);
    const dislikeButton = document.querySelector(`.comment-dislike-btn[data-comment-id="${commentId}"]`);
    if (!likeButton) return;

    const likeCountSpan = likeButton.querySelector('.like-count');
    const dislikeCountSpan = dislikeButton?.querySelector('.dislike-count');
    const currentLikes = likeCountSpan.textContent === 'Like' ? 0 : parseInt(likeCountSpan.textContent) || 0;
    const currentDislikes = dislikeCountSpan?.textContent === 'Dislike' ? 0 : parseInt(dislikeCountSpan?.textContent) || 0;
    const wasLiked = likeButton.classList.contains('active');
    const wasDisliked = dislikeButton?.classList.contains('active');

    // Get user's existing reaction from cache
    const commentReactions = currentCommentsState.reactions.get(commentId);
    const userReaction = commentReactions?.get(currentUser.pubkey);

    // Optimistically update UI
    if (wasLiked) {
        // Removing like
        likeButton.classList.remove('active');
        const newCount = Math.max(0, currentLikes - 1);
        likeCountSpan.textContent = newCount > 0 ? formatNumber(newCount) : 'Like';
    } else {
        // Adding like
        likeButton.classList.add('active');
        likeCountSpan.textContent = formatNumber(currentLikes + 1);
        // Remove dislike if present
        if (wasDisliked && dislikeButton && dislikeCountSpan) {
            dislikeButton.classList.remove('active');
            const newDislikeCount = Math.max(0, currentDislikes - 1);
            dislikeCountSpan.textContent = newDislikeCount > 0 ? formatNumber(newDislikeCount) : 'Dislike';
        }
    }

    try {
        let published = false;

        if (wasLiked && userReaction?.eventId) {
            // Remove like by publishing kind 5 deletion event
            const deleteEvent = {
                kind: 5,
                tags: [['e', userReaction.eventId]],
                content: 'Removed reaction',
                created_at: Math.floor(Date.now() / 1000)
            };
            const signedDelete = await signEvent(deleteEvent);
            published = await publishEvent(signedDelete);

            // Remove from local cache
            if (published && commentReactions) {
                commentReactions.delete(currentUser.pubkey);
            }
        } else {
            // Add like reaction
            const reactionEvent = {
                kind: 7,
                tags: [
                    ['e', commentId],
                    ['p', allEvents.get(commentId)?.pubkey || ''],
                    ['t', 'pv69420']
                ],
                content: '👍',
                created_at: Math.floor(Date.now() / 1000)
            };
            const signedEvent = await signEvent(reactionEvent);
            published = await publishEvent(signedEvent);

            // Update local cache
            if (published) {
                if (!currentCommentsState.reactions.has(commentId)) {
                    currentCommentsState.reactions.set(commentId, new Map());
                }
                currentCommentsState.reactions.get(commentId).set(currentUser.pubkey, {
                    eventId: signedEvent.id,
                    reaction: '👍',
                    timestamp: signedEvent.created_at,
                    pubkey: currentUser.pubkey,
                    hasPoW: validateEventPoW(signedEvent)
                });
            }
        }

        if (!published) {
            // Revert on failure
            if (wasLiked) {
                likeButton.classList.add('active');
                likeCountSpan.textContent = currentLikes > 0 ? formatNumber(currentLikes) : 'Like';
            } else {
                likeButton.classList.remove('active');
                likeCountSpan.textContent = currentLikes > 0 ? formatNumber(currentLikes) : 'Like';
                if (wasDisliked && dislikeButton && dislikeCountSpan) {
                    dislikeButton.classList.add('active');
                    dislikeCountSpan.textContent = currentDislikes > 0 ? formatNumber(currentDislikes) : 'Dislike';
                }
            }
            throw new Error('Failed to publish reaction');
        }
    } catch (error) {
        console.error('Failed to like comment:', error);
    }
}

// Dislike a comment
async function dislikeComment(commentId) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to dislike comments', 'warning');
            return;
        }
    }

    const dislikeButton = document.querySelector(`.comment-dislike-btn[data-comment-id="${commentId}"]`);
    const likeButton = document.querySelector(`.comment-like-btn[data-comment-id="${commentId}"]`);
    if (!dislikeButton) return;

    const dislikeCountSpan = dislikeButton.querySelector('.dislike-count');
    const likeCountSpan = likeButton?.querySelector('.like-count');
    const currentDislikes = dislikeCountSpan.textContent === 'Dislike' ? 0 : parseInt(dislikeCountSpan.textContent) || 0;
    const currentLikes = likeCountSpan?.textContent === 'Like' ? 0 : parseInt(likeCountSpan?.textContent) || 0;
    const wasDisliked = dislikeButton.classList.contains('active');
    const wasLiked = likeButton?.classList.contains('active');

    // Get user's existing reaction from cache
    const commentReactions = currentCommentsState.reactions.get(commentId);
    const userReaction = commentReactions?.get(currentUser.pubkey);

    // Optimistically update UI
    if (wasDisliked) {
        // Removing dislike
        dislikeButton.classList.remove('active');
        const newCount = Math.max(0, currentDislikes - 1);
        dislikeCountSpan.textContent = newCount > 0 ? formatNumber(newCount) : 'Dislike';
    } else {
        // Adding dislike
        dislikeButton.classList.add('active');
        dislikeCountSpan.textContent = formatNumber(currentDislikes + 1);
        // Remove like if present
        if (wasLiked && likeButton && likeCountSpan) {
            likeButton.classList.remove('active');
            const newLikeCount = Math.max(0, currentLikes - 1);
            likeCountSpan.textContent = newLikeCount > 0 ? formatNumber(newLikeCount) : 'Like';
        }
    }

    try {
        let published = false;

        if (wasDisliked && userReaction?.eventId) {
            // Remove dislike by publishing kind 5 deletion event
            const deleteEvent = {
                kind: 5,
                tags: [['e', userReaction.eventId]],
                content: 'Removed reaction',
                created_at: Math.floor(Date.now() / 1000)
            };
            const signedDelete = await signEvent(deleteEvent);
            published = await publishEvent(signedDelete);

            // Remove from local cache
            if (published && commentReactions) {
                commentReactions.delete(currentUser.pubkey);
            }
        } else {
            // Add dislike reaction
            const reactionEvent = {
                kind: 7,
                tags: [
                    ['e', commentId],
                    ['p', allEvents.get(commentId)?.pubkey || ''],
                    ['t', 'pv69420']
                ],
                content: '👎',
                created_at: Math.floor(Date.now() / 1000)
            };
            const signedEvent = await signEvent(reactionEvent);
            published = await publishEvent(signedEvent);

            // Update local cache
            if (published) {
                if (!currentCommentsState.reactions.has(commentId)) {
                    currentCommentsState.reactions.set(commentId, new Map());
                }
                currentCommentsState.reactions.get(commentId).set(currentUser.pubkey, {
                    eventId: signedEvent.id,
                    reaction: '👎',
                    timestamp: signedEvent.created_at,
                    pubkey: currentUser.pubkey,
                    hasPoW: validateEventPoW(signedEvent)
                });
            }
        }

        if (!published) {
            // Revert on failure
            if (wasDisliked) {
                dislikeButton.classList.add('active');
                dislikeCountSpan.textContent = currentDislikes > 0 ? formatNumber(currentDislikes) : 'Dislike';
            } else {
                dislikeButton.classList.remove('active');
                dislikeCountSpan.textContent = currentDislikes > 0 ? formatNumber(currentDislikes) : 'Dislike';
                if (wasLiked && likeButton && likeCountSpan) {
                    likeButton.classList.add('active');
                    likeCountSpan.textContent = currentLikes > 0 ? formatNumber(currentLikes) : 'Like';
                }
            }
            throw new Error('Failed to publish reaction');
        }
    } catch (error) {
        console.error('Failed to dislike comment:', error);
    }
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
    };
    return text.replace(/[&<>]/g, m => map[m]);
}

// Upload modal functions
let currentUploadType = 'video'; // 'video' or 'short'
let mediaRecorder = null;
let recordedChunks = [];
let recordingStream = null;
let recordingTimer = null;
let recordingSeconds = 0;
let currentFacingMode = 'environment'; // 'environment' (back) or 'user' (front)
let isRecordedFromCamera = false; // Flag to skip orientation validation for camera recordings
let isSwitchingCamera = false; // Flag to prevent handleRecordingComplete during camera switch

function showUploadModal(type = 'video') {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    // Check if user is blocked
    if (isPubkeyBlocked(currentUser.pubkey)) {
        showToast('Your account has been restricted from uploading', 'error');
        return;
    }

    currentUploadType = type;
    document.getElementById('uploadType').value = type;

    // Update modal title
    const modalTitle = document.getElementById('uploadModalTitle');
    if (modalTitle) {
        modalTitle.textContent = type === 'short' ? 'Create Short' : 'Upload Video';
    }

    // Show/hide recording option for shorts
    const recordOption = document.getElementById('recordOption');
    if (recordOption) {
        recordOption.style.display = type === 'short' ? 'block' : 'none';
    }

    // Update upload hint text
    const uploadHint = document.getElementById('uploadHint');
    if (uploadHint) {
        uploadHint.textContent = type === 'short'
            ? 'Vertical video, max 60 seconds'
            : 'MP4, AVI, MOV, etc (max 2GB input, will compress to <100MB)';
    }

    // Create hidden camera input for mobile devices (will be triggered by record button)
    // Uses native camera app which handles orientation and audio correctly
    let mobileCameraInput = document.getElementById('mobileCameraInput');
    if (!mobileCameraInput) {
        mobileCameraInput = document.createElement('input');
        mobileCameraInput.type = 'file';
        mobileCameraInput.id = 'mobileCameraInput';
        mobileCameraInput.accept = 'video/*';
        mobileCameraInput.capture = 'environment';
        mobileCameraInput.style.display = 'none';
        mobileCameraInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];
                // Trigger the video file selection handler
                const videoInput = document.getElementById('videoFile');
                if (videoInput) {
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    videoInput.files = dataTransfer.files;
                    const event = new Event('change', { bubbles: true });
                    videoInput.dispatchEvent(event);
                }
            }
            // Reset for next use
            e.target.value = '';
        });
        document.body.appendChild(mobileCameraInput);
    }

    document.getElementById('uploadModal').classList.add('active');
}

// Back to create modal from upload modal
function backToCreateModal() {
    hideUploadModal();
    showCreateModal();
}

// Back to create modal from go live modal
function backToCreateModalFromLive() {
    hideGoLiveModal();
    showCreateModal();
}

function hideUploadModal() {
    document.getElementById('uploadModal').classList.remove('active');
    document.getElementById('uploadForm').reset();

    // Reset upload state
    resetUploadState();

    // Reset video file upload display
    const fileUpload = document.getElementById('fileUpload');
    if (fileUpload) {
        fileUpload.classList.remove('active');
        fileUpload.style.display = 'flex';
        fileUpload.innerHTML = `
            <svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor" style="opacity: 0.5;">
                <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v-2H5z"/>
            </svg>
            <p>Click to select video or drag and drop</p>
            <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                MP4, AVI, MOV, etc (max 2GB input, will compress to <100MB)
            </p>
        `;
    }

    // Reset thumbnail upload display
    const thumbnailUpload = document.getElementById('thumbnailUpload');
    if (thumbnailUpload) {
        thumbnailUpload.style.display = 'flex';
    }

    // Hide video upload progress and preview
    const videoUploadProgress = document.getElementById('videoUploadProgress');
    if (videoUploadProgress) {
        videoUploadProgress.style.display = 'none';
        document.getElementById('videoProgressFill').style.width = '0%';
        document.getElementById('videoUploadDetails').innerHTML = '';
    }
    const videoServerStatus = document.getElementById('videoServerStatus');
    if (videoServerStatus) {
        videoServerStatus.innerHTML = '';
    }
    // Clean up video preview
    const videoPreview = document.getElementById('videoPreview');
    const videoPlayer = document.getElementById('videoPreviewPlayer');
    if (videoPreview) {
        videoPreview.style.display = 'none';
    }
    if (videoPlayer) {
        videoPlayer.pause();
        if (videoPlayer.src && videoPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(videoPlayer.src);
        }
        videoPlayer.src = '';
    }

    // Hide thumbnail upload progress and preview
    const thumbnailUploadProgress = document.getElementById('thumbnailUploadProgress');
    if (thumbnailUploadProgress) {
        thumbnailUploadProgress.style.display = 'none';
        document.getElementById('thumbnailProgressFill').style.width = '0%';
    }
    const thumbnailServerStatus = document.getElementById('thumbnailServerStatus');
    if (thumbnailServerStatus) {
        thumbnailServerStatus.innerHTML = '';
    }
    // Clean up thumbnail preview
    const thumbnailPreview = document.getElementById('thumbnailPreview');
    const thumbnailImage = document.getElementById('thumbnailPreviewImage');
    if (thumbnailPreview) {
        thumbnailPreview.style.display = 'none';
    }
    if (thumbnailImage && thumbnailImage.src && thumbnailImage.src.startsWith('blob:')) {
        URL.revokeObjectURL(thumbnailImage.src);
        thumbnailImage.src = '';
    }

    // Reset publish button
    const publishBtn = document.getElementById('publishButton');
    const publishText = document.getElementById('publishButtonText');
    if (publishBtn && publishText) {
        publishBtn.disabled = true;
        publishBtn.classList.remove('ready');
        publishText.textContent = t('status.selectVideoAndThumbnail');
    }

    // Reset legacy elements
    document.getElementById('uploadProgress').style.display = 'none';
    const compressionProgress = document.getElementById('compressionProgress');
    if (compressionProgress) {
        compressionProgress.style.display = 'none';
    }
    const serverStatus = document.getElementById('serverStatus');
    if (serverStatus) {
        serverStatus.innerHTML = '';
    }

    // Clear file references
    window.droppedVideoFile = null;
    window.selectedVideoFile = null;

    // Reset recording state
    stopRecordingCleanup();

    // Reset recording UI
    const recordOption = document.getElementById('recordOption');
    if (recordOption) {
        recordOption.style.display = 'none';
    }
    const recordPreviewContainer = document.getElementById('recordPreviewContainer');
    if (recordPreviewContainer) {
        recordPreviewContainer.style.display = 'none';
    }
    const recordVideoBtn = document.getElementById('recordVideoBtn');
    if (recordVideoBtn) {
        recordVideoBtn.classList.remove('recording');
    }
    const recordBtnText = document.getElementById('recordBtnText');
    if (recordBtnText) {
        recordBtnText.textContent = t('button.recordFromCamera');
    }
    const cameraSwitchBtn = document.getElementById('cameraSwitchBtn');
    if (cameraSwitchBtn) {
        cameraSwitchBtn.style.display = 'none';
    }

    // Reset upload type
    currentUploadType = 'video';
}

// ===== Recording Functions for Shorts =====

function stopRecordingCleanup() {
    // Stop any active recording
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
    }
    mediaRecorder = null;
    recordedChunks = [];

    // Stop recording stream
    if (recordingStream) {
        recordingStream.getTracks().forEach(track => track.stop());
        recordingStream = null;
    }

    // Clear timer
    if (recordingTimer) {
        clearInterval(recordingTimer);
        recordingTimer = null;
    }
    recordingSeconds = 0;

    // Clean up rotation resources
    if (window._rotationAnimationId) {
        cancelAnimationFrame(window._rotationAnimationId);
        window._rotationAnimationId = null;
    }
    if (window._rotationVideo) {
        window._rotationVideo.pause();
        window._rotationVideo.srcObject = null;
        window._rotationVideo = null;
    }
    window._rotationCanvas = null;

    // Unlock screen orientation
    if (screen.orientation && screen.orientation.unlock) {
        try {
            screen.orientation.unlock();
        } catch (e) {
            // Ignore unlock errors
        }
    }

    // Reset camera state
    currentFacingMode = 'environment';
    // Note: Don't reset isRecordedFromCamera here - it needs to persist until file is processed
}

async function toggleRecording() {
    const recordBtn = document.getElementById('recordVideoBtn');
    const recordBtnText = document.getElementById('recordBtnText');
    const previewContainer = document.getElementById('recordPreviewContainer');
    const preview = document.getElementById('recordPreview');

    // On mobile devices, use native camera app instead of MediaRecorder
    // This handles orientation and audio correctly across all mobile browsers
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    if (isMobile) {
        // Trigger the hidden camera input to launch native Camera app
        const mobileCameraInput = document.getElementById('mobileCameraInput');
        if (mobileCameraInput) {
            mobileCameraInput.click();
        }
        return;
    }

    if (!mediaRecorder || mediaRecorder.state === 'inactive') {
        // Start recording
        try {
            // Check if mediaDevices API is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert(t('alert.cameraNotSupported'));
                return;
            }

            // Update button to show we're requesting access
            recordBtnText.textContent = t('button.requestingCamera');

            // Request camera and microphone access
            const videoConstraints = {
                facingMode: currentFacingMode,
                width: { ideal: 1080 },
                height: { ideal: 1920 },
                aspectRatio: { ideal: 9 / 16 }
            };

            recordingStream = await navigator.mediaDevices.getUserMedia({
                video: videoConstraints,
                audio: true
            });
            isRecordedFromCamera = true;

            // Always set flag to crop to portrait in post-processing
            // This ensures vertical 9:16 video output regardless of camera orientation
            window.cameraRecordingNeedsCrop = true;

            // Show preview with object-fit:cover to simulate the crop visually
            preview.srcObject = recordingStream;
            preview.style.transform = '';
            preview.style.objectFit = 'cover';
            previewContainer.style.display = 'block';

            // Show camera switch button on mobile
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const switchBtn = document.getElementById('cameraSwitchBtn');
            if (switchBtn && isMobile) {
                switchBtn.style.display = 'flex';
            }

            // Try to lock orientation
            if (isMobile && screen.orientation && screen.orientation.lock) {
                try {
                    await screen.orientation.lock('portrait');
                } catch (lockErr) {
                    console.log('Could not lock orientation:', lockErr.message);
                }
            }

            // Setup media recorder - prefer MP4 since we process to MP4 anyway
            // Keep options simple for iOS Safari compatibility
            let options = { mimeType: 'video/mp4' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm';
            }

            mediaRecorder = new MediaRecorder(recordingStream, options);
            recordedChunks = [];

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    recordedChunks.push(e.data);
                }
            };

            mediaRecorder.onstop = () => {
                if (!isSwitchingCamera) {
                    handleRecordingComplete();
                }
            };

            mediaRecorder.start(1000);

            // Update UI
            recordBtn.classList.add('recording');
            recordBtnText.textContent = t('button.recording');

            // Start timer
            recordingSeconds = 0;
            updateRecordingTimer();
            recordingTimer = setInterval(() => {
                recordingSeconds++;
                updateRecordingTimer();
                if (recordingSeconds >= 60) {
                    stopRecording();
                }
            }, 1000);

        } catch (err) {
            console.error('Error accessing camera:', err);

            // Reset button text
            recordBtnText.textContent = t('button.recordFromCamera');

            // Provide specific error messages based on error type
            if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                alert(t('alert.noCameraFound'));
            } else if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                alert(t('alert.cameraAccessDenied'));
            } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                alert(t('alert.cameraInUse'));
            } else if (err.name === 'OverconstrainedError') {
                // Try again with simpler constraints
                try {
                    recordBtnText.textContent = t('button.requestingCamera');
                    recordingStream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: { echoCancellation: true, noiseSuppression: true }
                    });
                    isRecordedFromCamera = true;
                    window.cameraRecordingNeedsCrop = true;

                    // Verify audio tracks
                    if (recordingStream.getAudioTracks().length === 0) {
                        try {
                            const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            audioStream.getAudioTracks().forEach(track => recordingStream.addTrack(track));
                        } catch (e) {
                            console.warn('Could not add audio track:', e);
                        }
                    }

                    preview.srcObject = recordingStream;
                    preview.style.transform = '';
                    preview.style.objectFit = 'cover';
                    previewContainer.style.display = 'block';

                    // Prefer MP4 since we process to MP4 anyway
                    let options = { mimeType: 'video/mp4' };
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm';
                    }
                    if (recordingStream.getAudioTracks().length > 0) {
                        options.audioBitsPerSecond = 128000;
                    }
                    mediaRecorder = new MediaRecorder(recordingStream, options);
                    recordedChunks = [];
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) recordedChunks.push(e.data);
                    };
                    mediaRecorder.onstop = () => {
                        if (!isSwitchingCamera) {
                            handleRecordingComplete();
                        }
                    };
                    mediaRecorder.start(1000);
                    recordBtn.classList.add('recording');
                    recordBtnText.textContent = t('button.recording');
                    recordingSeconds = 0;
                    updateRecordingTimer();
                    recordingTimer = setInterval(() => {
                        recordingSeconds++;
                        updateRecordingTimer();
                        if (recordingSeconds >= 60) stopRecording();
                    }, 1000);

                    // Show camera switch button on mobile
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    const switchBtn = document.getElementById('cameraSwitchBtn');
                    if (switchBtn && isMobile) {
                        switchBtn.style.display = 'flex';
                    }
                } catch (retryErr) {
                    recordBtnText.textContent = t('button.recordFromCamera');
                    alert(t('alert.cameraUnableAccess'));
                }
            } else {
                alert(t('alert.cameraUnableAccessWithError').replace('{error}', err.message));
            }
        }
    }
}

function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
    }

    // Stop timer
    if (recordingTimer) {
        clearInterval(recordingTimer);
        recordingTimer = null;
    }

    // Update UI
    const recordBtn = document.getElementById('recordVideoBtn');
    const recordBtnText = document.getElementById('recordBtnText');
    if (recordBtn) recordBtn.classList.remove('recording');
    if (recordBtnText) recordBtnText.textContent = t('button.recordFromCamera');

    // Hide camera switch button
    const switchBtn = document.getElementById('cameraSwitchBtn');
    if (switchBtn) switchBtn.style.display = 'none';

    // Reset preview transform
    const preview = document.getElementById('recordPreview');
    if (preview) {
        preview.style.transform = '';
    }
}

async function switchCamera() {
    // Toggle facing mode
    currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';

    const preview = document.getElementById('recordPreview');
    const wasRecording = mediaRecorder && mediaRecorder.state === 'recording';

    // Set flag to prevent handleRecordingComplete from triggering
    isSwitchingCamera = true;

    // Stop current stream
    if (recordingStream) {
        recordingStream.getTracks().forEach(track => track.stop());
    }

    // If we were recording, stop the MediaRecorder (this preserves chunks via ondataavailable)
    if (wasRecording && mediaRecorder) {
        mediaRecorder.stop();
    }

    try {
        // Request new stream with updated facing mode
        const videoConstraints = {
            facingMode: currentFacingMode,
            width: { ideal: 1080 },
            height: { ideal: 1920 },
            aspectRatio: { ideal: 9 / 16 }
        };

        recordingStream = await navigator.mediaDevices.getUserMedia({
            video: videoConstraints,
            audio: true
        });

        // Update preview with object-fit:cover to simulate crop
        if (preview) {
            preview.srcObject = recordingStream;
            preview.style.transform = '';
            preview.style.objectFit = 'cover';
        }

        // If we were recording, restart the MediaRecorder with the new stream
        if (wasRecording) {
            let options = { mimeType: 'video/mp4' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm';
            }

            mediaRecorder = new MediaRecorder(recordingStream, options);
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    recordedChunks.push(e.data);
                }
            };
            mediaRecorder.onstop = () => {
                if (!isSwitchingCamera) {
                    handleRecordingComplete();
                }
            };
            mediaRecorder.start(1000);
        }

        isSwitchingCamera = false;
    } catch (err) {
        console.error('Error switching camera:', err);
        isSwitchingCamera = false;
        // Revert facing mode on error
        currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
        showToast('Unable to switch camera', 'error');
    }
}

function updateRecordingTimer() {
    const timerEl = document.getElementById('recordTimer');
    if (timerEl) {
        const mins = Math.floor(recordingSeconds / 60);
        const secs = recordingSeconds % 60;
        timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        timerEl.classList.toggle('recording', recordingSeconds > 0);
    }
}

function handleRecordingComplete() {
    // Stop stream
    if (recordingStream) {
        recordingStream.getTracks().forEach(track => track.stop());
        recordingStream = null;
    }

    // Hide preview
    const previewContainer = document.getElementById('recordPreviewContainer');
    const preview = document.getElementById('recordPreview');
    if (previewContainer) previewContainer.style.display = 'none';
    if (preview) preview.srcObject = null;

    // Create video file from recorded chunks
    if (recordedChunks.length > 0) {
        const mimeType = recordedChunks[0].type || 'video/webm';
        const blob = new Blob(recordedChunks, { type: mimeType });
        const extension = mimeType.includes('mp4') ? 'mp4' : 'webm';
        const file = new File([blob], `short_${Date.now()}.${extension}`, { type: blob.type });

        // Trigger the video file selection handler
        const videoInput = document.getElementById('videoFile');
        if (videoInput) {
            // Create a DataTransfer to simulate file selection
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            videoInput.files = dataTransfer.files;

            // Trigger change event
            const event = new Event('change', { bubbles: true });
            videoInput.dispatchEvent(event);
        }
    }

    // Reset recording state
    recordedChunks = [];
    mediaRecorder = null;
}

// Update publish button state based on upload status
function updatePublishButton() {
    const publishBtn = document.getElementById('publishButton');
    const publishText = document.getElementById('publishButtonText');
    if (!publishBtn || !publishText) return;

    const videoReady = uploadState.video.status === 'complete';
    const thumbnailReady = uploadState.thumbnail.status === 'complete';
    const videoProcessing = ['compressing', 'uploading'].includes(uploadState.video.status);
    const thumbnailProcessing = uploadState.thumbnail.status === 'uploading';

    // Video is required, thumbnail is optional (will be auto-generated if not provided)
    if (videoReady && !thumbnailProcessing) {
        publishBtn.disabled = false;
        publishBtn.classList.add('ready');
        publishText.textContent = thumbnailReady ? 'Publish Video' : 'Publish Video (auto-thumbnail)';
    } else if (videoProcessing || thumbnailProcessing) {
        publishBtn.disabled = true;
        publishBtn.classList.remove('ready');
        if (videoProcessing && thumbnailProcessing) {
            publishText.textContent = t('status.processingVideoAndThumbnail');
        } else if (videoProcessing) {
            publishText.textContent = uploadState.video.status === 'compressing' ? t('status.compressingVideo') : t('status.uploadingVideo');
        } else {
            publishText.textContent = t('status.uploadingThumbnail');
        }
    } else if (uploadState.video.status === 'error' || uploadState.thumbnail.status === 'error') {
        publishBtn.disabled = true;
        publishBtn.classList.remove('ready');
        publishText.textContent = t('status.uploadFailed');
    } else {
        publishBtn.disabled = true;
        publishBtn.classList.remove('ready');
        if (!uploadState.video.file) {
            publishText.textContent = t('status.selectVideoToUpload');
        } else {
            publishText.textContent = t('status.waitingForVideoUpload');
        }
    }
}

// Update video upload UI
function updateVideoUploadUI(status, progress, details = '') {
    const progressDiv = document.getElementById('videoUploadProgress');
    const statusSpan = document.getElementById('videoUploadStatus');
    const progressFill = document.getElementById('videoProgressFill');
    const detailsDiv = document.getElementById('videoUploadDetails');

    if (!progressDiv) return;

    progressDiv.style.display = 'block';
    progressFill.style.width = `${progress}%`;

    statusSpan.className = 'upload-item-status';
    switch (status) {
        case 'compressing':
            statusSpan.textContent = `Compressing... ${progress}%`;
            statusSpan.classList.add('processing');
            break;
        case 'uploading':
            statusSpan.textContent = `Uploading... ${progress}%`;
            statusSpan.classList.add('processing');
            break;
        case 'complete':
            statusSpan.textContent = t('status.ready');
            statusSpan.classList.add('success');
            progressFill.style.width = '100%';
            break;
        case 'error':
            statusSpan.textContent = t('status.failed');
            statusSpan.classList.add('error');
            break;
        default:
            statusSpan.textContent = status;
    }

    if (details) {
        detailsDiv.innerHTML = details;
    }

    updatePublishButton();
}

// Update thumbnail upload UI
function updateThumbnailUploadUI(status, progress) {
    const progressDiv = document.getElementById('thumbnailUploadProgress');
    const statusSpan = document.getElementById('thumbnailUploadStatus');
    const progressFill = document.getElementById('thumbnailProgressFill');

    if (!progressDiv) return;

    progressDiv.style.display = 'block';
    progressFill.style.width = `${progress}%`;

    statusSpan.className = 'upload-item-status';
    switch (status) {
        case 'uploading':
            statusSpan.textContent = `Uploading... ${progress}%`;
            statusSpan.classList.add('processing');
            break;
        case 'complete':
            statusSpan.textContent = t('status.ready');
            statusSpan.classList.add('success');
            progressFill.style.width = '100%';
            break;
        case 'error':
            statusSpan.textContent = t('status.failed');
            statusSpan.classList.add('error');
            break;
        default:
            statusSpan.textContent = status;
    }

    updatePublishButton();
}

// Process and upload video immediately
async function processAndUploadVideo(file) {
    const maxFinalSize = 100 * 1024 * 1024; // 100MB
    const fileSizeMB = file.size / (1024 * 1024);

    uploadState.video.file = file;
    uploadState.video.status = 'pending';
    uploadState.video.size = file.size;

    // Get video metadata
    try {
        const metadata = await VideoCompressor.getVideoMetadata(file);
        uploadState.video.duration = metadata.duration;
        uploadState.video.dimensions = { width: metadata.width, height: metadata.height };

        const detailsHtml = `${metadata.width}x${metadata.height} • ${formatDuration(Math.floor(metadata.duration))} • ${fileSizeMB.toFixed(1)}MB`;
        updateVideoUploadUI('Preparing...', 0, detailsHtml);
    } catch (e) {
        console.log('Could not read video metadata:', e);
        updateVideoUploadUI('Preparing...', 0, `${fileSizeMB.toFixed(1)}MB`);
    }

    let fileToUpload = file;

    // Check if file needs transcoding (WebM from camera recording needs to be converted to MP4)
    const isWebM = file.type === 'video/webm' || file.name.endsWith('.webm');
    const needsTranscode = isWebM && file.size <= maxFinalSize;
    const needsCompression = file.size > maxFinalSize;

    // Check if camera recording needs cropping to portrait (9:16)
    // iOS Safari doesn't support video.captureStream() so cropping would lose audio
    // Skip cropping on iOS Safari to preserve audio
    const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) &&
        !window.MSStream &&
        /Safari/.test(navigator.userAgent);
    const needsCrop = (window.cameraRecordingNeedsCrop || false) && !isIOSSafari;

    if (isIOSSafari && window.cameraRecordingNeedsCrop) {
        console.log('iOS Safari detected - skipping crop to preserve audio');
    }

    // Compress, transcode, or crop if needed
    if (needsCompression || needsTranscode || needsCrop) {
        uploadState.video.status = 'compressing';

        // Check iOS compatibility before starting compression
        const iosCheck = VideoCompressor.checkiOSCompatibility();
        let warningText = '';
        if (!iosCheck.supported) {
            warningText = '<br><span style="color: var(--warning-color);">Note: Your browser will output WebM format (may not play on iOS). For iOS-compatible MP4, use Chrome on Windows/Mac.</span>';
            console.warn('iOS-compatible encoding not supported in this browser');
        }

        let actionText;
        if (needsCrop && !needsTranscode && !needsCompression) {
            actionText = 'Cropping to portrait';
        } else if (needsTranscode) {
            actionText = 'Converting to MP4';
            if (needsCrop) actionText += ' and cropping to portrait';
        } else {
            actionText = `Compressing ${fileSizeMB.toFixed(1)}MB to <100MB`;
            if (needsCrop) actionText += ' (cropping to portrait)';
        }
        updateVideoUploadUI('compressing', 5, `${actionText}...${warningText}`);

        // Always use high quality
        window.suggestedCompressionQuality = 'high';
        window.userSelectedQuality = 'high';

        console.log(`Processing video: isWebM=${isWebM}, needsTranscode=${needsTranscode}, needsCompression=${needsCompression}, needsCrop=${needsCrop}`);
        if (needsCrop) {
            console.log('Camera recording needs cropping to 9:16 portrait');
        }

        try {
            fileToUpload = await VideoCompressor.compressVideo(file, {
                maxSizeMB: 100,
                cropToPortrait: needsCrop,
                onProgress: (info) => {
                    let progress = 5;
                    let details = '';

                    switch (info.stage) {
                        case 'analyzing':
                            progress = 5;
                            details = 'Analyzing video content...';
                            break;
                        case 'calibrating':
                            progress = 10;
                            details = 'Calibrating encoder settings...';
                            break;
                        case 'preparing':
                            progress = 15;
                            details = needsTranscode
                                ? 'Preparing MP4 conversion...'
                                : `Preparing compression (${info.quality} quality)...`;
                            break;
                        case 'compressing':
                            progress = info.progress || 20;
                            details = `${info.currentTime || 0}s / ${info.duration || '?'}s`;
                            if (info.currentSize) {
                                details += ` • Current: ${info.currentSize}MB`;
                            }
                            break;
                        case 'retrying':
                            details = info.message || 'Adjusting settings...';
                            break;
                        case 'complete':
                            progress = 100;
                            if (needsTranscode) {
                                details = `Converted to MP4: ${(info.compressedSize / 1024 / 1024).toFixed(1)}MB`;
                            } else {
                                const savedPct = ((1 - info.compressionRatio) * 100).toFixed(0);
                                details = `Compressed: ${(info.compressedSize / 1024 / 1024).toFixed(1)}MB (${savedPct}% smaller)`;
                            }
                            break;
                    }

                    updateVideoUploadUI('compressing', Math.min(progress, 95), details);
                }
            });

            const compressedSizeMB = fileToUpload.size / (1024 * 1024);
            if (compressedSizeMB > 100) {
                throw new Error(`Compression failed: ${compressedSizeMB.toFixed(1)}MB exceeds 100MB limit`);
            }

            uploadState.video.size = fileToUpload.size;
            uploadState.video.type = fileToUpload.type;
        } catch (error) {
            console.error('Compression failed:', error);
            uploadState.video.status = 'error';
            uploadState.video.error = error.message;
            updateVideoUploadUI('error', 0, `Compression failed: ${error.message}`);
            return;
        }
    }

    // Upload the file
    uploadState.video.status = 'uploading';
    updateVideoUploadUI('uploading', 0, 'Uploading to blossom servers...');

    try {
        const result = await uploadToBlossom(
            fileToUpload,
            BLOSSOM_SERVERS,
            'videoServerStatus',
            (progress, completed, total) => {
                updateVideoUploadUI('uploading', progress, `Uploading to blossom servers... (${completed}/${total})`);
            }
        );

        if (result.success && result.url) {
            uploadState.video.status = 'complete';
            uploadState.video.url = result.url;
            uploadState.video.hash = result.hash;
            uploadState.video.mirrors = result.mirrors || []; // Store all successful upload URLs
            uploadedVideoHash = result.hash;

            const finalSizeMB = (fileToUpload.size / 1024 / 1024).toFixed(1);
            const mirrorCount = result.mirrors?.length || 1;
            updateVideoUploadUI('complete', 100, `${finalSizeMB}MB • ${mirrorCount} server${mirrorCount > 1 ? 's' : ''} • Ready to publish`);

            // Show video preview
            showVideoPreview(fileToUpload);
        } else {
            throw new Error(result.error || 'Upload failed');
        }
    } catch (error) {
        console.error('Upload failed:', error);
        uploadState.video.status = 'error';
        uploadState.video.error = error.message;
        updateVideoUploadUI('error', 0, `Upload failed: ${error.message}`);
    }
}

// Show video preview after successful upload
function showVideoPreview(file) {
    const previewDiv = document.getElementById('videoPreview');
    const videoPlayer = document.getElementById('videoPreviewPlayer');

    if (previewDiv && videoPlayer) {
        // Revoke any existing URL
        if (videoPlayer.src && videoPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(videoPlayer.src);
        }

        // Create new preview URL
        const previewUrl = URL.createObjectURL(file);
        videoPlayer.src = previewUrl;
        previewDiv.style.display = 'block';

        // Store for cleanup
        uploadState.video.previewUrl = previewUrl;
    }
}

// Delete video upload and reset
function deleteVideoUpload() {
    // Revoke preview URL
    const videoPlayer = document.getElementById('videoPreviewPlayer');
    if (videoPlayer && videoPlayer.src) {
        videoPlayer.pause();
        if (videoPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(videoPlayer.src);
        }
        videoPlayer.src = '';
    }

    // Hide preview
    const previewDiv = document.getElementById('videoPreview');
    if (previewDiv) {
        previewDiv.style.display = 'none';
    }

    // Reset upload state for video
    uploadState.video = {
        file: null,
        status: 'pending',
        progress: 0,
        url: null,
        hash: null,
        error: null,
        size: 0,
        type: null,
        duration: null,
        dimensions: null,
        previewUrl: null,
        mirrors: []
    };
    uploadedVideoHash = null;

    // Reset UI elements
    const fileUpload = document.getElementById('fileUpload');
    if (fileUpload) {
        fileUpload.style.display = 'flex';
    }

    const videoUploadProgress = document.getElementById('videoUploadProgress');
    if (videoUploadProgress) {
        videoUploadProgress.style.display = 'none';
    }

    document.getElementById('videoProgressFill').style.width = '0%';
    document.getElementById('videoUploadDetails').innerHTML = '';
    document.getElementById('videoServerStatus').innerHTML = '';

    // Reset file input
    document.getElementById('videoFile').value = '';
    window.selectedVideoFile = null;

    // Reset recording UI to allow re-recording (for shorts)
    if (currentUploadType === 'short') {
        const recordOption = document.getElementById('recordOption');
        if (recordOption) {
            recordOption.style.display = 'block';
        }
        const recordPreviewContainer = document.getElementById('recordPreviewContainer');
        if (recordPreviewContainer) {
            recordPreviewContainer.style.display = 'none';
        }
        const recordVideoBtn = document.getElementById('recordVideoBtn');
        if (recordVideoBtn) {
            recordVideoBtn.classList.remove('recording');
        }
        const recordBtnText = document.getElementById('recordBtnText');
        if (recordBtnText) {
            recordBtnText.textContent = t('button.recordFromCamera');
        }
        const cameraSwitchBtn = document.getElementById('cameraSwitchBtn');
        if (cameraSwitchBtn) {
            cameraSwitchBtn.style.display = 'none';
        }
        // Reset camera recording state
        isRecordedFromCamera = false;
        currentFacingMode = 'environment';
        window.cameraRecordingNeedsCrop = false;
    }

    // Update publish button
    updatePublishButton();
}

// Upload thumbnail immediately
async function uploadThumbnail(file) {
    uploadState.thumbnail.file = file;
    uploadState.thumbnail.status = 'uploading';

    updateThumbnailUploadUI('uploading', 10);

    try {
        // Validate thumbnail orientation matches video type if video has been uploaded
        if (uploadState.video.status === 'complete' && uploadState.video.dimensions) {
            const thumbnailDimensions = await getImageDimensions(file);
            const videoIsShort = isVideoShort(
                uploadState.video.dimensions.width,
                uploadState.video.dimensions.height,
                uploadState.video.duration
            );

            if (!isThumbnailOrientationValid(thumbnailDimensions.width, thumbnailDimensions.height, videoIsShort)) {
                uploadState.thumbnail.status = 'error';
                uploadState.thumbnail.error = 'Thumbnail orientation mismatch';
                updateThumbnailUploadUI('error', 0);

                if (videoIsShort) {
                    showToast('Thumbnail must be vertical (portrait) to match your Short video', 'error');
                } else {
                    showToast('Thumbnail must be horizontal (landscape) to match your video', 'error');
                }
                return;
            }
        }

        const result = await uploadToBlossom(
            file,
            BLOSSOM_SERVERS,
            'thumbnailServerStatus',
            (progress, completed, total) => {
                updateThumbnailUploadUI('uploading', progress);
                const statusSpan = document.getElementById('thumbnailUploadStatus');
                if (statusSpan) {
                    statusSpan.textContent = `Uploading... (${completed}/${total} servers)`;
                }
            }
        );

        if (result.success && result.url) {
            uploadState.thumbnail.status = 'complete';
            uploadState.thumbnail.url = result.url;
            updateThumbnailUploadUI('complete', 100);

            // Show thumbnail preview
            showThumbnailPreview(file);
        } else {
            throw new Error(result.error || 'Upload failed');
        }
    } catch (error) {
        console.error('Thumbnail upload failed:', error);
        uploadState.thumbnail.status = 'error';
        uploadState.thumbnail.error = error.message;
        updateThumbnailUploadUI('error', 0);
    }
}

// Show thumbnail preview after successful upload
function showThumbnailPreview(file) {
    const previewDiv = document.getElementById('thumbnailPreview');
    const previewImage = document.getElementById('thumbnailPreviewImage');

    if (previewDiv && previewImage) {
        // Revoke any existing URL
        if (previewImage.src && previewImage.src.startsWith('blob:')) {
            URL.revokeObjectURL(previewImage.src);
        }

        // Create new preview URL
        const previewUrl = URL.createObjectURL(file);
        previewImage.src = previewUrl;
        previewDiv.style.display = 'block';

        // Store for cleanup
        uploadState.thumbnail.previewUrl = previewUrl;
    }
}

// Delete thumbnail upload and reset
function deleteThumbnailUpload() {
    // Revoke preview URL
    const previewImage = document.getElementById('thumbnailPreviewImage');
    if (previewImage && previewImage.src && previewImage.src.startsWith('blob:')) {
        URL.revokeObjectURL(previewImage.src);
        previewImage.src = '';
    }

    // Hide preview
    const previewDiv = document.getElementById('thumbnailPreview');
    if (previewDiv) {
        previewDiv.style.display = 'none';
    }

    // Reset upload state for thumbnail
    uploadState.thumbnail = {
        file: null,
        status: 'pending',
        progress: 0,
        url: null,
        error: null,
        previewUrl: null
    };

    // Reset UI elements
    const thumbnailUpload = document.getElementById('thumbnailUpload');
    if (thumbnailUpload) {
        thumbnailUpload.style.display = 'flex';
    }

    const thumbnailUploadProgress = document.getElementById('thumbnailUploadProgress');
    if (thumbnailUploadProgress) {
        thumbnailUploadProgress.style.display = 'none';
    }

    document.getElementById('thumbnailProgressFill').style.width = '0%';
    document.getElementById('thumbnailServerStatus').innerHTML = '';

    // Reset file input
    document.getElementById('thumbnailFile').value = '';

    // Update publish button
    updatePublishButton();
}

// Reset upload state
function resetUploadState() {
    uploadState.video = {
        file: null,
        status: 'pending',
        progress: 0,
        url: null,
        hash: null,
        error: null,
        size: 0,
        type: null,
        duration: null,
        dimensions: null,
        mirrors: []
    };
    uploadState.thumbnail = {
        file: null,
        status: 'pending',
        progress: 0,
        url: null,
        error: null
    };
    uploadState.preview = {
        file: null,
        status: 'pending',
        progress: 0,
        url: null,
        error: null
    };
    uploadState.draftId = null;
    uploadedVideoHash = null;
    window.userSelectedQuality = null;
    window.suggestedCompressionQuality = null;

    // Reset camera recording state
    isRecordedFromCamera = false;
    currentFacingMode = 'environment';
    window.cameraRecordingNeedsCrop = false;
}

// Handle file selection - now starts upload immediately
async function handleFileSelect(event) {
    const input = event.target;
    const file = input.files[0];
    if (!file) return;

    // Allow up to 2GB input files (they will be compressed)
    const maxInputSize = 2 * 1024 * 1024 * 1024; // 2GB

    if (file.size > maxInputSize) {
        showToast(`File size must be less than 2GB. Your file is ${(file.size / 1024 / 1024).toFixed(1)}MB.`, 'error', 5000);
        input.value = '';
        return;
    }

    if (input.id === 'videoFile') {
        const allowedVideoTypes = [
            'video/mp4',
            'video/webm',
            'video/mov',
            'video/avi',
            'video/mkv',
            'video/wmv',
            'video/quicktime'
        ];

        const fileType = file.type || 'video/' + file.name.split('.').pop().toLowerCase();

        if (!allowedVideoTypes.some(type => fileType.includes(type.split('/')[1]))) {
            showToast('Invalid video file type. Please upload a video file (mp4, webm, mov, avi, mkv, wmv)', 'error');
            input.value = '';
            return;
        }

        // If uploading via Create Short modal, validate that video is vertical
        // Skip validation for camera-recorded videos (mobile browsers often report wrong dimensions due to sensor orientation)
        if (currentUploadType === 'short' && !isRecordedFromCamera) {
            const isVertical = await validateVideoIsVertical(file);
            if (!isVertical) {
                showToast('This video appears to be horizontal (landscape). Shorts must be vertical (portrait) videos. Please use "Upload Video" for horizontal videos.', 'error', 7000);
                input.value = '';
                return;
            }
        }

        // Reset the camera recording flag after validation
        isRecordedFromCamera = false;

        // Hide the file upload drop zone, show progress
        const fileUpload = document.getElementById('fileUpload');
        fileUpload.style.display = 'none';

        // Update filename in progress UI
        document.getElementById('videoFileName').textContent = file.name;
        document.getElementById('videoUploadProgress').style.display = 'block';

        // Store reference
        window.selectedVideoFile = file;

        // Start processing and upload immediately (don't await - let it run in background)
        processAndUploadVideo(file);

    } else if (input.id === 'thumbnailFile') {
        const allowedImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!allowedImageTypes.includes(file.type)) {
            showToast('Invalid thumbnail file type. Please upload an image file (jpg, png, gif, webp)', 'error');
            input.value = '';
            return;
        }

        // Hide the thumbnail drop zone, show progress
        const thumbnailUpload = document.getElementById('thumbnailUpload');
        thumbnailUpload.style.display = 'none';

        // Update filename in progress UI
        document.getElementById('thumbnailFileName').textContent = file.name;
        document.getElementById('thumbnailUploadProgress').style.display = 'block';

        // Start upload immediately
        uploadThumbnail(file);
    }
}

// Calculate SHA-256 hash
async function calculateSHA256(file) {
    const buffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
}

// Create Blossom authorization event
async function createBlossomAuthEvent(hash, server) {
    const expiration = Math.floor(Date.now() / 1000) + 60;
    const authEvent = {
        kind: 24242,
        content: `Upload ${hash}`,
        tags: [
            ['t', 'upload'],
            ['x', hash],
            ['expiration', expiration.toString()],
            ['client', 'Plebs']
        ],
        created_at: Math.floor(Date.now() / 1000)
    };

    const signedEvent = await signEvent(authEvent);
    return signedEvent;
}

// Upload to Blossom with proper authentication
async function uploadToBlossom(file, servers = BLOSSOM_SERVERS, statusElementId = 'serverStatus', onProgress = null) {
    const hash = await calculateSHA256(file);
    const successfulUploads = [];
    let primaryUrl = null;
    const totalServers = servers.length;

    const serverStatusDiv = document.getElementById(statusElementId) || document.getElementById('serverStatus');
    if (serverStatusDiv) {
        serverStatusDiv.innerHTML = '';
    }

    // Report initial progress (hash calculation complete)
    if (onProgress) {
        onProgress(10, 0, totalServers);
    }

    for (let i = 0; i < servers.length; i++) {
        const server = servers[i];
        try {
            const authEvent = await createBlossomAuthEvent(hash, server);
            const authHeader = btoa(JSON.stringify(authEvent));

            const response = await fetch(`${server}/upload`, {
                method: 'PUT',
                body: file,
                headers: {
                    'Content-Type': file.type,
                    'Authorization': `Nostr ${authHeader}`
                }
            });

            if (response.ok) {
                const result = await response.json();
                const url = result.url || `${server}/${hash}`;
                successfulUploads.push({ server, url });

                if (!primaryUrl) {
                    primaryUrl = url;
                }

                console.log(`Successfully uploaded to ${server}`);

                // Create a status element for the current server
                if (serverStatusDiv) {
                    const serverStatus = document.createElement('div');
                    serverStatus.classList.add('server');
                    serverStatus.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z" />
                        </svg>
                        ${server.replace('https://', '')}
                    `;
                    serverStatusDiv.appendChild(serverStatus);
                }
            } else {
                console.error(`Upload to ${server} failed with status ${response.status}`);

                // Create a status element for the current server with failure status
                if (serverStatusDiv) {
                    const serverStatus = document.createElement('div');
                    serverStatus.classList.add('server', 'failure');
                    serverStatus.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
                        </svg>
                        ${server.replace('https://', '')}
                    `;
                    serverStatusDiv.appendChild(serverStatus);
                }
            }
        } catch (error) {
            console.error(`Failed to upload to ${server}:`, error);

            // Create a status element for the current server with failure status
            if (serverStatusDiv) {
                const serverStatus = document.createElement('div');
                serverStatus.classList.add('server', 'failure');
                serverStatus.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
                    </svg>
                    ${server.replace('https://', '')}
                `;
                serverStatusDiv.appendChild(serverStatus);
            }
        }

        // Report progress after each server attempt
        if (onProgress) {
            const completedServers = i + 1;
            // Progress goes from 10% to 100% as servers complete
            const progress = 10 + Math.round((completedServers / totalServers) * 90);
            onProgress(progress, completedServers, totalServers);
        }
    }

    if (successfulUploads.length > 0) {
        return {
            success: true,
            hash: hash,
            url: primaryUrl,
            server: successfulUploads[0].server,
            mirrors: successfulUploads
        };
    }

    return { success: false, error: 'Failed to upload to all servers' };
}

// Show ratioed modal
function showRatioedModal(eventId, type = 'video') {
    pendingRatioedAction = { eventId, type };
    document.getElementById('ratioedModal').classList.add('active');
}

// Proceed with ratioed video
function proceedRatioed() {
    if (pendingRatioedAction) {
        const { eventId, type } = pendingRatioedAction;
        const rememberChoice = document.getElementById('rememberCommunityWarning').checked;

        if (rememberChoice) {
            localStorage.setItem('allowCommunityWarning', 'true');
        }

        sessionRatioedAllowed.add(eventId);
        document.getElementById('ratioedModal').classList.remove('active');
        pendingRatioedAction = null;

        if (type === 'live') {
            // Handle live stream
            const needsHashChange = !window.location.hash.includes(`/live/${eventId}`);

            if (needsHashChange) {
                window.location.hash = `/live/${eventId}`;
            } else {
                document.getElementById('mainContent').innerHTML = '<div class="spinner"></div>';
                setTimeout(() => {
                    playLiveStream(eventId, false, true);
                }, 10);
            }
        } else {
            // Handle video (default)
            const needsHashChange = !window.location.hash.includes(`/video/${eventId}`);

            if (needsHashChange) {
                window.location.hash = `/video/${eventId}`;
            } else {
                document.getElementById('mainContent').innerHTML = '<div class="spinner"></div>';
                setTimeout(() => {
                    playVideo(eventId, false, true);
                }, 10);
            }
        }
    }
}

// Cancel ratioed
function cancelRatioed() {
    document.getElementById('ratioedModal').classList.remove('active');
    pendingRatioedAction = null;
    document.getElementById('rememberCommunityWarning').checked = false;
    if (window.location.hash.startsWith('#/video/') || window.location.hash.startsWith('#/live/')) {
        navigateTo('/');
    }
}

// Show NSFW modal
function showNSFWModal(action, eventId) {
    pendingNSFWAction = { action, eventId };
    document.getElementById('nsfwModal').classList.add('active');
}

// Confirm NSFW
async function confirmNSFW() {
    const rememberChoice = document.getElementById('rememberNSFW').checked;

    if (rememberChoice) {
        localStorage.setItem('allowNSFW', 'true');
    }

    sessionNSFWAllowed = true;

    document.getElementById('nsfwModal').classList.remove('active');

    if (pendingNSFWAction && pendingNSFWAction.action === 'playVideo') {
        const eventId = pendingNSFWAction.eventId;
        pendingNSFWAction = null;

        // Check if we need to change the URL (hashchange will trigger playVideo via handleRoute)
        const needsHashChange = !window.location.hash.includes(`/video/${eventId}`);

        if (needsHashChange) {
            // Setting hash triggers hashchange -> handleRoute -> playVideo
            // No need to call playVideo again
            window.location.hash = `/video/${eventId}`;
        } else {
            // Already on this video page, call playVideo directly
            document.getElementById('mainContent').innerHTML = '<div class="spinner"></div>';
            setTimeout(() => {
                playVideo(eventId, true, false);
            }, 10);
        }
    } else if (pendingNSFWAction && pendingNSFWAction.action === 'playLive') {
        const eventId = pendingNSFWAction.eventId;
        pendingNSFWAction = null;

        // Check if we need to change the URL (hashchange will trigger playLiveStream via handleRoute)
        const needsHashChange = !window.location.hash.includes(`/live/${eventId}`);

        if (needsHashChange) {
            window.location.hash = `/live/${eventId}`;
        } else {
            // Already on this live page, call playLiveStream directly
            document.getElementById('mainContent').innerHTML = '<div class="spinner"></div>';
            setTimeout(() => {
                playLiveStream(eventId, true, false);
            }, 10);
        }
    }
}

// Cancel NSFW
function cancelNSFW() {
    document.getElementById('nsfwModal').classList.remove('active');
    pendingNSFWAction = null;
    document.getElementById('rememberNSFW').checked = false;
    if (window.location.hash.startsWith('#/video/') || window.location.hash.startsWith('#/live/')) {
        navigateTo('/');
    }
}

// NIP-56 Report functions
let pendingReport = null;

// Show report modal
// reportType: 'video' (default), 'comment', 'user'
function showReportModal(eventId, pubkey, reportType = 'video') {
    if (!currentUser) {
        showToast('Please log in to report content', 'error');
        return;
    }

    pendingReport = { eventId, pubkey };

    // Update modal title and description based on report type
    const titleEl = document.getElementById('reportModalTitle');
    const descEl = document.getElementById('reportModalDescription');
    if (titleEl && descEl) {
        switch (reportType) {
            case 'comment':
                titleEl.textContent = t('report.titleComment');
                descEl.textContent = t('report.descComment');
                break;
            case 'user':
                titleEl.textContent = t('report.titleUser');
                descEl.textContent = t('report.descUser');
                break;
            default:
                titleEl.textContent = t('report.titleVideo');
                descEl.textContent = t('report.descVideo');
        }
    }

    // Reset form
    const radioButtons = document.querySelectorAll('input[name="reportType"]');
    radioButtons.forEach(rb => rb.checked = false);
    document.getElementById('reportReason').value = '';

    document.getElementById('reportModal').classList.add('active');
}

// Cancel report
function cancelReport() {
    document.getElementById('reportModal').classList.remove('active');
    pendingReport = null;
}

// Submit report (NIP-56 kind 1984)
async function submitReport() {
    if (!pendingReport || !currentUser) {
        showToast('Unable to submit report', 'error');
        return;
    }

    const selectedType = document.querySelector('input[name="reportType"]:checked');
    if (!selectedType) {
        showToast('Please select a report reason', 'error');
        return;
    }

    const reportType = selectedType.value;
    const additionalReason = document.getElementById('reportReason').value.trim();

    const submitBtn = document.getElementById('submitReportBtn');
    submitBtn.disabled = true;
    submitBtn.textContent = t('button.submitting');

    try {
        // Build NIP-56 kind 1984 event
        const tags = [];

        // Only add event tag if we're reporting a specific event (not just a user)
        if (pendingReport.eventId) {
            tags.push(['e', pendingReport.eventId, reportType]);
        }

        // Always report the pubkey
        tags.push(['p', pendingReport.pubkey, reportType]);

        // Add L and l tags for NIP-32 label
        tags.push(['L', 'NIP-56']);
        tags.push(['l', reportType, 'NIP-56']);

        const content = additionalReason || `Reported for: ${reportType}`;

        const event = {
            kind: 1984,
            created_at: Math.floor(Date.now() / 1000),
            tags: tags,
            content: content
        };

        // Sign the event
        const signedEvent = await signEvent(event);
        if (!signedEvent) {
            throw new Error('Failed to sign event');
        }

        // Publish to relays using the existing publishEvent function
        const published = await publishEvent(signedEvent);

        if (published) {
            showToast('Report submitted successfully', 'success');
            cancelReport();
        } else {
            throw new Error('Failed to publish to any relay');
        }

    } catch (error) {
        console.error('Failed to submit report:', error);
        showToast('Failed to submit report: ' + error.message, 'error');
    } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = t('report.submit');
    }
}

// Parse video event
function parseVideoEvent(event) {
    if (event.kind !== 1) {
        return null;
    }

    const tags = event.tags || [];

    if (!tags.some(tag => tag[0] === 't' && tag[1] === 'pv69420')) {
        return null;
    }

    const videoData = {
        title: '',
        description: event.content || '',
        hash: '',
        url: '',
        thumbnail: '',
        duration: 0,
        tags: [],
        author: event.pubkey
    };

    for (const tag of tags) {
        switch (tag[0]) {
            case 'title':
                videoData.title = tag[1];
                break;
            case 'x':
                videoData.hash = tag[1];
                break;
            case 'url':
                videoData.url = tag[1];
                break;
            case 'thumb':
                videoData.thumbnail = tag[1];
                break;
            case 'duration':
                videoData.duration = parseInt(tag[1]);
                break;
            case 't':
                if (tag[1] && tag[1] !== 'pv69420') {
                    videoData.tags.push(tag[1]);
                }
                break;
        }
    }

    // If we have a title from the tags, we need to strip it from the description
    if (videoData.title && videoData.description) {
        const parts = videoData.description.split('\n\n');

        if (parts.length > 1) {
            const firstPart = parts[0];

            const cleanFirstPart = firstPart.replace(/^[^\w\s]+\s*/, '').trim();

            if (cleanFirstPart === videoData.title || firstPart.includes(videoData.title)) {
                videoData.description = parts.slice(1).join('\n\n').trim();
            }
        } else {
            const cleanContent = videoData.description.replace(/^[^\w\s]+\s*/, '').trim();
            if (cleanContent.startsWith(videoData.title)) {
                const titleIndex = videoData.description.indexOf(videoData.title);
                const afterTitle = videoData.description.substring(titleIndex + videoData.title.length).trim();
                videoData.description = afterTitle.startsWith('\n') ? afterTitle.substring(1).trim() : afterTitle;
            }
        }
    }

    if (!videoData.title && videoData.description) {
        const lines = videoData.description.split('\n');

        if (lines[0]) {
            videoData.title = lines[0].replace(/^[^\w\s]+\s*/, '').trim();

            if (lines.length > 1) {
                videoData.description = lines.slice(1).join('\n').trim();
                videoData.description = videoData.description.replace(/^\n+/, '');
            } else {
                videoData.description = '';
            }
        }
    }

    // Remove any video URLs from the description
    const videoExtensions = ['mp4', 'mov', 'webm', 'avi', 'mkv', 'flv', 'wmv'];
    const extensionsPattern = videoExtensions.join('|');

    const urlRegex = new RegExp(
        `https?:\\/\\/[^\\s]*([a-f0-9]{64})\\.(${extensionsPattern})(\\?[^\\s]*)?`,
        'gi'
    );

    videoData.description = videoData.description.replace(urlRegex, '').trim();

    // Also remove the exact URL if it matches
    if (videoData.url && videoData.description.includes(videoData.url)) {
        videoData.description = videoData.description.replace(videoData.url, '').trim();
    }

    return videoData.title ? videoData : null;
}

// Check if video is NSFW (case-insensitive check for content-warning value)
function isVideoNSFW(event) {
    const tags = event.tags || [];
    return tags.some(tag => tag[0] === 'content-warning' && tag[1]?.toLowerCase() === 'nsfw');
}

// Invalid patterns for NIP-05 validation
const INVALID_NIP05 = [
    'r2a.primal.net',
    'blossom.primal.net',
    'localhost',
    '127.0.0.1',
    'files',
    'uploads'
];

// Helper function to validate NIP-05
// Caches the promise to prevent multiple simultaneous requests for the same pubkey
function validateNip05(nip05, pubkey) {
    const cacheKey = `${nip05}:${pubkey}`;

    // Return cached result or pending promise
    if (nip05ValidationCache.has(cacheKey)) {
        const cached = nip05ValidationCache.get(cacheKey);
        // If it's a promise, return it; if it's a boolean, wrap in resolved promise
        return cached instanceof Promise ? cached : Promise.resolve(cached);
    }

    // Create the validation promise
    const validationPromise = (async () => {
        try {
            const [name, domain] = nip05.split('@');
            if (!name || !domain) {
                return false;
            }

            const isBlocked = INVALID_NIP05.some(pattern =>
                domain.toLowerCase().includes(pattern.toLowerCase())
            );

            if (isBlocked) {
                return false;
            }

            const response = await fetch(`https://${domain}/.well-known/nostr.json?name=${name}`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                return false;
            }

            const data = await response.json();
            return data.names && data.names[name] === pubkey;
        } catch (error) {
            console.error('NIP-05 validation error:', error);
            return false;
        }
    })();

    // Cache the promise immediately to prevent duplicate requests
    nip05ValidationCache.set(cacheKey, validationPromise);

    // When promise resolves, replace with the actual result for faster future lookups
    validationPromise.then(isValid => {
        nip05ValidationCache.set(cacheKey, isValid);
        // Clear cache after 24 hours
        setTimeout(() => nip05ValidationCache.delete(cacheKey), 24 * 60 * 60 * 1000);
    });

    return validationPromise;
}

// Helper to check if image URL is valid
function createImageValidationPromise(url) {
    if (!url) {
        return Promise.resolve(false);
    }

    // Check cache first
    if (imageValidationCache.has(url)) {
        return Promise.resolve(imageValidationCache.get(url));
    }

    return new Promise((resolve) => {
        const img = new Image();
        const timeout = setTimeout(() => {
            img.src = '';
            imageValidationCache.set(url, false);
            resolve(false);
        }, 3000); // Reduced from 5s to 3s

        img.onload = () => {
            clearTimeout(timeout);
            imageValidationCache.set(url, true);
            resolve(true);
        };

        img.onerror = () => {
            clearTimeout(timeout);
            imageValidationCache.set(url, false);
            resolve(false);
        };

        img.src = url;
    });
}

// Function to create cards for videos
function createVideoCard(event, profile, reactions, isTrending = false, trendingRank = null, lazy = true, showOwnerActions = false) {
    // Parse both kind 1 and NIP-71 events
    let videoData;
    if (isNip71Kind(event.kind)) {
        videoData = parseNip71VideoEvent(event);
    } else {
        videoData = parseVideoEvent(event);
    }
    if (!videoData) return '';

    // Check if content is blocked by admin
    if (isBlockedByAdmin(event.id, event.pubkey)) {
        return ''; // Silently skip blocked content
    }

    // Check if content from this user should be hidden (muted)
    if (shouldHideMutedContent(event.pubkey)) {
        // For trending, just skip entirely
        if (isTrending) return '';
        // For other views, show a placeholder with event ID for in-place replacement
        return createMutedContentPlaceholder(event.pubkey, 'video', event.id);
    }

    // Check if content matches enabled filter packs
    const filterResult = shouldFilterVideoContent(event, videoData);
    if (filterResult.filtered) {
        // For trending, just skip entirely
        if (isTrending) return '';
        // For other views, show a filtered content placeholder
        return createFilteredContentPlaceholder(event, filterResult, 'video');
    }

    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';
    const isNSFW = isVideoNSFW(event);
    const isRatioed = isVideoRatioed(reactions || {});

    const cardId = `video-card-${event.id}`;
    // Track whether profile has been checked - with progressive rendering,
    // we render before profile loads. Warning should only show after profile check.
    // profileChecked means we've attempted to load the profile (even if it returned null)
    const profileChecked = profileCache.has(event.pubkey);
    // Suspicious if: profile was checked AND (no profile OR missing avatar/nip05)
    const isSuspiciousProfile = profileChecked && (!profile || !avatarUrl || !nip05);

    // Get boost data from cache
    const boostAmount = boostsCache.get(event.id) || 0;
    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;

    // Determine what type of overlay to show (skip for own videos)
    const isOwnVideo = currentUser?.pubkey === event.pubkey;
    const showNSFWOverlay = !isOwnVideo && isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own videos)
    const isReportedByFollowsCheck = !isOwnVideo && isReportedByFollowsSync(event.id, event.pubkey);
    const showCommunityWarning = !isOwnVideo && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning();
    const showBlurred = showNSFWOverlay || showCommunityWarning;

    // NSFW takes precedence
    const overlayType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    if (isTrending && (isRatioed || isSuspiciousProfile)) {
        return '';
    }

    const cardHTML = `
        <div class="video-card ${isBoosted ? `boosted boost-level-${boostLevel}` : ''}" id="${cardId}" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-is-trending="${isTrending}" data-validation-pending="${avatarUrl || nip05 ? 'true' : 'false'}"${lazy ? ' data-lazy="true"' : ''}${videoData.preview ? ' data-has-preview="true"' : ''}>
            <div class="video-thumbnail ${showBlurred ? overlayType : ''}"
                 onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${event.id}')` : `showRatioedModal('${event.id}')`) : `navigateTo('/video/${event.id}')`}">
                ${videoData.thumbnail ?
            `<img class="thumbnail-img" ${lazy ? `data-src="${videoData.thumbnail}"` : `src="${videoData.thumbnail}" data-original-src="${videoData.thumbnail}" onload="cacheLoadedImage(this)"`} alt="${videoData.title}" onerror="this.style.display='none'">` :
            `<video ${lazy ? `data-src="${videoData.url}"` : `src="${videoData.url}"`} preload="metadata"></video>`
        }
                ${videoData.preview ? `<img class="preview-img" ${lazy ? `data-src="${videoData.preview}"` : `src="${videoData.preview}" data-original-src="${videoData.preview}" onload="this.classList.add('loaded'); cacheLoadedImage(this)"`} alt="${videoData.title} preview" style="display:none;">` : ''}
                ${showBlurred ? `
                    <div class="${overlayType}-overlay">
                        <div class="${overlayType}-badge">${overlayType === 'nsfw' ? t('badge.nsfw') : t('badge.communityWarning')}</div>
                        <div>Click to view</div>
                    </div>
                ` : ''}
                ${isBoosted ? `
                    <div class="boost-indicator">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                        </svg>
                        ${formatSats(boostAmount)}
                    </div>
                ` : ''}
                ${!showBlurred && videoData.duration ? `<span class="video-duration">${formatDuration(videoData.duration)}</span>` : ''}
                ${reactions && (reactions.likes > 0 || reactions.dislikes > 0) ? `
                    <div class="video-reactions">
                        ${reactions.likes > 0 ? `
                            <span class="reaction-count likes">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                                </svg>
                                ${formatNumber(reactions.likes)}
                            </span>
                        ` : ''}
                        ${reactions.dislikes > 0 ? `
                            <span class="reaction-count dislikes">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                                </svg>
                                ${formatNumber(reactions.dislikes)}
                            </span>
                        ` : ''}
                    </div>
                ` : ''}
                ${isTrending && trendingRank ? `<div class="trending-rank">#${trendingRank}</div>` : ''}
                ${showOwnerActions ? `
                    <div class="video-owner-actions">
                        ${(event.kind === NIP71_VIDEO_KIND || event.kind === NIP71_SHORT_KIND) ? `
                            <button class="owner-edit-btn" onclick="event.stopPropagation(); showEditVideoModal('${event.id}')" title="${t('button.editVideo')}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                                </svg>
                            </button>
                        ` : ''}
                        <button class="owner-delete-btn" onclick="event.stopPropagation(); handleDelete('${event.id}')" title="${t('button.deleteVideo')}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                        </button>
                    </div>
                ` : ''}
            </div>
            <div class="video-info">
                <a href="#/profile/${event.pubkey}" class="channel-info">
                    <div class="channel-avatar">
                        ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}" data-avatar-url="${avatarUrl}">` : ''}
                    </div>
                    <div class="channel-details">
                        <div class="channel-name">${displayName}</div>
                        ${nip05 ? `<div class="channel-nip05" data-nip05="${nip05}">${nip05}</div>` : ''}
                    </div>
                </a>
                <h3 class="video-title" onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${event.id}')` : `showRatioedModal('${event.id}')`) : `navigateTo('/video/${event.id}')`}">${videoData.title}</h3>
                <div class="video-meta">
                    ${formatTimestamp(event.created_at)}
                    <span class="video-views" data-event-id="${event.id}">${(() => { const c = getCachedViewCount(event.id); return c !== null ? ` • ${formatNumber(c)} ${t('stat.views')}` : ''; })()}</span>
                    ${isNSFW ? ' • <span style="color: #ff0000;">NSFW</span>' : ''}
                    <span class="community-warning-indicator" style="${showCommunityWarning && !showNSFWOverlay ? '' : 'display: none;'}"> • <span style="color: #ff9800;">Community Warning</span></span>
                </div>
            </div>
        </div>
    `;

    if (profile && (avatarUrl || nip05)) {
        setTimeout(() => validateVideoCard(event.id, event.pubkey, profile, reactions, isTrending), 0);
    }

    return cardHTML;
}

// Update video card in place without replacing the entire DOM element (prevents image flickering)
function updateVideoCardInPlace(eventId, profile, reactions) {
    const card = document.getElementById(`video-card-${eventId}`);
    if (!card) return false;

    const displayName = profile?.name || profile?.display_name || `User ${card.dataset.pubkey?.slice(0, 8) || ''}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';

    // Update channel avatar (only if different to prevent flicker)
    const avatarContainer = card.querySelector('.channel-avatar');
    if (avatarContainer) {
        const existingImg = avatarContainer.querySelector('img');
        const existingAvatarUrl = existingImg?.getAttribute('data-avatar-url') || existingImg?.src || '';

        if (avatarUrl && avatarUrl !== existingAvatarUrl) {
            if (existingImg) {
                existingImg.src = avatarUrl;
                existingImg.setAttribute('data-avatar-url', avatarUrl);
            } else {
                avatarContainer.innerHTML = `<img src="${avatarUrl}" alt="${displayName}" data-avatar-url="${avatarUrl}">`;
            }
        } else if (!avatarUrl && existingImg) {
            existingImg.remove();
        }
    }

    // Update channel name
    const channelName = card.querySelector('.channel-name');
    if (channelName && channelName.textContent !== displayName) {
        channelName.textContent = displayName;
    }

    // Update NIP-05
    const channelDetails = card.querySelector('.channel-details');
    if (channelDetails) {
        const existingNip05 = channelDetails.querySelector('.channel-nip05');
        if (nip05) {
            if (existingNip05) {
                if (existingNip05.textContent !== nip05) {
                    existingNip05.textContent = nip05;
                    existingNip05.setAttribute('data-nip05', nip05);
                }
            } else {
                const nip05El = document.createElement('div');
                nip05El.className = 'channel-nip05';
                nip05El.setAttribute('data-nip05', nip05);
                nip05El.textContent = nip05;
                channelDetails.appendChild(nip05El);
            }
        } else if (existingNip05) {
            existingNip05.remove();
        }
    }

    // Update reaction counts on thumbnail
    if (reactions) {
        const thumbnail = card.querySelector('.video-thumbnail');
        if (thumbnail) {
            let reactionsDiv = thumbnail.querySelector('.video-reactions');
            const hasReactions = reactions.likes > 0 || reactions.dislikes > 0;

            if (hasReactions) {
                const reactionsHTML = `
                    ${reactions.likes > 0 ? `
                        <span class="reaction-count likes">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                            </svg>
                            ${formatNumber(reactions.likes)}
                        </span>
                    ` : ''}
                    ${reactions.dislikes > 0 ? `
                        <span class="reaction-count dislikes">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                            </svg>
                            ${formatNumber(reactions.dislikes)}
                        </span>
                    ` : ''}
                `;

                if (reactionsDiv) {
                    reactionsDiv.innerHTML = reactionsHTML;
                } else {
                    reactionsDiv = document.createElement('div');
                    reactionsDiv.className = 'video-reactions';
                    reactionsDiv.innerHTML = reactionsHTML;
                    thumbnail.appendChild(reactionsDiv);
                }
            } else if (reactionsDiv) {
                reactionsDiv.remove();
            }
        }
    }

    // Trigger proper validation if not done yet
    // This validates nip05 (checks if it actually resolves to the pubkey)
    // and avatar (checks if image loads) - then updates warning accordingly
    const pubkey = card.dataset.pubkey;
    if (card.dataset.validationDone !== 'true' && pubkey) {
        const isTrending = card.dataset.isTrending === 'true';
        setTimeout(() => validateVideoCard(eventId, pubkey, profile, reactions, isTrending), 0);
    }

    return true;
}

// Get NIP-05 verified checkmark SVG
function getNip05CheckmarkSVG(size = 14) {
    return `<svg class="nip05-verified" width="${size}" height="${size}" viewBox="0 0 24 24" fill="currentColor" title="${t('badge.verifiedNip05')}">
        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
    </svg>`;
}

// Apply NIP-05 checkmark to any element with nip05
function applyNip05Checkmark(element, isValid, size = 14) {
    if (!element || !isValid) return;
    if (element.querySelector('.nip05-verified')) return; // Already has checkmark

    const nip05Text = element.textContent;
    element.innerHTML = `<span class="nip05-text">${nip05Text}</span>${getNip05CheckmarkSVG(size)}`;
}

// Apply validation result to a single card
function applyValidationToCard(card, isSuspiciousProfile) {
    if (!card) return;

    const eventId = card.dataset.eventId || card.id?.replace('video-card-', '');
    if (!eventId) return;

    const pubkey = card.dataset.pubkey;
    const isTrending = card.dataset.isTrending === 'true';
    const reactions = reactionsCache.get(eventId) || {};
    const isNSFW = isVideoNSFW(allEvents.get(eventId));
    const isRatioed = isVideoRatioed(reactions);

    card.dataset.validationDone = 'true';
    card.dataset.needsValidation = 'false';

    // Add NIP-05 verified checkmark if valid
    if (pubkey && profileValidationCache.has(pubkey)) {
        const cached = profileValidationCache.get(pubkey);
        const nip05El = card.querySelector('.channel-nip05');
        applyNip05Checkmark(nip05El, cached.nip05Valid);
    }

    // Remove trending cards with suspicious profiles
    if (isTrending && (isRatioed || isSuspiciousProfile)) {
        // Track removed ID for filtering
        trendingRemovedIds.add(eventId);
        card.remove();

        // Only attempt to refill if cache has videos to draw from
        // Compute filteredVideos inside timeout to get latest cache state
        setTimeout(() => {
            const trendingGrid = document.getElementById('trendingGrid');
            if (!trendingGrid) return;

            const filteredVideos = cachedTrendingVideos.filter(v => !trendingRemovedIds.has(v.id));
            const currentCardCount = trendingGrid.querySelectorAll('.video-card').length;

            // Only re-render if we have videos to refill with and need more cards
            const isMobile = window.innerWidth <= 480;
            const isTablet = window.innerWidth > 480 && window.innerWidth <= 768;
            const maxCards = (isMobile || isTablet) ? 3 : 4;

            if (filteredVideos.length > 0 && currentCardCount < maxCards) {
                renderTrendingVideosOptimized(filteredVideos, new Set());
            } else if (currentCardCount > 0) {
                // Just reinitialize carousel if we still have cards but don't need to refill
                initializeCarousel();
            }
        }, 50);
        return;
    }

    const thumbnail = card.querySelector('.video-thumbnail');
    if (!thumbnail) return;

    const currentOverlay = thumbnail.querySelector('.ratioed-overlay, .nsfw-overlay');

    const shouldShowNSFWOverlay = isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own videos)
    const isReportedByFollowsCheck = pubkey && currentUser?.pubkey !== pubkey && isReportedByFollowsSync(eventId, pubkey);
    const shouldShowCommunityWarning = (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning();
    const needsOverlay = shouldShowNSFWOverlay || shouldShowCommunityWarning;
    const overlayType = shouldShowNSFWOverlay ? 'nsfw' : 'ratioed';

    if ((currentOverlay && !needsOverlay) || (!currentOverlay && needsOverlay)) {
        if (needsOverlay && !currentOverlay) {
            thumbnail.classList.add(overlayType);
            thumbnail.setAttribute('onclick',
                overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${eventId}')` : `showRatioedModal('${eventId}')`
            );
            const overlayHTML = `
                <div class="${overlayType}-overlay">
                    <div class="${overlayType}-badge">${overlayType === 'nsfw' ? t('badge.nsfw') : t('badge.communityWarning')}</div>
                    <div>Click to view</div>
                </div>
            `;
            thumbnail.insertAdjacentHTML('beforeend', overlayHTML);
        } else if (!needsOverlay) {
            thumbnail.classList.remove('ratioed', 'nsfw');
            thumbnail.setAttribute('onclick', `navigateTo('/video/${eventId}')`);
            if (currentOverlay) currentOverlay.remove();
        }

        const warningIndicator = card.querySelector('.community-warning-indicator');
        if (warningIndicator) {
            warningIndicator.style.display = shouldShowCommunityWarning && !shouldShowNSFWOverlay ? 'inline' : 'none';
        }

        const title = card.querySelector('.video-title');
        if (title) {
            title.setAttribute('onclick',
                needsOverlay ?
                    (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${eventId}')` : `showRatioedModal('${eventId}')`) :
                    `navigateTo('/video/${eventId}')`
            );
        }
    }
}

// Function to validate and update video cards - uses cached results when available
async function validateVideoCard(eventId, pubkey, profile, reactions, isTrending = false) {
    const card = document.getElementById(`video-card-${eventId}`);
    if (!card) return;

    if (card.dataset.validationDone === 'true') return;

    // Check if we already have validation result cached for this pubkey
    if (profileValidationCache.has(pubkey)) {
        const cached = profileValidationCache.get(pubkey);
        applyValidationToCard(card, cached.isSuspicious);

        // Also apply NIP-05 checkmark to video page and profile page elements
        if (cached.nip05Valid) {
            const videoPageNip05 = document.querySelector(`.video-channel-info .channel-nip05`);
            if (videoPageNip05) applyNip05Checkmark(videoPageNip05, true);

            const profileNip05 = document.querySelector(`.profile-nip05`);
            if (profileNip05) applyNip05Checkmark(profileNip05, true, 16);

            // Apply to comments from this user
            document.querySelectorAll(`.comment-author-nip05[data-pubkey="${pubkey}"]`).forEach(el => {
                applyNip05Checkmark(el, true, 12);
            });
        }
        return;
    }

    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';

    const [avatarValid, nip05Valid] = await Promise.all([
        avatarUrl ? createImageValidationPromise(avatarUrl) : Promise.resolve(false),
        nip05 ? validateNip05(nip05, pubkey) : Promise.resolve(false)
    ]);

    const isSuspiciousProfile = !avatarValid || !nip05Valid;

    // Cache the validation result for this pubkey
    profileValidationCache.set(pubkey, {
        isSuspicious: isSuspiciousProfile,
        avatarValid,
        nip05Valid
    });

    // Apply validation to ALL cards for this pubkey (not just the current one)
    const allCardsForPubkey = document.querySelectorAll(`[data-pubkey="${pubkey}"]`);
    allCardsForPubkey.forEach(c => {
        if (c.classList.contains('sidebar-video-card')) {
            applySidebarValidation(c, isSuspiciousProfile);
        } else {
            applyValidationToCard(c, isSuspiciousProfile);
        }
    });

    // Also apply NIP-05 checkmark to video page and profile page elements
    if (nip05Valid) {
        // Video page channel info
        const videoPageNip05 = document.querySelector(`.video-channel-info .channel-nip05`);
        if (videoPageNip05) {
            applyNip05Checkmark(videoPageNip05, true);
        }

        // Profile page
        const profileNip05 = document.querySelector(`.profile-nip05`);
        if (profileNip05) {
            applyNip05Checkmark(profileNip05, true, 16);
        }

        // Apply to comments from this user
        document.querySelectorAll(`.comment-author-nip05[data-pubkey="${pubkey}"]`).forEach(el => {
            applyNip05Checkmark(el, true, 12);
        });
    }
}

// Get video URL with fallback
async function getVideoUrl(hash, servers = BLOSSOM_SERVERS) {
    for (const server of servers) {
        const url = `${server}/${hash}`;
        try {
            const response = await fetch(url, { method: 'HEAD' });
            if (response.ok) {
                return url;
            }
        } catch (error) {
            console.error(`Failed to check ${server}:`, error);
        }
    }
    return null;
}

// Format duration
function formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

// Format timestamp
function formatTimestamp(timestamp) {
    const date = new Date(timestamp * 1000);
    const now = new Date();
    const diff = now - date;

    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    const weeks = Math.floor(days / 7);
    const months = Math.floor(days / 30);
    const years = Math.floor(days / 365);

    if (years > 0) return years === 1 ? t('time.yearAgo') : t('time.yearsAgo', { n: years });
    if (months > 0) return months === 1 ? t('time.monthAgo') : t('time.monthsAgo', { n: months });
    if (weeks > 0) return weeks === 1 ? t('time.weekAgo') : t('time.weeksAgo', { n: weeks });
    if (days > 0) return days === 1 ? t('time.dayAgo') : t('time.daysAgo', { n: days });
    if (hours > 0) return hours === 1 ? t('time.hourAgo') : t('time.hoursAgo', { n: hours });
    if (minutes > 0) return minutes === 1 ? t('time.minuteAgo') : t('time.minutesAgo', { n: minutes });
    if (seconds > 5) return seconds === 1 ? t('time.secondAgo') : t('time.secondsAgo', { n: seconds });
    return t('time.justNow');
}

// ===== Create Modal Functions =====
function showCreateModal() {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }
    document.getElementById('createModal').classList.add('active');
}

const peertubeImportState = {
    metadata: null,
    lastFetched: null
};

function showPeertubeModal() {
    hideCreateModal();
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }
    resetPeertubeImportForm();
    document.getElementById('peertubeModal').classList.add('active');
}

function hidePeertubeModal() {
    document.getElementById('peertubeModal').classList.remove('active');
}

function backToCreateModalFromPeertube() {
    hidePeertubeModal();
    showCreateModal();
}

function resetPeertubeImportForm() {
    const form = document.getElementById('peertubeImportForm');
    if (form) {
        form.reset();
    }
    peertubeImportState.metadata = null;
    peertubeImportState.lastFetched = null;
    const statusEl = document.getElementById('peertubeMetaStatus');
    if (statusEl) {
        statusEl.textContent = '';
        statusEl.classList.remove('success', 'error', 'info');
    }
    const preview = document.getElementById('peertubePreview');
    if (preview) {
        preview.innerHTML = '';
    }
}

function setPeertubeMetaStatus(message, type = 'info') {
    const statusEl = document.getElementById('peertubeMetaStatus');
    if (!statusEl) return;
    statusEl.textContent = message;
    ['success', 'error', 'info'].forEach(cls => statusEl.classList.remove(cls));
    if (type) {
        statusEl.classList.add(type);
    }
}

async function fetchPeertubeMetadata() {
    const urlInput = document.getElementById('peertubeUrl');
    if (!urlInput) return;
    const url = urlInput.value.trim();
    if (!url) {
        setPeertubeMetaStatus('Enter a Peertube URL to fetch metadata.', 'error');
        return;
    }

    const parsed = parsePeertubeVideoUrl(url);
    if (!parsed || !parsed.id) {
        setPeertubeMetaStatus('Could not determine the video ID. Please check the URL.', 'error');
        return;
    }

    setPeertubeMetaStatus('Fetching metadata from the instance…', 'info');
    try {
        const response = await fetch(`${parsed.origin}/api/v1/videos/${parsed.id}`);
        if (!response.ok) {
            throw new Error(`Status ${response.status}`);
        }
        const data = await response.json();
        peertubeImportState.metadata = data;
        peertubeImportState.lastFetched = Date.now();

        const titleInput = document.getElementById('peertubeTitle');
        const descriptionInput = document.getElementById('peertubeDescription');
        const tagsInput = document.getElementById('peertubeTags');
        const authorInput = document.getElementById('peertubeAuthor');
        const thumbnailInput = document.getElementById('peertubeThumbnail');

        if (titleInput && data.name) {
            titleInput.value = data.name;
        }
        if (descriptionInput && data.description) {
            descriptionInput.value = data.description;
        }
        if (tagsInput && Array.isArray(data.tags)) {
            tagsInput.value = data.tags.join(',');
        }

        if (authorInput) {
            const owner = data.account || data.owner || data.user;
            let creator = '';
            if (owner?.displayName) {
                creator = owner.displayName;
            } else if (owner?.username) {
                creator = owner.username;
            }
            if (owner?.host) {
                creator = creator ? `${creator}@${owner.host}` : `${owner.username}@${owner.host}`;
            }
            if (creator) {
                authorInput.value = creator;
            }
        }

        if (thumbnailInput) {
            const thumb = data.snapshotUrl || data.thumbnail || data.previewUrl;
            if (thumb) {
                thumbnailInput.value = thumb;
            }
        }

        const preview = document.getElementById('peertubePreview');
        if (preview) {
            preview.innerHTML = `
                <strong>${data.name || 'Peertube Video'}</strong>
                <div style="margin-top:0.35rem;">
                    ${data.description ? data.description.slice(0, 150) + (data.description.length > 150 ? '…' : '') : 'No description available.'}
                </div>
                <div style="margin-top:0.5rem; color: var(--text-secondary); font-size:0.85rem;">
                    Instance: ${parsed.host || parsed.origin}
                </div>
            `;
        }

        setPeertubeMetaStatus(`Metadata loaded from ${parsed.origin}`, 'success');
    } catch (error) {
        console.error('Peertube metadata fetch failed:', error);
        setPeertubeMetaStatus('Unable to fetch metadata (CORS or network). Fill fields manually if needed.', 'error');
    }
}

function parsePeertubeVideoUrl(value) {
    try {
        const parsedUrl = new URL(value);
        const segments = parsedUrl.pathname.split('/').filter(Boolean);
        let videoId = null;
        const watchIndex = segments.indexOf('watch');
        const videosIndex = segments.indexOf('videos');

        if (watchIndex !== -1 && segments.length > watchIndex + 1) {
            videoId = segments[watchIndex + 1];
        } else if (segments.length > 0) {
            videoId = segments[segments.length - 1];
        }

        return {
            origin: parsedUrl.origin,
            host: parsedUrl.host,
            id: videoId
        };
    } catch (e) {
        return null;
    }
}

async function handlePeertubeImport(e) {
    e.preventDefault();
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const url = document.getElementById('peertubeUrl')?.value.trim();
    const title = document.getElementById('peertubeTitle')?.value.trim();
    const description = document.getElementById('peertubeDescription')?.value.trim();
    const tagsValue = document.getElementById('peertubeTags')?.value || '';
    const author = document.getElementById('peertubeAuthor')?.value.trim();
    const nostr = document.getElementById('peertubeNostr')?.value.trim();
    const magnet = document.getElementById('peertubeMagnet')?.value.trim();
    const allowTorrent = document.getElementById('peertubeAllowWebTorrent')?.checked;
    const thumbnail = document.getElementById('peertubeThumbnail')?.value.trim();

    if (!url || !title) {
        alert('Please provide both a Peertube URL and a title.');
        return;
    }

    const parsed = parsePeertubeVideoUrl(url);
    if (!parsed || !parsed.id) {
        alert('Invalid Peertube URL. Please double-check the link.');
        return;
    }

    const tags = tagsValue.split(',').map(tag => tag.trim()).filter(tag => tag);

    const importData = {
        url,
        title,
        description,
        tags,
        author,
        nostr,
        magnet,
        allowTorrent,
        thumbnail,
        metadata: peertubeImportState.metadata,
        parsedInstance: parsed.origin,
        parsedHost: parsed.host,
        videoId: parsed.id
    };

    try {
        await publishPeertubeVideo(importData);
        showToast('Peertube video imported successfully!', 'success');
        setTimeout(() => {
            resetPeertubeImportForm();
            hidePeertubeModal();
            navigateTo('/my-videos');
        }, 1500);
    } catch (error) {
        console.error('Peertube import failed:', error);
        showToast(error.message || 'Failed to import Peertube video.', 'error');
    }
}

// Adds published video events to caches and links them together
function finalizePublishedVideoEvents(addressableEvent, legacyEvent, kind1Event) {
    const eventIds = [addressableEvent.id, legacyEvent.id, kind1Event.id];
    for (const id1 of eventIds) {
        for (const id2 of eventIds) {
            if (id1 !== id2) {
                videoEventLinks.set(id1, id2);
            }
        }
    }

    allEvents.set(addressableEvent.id, addressableEvent);
    allEvents.set(legacyEvent.id, legacyEvent);
    allEvents.set(kind1Event.id, kind1Event);
}

async function publishPeertubeVideo(importData) {
    const submitButton = document.querySelector('#peertubeImportForm button[type="submit"]');
    const buttonText = submitButton ? submitButton.textContent : '';
    if (submitButton) {
        submitButton.disabled = true;
        submitButton.textContent = 'Importing…';
    }

    setPeertubeMetaStatus('Publishing Peertube video to Nostr…', 'info');

    try {
        const videoData = buildPeertubeVideoData(importData);
        videoData.dTag = generateVideoDTag();

        const addressableEvent = createNip71VideoEvent(videoData);
        const signedAddressableEvent = await signEvent(addressableEvent);

        const legacyNip71Event = createLegacyNip71VideoEvent(videoData);
        const signedLegacyEvent = await signEvent(legacyNip71Event);

        const kind1Event = createKind1VideoEvent(videoData, signedAddressableEvent.id);
        const signedKind1Event = await signEvent(kind1Event);

        const [addressablePublished, legacyPublished, kind1Published] = await Promise.all([
            publishEvent(signedAddressableEvent),
            publishEvent(signedLegacyEvent),
            publishEvent(signedKind1Event)
        ]);

        if (!addressablePublished && !legacyPublished && !kind1Published) {
            throw new Error('Failed to publish to any relay');
        }

        finalizePublishedVideoEvents(signedAddressableEvent, signedLegacyEvent, signedKind1Event);
        setPeertubeMetaStatus('Peertube video published successfully!', 'success');
    } catch (error) {
        setPeertubeMetaStatus(error.message || 'Failed to publish Peertube video.', 'error');
        throw error;
    } finally {
        if (submitButton) {
            submitButton.disabled = false;
            submitButton.textContent = buttonText;
        }
    }
}

function buildPeertubeVideoData(importData) {
    const metadata = importData.metadata || {};
    const primaryFile = selectPeertubePrimaryFile(metadata);
    const streamUrl = primaryFile?.url || metadata.streamingUrl || metadata.streamUrl || importData.url;
    const fallbackSourceUrls = Array.from(new Set([
        ...(metadata.files || []).map(file => file.url).filter(Boolean),
        ...(metadata.sourceFiles || []).map(file => file.url).filter(Boolean),
        metadata.streamingUrl,
        metadata.streamUrl
    ].filter(Boolean)));
    const fallbackUrls = fallbackSourceUrls.filter(url => url !== streamUrl);
    const mirrors = fallbackUrls.map(url => ({ url }));
    const tags = (importData.tags || []).map(tag => tag.toLowerCase()).filter(tag => tag);
    if (!tags.includes('peertube')) {
        tags.push('peertube');
    }
    const duration = Math.floor(metadata.duration || primaryFile?.duration || 0);
    const size = primaryFile?.size || metadata.fileSize || 0;
    const width = primaryFile?.width || metadata.width || 0;
    const height = primaryFile?.height || metadata.height || 0;
    const hash = primaryFile?.sha256 || metadata.hash || metadata.sha256 || '';
    const preview = metadata.previewUrl || metadata.snapshotUrl || '';
    const thumbnail = importData.thumbnail || metadata.snapshotUrl || metadata.thumbnail || '';

    return {
        title: importData.title,
        description: importData.description,
        url: streamUrl,
        thumbnail: thumbnail,
        preview: preview,
        duration: duration,
        size: size,
        type: primaryFile?.mime || metadata.mime || 'video/mp4',
        width: width,
        height: height,
        mirrors: mirrors,
        fallbackUrls: fallbackUrls,
        tags: tags,
        isNSFW: false,
        hash: hash,
        extraTags: buildPeertubeExtraTags(importData, metadata)
    };
}

function selectPeertubePrimaryFile(metadata) {
    if (!metadata) return null;

    const candidates = [];
    if (Array.isArray(metadata.files)) {
        candidates.push(...metadata.files);
    }
    if (Array.isArray(metadata.sourceFiles)) {
        candidates.push(...metadata.sourceFiles);
    }

    const validFiles = candidates.filter(file => file && file.url);
    if (!validFiles.length) {
        return null;
    }

    validFiles.sort((a, b) => {
        const widthDiff = (b.width || 0) - (a.width || 0);
        if (widthDiff !== 0) return widthDiff;
        return (b.size || 0) - (a.size || 0);
    });

    return validFiles[0];
}

function buildPeertubeExtraTags(importData, metadata) {
    const tags = [['source', 'peertube']];

    if (importData.parsedInstance) {
        tags.push(['peertube-instance', importData.parsedInstance]);
    }
    if (importData.videoId) {
        tags.push(['peertube-video-id', importData.videoId]);
    }
    if (importData.url) {
        tags.push(['peertube-watch', importData.url]);
    }
    const account = metadata.account || metadata.owner || metadata.user || null;
    let accountCreator = '';
    if (account) {
        const usernamePart = account.username || '';
        const hostPart = account.host ? `@${account.host}` : '';
        if (usernamePart || hostPart) {
            accountCreator = `${usernamePart}${hostPart}`;
        }
    }
    const creator = importData.author || accountCreator;
    if (creator) {
        tags.push(['peertube-author', creator]);
    }
    if (metadata.account?.nip05) {
        tags.push(['peertube-nip05', metadata.account.nip05]);
    }
    const normalizedPubkey = normalizeNostrPubkey(importData.nostr);
    if (normalizedPubkey) {
        tags.push(['p', normalizedPubkey]);
        tags.push(['peertube-nostr', normalizedPubkey]);
    } else if (importData.nostr) {
        tags.push(['peertube-nostr-raw', importData.nostr]);
    }

    if (importData.allowTorrent) {
        tags.push(['peertube-allow-webtorrent', 'true']);
        if (importData.magnet) {
            tags.push(['peertube-magnet', importData.magnet]);
        }
    }

    return tags;
}

function normalizeNostrPubkey(value) {
    if (!value) return null;
    const trimmed = value.trim();

    try {
        const decoded = window.NostrTools.nip19.decode(trimmed);
        if (decoded?.type === 'npub') {
            return decoded.data;
        }
        if (decoded?.type === 'nprofile' && decoded?.data?.pubkey) {
            return decoded.data.pubkey;
        }
    } catch (error) {
        // ignore
    }

    if (/^[0-9A-Fa-f]{64}$/.test(trimmed)) {
        return trimmed.toLowerCase();
    }

    return null;
}

function hideCreateModal() {
    document.getElementById('createModal').classList.remove('active');
}

// ===== Go Live Modal Functions =====
function showGoLiveModal() {
    hideCreateModal();
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    // Reset form
    document.getElementById('goLiveForm').reset();
    resetLiveStreamState();
    switchStreamType('now');

    // Set default date/time for scheduled streams
    const now = new Date();
    now.setMinutes(now.getMinutes() + 30);
    document.getElementById('streamDate').value = now.toISOString().split('T')[0];
    document.getElementById('streamTime').value = now.toTimeString().slice(0, 5);

    document.getElementById('goLiveModal').classList.add('active');

    // Setup thumbnail upload handler
    setupStreamThumbnailUpload();
}

function hideGoLiveModal() {
    document.getElementById('goLiveModal').classList.remove('active');
    resetLiveStreamState();
}

function resetLiveStreamState() {
    liveStreamState.thumbnailUrl = null;
    liveStreamState.thumbnailFile = null;
    liveStreamState.isScheduled = false;
    liveStreamState.scheduledTime = null;

    // Reset thumbnail preview
    const preview = document.getElementById('streamThumbnailPreview');
    if (preview) preview.style.display = 'none';
    const progress = document.getElementById('streamThumbnailProgress');
    if (progress) progress.style.display = 'none';
    const upload = document.getElementById('streamThumbnailUpload');
    if (upload) upload.style.display = 'flex';

    // Reset zap goal field
    const zapGoalField = document.getElementById('streamZapGoal');
    if (zapGoalField) zapGoalField.value = '';
}

function switchStreamType(type) {
    const tabs = document.querySelectorAll('.stream-type-tab');
    tabs.forEach(tab => {
        tab.classList.toggle('active', tab.dataset.type === type);
    });

    const scheduleOptions = document.getElementById('scheduleOptions');
    const goLiveBtn = document.getElementById('goLiveButtonText');

    if (type === 'schedule') {
        scheduleOptions.style.display = 'block';
        goLiveBtn.textContent = t('button.scheduleStream');
        liveStreamState.isScheduled = true;
    } else {
        scheduleOptions.style.display = 'none';
        goLiveBtn.textContent = t('button.goLive');
        liveStreamState.isScheduled = false;
    }
}

function setupStreamThumbnailUpload() {
    const fileInput = document.getElementById('streamThumbnailFile');
    if (fileInput) {
        fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Validate file type
            const allowedImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            if (!allowedImageTypes.includes(file.type)) {
                showToast('Invalid thumbnail file type. Please upload an image file (jpg, png, gif, webp)', 'error');
                fileInput.value = '';
                return;
            }

            liveStreamState.thumbnailFile = file;

            // Show progress
            document.getElementById('streamThumbnailUpload').style.display = 'none';
            document.getElementById('streamThumbnailProgress').style.display = 'block';
            document.getElementById('streamThumbnailName').textContent = file.name;
            document.getElementById('streamThumbnailStatus').textContent = t('status.uploading');
            document.getElementById('streamThumbnailProgressFill').style.width = '0%';

            try {
                // Upload directly to Blossom servers with progress callback
                const result = await uploadToBlossom(
                    file,
                    BLOSSOM_SERVERS,
                    'streamThumbnailServerStatus',
                    (progress, completed, total) => {
                        document.getElementById('streamThumbnailProgressFill').style.width = `${progress}%`;
                        document.getElementById('streamThumbnailStatus').textContent = `Uploading... (${completed}/${total} servers)`;
                    }
                );

                if (result.success && result.url) {
                    liveStreamState.thumbnailUrl = result.url;
                    document.getElementById('streamThumbnailProgressFill').style.width = '100%';

                    // Show preview
                    document.getElementById('streamThumbnailProgress').style.display = 'none';
                    document.getElementById('streamThumbnailPreview').style.display = 'block';
                    document.getElementById('streamThumbnailPreviewImage').src = result.url;
                    document.getElementById('streamThumbnailStatus').textContent = t('status.thumbnailReady');
                } else {
                    throw new Error(result.error || 'Upload failed');
                }
            } catch (error) {
                console.error('Failed to upload stream thumbnail:', error);
                showToast('Failed to upload thumbnail. Please try again.', 'error');
                document.getElementById('streamThumbnailStatus').textContent = t('status.thumbnailFailed');
                document.getElementById('streamThumbnailUpload').style.display = 'flex';
                document.getElementById('streamThumbnailProgress').style.display = 'none';
                liveStreamState.thumbnailFile = null;
                liveStreamState.thumbnailUrl = null;
            }
        };
    }
}

function deleteStreamThumbnail() {
    liveStreamState.thumbnailUrl = null;
    liveStreamState.thumbnailFile = null;
    document.getElementById('streamThumbnailPreview').style.display = 'none';
    document.getElementById('streamThumbnailUpload').style.display = 'flex';
    document.getElementById('streamThumbnailFile').value = '';
}

// Go Live Form Submit Handler
document.addEventListener('DOMContentLoaded', () => {
    const goLiveForm = document.getElementById('goLiveForm');
    if (goLiveForm) {
        goLiveForm.addEventListener('submit', handleGoLive);
    }
    const peertubeForm = document.getElementById('peertubeImportForm');
    if (peertubeForm) {
        peertubeForm.addEventListener('submit', handlePeertubeImport);
    }
});

async function handleGoLive(e) {
    e.preventDefault();

    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const title = document.getElementById('streamTitle').value.trim();
    const description = document.getElementById('streamDescription').value.trim();
    const tags = document.getElementById('streamTags').value.split(',').map(t => t.trim()).filter(t => t);
    const streamUrl = document.getElementById('streamUrl').value.trim();
    const zapGoal = document.getElementById('streamZapGoal').value.trim();
    const isNSFW = document.getElementById('streamNsfwCheckbox').checked;

    // Validate required fields including thumbnail
    if (!title || !streamUrl) {
        alert(t('alert.fillRequiredFields'));
        return;
    }

    if (!liveStreamState.thumbnailUrl) {
        alert(t('alert.uploadThumbnail'));
        return;
    }

    // Get scheduled time if applicable
    let startTime = Math.floor(Date.now() / 1000);
    let status = 'live';

    if (liveStreamState.isScheduled) {
        const dateStr = document.getElementById('streamDate').value;
        const timeStr = document.getElementById('streamTime').value;
        if (dateStr && timeStr) {
            const scheduledDate = new Date(`${dateStr}T${timeStr}`);
            startTime = Math.floor(scheduledDate.getTime() / 1000);
            status = 'planned';
        }
    }

    // Disable button
    const goLiveBtn = document.getElementById('goLiveButton');
    goLiveBtn.disabled = true;
    document.getElementById('goLiveButtonText').textContent = t('button.creatingStream');

    try {
        // Create NIP-53 Live Event (kind 30311)
        const dTag = `plebs-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

        const eventTags = [
            ['d', dTag],
            ['title', title],
            ['summary', description],
            ['streaming', streamUrl],
            ['status', status],
            ['starts', String(startTime)],
            ['t', 'pv69420'], // Plebs app tag
        ];

        // Add thumbnail if uploaded
        if (liveStreamState.thumbnailUrl) {
            eventTags.push(['image', liveStreamState.thumbnailUrl]);
        }

        // Add content tags
        tags.forEach(tag => {
            eventTags.push(['t', tag.toLowerCase()]);
        });

        // Add NSFW tag if applicable
        if (isNSFW) {
            eventTags.push(['content-warning', 'nsfw']);
        }

        // Add zap goal if specified
        if (zapGoal && parseInt(zapGoal) > 0) {
            eventTags.push(['goal', zapGoal]);
        }

        // Add host participant
        eventTags.push(['p', currentUser.pubkey, '', 'Host']);

        const event = {
            kind: NIP53_LIVE_EVENT_KIND,
            created_at: Math.floor(Date.now() / 1000),
            tags: eventTags,
            content: ''
        };

        const signedEvent = await signEvent(event);
        if (!signedEvent) {
            throw new Error('Failed to sign event');
        }

        await publishEvent(signedEvent);

        // Store in allEvents
        allEvents.set(signedEvent.id, signedEvent);

        hideGoLiveModal();

        // Navigate to the live stream page
        navigateTo(`/live/${signedEvent.id}`);

    } catch (error) {
        console.error('Failed to create live stream:', error);
        alert(t('alert.failedCreateStream'));
    } finally {
        goLiveBtn.disabled = false;
        document.getElementById('goLiveButtonText').textContent = liveStreamState.isScheduled ? 'Schedule Stream' : 'Go Live';
    }
}

// ===== Edit Live Stream Modal Functions =====
let editStreamState = {
    eventId: null,
    event: null,
    liveData: null,
    newThumbnailUrl: null
};

async function showEditStreamModal(eventId) {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    // Fetch the event
    let event = allEvents.get(eventId);
    if (!event) {
        event = await fetchLiveEvent(eventId);
    }

    if (!event) {
        alert(t('alert.streamNotFound'));
        return;
    }

    // Verify ownership
    if (event.pubkey !== currentUser.pubkey) {
        alert(t('alert.canOnlyEditOwnStreams'));
        return;
    }

    const liveData = parseLiveEvent(event);
    if (!liveData) {
        alert(t('alert.invalidStreamData'));
        return;
    }

    // Store state
    editStreamState = {
        eventId: eventId,
        event: event,
        liveData: liveData,
        newThumbnailUrl: null
    };

    // Populate form fields
    document.getElementById('editStreamTitle').value = liveData.title || '';
    document.getElementById('editStreamDescription').value = liveData.summary || '';
    document.getElementById('editStreamTags').value = (liveData.tags || []).join(', ');
    document.getElementById('editStreamUrl').value = liveData.streamUrl || '';
    document.getElementById('editStreamZapGoal').value = liveData.zapGoal || '';
    document.getElementById('editStreamNsfwCheckbox').checked = liveData.isNSFW || false;

    // Hidden fields
    document.getElementById('editStreamEventId').value = eventId;
    document.getElementById('editStreamDTag').value = liveData.dTag;
    document.getElementById('editStreamStatus').value = liveData.status;
    document.getElementById('editStreamStarts').value = liveData.starts;
    document.getElementById('editStreamEnds').value = liveData.ends || '';

    // Show thumbnail preview
    const thumbnailPreview = document.getElementById('editStreamThumbnailPreview');
    if (liveData.thumbnail) {
        thumbnailPreview.src = liveData.thumbnail;
        thumbnailPreview.style.display = 'block';
    } else {
        thumbnailPreview.style.display = 'none';
    }

    // Show modal
    document.getElementById('editStreamModal').classList.add('active');

    // Setup thumbnail upload handler
    setupEditStreamThumbnailUpload();
}

function hideEditStreamModal() {
    document.getElementById('editStreamModal').classList.remove('active');
    editStreamState = {
        eventId: null,
        event: null,
        liveData: null,
        newThumbnailUrl: null
    };
}

function setupEditStreamThumbnailUpload() {
    const fileInput = document.getElementById('editStreamThumbnailFile');
    if (fileInput) {
        fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const progressDiv = document.getElementById('editStreamThumbnailProgress');
            const statusEl = document.getElementById('editStreamThumbnailStatus');
            const progressFill = document.getElementById('editStreamThumbnailProgressFill');

            progressDiv.style.display = 'block';
            statusEl.textContent = t('status.uploadingThumbnail');
            progressFill.style.width = '0%';

            try {
                const result = await uploadToNostrBuild(file, (progress) => {
                    progressFill.style.width = `${progress}%`;
                });

                if (result && result.url) {
                    editStreamState.newThumbnailUrl = result.url;
                    document.getElementById('editStreamThumbnailPreview').src = result.url;
                    document.getElementById('editStreamThumbnailPreview').style.display = 'block';
                    document.getElementById('editStreamNewThumbnailUrl').value = result.url;
                    statusEl.textContent = t('status.thumbnailUploaded');
                } else {
                    throw new Error('Upload failed');
                }
            } catch (error) {
                console.error('Thumbnail upload failed:', error);
                statusEl.textContent = t('status.uploadFailedRetry');
            }

            setTimeout(() => {
                progressDiv.style.display = 'none';
            }, 2000);
        };
    }
}

async function handleEditStream(e) {
    e.preventDefault();

    if (!currentUser || !editStreamState.event) {
        return;
    }

    const title = document.getElementById('editStreamTitle').value.trim();
    const description = document.getElementById('editStreamDescription').value.trim();
    const tags = document.getElementById('editStreamTags').value.split(',').map(t => t.trim()).filter(t => t);
    const streamUrl = document.getElementById('editStreamUrl').value.trim();
    const zapGoal = document.getElementById('editStreamZapGoal').value.trim();
    const isNSFW = document.getElementById('editStreamNsfwCheckbox').checked;

    const dTag = document.getElementById('editStreamDTag').value;
    const status = document.getElementById('editStreamStatus').value;
    const starts = document.getElementById('editStreamStarts').value;
    const ends = document.getElementById('editStreamEnds').value;

    if (!title || !streamUrl) {
        alert(t('alert.fillRequiredFields'));
        return;
    }

    const saveBtn = document.getElementById('saveStreamButton');
    saveBtn.disabled = true;
    saveBtn.textContent = t('status.saving');

    try {
        // Use new thumbnail if uploaded, otherwise keep old one
        const thumbnailUrl = editStreamState.newThumbnailUrl || editStreamState.liveData?.thumbnail || '';

        // Build event tags
        const eventTags = [
            ['d', dTag],
            ['title', title],
            ['summary', description],
            ['streaming', streamUrl],
            ['status', status],
            ['starts', String(starts)],
            ['t', 'pv69420'],
        ];

        // Add ends tag if stream has ended
        if (ends) {
            eventTags.push(['ends', String(ends)]);
        }

        // Add thumbnail
        if (thumbnailUrl) {
            eventTags.push(['image', thumbnailUrl]);
        }

        // Add content tags
        tags.forEach(tag => {
            eventTags.push(['t', tag.toLowerCase()]);
        });

        // Add NSFW tag if applicable
        if (isNSFW) {
            eventTags.push(['content-warning', 'nsfw']);
        }

        // Add zap goal if specified
        if (zapGoal && parseInt(zapGoal) > 0) {
            eventTags.push(['goal', zapGoal]);
        }

        // Add host participant
        eventTags.push(['p', currentUser.pubkey, '', 'Host']);

        const event = {
            kind: NIP53_LIVE_EVENT_KIND,
            created_at: Math.floor(Date.now() / 1000),
            tags: eventTags,
            content: ''
        };

        const signedEvent = await signEvent(event);
        if (!signedEvent) {
            throw new Error('Failed to sign event');
        }

        await publishEvent(signedEvent);

        // Update in allEvents (remove old, add new)
        allEvents.delete(editStreamState.eventId);
        allEvents.set(signedEvent.id, signedEvent);

        hideEditStreamModal();

        // Refresh the page to show updated data
        navigateTo(`/live/${signedEvent.id}`);

    } catch (error) {
        console.error('Failed to update stream:', error);
        alert(t('alert.failedUpdateStream'));
    } finally {
        saveBtn.disabled = false;
        saveBtn.textContent = t('common.saveChanges');
    }
}

// Initialize edit stream form handler
function initEditStreamForm() {
    const editForm = document.getElementById('editStreamForm');
    if (editForm) {
        editForm.addEventListener('submit', handleEditStream);
    }
}

// ===== NIP-53 Live Event Parsing =====
function parseLiveEvent(event) {
    if (event.kind !== NIP53_LIVE_EVENT_KIND) return null;

    const getTags = (name) => event.tags.filter(t => t[0] === name);
    const getTag = (name) => event.tags.find(t => t[0] === name)?.[1] || '';

    const status = getTag('status') || 'live';
    const startsTag = getTag('starts');
    const endsTag = getTag('ends');

    return {
        id: event.id,
        pubkey: event.pubkey,
        dTag: getTag('d'),
        title: getTag('title') || 'Untitled Stream',
        summary: getTag('summary') || '',
        thumbnail: getTag('image') || getTag('thumb') || '',
        streamUrl: getTag('streaming') || '',
        recordingUrl: getTag('recording') || '',
        status: status,
        starts: startsTag ? parseInt(startsTag) : event.created_at,
        ends: endsTag ? parseInt(endsTag) : null,
        currentParticipants: parseInt(getTag('current_participants')) || 0,
        totalParticipants: parseInt(getTag('total_participants')) || 0,
        participants: getTags('p').map(t => ({
            pubkey: t[1],
            relay: t[2] || '',
            role: t[3] || 'Participant',
            proof: t[4] || ''
        })),
        tags: getTags('t').map(t => t[1]).filter(t => t !== 'pv69420'),
        isNSFW: event.tags.some(t => t[0] === 'content-warning'),
        pinnedMessage: getTag('pinned'),
        zapGoal: parseInt(getTag('goal')) || 0,
        zapGoalSince: parseInt(getTag('goal_since')) || 0,
        createdAt: event.created_at
    };
}

function isLiveEvent(event) {
    return event.kind === NIP53_LIVE_EVENT_KIND;
}

function isLiveStreamActive(liveData) {
    return liveData.status === 'live';
}

function isLiveStreamScheduled(liveData) {
    return liveData.status === 'planned';
}

function isLiveStreamEnded(liveData) {
    return liveData.status === 'ended';
}

// ===== Live Stream Page =====
async function playLiveStream(eventId, skipNSFWCheck = false, skipRatioedCheck = false) {
    currentView = 'live';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = '<div class="spinner"></div>';

    // Scroll to top of page
    window.scrollTo(0, 0);

    try {
        let event = allEvents.get(eventId);

        if (!event) {
            event = await fetchLiveEvent(eventId);
        }

        if (!event) {
            mainContent.innerHTML = `<div class="error-message">${t('error.liveStreamNotFound')}</div>`;
            return;
        }

        const liveData = parseLiveEvent(event);
        if (!liveData) {
            mainContent.innerHTML = `<div class="error-message">${t('error.invalidLiveStreamData')}</div>`;
            return;
        }

        const profile = await fetchUserProfile(event.pubkey);
        const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
        const avatarUrl = profile?.picture || profile?.avatar || '';
        const nip05 = profile?.nip05 || '';

        // Check if this is the user's own stream
        const isOwnStream = currentUser?.pubkey === event.pubkey;

        // Check NSFW (skip for own streams)
        const isNSFW = liveData.isNSFW || false;
        if (!isOwnStream && !skipNSFWCheck && isNSFW && !shouldShowNSFW()) {
            showNSFWModal('playLive', eventId);
            return;
        }

        // Check Community Warning (skip for own streams)
        const cachedReactions = reactionsCache.get(eventId) || {};
        const isRatioed = isVideoRatioed(cachedReactions);
        const isProfileSuspicious = profileCache.has(event.pubkey) && (!profile || !avatarUrl || !nip05);
        const isReportedByFollowsCheck = isReportedByFollowsSync(eventId, event.pubkey);

        if (!isOwnStream && !skipRatioedCheck && (isRatioed || isProfileSuspicious || isReportedByFollowsCheck)
            && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning()) {
            showRatioedModal(eventId, 'live');
            return;
        }

        // Update page title
        document.title = `${liveData.title} - Live on Plebs`;

        // Add to watch history
        addToWatchHistory(eventId, event.tags || [], event.pubkey);

        // Determine status badge
        let statusBadge = '';
        let statusClass = '';
        if (isLiveStreamActive(liveData)) {
            statusBadge = 'LIVE';
            statusClass = '';
        } else if (isLiveStreamScheduled(liveData)) {
            statusBadge = 'SCHEDULED';
            statusClass = 'scheduled';
        } else {
            statusBadge = 'ENDED';
            statusClass = 'ended';
        }

        // Get stream embed
        const streamEmbed = getStreamEmbed(liveData.streamUrl, liveData.status);

        // Scheduled stream overlay
        let scheduleOverlay = '';
        if (isLiveStreamScheduled(liveData)) {
            const scheduleDate = new Date(liveData.starts * 1000);
            scheduleOverlay = `
                <div class="stream-overlay">
                    ${liveData.thumbnail ? `<img src="${liveData.thumbnail}" class="thumbnail-preview" alt="Stream thumbnail">` : ''}
                    <h2>Stream Starting Soon</h2>
                    <p>Scheduled for ${scheduleDate.toLocaleDateString()} at ${scheduleDate.toLocaleTimeString()}</p>
                    <div class="stream-countdown" id="stream-countdown"></div>
                    <p>Chat is open - join the conversation!</p>
                </div>
            `;
        }

        // Ended stream overlay
        let endedOverlay = '';
        if (isLiveStreamEnded(liveData)) {
            endedOverlay = `
                <div class="stream-overlay">
                    ${liveData.thumbnail ? `<img src="${liveData.thumbnail}" class="thumbnail-preview" alt="Stream thumbnail">` : ''}
                    <h2>Stream Ended</h2>
                    <p>This live stream has ended.</p>
                    ${liveData.zapGoal > 0 ? `
                        <div class="ended-zap-goal" id="ended-zap-goal" data-goal="${liveData.zapGoal}" data-event-id="${event.id}">
                            <div class="ended-zap-goal-header">
                                <svg viewBox="0 0 24 24" fill="currentColor" class="zap-icon">
                                    <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                                </svg>
                                <span>Zap Goal</span>
                            </div>
                            <div class="ended-zap-goal-progress">
                                <span class="ended-zap-current" id="ended-zap-current">0</span>
                                <span class="ended-zap-separator">/</span>
                                <span class="ended-zap-target">${formatSatsExact(liveData.zapGoal)}</span>
                            </div>
                            <div class="ended-zap-goal-bar">
                                <div class="ended-zap-goal-fill" id="ended-zap-goal-fill" style="width: 0%"></div>
                            </div>
                            <div class="ended-zap-goal-status" id="ended-zap-goal-status"></div>
                        </div>
                    ` : ''}
                    ${liveData.recordingUrl ? `<a href="${liveData.recordingUrl}" class="upload-btn" style="margin-top: 1rem;">Watch Recording</a>` : ''}
                </div>
            `;
        }

        mainContent.innerHTML = `
            <div class="live-stream-container">
                <div class="live-stream-main">
                    <div class="live-stream-player">
                        ${streamEmbed}
                        <div class="live-status-overlay">
                            <div class="live-status-badge ${statusClass}">${statusBadge}</div>
                            <div class="live-viewer-count" id="live-viewer-count">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                                </svg>
                                <span id="viewer-count-number">${liveData.currentParticipants}</span> watching
                            </div>
                        </div>
                        ${liveData.zapGoal > 0 ? `
                        <div class="live-zap-goal" id="live-zap-goal" data-goal="${liveData.zapGoal}" data-goalsince="${liveData.zapGoalSince || 0}" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-dtag="${liveData.dTag}">
                            <div class="zap-goal-header">
                                <svg viewBox="0 0 24 24" fill="currentColor" class="zap-icon">
                                    <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                                </svg>
                                <span class="zap-goal-text">
                                    <span class="zap-current" id="zap-current-amount">0</span>
                                    <span class="zap-separator">/</span>
                                    <span class="zap-target" id="zap-target-amount">${formatSatsExact(liveData.zapGoal)}</span>
                                </span>
                            </div>
                            <div class="zap-goal-bar">
                                <div class="zap-goal-fill" id="zap-goal-fill" style="width: 0%"></div>
                            </div>
                            ${isOwnStream ? `
                            <div class="zap-goal-reset-form" id="zap-goal-reset-form">
                                <div class="reset-form-inner">
                                    <label>Set new goal (sats)</label>
                                    <div class="reset-input-row">
                                        <input type="number" id="new-zap-goal-input" placeholder="e.g. 10000" min="1">
                                        <button onclick="resetZapGoal()">Reset</button>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                        ` : ''}
                        ${scheduleOverlay}
                        ${endedOverlay}
                    </div>

                    <div class="live-stream-details">
                        <h1>${escapeHtml(liveData.title)}</h1>
                        <div class="video-meta">
                            Started ${formatTimestamp(liveData.starts)}
                            ${isNSFW ? ' • <span style="color: #f44336;">NSFW</span>' : ''}
                            <span class="community-warning-indicator" style="${(isRatioed || isProfileSuspicious || isReportedByFollowsCheck) && !isNSFW ? '' : 'display: none;'}"> • <span style="color: #ff9800;">Community Warning</span></span>
                            • <span class="report-flag" onclick="showReportModal('${event.id}', '${event.pubkey}')" title="${t('action.reportStream')}">${t('action.report')}</span>
                        </div>
                        <div class="video-channel-info">
                            <a href="#/profile/${event.pubkey}" class="channel-info" style="text-decoration: none;">
                                <div class="channel-avatar">
                                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                                </div>
                                <div class="channel-details">
                                    <div class="channel-name">${displayName}</div>
                                    ${profile?.nip05 ? `<div class="channel-nip05">${profile.nip05}</div>` : ''}
                                    <div class="channel-stats" id="channel-stats-${event.pubkey}">
                                        <span class="channel-stat loading">
                                            <span class="stat-value">-</span> videos
                                        </span>
                                        <span class="channel-stat-separator">•</span>
                                        <span class="channel-stat loading">
                                            <span class="stat-value">-</span> followers
                                        </span>
                                    </div>
                                </div>
                            </a>
                            <div class="channel-actions" id="channel-actions-${event.pubkey}">
                                ${currentUser && currentUser.pubkey !== event.pubkey ? `
                                    <button class="channel-follow-btn loading" disabled>
                                        <span class="spinner-small"></span>
                                    </button>
                                    <button class="channel-mute-btn loading" disabled>
                                        <span class="spinner-small"></span>
                                    </button>
                                ` : ''}
                            </div>
                        </div>

                        <div class="video-actions" style="margin-top: 1rem;" id="live-stream-actions-${event.id}">
                            <button class="action-btn like" onclick="handleLiveLike('${event.id}')" data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                                </svg>
                                <span class="count live-like-count" data-event-id="${event.id}">0</span>
                            </button>
                            <button class="action-btn dislike" onclick="handleLiveDislike('${event.id}')" data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                                </svg>
                                <span class="count live-dislike-count" data-event-id="${event.id}">0</span>
                            </button>
                            <button class="action-btn zap ${currentUser && currentUser.pubkey === event.pubkey ? 'self-content' : ''}"
                                    onclick="${currentUser && currentUser.pubkey === event.pubkey ? '' : `handleZap('${window.NostrTools.nip19.npubEncode(event.pubkey)}', 1000, '${event.id}')`}"
                                    data-event-id="${event.id}"
                                    ${currentUser && currentUser.pubkey === event.pubkey ? `title="${t('zap.cannotZapOwnContent')}"` : ''}>
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                                </svg>
                                <span class="count">Zap</span>
                            </button>
                            <button class="action-btn boost" onclick="handleBoost('${event.id}')" data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                                </svg>
                                <span class="count">Boost</span>
                            </button>
                            <button class="action-btn" onclick="shareLiveStream('${event.id}')">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
                                </svg>
                                Share
                            </button>
                            ${currentUser && currentUser.pubkey === event.pubkey ? `
                                <div class="video-owner-actions-row">
                                    <button class="action-btn edit" onclick="showEditStreamModal('${event.id}')">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                                        </svg>
                                        Edit
                                    </button>
                                    ${!isLiveStreamEnded(liveData) ? `
                                        <button class="action-btn delete" onclick="endLiveStream('${event.id}')">
                                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M6 6h12v12H6z"/>
                                            </svg>
                                            End Stream
                                        </button>
                                    ` : ''}
                                </div>
                            ` : ''}
                        </div>

                        <div style="margin-top: 1.5rem;">
                            <h3>Description</h3>
                            <div class="video-description-container">
                                <div id="video-description" class="video-description ${liveData.summary && liveData.summary.length > 300 ? 'collapsed' : ''}">
                                    <p style="white-space: pre-wrap; margin-top: 0.5rem;">${liveData.summary ? processTextWithLinks(liveData.summary) : t('live.noDescription')}</p>
                                </div>
                                ${liveData.summary && liveData.summary.length > 300 ? `
                                    <button id="description-toggle" class="description-toggle-btn" onclick="toggleDescription()">
                                        Show More
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                        ${liveData.tags.length > 0 ? `
                            <div class="tags" style="margin-top: 0.5rem;">
                                ${liveData.tags.map(tag => `<span class="tag" onclick="navigateTo('/tag/${tag.toLowerCase()}')">#${tag}</span>`).join('')}
                            </div>
                        ` : ''}
                    </div>

                    <!-- Also Live Section - inside main content area -->
                    <div class="also-live-section" id="also-live-section" style="display: none;">
                        <div class="also-live-header">
                            <h3>
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                    <circle cx="12" cy="12" r="4" fill="#f44336"/>
                                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                                </svg>
                                Also Live
                            </h3>
                        </div>
                        <div class="also-live-grid" id="also-live-grid"></div>
                    </div>
                </div>

                <div class="live-chat-sidebar" id="live-chat-sidebar">
                    <div class="live-chat-header">
                        <h3>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"/>
                            </svg>
                            ${isLiveStreamEnded(liveData) ? 'Chat (Ended)' : 'Live Chat'}
                        </h3>
                        <div class="chat-header-actions">
                            <div class="chat-viewers">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                                </svg>
                                <span id="chat-viewer-count">${liveData.currentParticipants}</span>
                            </div>
                            <button class="chat-collapse-btn" onclick="toggleLiveChat()" title="${t('button.toggleChat')}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="collapse-icon">
                                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                                </svg>
                            </button>
                        </div>
                    </div>

                    <div class="live-chat-messages" id="live-chat-messages">
                        <div class="chat-message system-message">${isLiveStreamEnded(liveData) ? t('stream.ended') : t('stream.welcomeChat')}</div>
                    </div>

                    ${isLiveStreamEnded(liveData) ? `
                        <div class="live-chat-input-container">
                            <div class="live-chat-input-wrapper">
                                <input type="text" class="live-chat-input" id="live-chat-input" placeholder="${t('placeholder.chatEnded')}" disabled maxlength="500">
                                <button class="live-chat-send-btn" id="live-chat-send" disabled>
                                    <svg viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    ` : currentUser ? `
                        <div class="live-chat-input-container">
                            <div class="live-chat-input-wrapper">
                                <input type="text" class="live-chat-input" id="live-chat-input" placeholder="${t('placeholder.addComment')}" maxlength="500">
                                <button class="live-chat-send-btn" id="live-chat-send" onclick="sendLiveChatMessage('${event.id}')">
                                    <svg viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    ` : `
                        <div class="chat-login-prompt">
                            <p>Login to join the chat</p>
                            <button onclick="ensureLoggedIn()">Login</button>
                        </div>
                    `}
                </div>
            </div>
        `;

        // Restore live chat collapsed state
        restoreLiveChatState();

        // Setup chat input enter key handler
        const chatInput = document.getElementById('live-chat-input');
        if (chatInput) {
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendLiveChatMessage(event.id);
                }
            });
        }

        // Start loading live chat
        loadLiveChat(event.id, event.pubkey, liveData.dTag);

        // Start countdown if scheduled
        if (isLiveStreamScheduled(liveData)) {
            startStreamCountdown(liveData.starts);
        }

        // Note: trackLiveViewer is now called at the end of setupLiveChatSubscription
        // to avoid the interval being cleared by cleanupLiveChatSubscriptions

        // Load reactions (likes/dislikes) for the live stream
        loadLiveStreamReactions(event.id);

        // Load zap count for the zap button
        loadZapsForVideo(event.id).then(zapData => {
            updateZapButton(event.id, zapData.totalZaps);
        });

        // Load boost count for the boost button
        loadBoostsForVideo(event.id).then(boostData => {
            updateBoostButton(event.id, boostData.totalBoosts);
        });

        // Initialize zap goal tracking if there's a goal set
        if (liveData.zapGoal > 0) {
            if (isLiveStreamEnded(liveData)) {
                // For ended streams, just load the final zap total
                loadEndedStreamZapGoal(event.id, liveData.zapGoal);
            } else {
                // For active streams, track in real-time
                initLiveStreamZapGoal(event.id, liveData.zapGoal);
            }
        }

        // Load channel stats and actions (follow/mute buttons)
        setTimeout(() => loadChannelStats(event.pubkey), 100);

        // Load "Also Live" section with recommendation-based related live streams
        loadAlsoLive(event.pubkey, liveData.dTag, liveData.tags);

        // Validate NIP-05 and add checkmark if valid
        if (profile?.nip05) {
            // Check cache first
            if (profileValidationCache.has(event.pubkey)) {
                const cached = profileValidationCache.get(event.pubkey);
                if (cached.nip05Valid) {
                    const channelNip05 = document.querySelector('.live-stream-details .channel-nip05');
                    applyNip05Checkmark(channelNip05, true);
                }
            } else {
                // Validate asynchronously
                validateNip05(profile.nip05, event.pubkey).then(isValid => {
                    if (isValid) {
                        const channelNip05 = document.querySelector('.live-stream-details .channel-nip05');
                        applyNip05Checkmark(channelNip05, true);
                    }
                });
            }
        }

    } catch (error) {
        console.error('Failed to load live stream:', error);
        mainContent.innerHTML = `<div class="error-message">${t('error.failedLoadLiveStream')}</div>`;
    }
}

function getStreamEmbed(streamUrl, status) {
    if (!streamUrl || status === 'planned' || status === 'ended') {
        return '<div style="width: 100%; height: 100%; background: #000;"></div>';
    }

    // Check for common streaming services
    if (streamUrl.includes('youtube.com') || streamUrl.includes('youtu.be')) {
        const videoId = streamUrl.match(/(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([^&\s]+)/)?.[1];
        if (videoId) {
            return `<iframe src="https://www.youtube.com/embed/${videoId}?autoplay=1" allow="autoplay; encrypted-media" allowfullscreen></iframe>`;
        }
    }

    if (streamUrl.includes('twitch.tv')) {
        const channel = streamUrl.match(/twitch\.tv\/([^\/\?]+)/)?.[1];
        if (channel) {
            return `<iframe src="https://player.twitch.tv/?channel=${channel}&parent=${window.location.hostname}" allow="autoplay; encrypted-media" allowfullscreen></iframe>`;
        }
    }

    // HLS/m3u8 streams
    if (streamUrl.endsWith('.m3u8') || streamUrl.includes('m3u8')) {
        return `
            <video id="live-video-player" controls autoplay playsinline>
                <source src="${streamUrl}" type="application/x-mpegURL">
            </video>
            <script>
                if (Hls && Hls.isSupported()) {
                    var video = document.getElementById('live-video-player');
                    var hls = new Hls();
                    hls.loadSource('${streamUrl}');
                    hls.attachMedia(video);
                }
            </script>
        `;
    }

    // Default video player
    return `<video controls autoplay playsinline><source src="${streamUrl}"></video>`;
}

function startStreamCountdown(startTime) {
    const countdownEl = document.getElementById('stream-countdown');
    if (!countdownEl) return;

    const updateCountdown = () => {
        const now = Math.floor(Date.now() / 1000);
        const diff = startTime - now;

        if (diff <= 0) {
            countdownEl.textContent = t('status.startingNow');
            // Reload page to show live stream
            setTimeout(() => location.reload(), 2000);
            return;
        }

        const hours = Math.floor(diff / 3600);
        const minutes = Math.floor((diff % 3600) / 60);
        const seconds = diff % 60;

        if (hours > 0) {
            countdownEl.textContent = `${hours}h ${minutes}m ${seconds}s`;
        } else if (minutes > 0) {
            countdownEl.textContent = `${minutes}m ${seconds}s`;
        } else {
            countdownEl.textContent = `${seconds}s`;
        }
    };

    updateCountdown();
    setInterval(updateCountdown, 1000);
}

async function fetchLiveEvent(eventId) {
    return new Promise((resolve) => {
        let found = false;
        requestEventsStream({ kinds: [NIP53_LIVE_EVENT_KIND], ids: [eventId] }, (event) => {
            if (!found) {
                found = true;
                allEvents.set(event.id, event);
                resolve(event);
            }
        }, () => {
            if (!found) resolve(null);
        });
    });
}

// Toggle live chat sidebar visibility
function toggleLiveChat() {
    const sidebar = document.getElementById('live-chat-sidebar');
    if (!sidebar) return;

    sidebar.classList.toggle('collapsed');

    // Save preference
    const isCollapsed = sidebar.classList.contains('collapsed');
    localStorage.setItem('liveChatCollapsed', isCollapsed ? 'true' : 'false');
}

// Restore live chat collapsed state
function restoreLiveChatState() {
    const sidebar = document.getElementById('live-chat-sidebar');
    if (!sidebar) return;

    const isCollapsed = localStorage.getItem('liveChatCollapsed') === 'true';
    if (isCollapsed) {
        sidebar.classList.add('collapsed');
    }
}

// ===== Live Chat System =====
async function loadLiveChat(eventId, pubkey, dTag) {
    const chatContainer = document.getElementById('live-chat-messages');
    if (!chatContainer) return;

    // Clear the welcome message when loading actual chat
    chatContainer.innerHTML = '';

    // Store current stream info including the streamer's pubkey
    currentLiveChat.streamId = eventId;
    currentLiveChat.eventId = eventId;
    currentLiveChat.streamerPubkey = pubkey; // Store streamer pubkey for badge
    currentLiveChat.dTag = dTag;
    currentLiveChat.messages = [];
    currentLiveChat.zapEventIds = new Set(); // Track zap events to avoid duplicates
    currentLiveChat.chatParticipants = new Map(); // Reset chat participants

    // Subscribe to live chat messages (kind 1311)
    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${pubkey}:${dTag}`;

    const filter = {
        kinds: [NIP53_LIVE_CHAT_KIND],
        '#a': [aTagValue],
        limit: 100
    };

    // Also load zaps for this stream to show in chat
    const zapFilter = {
        kinds: [9735],
        '#e': [eventId],
        limit: 50
    };

    // Load existing messages
    requestEventsStream(filter, (event) => {
        // Track participant immediately (before async profile fetch in addChatMessage)
        currentLiveChat.chatParticipants.set(event.pubkey, event.created_at);
        addChatMessage(event, chatContainer);
    }, () => {
        // After loading existing messages, scroll to bottom (newest messages are at bottom)
        // Use multiple delayed scrolls to ensure messages are rendered after async profile fetches
        chatContainer.scrollTop = chatContainer.scrollHeight;
        setTimeout(() => {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }, 100);
        setTimeout(() => {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }, 500);

        // Calculate initial chat user count after loading all messages
        // Update immediately and again after a short delay to catch any async updates
        updateActiveChatUserCount();
        setTimeout(() => {
            updateActiveChatUserCount();
        }, 500);

        // Re-filter for muted users after initial load (handles race condition with mute list loading)
        // Call multiple times with increasing delays to catch slow mute list loads
        setTimeout(() => filterMutedChatMessages(), 500);
        setTimeout(() => filterMutedChatMessages(), 1500);
        setTimeout(() => filterMutedChatMessages(), 3000);
    });

    // Load zaps and display as notifications
    requestEventsStream(zapFilter, (event) => {
        addZapNotification(event, chatContainer, false);
    });

    // Set up real-time subscription for new messages and zaps
    setupLiveChatSubscription(aTagValue, chatContainer, eventId);
}

function setupLiveChatSubscription(aTagValue, chatContainer, eventId) {
    // Clean up any existing subscriptions first
    cleanupLiveChatSubscriptions();

    // Store subscription info for cleanup
    currentLiveChat.aTagValue = aTagValue;
    currentLiveChat.subscriptionStartTime = Math.floor(Date.now() / 1000);

    // Subscribe to new messages in real-time using persistent subscription
    const messageFilter = {
        kinds: [NIP53_LIVE_CHAT_KIND],
        '#a': [aTagValue],
        since: currentLiveChat.subscriptionStartTime
    };

    // Subscribe to new zaps in real-time (use #a for persistence across stream updates)
    const zapFilter = {
        kinds: [9735],
        '#a': [aTagValue],
        since: currentLiveChat.subscriptionStartTime
    };

    // Subscribe to new reactions (likes/dislikes) on the live stream (use #a for persistence)
    const reactionFilter = {
        kinds: [7],
        '#a': [aTagValue],
        since: currentLiveChat.subscriptionStartTime
    };

    // Subscribe to new viewer presence events
    // Parse aTagValue to get pubkey and dTag for building the d-tag pattern
    const aTagParts = aTagValue.split(':');
    const streamerPubkey = aTagParts[1];
    const streamDTag = aTagParts.slice(2).join(':'); // In case dTag contains colons
    const viewerDTagPattern = `${LIVE_VIEWER_TRACKING_APP_ID}/${streamerPubkey}:${streamDTag}`;

    const viewerFilter = {
        kinds: [VIEW_EVENT_KIND],
        '#d': [viewerDTagPattern],
        since: currentLiveChat.subscriptionStartTime
    };

    // Use persistent subscription for real-time chat messages (doesn't close after EOSE)
    currentLiveChat.messageSubscription = subscribePersistent(messageFilter, (event) => {
        // Check for duplicates
        if (!currentLiveChat.messages.some(m => m.id === event.id)) {
            addChatMessage(event, chatContainer, true);
        }
    });

    // Use persistent subscription for real-time zaps
    currentLiveChat.zapSubscription = subscribePersistent(zapFilter, (event) => {
        addZapNotification(event, chatContainer, true);
    });

    // Use persistent subscription for real-time reactions on the live stream
    currentLiveChat.reactionSubscription = subscribePersistent(reactionFilter, (event) => {
        // Update live stream like/dislike counts in real-time
        const likeCount = document.querySelector(`.live-like-count[data-event-id="${eventId}"]`);
        const dislikeCount = document.querySelector(`.live-dislike-count[data-event-id="${eventId}"]`);

        if (event.content === '+' || event.content === '👍') {
            if (likeCount) {
                const current = parseInt(likeCount.textContent) || 0;
                likeCount.textContent = formatNumber(current + 1);
            }
        } else if (event.content === '-' || event.content === '👎') {
            if (dislikeCount) {
                const current = parseInt(dislikeCount.textContent) || 0;
                dislikeCount.textContent = formatNumber(current + 1);
            }
        }
    });

    // Use persistent subscription for real-time viewer presence updates
    currentLiveChat.viewerSubscription = subscribePersistent(viewerFilter, (event) => {
        // When a new viewer presence event comes in, refresh the viewer count
        loadLiveViewers(eventId);
    });

    // Subscribe to live event updates (for zap goal changes, status changes, etc.)
    const liveEventFilter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        authors: [streamerPubkey],
        '#d': [streamDTag],
        since: currentLiveChat.subscriptionStartTime
    };

    currentLiveChat.liveEventSubscription = subscribePersistent(liveEventFilter, (event) => {
        handleLiveEventUpdate(event, eventId);
    });

    // Set up periodic refresh as backup to catch any missed messages (every 15 seconds)
    if (currentLiveChat.refreshInterval) {
        clearInterval(currentLiveChat.refreshInterval);
    }
    currentLiveChat.refreshInterval = setInterval(() => {
        refreshLiveChatMessages(aTagValue, chatContainer, eventId);
    }, 15000);

    // Set up interval to refresh viewer count and chat user counts (every 30 seconds)
    if (currentLiveChat.chatUserCountInterval) {
        clearInterval(currentLiveChat.chatUserCountInterval);
    }
    currentLiveChat.chatUserCountInterval = setInterval(() => {
        loadLiveViewers(eventId); // Refresh viewer count from relays
        updateActiveChatUserCount();
        refreshChatMessageReactionsAndZaps(); // Refresh reactions/zaps on chat messages
    }, 30000);

    // Start viewer presence tracking (must be after cleanup to avoid interval being cleared)
    trackLiveViewer(eventId);
}

// Clean up live chat subscriptions when leaving the page
function cleanupLiveChatSubscriptions() {
    if (currentLiveChat.messageSubscription) {
        currentLiveChat.messageSubscription.unsubscribe();
        currentLiveChat.messageSubscription = null;
    }
    if (currentLiveChat.zapSubscription) {
        currentLiveChat.zapSubscription.unsubscribe();
        currentLiveChat.zapSubscription = null;
    }
    if (currentLiveChat.reactionSubscription) {
        currentLiveChat.reactionSubscription.unsubscribe();
        currentLiveChat.reactionSubscription = null;
    }
    if (currentLiveChat.viewerSubscription) {
        currentLiveChat.viewerSubscription.unsubscribe();
        currentLiveChat.viewerSubscription = null;
    }
    if (currentLiveChat.liveEventSubscription) {
        currentLiveChat.liveEventSubscription.unsubscribe();
        currentLiveChat.liveEventSubscription = null;
    }
    if (currentLiveChat.refreshInterval) {
        clearInterval(currentLiveChat.refreshInterval);
        currentLiveChat.refreshInterval = null;
    }
    if (currentLiveChat.chatUserCountInterval) {
        clearInterval(currentLiveChat.chatUserCountInterval);
        currentLiveChat.chatUserCountInterval = null;
    }
    if (currentLiveChat.viewerTrackingInterval) {
        clearInterval(currentLiveChat.viewerTrackingInterval);
        currentLiveChat.viewerTrackingInterval = null;
    }
}

// Handle real-time updates to the live event (zap goal changes, etc.)
function handleLiveEventUpdate(event, currentEventId) {
    const liveData = parseLiveEvent(event);
    if (!liveData) return;

    // Update the zap goal if it changed
    const zapGoalEl = document.getElementById('live-zap-goal');
    if (zapGoalEl) {
        const currentGoal = parseInt(zapGoalEl.dataset.goal) || 0;
        const currentGoalSince = parseInt(zapGoalEl.dataset.goalsince) || 0;
        const newGoal = liveData.zapGoal || 0;
        const newGoalSince = liveData.zapGoalSince || 0;

        // Check if this is a goal reset (new goal_since timestamp)
        const isGoalReset = newGoalSince > 0 && newGoalSince !== currentGoalSince;

        if ((newGoal !== currentGoal && newGoal > 0) || isGoalReset) {
            // Update the goal display
            zapGoalEl.dataset.goal = newGoal;
            zapGoalEl.dataset.goalsince = newGoalSince;

            const targetEl = document.getElementById('zap-target-amount');
            if (targetEl) {
                targetEl.textContent = formatSatsExact(newGoal);
            }

            // If goal was reset, start fresh
            if (isGoalReset) {
                // Reset zap counter to 0 for new goal
                liveStreamZapTotal = 0;
                zapGoalReachedMessageShown = false;

                zapGoalEl.classList.remove('goal-reached');
                const resetFormEl = document.getElementById('zap-goal-reset-form');
                if (resetFormEl) {
                    resetFormEl.classList.remove('visible');
                }

                // Restart zap subscription with new goal_since filter
                const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${event.pubkey}:${liveData.dTag}`;
                subscribeLiveStreamZaps(aTagValue, newGoal, new Set(), newGoalSince);

                updateZapGoalDisplay(0, newGoal, false);

                // Announce new zap goal in chat
                addNewZapGoalMessage(newGoal);
            } else if (newGoal > currentGoal) {
                // Goal increased but not reset - keep current progress
                zapGoalEl.classList.remove('goal-reached');
                const resetFormEl = document.getElementById('zap-goal-reset-form');
                if (resetFormEl) {
                    resetFormEl.classList.remove('visible');
                }
                zapGoalReachedMessageShown = false;
                updateZapGoalDisplay(liveStreamZapTotal || 0, newGoal, false);

                // Announce new zap goal in chat
                addNewZapGoalMessage(newGoal);
            } else if (newGoal !== currentGoal) {
                // Goal decreased - recalculate with current zaps
                updateZapGoalDisplay(liveStreamZapTotal || 0, newGoal, false);

                // Announce new zap goal in chat
                addNewZapGoalMessage(newGoal);
            }

            // Update allEvents with the new event
            allEvents.delete(currentEventId);
            allEvents.set(event.id, event);
        }
    }

    // Update browser URL and data attributes if event ID changed (so refresh works)
    if (event.id !== currentEventId) {
        const newUrl = `#/live/${event.id}`;
        history.replaceState(null, '', newUrl);

        // Update data-event-id attributes on the page
        document.querySelectorAll(`[data-event-id="${currentEventId}"]`).forEach(el => {
            el.dataset.eventId = event.id;
        });

        // Update allEvents if not already done
        if (allEvents.has(currentEventId)) {
            allEvents.delete(currentEventId);
            allEvents.set(event.id, event);
        }
    }

    // Handle status changes (e.g., stream ended)
    const statusBadge = document.querySelector('.live-status-badge');
    if (statusBadge && liveData.status) {
        if (liveData.status === 'ended' && !statusBadge.classList.contains('ended')) {
            statusBadge.textContent = t('status.ended');
            statusBadge.classList.add('ended');
            statusBadge.classList.remove('scheduled');
        }
    }
}

// Calculate and update active chat user count (users who chatted in last 5 minutes)
function updateActiveChatUserCount() {
    const fiveMinutesAgo = Math.floor(Date.now() / 1000) - 300; // 5 minutes = 300 seconds

    // Count unique users who have sent a message in the last 5 minutes
    // Use the messages array directly for reliability
    const activeUserPubkeys = new Set();

    currentLiveChat.messages.forEach(msg => {
        if (msg.created_at >= fiveMinutesAgo) {
            activeUserPubkeys.add(msg.pubkey);
        }
    });

    // Also check chatParticipants map (for any participants tracked via subscriptions)
    currentLiveChat.chatParticipants.forEach((lastActivityTime, pubkey) => {
        if (lastActivityTime >= fiveMinutesAgo) {
            activeUserPubkeys.add(pubkey);
        }
    });

    const activeUsers = activeUserPubkeys.size;

    // Update the chat viewer count element
    const chatViewerCountEl = document.getElementById('chat-viewer-count');
    if (chatViewerCountEl) {
        chatViewerCountEl.textContent = formatNumber(activeUsers);
    }
}

// Refresh live chat to catch any missed messages
function refreshLiveChatMessages(aTagValue, chatContainer, eventId) {
    if (!chatContainer || currentView !== 'live') {
        if (currentLiveChat.refreshInterval) {
            clearInterval(currentLiveChat.refreshInterval);
            currentLiveChat.refreshInterval = null;
        }
        return;
    }

    const lastMessageTime = currentLiveChat.messages.length > 0
        ? Math.max(...currentLiveChat.messages.map(m => m.created_at))
        : currentLiveChat.subscriptionStartTime;

    const filter = {
        kinds: [NIP53_LIVE_CHAT_KIND],
        '#a': [aTagValue],
        since: lastMessageTime - 5 // 5 second buffer
    };

    requestEventsStream(filter, (event) => {
        if (!currentLiveChat.messages.some(m => m.id === event.id)) {
            addChatMessage(event, chatContainer, true);
        }
    });
}

// Refresh reactions and zaps for recent chat messages (for real-time updates)
function refreshChatMessageReactionsAndZaps() {
    if (currentView !== 'live' || !currentLiveChat.messages.length) return;

    // Get IDs of recent chat messages (last 50 or so)
    const recentMessages = currentLiveChat.messages.slice(-50);
    const messageIds = recentMessages.map(m => m.id);

    if (messageIds.length === 0) return;

    // Track what we've already counted for each message
    const reactionsPerMessage = new Map(); // eventId -> { likes: 0, dislikes: 0 }
    const zapsPerMessage = new Map(); // eventId -> totalSats

    // Initialize
    messageIds.forEach(id => {
        reactionsPerMessage.set(id, { likes: 0, dislikes: 0 });
        zapsPerMessage.set(id, 0);
    });

    // Load reactions for these messages
    const reactionFilter = {
        kinds: [7],
        '#e': messageIds,
        limit: 500
    };

    requestEventsStream(reactionFilter, (event) => {
        const eTag = event.tags.find(t => t[0] === 'e');
        if (eTag && reactionsPerMessage.has(eTag[1])) {
            const data = reactionsPerMessage.get(eTag[1]);
            if (event.content === '+' || event.content === '👍') {
                data.likes++;
            } else if (event.content === '-' || event.content === '👎') {
                data.dislikes++;
            }
        }
    }, () => {
        // Update UI for reactions
        reactionsPerMessage.forEach((data, eventId) => {
            const likeCount = document.querySelector(`.chat-like-count[data-event-id="${eventId}"]`);
            const dislikeCount = document.querySelector(`.chat-dislike-count[data-event-id="${eventId}"]`);
            if (likeCount) likeCount.textContent = data.likes > 0 ? data.likes : '0';
            if (dislikeCount) dislikeCount.textContent = data.dislikes > 0 ? data.dislikes : '0';
        });
    });

    // Load zaps for these messages
    const zapFilter = {
        kinds: [9735],
        '#e': messageIds,
        limit: 500
    };

    requestEventsStream(zapFilter, (event) => {
        const eTag = event.tags.find(t => t[0] === 'e');
        if (eTag && zapsPerMessage.has(eTag[1])) {
            const bolt11Tag = event.tags.find(t => t[0] === 'bolt11');
            if (bolt11Tag && bolt11Tag[1]) {
                const amount = extractAmountFromBolt11(bolt11Tag[1]);
                if (amount > 0) {
                    zapsPerMessage.set(eTag[1], zapsPerMessage.get(eTag[1]) + amount);
                }
            }
        }
    }, () => {
        // Update UI for zaps
        zapsPerMessage.forEach((totalSats, eventId) => {
            const zapCount = document.querySelector(`.chat-zap-count[data-event-id="${eventId}"]`);
            if (zapCount) zapCount.textContent = totalSats > 0 ? formatSats(totalSats) : '0';
        });
    });
}

async function addChatMessage(event, container, isNew = false) {
    // Prevent duplicates
    if (currentLiveChat.messages.some(m => m.id === event.id)) return;
    currentLiveChat.messages.push(event);

    // Track chat participant activity (update their last activity time)
    currentLiveChat.chatParticipants.set(event.pubkey, event.created_at);

    // Update active chat user count immediately for new messages
    if (isNew) {
        updateActiveChatUserCount();
    }

    // Sort messages by timestamp in ascending order (oldest first, newest at bottom)
    currentLiveChat.messages.sort((a, b) => a.created_at - b.created_at);

    const isOwnMessage = currentUser && currentUser.pubkey === event.pubkey;

    // Check if message is from a muted user (don't hide own messages)
    // Check both the function and direct cache in case mute list is still loading
    const isMutedUser = !isOwnMessage && (shouldHideMutedContent(event.pubkey) ||
        (currentUser && mutedUsersCache.has(event.pubkey) && !sessionUnhiddenMutedUsers.has(event.pubkey)));

    if (isMutedUser) {
        const placeholderHTML = `
            <div class="chat-message muted-chat-message" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-timestamp="${event.created_at}">
                <div class="chat-hidden-placeholder">
                    ${getMuteIconSVG(12)}
                    <span>Message from muted user</span>
                    <button class="chat-unhide-btn" onclick="unhideChatMessage('${event.id}', '${event.pubkey}')">Show</button>
                </div>
            </div>
        `;
        insertChatMessageHTML(container, placeholderHTML, event.created_at, isNew);
        return;
    }

    // Check if message matches content filters
    const filterResult = shouldFilterComment(event.content);
    if (!isOwnMessage && filterResult.filtered && !sessionFilteredAllowed.has(event.id)) {
        const packNames = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.name || p.packName).join(', ');
        const packIcons = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.icon || '🚫').join(' ');
        const placeholderHTML = `
            <div class="chat-message filtered-chat-message" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-timestamp="${event.created_at}">
                <div class="chat-hidden-placeholder">
                    <span>${packIcons}</span>
                    <span>Message hidden (${escapeHtml(packNames)})</span>
                    <button class="chat-unhide-btn" onclick="unhideFilteredChatMessage('${event.id}')">Show</button>
                </div>
            </div>
        `;
        insertChatMessageHTML(container, placeholderHTML, event.created_at, isNew);
        return;
    }

    // Check if message is reported by follows
    if (!isOwnMessage && isReportedByFollowsSync(event.id, event.pubkey) &&
        !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning()) {
        const placeholderHTML = `
            <div class="chat-message reported-chat-message" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-timestamp="${event.created_at}">
                <div class="chat-hidden-placeholder">
                    <span>⚠️</span>
                    <span>Message reported by people you follow</span>
                    <button class="chat-unhide-btn" onclick="unhideReportedChatMessage('${event.id}')">Show</button>
                </div>
            </div>
        `;
        insertChatMessageHTML(container, placeholderHTML, event.created_at, isNew);
        return;
    }

    // Check for @mentions of current user (for notifications)
    if (isNew && currentUser && !isOwnMessage) {
        checkChatMentionNotification(event);
    }

    const profile = await fetchUserProfile(event.pubkey);
    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const authorNpub = window.NostrTools.nip19.npubEncode(event.pubkey);

    // Check if this is the streamer (creator of the live stream)
    const isStreamer = event.pubkey === currentLiveChat.streamerPubkey;

    // Process mentions in content
    const content = processChatMentions(event.content);

    // Streamer badge HTML
    const streamerBadge = isStreamer ? `
        <span class="streamer-badge" title="Streamer">
            <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                <circle cx="12" cy="12" r="4" fill="#f44336"/>
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
            </svg>
        </span>
    ` : '';

    const messageHTML = `
        <div class="chat-message ${isStreamer ? 'streamer-message' : ''}" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-timestamp="${event.created_at}">
            <div class="chat-message-header">
                <div class="chat-message-avatar">
                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                </div>
                <span class="chat-message-author ${isStreamer ? 'streamer-author' : ''}" onclick="navigateTo('/profile/${event.pubkey}')">${streamerBadge}${escapeHtml(displayName)}</span>
                <span class="chat-message-time">${formatChatTime(event.created_at)}</span>
            </div>
            <div class="chat-message-content">${content}</div>
            <div class="chat-message-stats">
                <span class="chat-stat chat-likes" data-event-id="${event.id}">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                    <span class="chat-like-count" data-event-id="${event.id}">0</span>
                </span>
                <span class="chat-stat chat-dislikes" data-event-id="${event.id}">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                    <span class="chat-dislike-count" data-event-id="${event.id}">0</span>
                </span>
                <span class="chat-stat chat-zaps" data-event-id="${event.id}">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                        <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                    </svg>
                    <span class="chat-zap-count" data-event-id="${event.id}">0</span>
                </span>
            </div>
            <div class="chat-message-actions">
                <button class="chat-action-btn chat-like-btn" onclick="likeChatMessage('${event.id}')" title="Like" data-event-id="${event.id}">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                </button>
                <button class="chat-action-btn chat-dislike-btn" onclick="dislikeChatMessage('${event.id}')" title="Dislike" data-event-id="${event.id}">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                </button>
                <button class="chat-action-btn" onclick="replyToChatMessage('${event.id}', '${escapeHtml(displayName)}')" title="Reply">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/>
                    </svg>
                </button>
                ${!isOwnMessage ? `
                    <button class="chat-action-btn chat-zap-btn" onclick="handleZap('${authorNpub}', 100, '${event.id}')" title="Zap" data-event-id="${event.id}">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                        </svg>
                    </button>
                    <button class="chat-action-btn" onclick="handleChatMute('${event.pubkey}')" title="Mute">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69 16.9C4.63 15.55 4 13.85 4 12zm8 8c-1.85 0-3.55-.63-4.9-1.69L18.31 7.1C19.37 8.45 20 10.15 20 12c0 4.42-3.58 8-8 8z"/>
                        </svg>
                    </button>
                    <button class="chat-action-btn" onclick="showReportModal('${event.id}', '${event.pubkey}', 'comment')" title="Report">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"/>
                        </svg>
                    </button>
                ` : ''}
            </div>
        </div>
    `;

    // Insert message in ascending order (oldest first, newest at bottom)
    const existingMessages = container.querySelectorAll('.chat-message[data-timestamp]');
    let inserted = false;
    for (const msg of existingMessages) {
        const msgTimestamp = parseInt(msg.dataset.timestamp);
        // If new message is older than existing, insert before it
        if (event.created_at < msgTimestamp) {
            msg.insertAdjacentHTML('beforebegin', messageHTML);
            inserted = true;
            break;
        }
    }
    // If not inserted yet (newest message), add at the end (bottom)
    if (!inserted) {
        container.insertAdjacentHTML('beforeend', messageHTML);
    }

    // Load reactions and zaps for this message asynchronously
    loadChatMessageReactions(event.id);

    // Auto-scroll to bottom if user is near bottom (since newest messages are at bottom)
    if (isNew && container.scrollHeight - container.scrollTop - container.clientHeight < 100) {
        container.scrollTop = container.scrollHeight;
    }
}

// Helper function to insert chat message HTML in the correct position
function insertChatMessageHTML(container, html, timestamp, isNew) {
    const existingMessages = container.querySelectorAll('.chat-message[data-timestamp]');
    let inserted = false;
    for (const msg of existingMessages) {
        const msgTimestamp = parseInt(msg.dataset.timestamp);
        if (timestamp < msgTimestamp) {
            msg.insertAdjacentHTML('beforebegin', html);
            inserted = true;
            break;
        }
    }
    if (!inserted) {
        container.insertAdjacentHTML('beforeend', html);
    }
    // Auto-scroll for new messages
    if (isNew && container.scrollHeight - container.scrollTop - container.clientHeight < 100) {
        container.scrollTop = container.scrollHeight;
    }
}

// Unhide a muted chat message
function unhideChatMessage(eventId, pubkey) {
    // Temporarily show muted content for this user
    sessionUnhiddenMutedUsers.add(pubkey);
    // Remove the placeholder and reload the message
    const placeholder = document.querySelector(`.chat-message[data-event-id="${eventId}"]`);
    if (placeholder) {
        placeholder.remove();
        // Find the event and re-add it
        const event = currentLiveChat.messages.find(m => m.id === eventId);
        if (event) {
            // Remove from messages array so it can be re-added
            currentLiveChat.messages = currentLiveChat.messages.filter(m => m.id !== eventId);
            const container = document.getElementById('live-chat-messages');
            if (container) {
                addChatMessage(event, container, false);
            }
        }
    }
}

// Unhide a filtered chat message
function unhideFilteredChatMessage(eventId) {
    sessionFilteredAllowed.add(eventId);
    const placeholder = document.querySelector(`.chat-message[data-event-id="${eventId}"]`);
    if (placeholder) {
        placeholder.remove();
        const event = currentLiveChat.messages.find(m => m.id === eventId);
        if (event) {
            currentLiveChat.messages = currentLiveChat.messages.filter(m => m.id !== eventId);
            const container = document.getElementById('live-chat-messages');
            if (container) {
                addChatMessage(event, container, false);
            }
        }
    }
}

// Unhide a reported chat message
function unhideReportedChatMessage(eventId) {
    sessionRatioedAllowed.add(eventId);
    const placeholder = document.querySelector(`.chat-message[data-event-id="${eventId}"]`);
    if (placeholder) {
        placeholder.remove();
        const event = currentLiveChat.messages.find(m => m.id === eventId);
        if (event) {
            currentLiveChat.messages = currentLiveChat.messages.filter(m => m.id !== eventId);
            const container = document.getElementById('live-chat-messages');
            if (container) {
                addChatMessage(event, container, false);
            }
        }
    }
}

// Unhide a ratioed (heavily downvoted) chat message
function unhideRatioedChatMessage(eventId) {
    sessionRatioedAllowed.add(eventId);
    const placeholder = document.querySelector(`.chat-message[data-event-id="${eventId}"]`);
    if (placeholder) {
        placeholder.remove();
        const event = currentLiveChat.messages.find(m => m.id === eventId);
        if (event) {
            currentLiveChat.messages = currentLiveChat.messages.filter(m => m.id !== eventId);
            const container = document.getElementById('live-chat-messages');
            if (container) {
                addChatMessage(event, container, false);
            }
        }
    }
}

// Check if a chat message mentions the current user and show notification
async function checkChatMentionNotification(event) {
    if (!currentUser) return;

    // Don't show notifications from muted users
    if (isUserMuted(event.pubkey)) return;

    // Get current user's profile to check for username mentions
    const myProfile = profileCache.get(currentUser.pubkey);
    const myName = myProfile?.name || myProfile?.display_name || '';

    // Check for @mention of user's name (case insensitive)
    const mentionPattern = new RegExp(`@${myName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');

    if (myName && mentionPattern.test(event.content)) {
        // Show a notification toast
        const senderProfile = await fetchUserProfile(event.pubkey);
        const senderName = senderProfile?.name || senderProfile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
        showToast(`${senderName} mentioned you in live chat`, 'info');

        // Update notification badge
        incrementNotificationBadge();
    }
}

// Increment the notification badge count
function incrementNotificationBadge() {
    const badge = document.querySelector('.notification-badge');
    if (badge) {
        const current = parseInt(badge.textContent) || 0;
        badge.textContent = current + 1;
        badge.style.display = 'flex';
    }
}

// Reply to chat message by adding @mention
function replyToChatMessage(eventId, displayName) {
    const input = document.getElementById('live-chat-input');
    if (!input) return;

    // Add @mention at cursor position or end
    const mention = `@${displayName.replace(/\s+/g, '')} `;
    input.value = mention + input.value;
    input.focus();
    input.setSelectionRange(mention.length, mention.length);
}

// Load reactions (likes/dislikes) and zaps for a chat message
async function loadChatMessageReactions(eventId) {
    const filter = {
        kinds: [7], // Reactions
        '#e': [eventId],
        limit: 50
    };

    const zapFilter = {
        kinds: [9735],
        '#e': [eventId],
        limit: 20
    };

    let likes = 0;
    let dislikes = 0;
    let zapAmount = 0;

    // Load reactions
    requestEventsStream(filter, (event) => {
        if (event.content === '+' || event.content === '👍') {
            likes++;
        } else if (event.content === '-' || event.content === '👎') {
            dislikes++;
        }
    }, () => {
        // Update UI
        const likeCount = document.querySelector(`.chat-like-count[data-event-id="${eventId}"]`);
        const dislikeCount = document.querySelector(`.chat-dislike-count[data-event-id="${eventId}"]`);
        if (likeCount && likes > 0) likeCount.textContent = likes;
        if (dislikeCount && dislikes > 0) dislikeCount.textContent = dislikes;

        // Check if message is ratioed (more dislikes than likes, at least 3 dislikes)
        const isRatioed = dislikes > likes && dislikes >= 3;
        if (isRatioed && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning()) {
            // Find the message element and check if it's not own message
            const msgEl = document.querySelector(`.chat-message[data-event-id="${eventId}"]:not(.ratioed-chat-message)`);
            if (msgEl) {
                const msgPubkey = msgEl.dataset.pubkey;
                // Don't hide own messages
                if (!currentUser || currentUser.pubkey !== msgPubkey) {
                    const timestamp = msgEl.dataset.timestamp;
                    const placeholderHTML = `
                        <div class="chat-message ratioed-chat-message" data-event-id="${eventId}" data-pubkey="${msgPubkey}" data-timestamp="${timestamp}">
                            <div class="chat-hidden-placeholder" style="border-color: #ff9800;">
                                <span style="color: #ff9800;">👎</span>
                                <span>Message heavily downvoted</span>
                                <button class="chat-unhide-btn" onclick="unhideRatioedChatMessage('${eventId}')">Show</button>
                            </div>
                        </div>
                    `;
                    msgEl.outerHTML = placeholderHTML;
                }
            }
        }
    });

    // Load zaps
    requestEventsStream(zapFilter, (event) => {
        const bolt11Tag = event.tags.find(t => t[0] === 'bolt11');
        if (bolt11Tag && bolt11Tag[1]) {
            const amount = extractAmountFromBolt11(bolt11Tag[1]);
            if (amount > 0) zapAmount += amount;
        }
    }, () => {
        const zapCount = document.querySelector(`.chat-zap-count[data-event-id="${eventId}"]`);
        if (zapCount && zapAmount > 0) zapCount.textContent = formatSats(zapAmount);
    });
}

// Dislike a chat message
async function dislikeChatMessage(eventId) {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const event = {
        kind: 7,
        created_at: Math.floor(Date.now() / 1000),
        tags: [['e', eventId]],
        content: '-'
    };

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            // Update UI immediately
            const dislikeCount = document.querySelector(`.chat-dislike-count[data-event-id="${eventId}"]`);
            if (dislikeCount) {
                const current = parseInt(dislikeCount.textContent) || 0;
                dislikeCount.textContent = current + 1;
            }
        }
    } catch (error) {
        console.error('Failed to dislike chat message:', error);
    }
}

async function addZapNotification(event, container, isNew = false) {
    try {
        // Prevent duplicate zap notifications
        if (currentLiveChat.zapEventIds && currentLiveChat.zapEventIds.has(event.id)) return;
        if (currentLiveChat.zapEventIds) currentLiveChat.zapEventIds.add(event.id);

        const bolt11Tag = event.tags.find(t => t[0] === 'bolt11');
        if (!bolt11Tag || !bolt11Tag[1]) return;

        const amount = extractAmountFromBolt11(bolt11Tag[1]);
        if (amount <= 0) return;

        // Get sender from description
        const descTag = event.tags.find(t => t[0] === 'description');
        let senderPubkey = null;
        if (descTag && descTag[1]) {
            try {
                const desc = JSON.parse(descTag[1]);
                senderPubkey = desc.pubkey;
            } catch (e) { }
        }

        // Fetch sender profile if not cached
        let senderName = 'Someone';
        if (senderPubkey) {
            let profile = profileCache.get(senderPubkey);
            if (!profile) {
                // Fetch profile asynchronously
                profile = await fetchUserProfile(senderPubkey);
            }
            senderName = profile?.name || profile?.display_name || `User ${senderPubkey.slice(0, 8)}`;
        }

        const messageHTML = `
            <div class="chat-message zap-notification" data-zap-event-id="${event.id}" data-timestamp="${event.created_at}">
                <div class="chat-message-content">
                    <svg class="zap-icon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                    </svg>
                    ${escapeHtml(senderName)} zapped ${formatSats(amount)} sats!
                </div>
            </div>
        `;

        // Insert zap notification in ascending order (by timestamp)
        const existingMessages = container.querySelectorAll('.chat-message[data-timestamp]');
        let inserted = false;
        for (const msg of existingMessages) {
            const msgTimestamp = parseInt(msg.dataset.timestamp);
            // If zap is older than this message, insert before it
            if (event.created_at < msgTimestamp) {
                msg.insertAdjacentHTML('beforebegin', messageHTML);
                inserted = true;
                break;
            }
        }
        // If not inserted yet (newest), add at the end (bottom)
        if (!inserted) {
            container.insertAdjacentHTML('beforeend', messageHTML);
        }

        // Auto-scroll for new zaps if user is near bottom
        if (isNew && container.scrollHeight - container.scrollTop - container.clientHeight < 100) {
            container.scrollTop = container.scrollHeight;
        }
    } catch (e) {
        console.error('Failed to add zap notification:', e);
    }
}

function processChatMentions(content) {
    // Process @mentions
    return escapeHtml(content).replace(/@(\w+)/g, '<span class="mention">@$1</span>');
}

function formatChatTime(timestamp) {
    const date = new Date(timestamp * 1000);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

async function sendLiveChatMessage(eventId) {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const input = document.getElementById('live-chat-input');
    const message = input.value.trim();

    if (!message) return;

    // Get the stream event to construct the 'a' tag
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    const event = {
        kind: NIP53_LIVE_CHAT_KIND,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
            ['a', aTagValue, '', 'root']
        ],
        content: message
    };

    // Disable input while sending
    input.disabled = true;
    const sendBtn = document.getElementById('live-chat-send');
    sendBtn.disabled = true;

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            input.value = '';

            // Add message to chat immediately
            const chatContainer = document.getElementById('live-chat-messages');
            if (chatContainer) {
                addChatMessage(signedEvent, chatContainer, true);
            }
        }
    } catch (error) {
        console.error('Failed to send chat message:', error);
    } finally {
        input.disabled = false;
        sendBtn.disabled = false;
        input.focus();
    }
}

async function likeChatMessage(eventId) {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const event = {
        kind: 7,
        created_at: Math.floor(Date.now() / 1000),
        tags: [['e', eventId]],
        content: '+'
    };

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            // Update UI immediately
            const likeCount = document.querySelector(`.chat-like-count[data-event-id="${eventId}"]`);
            if (likeCount) {
                const current = parseInt(likeCount.textContent) || 0;
                likeCount.textContent = current + 1;
            }
            // Add visual feedback
            const likeBtn = document.querySelector(`.chat-like-btn[data-event-id="${eventId}"]`);
            if (likeBtn) {
                likeBtn.classList.add('liked');
            }
        }
    } catch (error) {
        console.error('Failed to like chat message:', error);
    }
}

// Track viewer presence - publishes a presence event and sets up periodic updates
async function trackLiveViewer(eventId) {
    // Clear any existing viewer tracking interval
    if (currentLiveChat.viewerTrackingInterval) {
        clearInterval(currentLiveChat.viewerTrackingInterval);
        currentLiveChat.viewerTrackingInterval = null;
    }

    // Record initial view
    console.log('Recording initial viewer presence for:', eventId);
    await recordLiveViewer(eventId);

    // Load current viewer count
    await loadLiveViewers(eventId);

    // Set up interval to send presence updates every 4 minutes (before 5min timeout)
    console.log(`Setting up viewer presence interval (${LIVE_VIEWER_UPDATE_INTERVAL}ms)`);
    currentLiveChat.viewerTrackingInterval = setInterval(async () => {
        console.log('Viewer presence interval fired, checking conditions...');
        console.log('currentView:', currentView, 'eventId match:', currentLiveChat.eventId === eventId);
        if (currentView !== 'live' || currentLiveChat.eventId !== eventId) {
            console.log('Stopping viewer presence interval - view changed or stream changed');
            clearInterval(currentLiveChat.viewerTrackingInterval);
            currentLiveChat.viewerTrackingInterval = null;
            return;
        }
        console.log('Sending viewer presence update...');
        await recordLiveViewer(eventId);
    }, LIVE_VIEWER_UPDATE_INTERVAL); // Every 4 minutes
}

// Publish a live viewer presence event (replaceable - one per user per stream)
async function recordLiveViewer(eventId) {
    const event = allEvents.get(eventId);
    if (!event) return;

    const liveData = parseLiveEvent(event);
    if (!liveData) return;

    const now = Math.floor(Date.now() / 1000);
    const dTagValue = `${LIVE_VIEWER_TRACKING_APP_ID}/${event.pubkey}:${liveData.dTag}`;

    // Build presence event
    const viewerEvent = {
        kind: VIEW_EVENT_KIND,
        created_at: now,
        tags: [
            ['d', dTagValue],
            ['t', 'live-viewer'],
            ['e', eventId],
            ['p', event.pubkey],
            ['client', 'Plebs']
        ],
        content: JSON.stringify({
            timestamp: now,
            streamId: eventId
        })
    };

    try {
        if (currentUser) {
            // Logged-in user: sign with their key
            const signedEvent = await signEvent(viewerEvent);
            if (signedEvent) {
                await publishEvent(signedEvent);
                console.log('Published viewer presence (logged in user)');
            }
        } else {
            // Anonymous user: generate ephemeral keypair
            const sk = window.NostrTools.generateSecretKey();
            const signedEvent = window.NostrTools.finalizeEvent(viewerEvent, sk);
            await publishEvent(signedEvent);
            console.log('Published viewer presence (anonymous user)');
        }
    } catch (e) {
        console.error('Failed to record live viewer:', e);
    }
}

// Load and count active live viewers (those who updated within timeout window)
async function loadLiveViewers(eventId) {
    const event = allEvents.get(eventId);
    if (!event) return 0;

    const liveData = parseLiveEvent(event);
    if (!liveData) return 0;

    const cutoffTime = Math.floor(Date.now() / 1000) - LIVE_VIEWER_TIMEOUT;
    const viewers = new Set();

    // Build the d-tag pattern for this stream's viewers
    const dTagPattern = `${LIVE_VIEWER_TRACKING_APP_ID}/${event.pubkey}:${liveData.dTag}`;

    return new Promise((resolve) => {
        // Use #d filter (canonical for NIP-78 replaceable events) plus #e for reliability
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#d': [dTagPattern],
            limit: 500
        };

        requestEventsStream(filter, (viewerEvent) => {
            // Only count viewers who updated within timeout window
            if (viewerEvent.created_at >= cutoffTime) {
                viewers.add(viewerEvent.pubkey);
            }
        }, () => {
            const count = viewers.size;
            updateLiveViewerCount(count);
            resolve(count);
        });
    });
}

// Update live viewer count on page and cards
function updateLiveViewerCount(count) {
    // Update main viewer count on live stream page
    const viewerCountEl = document.getElementById('viewer-count-number');
    if (viewerCountEl) {
        viewerCountEl.textContent = formatNumber(count);
    }

    // Update any visible live stream cards with this event ID
    if (currentLiveChat.eventId) {
        const cards = document.querySelectorAll(`[data-live-event-id="${currentLiveChat.eventId}"] .live-viewers-count`);
        cards.forEach(card => {
            card.textContent = formatNumber(count);
        });
    }
}

// Load viewer count for a live stream card (used in grids/homepage)
async function loadLiveStreamCardViewers(eventId) {
    const event = allEvents.get(eventId);
    if (!event) return 0;

    const liveData = parseLiveEvent(event);
    if (!liveData) return 0;

    const cutoffTime = Math.floor(Date.now() / 1000) - LIVE_VIEWER_TIMEOUT;
    const viewers = new Set();

    // Build the d-tag pattern for this stream's viewers
    const dTagPattern = `${LIVE_VIEWER_TRACKING_APP_ID}/${event.pubkey}:${liveData.dTag}`;

    return new Promise((resolve) => {
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#d': [dTagPattern],
            limit: 500
        };

        requestEventsStream(filter, (viewerEvent) => {
            // Only count viewers who updated within timeout window
            if (viewerEvent.created_at >= cutoffTime) {
                viewers.add(viewerEvent.pubkey);
            }
        }, () => {
            const count = viewers.size;
            // Update the card's viewer count
            const card = document.querySelector(`[data-live-event-id="${eventId}"] .live-viewers-count`);
            if (card) {
                card.textContent = formatNumber(count);
            }
            resolve(count);
        });
    });
}

// Load viewer counts for multiple live stream cards (batch operation)
async function loadLiveStreamCardsViewers(eventIds) {
    if (!eventIds || eventIds.length === 0) return;

    const cutoffTime = Math.floor(Date.now() / 1000) - LIVE_VIEWER_TIMEOUT;
    const viewersByStream = new Map(); // eventId -> Set of viewer pubkeys
    const dTagToEventId = new Map(); // dTagPattern -> eventId

    // Build d-tag patterns for each event and initialize viewer sets
    const dTagPatterns = [];
    eventIds.forEach(eventId => {
        viewersByStream.set(eventId, new Set());
        const event = allEvents.get(eventId);
        if (event) {
            const liveData = parseLiveEvent(event);
            if (liveData) {
                const dTagPattern = `${LIVE_VIEWER_TRACKING_APP_ID}/${event.pubkey}:${liveData.dTag}`;
                dTagPatterns.push(dTagPattern);
                dTagToEventId.set(dTagPattern, eventId);
            }
        }
    });

    if (dTagPatterns.length === 0) return viewersByStream;

    return new Promise((resolve) => {
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#d': dTagPatterns,
            limit: 1000
        };

        requestEventsStream(filter, (viewerEvent) => {
            // Only count viewers who updated within timeout window
            if (viewerEvent.created_at < cutoffTime) return;

            // Find which stream this viewer event is for using d-tag
            const dTag = viewerEvent.tags.find(t => t[0] === 'd')?.[1];
            if (dTag && dTagToEventId.has(dTag)) {
                const streamId = dTagToEventId.get(dTag);
                if (viewersByStream.has(streamId)) {
                    viewersByStream.get(streamId).add(viewerEvent.pubkey);
                }
            }
        }, () => {
            // Update all cards with their viewer counts
            viewersByStream.forEach((viewers, eventId) => {
                const count = viewers.size;
                const card = document.querySelector(`[data-live-event-id="${eventId}"] .live-viewers-count`);
                if (card) {
                    card.textContent = formatNumber(count);
                }
            });
            resolve(viewersByStream);
        });
    });
}

// End live stream (for host)
async function endLiveStream(eventId) {
    if (!currentUser) return;

    const streamEvent = allEvents.get(eventId);
    if (!streamEvent || streamEvent.pubkey !== currentUser.pubkey) {
        showToast('You can only end your own streams', 'error');
        return;
    }

    showConfirmModal(
        'End Live Stream',
        'Are you sure you want to end this live stream? This action cannot be undone.',
        async () => {
            await performEndLiveStream(eventId, streamEvent);
        },
        { confirmText: 'End Stream', danger: true }
    );
}

// Actually perform the stream ending after confirmation
async function performEndLiveStream(eventId, streamEvent) {
    const liveData = parseLiveEvent(streamEvent);

    // Create updated event with 'ended' status
    const updatedTags = streamEvent.tags.map(tag => {
        if (tag[0] === 'status') return ['status', 'ended'];
        return tag;
    });

    // Add ends timestamp if not present
    if (!updatedTags.some(t => t[0] === 'ends')) {
        updatedTags.push(['ends', String(Math.floor(Date.now() / 1000))]);
    }

    const event = {
        kind: NIP53_LIVE_EVENT_KIND,
        created_at: Math.floor(Date.now() / 1000),
        tags: updatedTags,
        content: ''
    };

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            allEvents.set(signedEvent.id, signedEvent);

            // Update UI in place instead of reloading
            updateStreamEndedUI(eventId, liveData);
            showToast('Stream ended successfully', 'success');
        }
    } catch (error) {
        console.error('Failed to end stream:', error);
        showToast('Failed to end stream', 'error');
    }
}

// Update the UI when a stream is ended
function updateStreamEndedUI(eventId, liveData) {
    // Update status badge from LIVE to ENDED
    const statusBadge = document.querySelector('.live-status-badge');
    if (statusBadge) {
        statusBadge.textContent = t('status.ended');
        statusBadge.classList.add('ended');
    }

    // Hide viewer count
    const viewerCount = document.getElementById('live-viewer-count');
    if (viewerCount) {
        viewerCount.style.display = 'none';
    }

    // Show ended overlay on the player
    const player = document.querySelector('.live-stream-player');
    if (player) {
        // Remove any existing stream embed
        const existingEmbed = player.querySelector('iframe, video');
        if (existingEmbed) {
            existingEmbed.remove();
        }

        // Add ended overlay if not already present
        if (!player.querySelector('.stream-overlay')) {
            const endedOverlay = document.createElement('div');
            endedOverlay.className = 'stream-overlay';
            endedOverlay.innerHTML = `
                ${liveData.thumbnail ? `<img src="${liveData.thumbnail}" class="thumbnail-preview" alt="Stream thumbnail">` : ''}
                <h2>Stream Ended</h2>
                <p>This live stream has ended.</p>
            `;
            player.appendChild(endedOverlay);
        }
    }

    // Remove the End Stream button
    const actionsContainer = document.getElementById(`live-stream-actions-${eventId}`);
    if (actionsContainer) {
        const endStreamBtn = actionsContainer.querySelector('button[onclick*="endLiveStream"]');
        if (endStreamBtn) {
            endStreamBtn.remove();
        }
    }

    // Disable live chat input
    const chatInput = document.getElementById('live-chat-input');
    if (chatInput) {
        chatInput.disabled = true;
        chatInput.placeholder = 'Chat is closed - stream has ended';
    }

    const sendBtn = document.getElementById('live-chat-send');
    if (sendBtn) {
        sendBtn.disabled = true;
    }

    // Update the chat header to show ended status
    const chatHeader = document.querySelector('.live-chat-header h3');
    if (chatHeader) {
        chatHeader.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"/>
            </svg>
            Chat (Ended)
        `;
    }

    // Clean up live chat subscriptions
    cleanupLiveChatSubscriptions();
}

// ===== Live Feed Page =====
async function loadLiveFeed() {
    currentView = 'live';
    const mainContent = document.getElementById('mainContent');

    mainContent.innerHTML = `
        <div class="live-feed-header">
            <h2>
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <circle cx="12" cy="12" r="4" fill="#f44336"/>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                </svg>
                ${t('pageTitle.liveStreams')}
            </h2>
            <span class="live-count" id="live-count">Loading...</span>
        </div>

        <div class="live-feed-section" id="live-now-section">
            <div class="video-grid" id="live-now-grid"></div>
        </div>

        <div class="live-feed-section" id="scheduled-section" style="display: none;">
            <h3>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM9 10H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm-8 4H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2z"/>
                </svg>
                Upcoming Streams
            </h3>
            <div class="scheduled-streams-list" id="scheduled-streams-list"></div>
        </div>

        <div class="live-feed-section" id="past-streams-section" style="display: none;">
            <h3>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/>
                </svg>
                Past Streams
            </h3>
            <div class="video-grid" id="past-streams-grid"></div>
        </div>
    `;

    // Show skeleton loading cards while fetching
    showLiveStreamSkeletonGrid(document.getElementById('live-now-grid'), 4);

    // Load live streams
    const liveStreams = [];
    const scheduledStreams = [];
    const pastStreams = [];

    const filter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        '#t': ['pv69420'],
        limit: 100
    };

    requestEventsStream(filter, (event) => {
        const liveData = parseLiveEvent(event);
        if (!liveData) return;

        if (isLiveStreamActive(liveData)) {
            liveStreams.push({ event, liveData });
        } else if (isLiveStreamScheduled(liveData)) {
            scheduledStreams.push({ event, liveData });
        } else if (isLiveStreamEnded(liveData)) {
            pastStreams.push({ event, liveData });
        }
    }, async () => {
        // Update live count
        document.getElementById('live-count').textContent = `${liveStreams.length} live`;

        // Render live streams
        const liveNowGrid = document.getElementById('live-now-grid');
        if (liveStreams.length === 0) {
            liveNowGrid.innerHTML = `<p style="color: var(--text-secondary); text-align: center; grid-column: 1/-1;">${t('empty.noLiveNow')}</p>`;
        } else {
            liveNowGrid.innerHTML = '';
            const liveEventIds = [];
            for (const { event, liveData } of liveStreams) {
                const profile = await fetchUserProfile(event.pubkey);
                const card = createLiveStreamCard(event, liveData, profile);
                liveNowGrid.insertAdjacentHTML('beforeend', card);
                liveEventIds.push(event.id);
            }
            // Load actual viewer counts for all live streams
            loadLiveStreamCardsViewers(liveEventIds);
        }

        // Render scheduled streams
        if (scheduledStreams.length > 0) {
            document.getElementById('scheduled-section').style.display = 'block';
            const scheduledList = document.getElementById('scheduled-streams-list');
            scheduledList.innerHTML = '';

            // Sort by start time
            scheduledStreams.sort((a, b) => a.liveData.starts - b.liveData.starts);

            for (const { event, liveData } of scheduledStreams) {
                const profile = await fetchUserProfile(event.pubkey);
                const card = createScheduledStreamCard(event, liveData, profile);
                scheduledList.insertAdjacentHTML('beforeend', card);
            }
        }

        // Render past streams
        if (pastStreams.length > 0) {
            document.getElementById('past-streams-section').style.display = 'block';
            const pastGrid = document.getElementById('past-streams-grid');
            pastGrid.innerHTML = '';

            // Sort by end time (most recent first)
            pastStreams.sort((a, b) => (b.liveData.ends || b.event.created_at) - (a.liveData.ends || a.event.created_at));

            for (const { event, liveData } of pastStreams.slice(0, 12)) {
                const profile = await fetchUserProfile(event.pubkey);
                const card = createLiveStreamCard(event, liveData, profile, true);
                pastGrid.insertAdjacentHTML('beforeend', card);
            }
        }
    });
}

function createLiveStreamCard(event, liveData, profile, isEnded = false, reactions = null) {
    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';

    // Check boost level
    const boostAmount = boostsCache.get(event.id) || 0;
    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;
    const boostClasses = isBoosted ? `boosted boost-level-${boostLevel}` : '';

    // Check if nip05 validation is cached
    const validationCached = profileValidationCache.get(event.pubkey);
    const nip05Valid = validationCached?.nip05Valid || false;

    // Validate nip05 async if not cached
    if (nip05 && !validationCached) {
        setTimeout(() => {
            validateNip05(nip05, event.pubkey).then(isValid => {
                if (isValid) {
                    const card = document.querySelector(`.video-card[data-pubkey="${event.pubkey}"][data-live-event-id="${event.id}"] .channel-nip05`);
                    if (card) applyNip05Checkmark(card, true);
                }
            });
        }, 0);
    }

    // Check NSFW and community warning states
    const isNSFW = liveData.isNSFW || false;
    const cachedReactions = reactions || reactionsCache.get(event.id) || {};
    const isRatioed = isVideoRatioed(cachedReactions);

    // Check suspicious profile
    const profileChecked = profileCache.has(event.pubkey);
    const isSuspiciousProfile = profileChecked && (!profile || !avatarUrl || !nip05);

    // Determine what type of overlay to show (skip for own streams)
    const isOwnStream = currentUser?.pubkey === event.pubkey;
    const showNSFWOverlay = !isOwnStream && isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own streams)
    const isReportedByFollowsCheck = !isOwnStream && isReportedByFollowsSync(event.id, event.pubkey);
    const showCommunityWarning = !isOwnStream && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning();
    const showBlurred = showNSFWOverlay || showCommunityWarning;
    const overlayType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    return `
        <div class="video-card is-live ${boostClasses}" data-live-event-id="${event.id}" data-pubkey="${event.pubkey}" onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playLive', '${event.id}')` : `showRatioedModal('${event.id}', 'live')`) : `navigateTo('/live/${event.id}')`}">
            <div class="video-thumbnail ${showBlurred ? overlayType : ''}">
                ${liveData.thumbnail ?
            `<img src="${liveData.thumbnail}" data-original-src="${liveData.thumbnail}" alt="${liveData.title}" onload="cacheLoadedImage(this)"${showBlurred ? ' style="filter: blur(20px);"' : ''}>` :
            '<div style="width:100%; height:100%; background: var(--bg-secondary);"></div>'
        }
                ${showBlurred ? `
                    <div class="${overlayType}-overlay">
                        <div class="${overlayType}-badge">${overlayType === 'nsfw' ? t('badge.nsfw') : t('badge.communityWarning')}</div>
                        <div>Click to view</div>
                    </div>
                ` : ''}
                ${!isEnded && !showBlurred ? '<div class="live-badge">Live</div>' : ''}
                ${!isEnded && !showBlurred ? `
                    <div class="live-viewers">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <span class="live-viewers-count">${liveData.currentParticipants || 0}</span>
                    </div>
                ` : ''}
                ${isBoosted && !showBlurred ? `
                    <div class="boost-indicator">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                        </svg>
                        ${formatSats(boostAmount)}
                    </div>
                ` : ''}
            </div>
            <div class="video-info">
                <a href="#/profile/${event.pubkey}" class="channel-info" onclick="event.stopPropagation();">
                    <div class="channel-avatar">
                        ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                    </div>
                    <div class="channel-details">
                        <div class="channel-name">${escapeHtml(displayName)}</div>
                        ${nip05 ? `<div class="channel-nip05">${nip05}${nip05Valid ? getNip05CheckmarkSVG(12) : ''}</div>` : ''}
                    </div>
                </a>
                <h3 class="video-title">${escapeHtml(liveData.title)}</h3>
                <div class="video-meta">
                    ${isEnded ? 'Ended ' : 'Started '}${formatTimestamp(isEnded ? (liveData.ends || event.created_at) : liveData.starts)}
                    ${liveData.isNSFW ? ' • <span style="color: #f44336;">NSFW</span>' : ''}
                </div>
            </div>
        </div>
    `;
}

function createScheduledStreamCard(event, liveData, profile) {
    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';
    const scheduleDate = new Date(liveData.starts * 1000);

    // Check if nip05 validation is cached
    const validationCached = profileValidationCache.get(event.pubkey);
    const nip05Valid = validationCached?.nip05Valid || false;

    // Validate nip05 async if not cached
    if (nip05 && !validationCached) {
        setTimeout(() => {
            validateNip05(nip05, event.pubkey).then(isValid => {
                if (isValid) {
                    const card = document.querySelector(`.scheduled-stream-card[data-pubkey="${event.pubkey}"][data-event-id="${event.id}"] .channel-nip05`);
                    if (card) applyNip05Checkmark(card, true);
                }
            });
        }, 0);
    }

    // Check NSFW and community warning states
    const isNSFW = liveData.isNSFW || false;
    const cachedReactions = reactionsCache.get(event.id) || {};
    const isRatioed = isVideoRatioed(cachedReactions);

    // Check suspicious profile
    const profileChecked = profileCache.has(event.pubkey);
    const isSuspiciousProfile = profileChecked && (!profile || !avatarUrl || !nip05);

    // Determine what type of overlay to show (skip for own streams)
    const isOwnStream = currentUser?.pubkey === event.pubkey;
    const showNSFWOverlay = !isOwnStream && isNSFW && !shouldShowNSFW();
    const isReportedByFollowsCheck = !isOwnStream && isReportedByFollowsSync(event.id, event.pubkey);
    const showCommunityWarning = !isOwnStream && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning();
    const showBlurred = showNSFWOverlay || showCommunityWarning;
    const overlayType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    return `
        <div class="scheduled-stream-card" data-event-id="${event.id}" data-pubkey="${event.pubkey}" onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playLive', '${event.id}')` : `showRatioedModal('${event.id}', 'live')`) : `navigateTo('/live/${event.id}')`}">
            <div class="scheduled-stream-thumbnail ${showBlurred ? overlayType : ''}">
                ${liveData.thumbnail ?
            `<img src="${liveData.thumbnail}" data-original-src="${liveData.thumbnail}" alt="${liveData.title}" onload="cacheLoadedImage(this)"${showBlurred ? ' style="filter: blur(20px);"' : ''}>` :
            '<div style="width:100%; height:100%; background: var(--bg-secondary);"></div>'
        }
                ${showBlurred ? `
                    <div class="${overlayType}-overlay">
                        <div class="${overlayType}-badge">${overlayType === 'nsfw' ? t('badge.nsfw') : t('badge.communityWarning')}</div>
                        <div>Click to view</div>
                    </div>
                ` : `<div class="scheduled-badge">SCHEDULED</div>`}
            </div>
            <div class="scheduled-stream-info">
                <h4>${escapeHtml(liveData.title)}</h4>
                <div class="scheduled-stream-time">
                    ${scheduleDate.toLocaleDateString()} at ${scheduleDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </div>
                ${liveData.summary ? `<p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.25rem;">${escapeHtml(liveData.summary.slice(0, 100))}${liveData.summary.length > 100 ? '...' : ''}</p>` : ''}
                <div class="scheduled-stream-creator">
                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                    <span>${escapeHtml(displayName)}</span>
                    ${nip05 ? `<span class="channel-nip05" style="margin-left: 0.5rem; font-size: 0.75rem; color: var(--text-secondary);">${nip05}${nip05Valid ? getNip05CheckmarkSVG(12) : ''}</span>` : ''}
                </div>
            </div>
        </div>
    `;
}

// Format sats for display
function formatSats(sats) {
    if (sats >= 1000000) {
        return `${(sats / 1000000).toFixed(1)}M`;
    } else if (sats >= 1000) {
        return `${(sats / 1000).toFixed(1)}K`;
    }
    return sats.toString();
}

// ===== Live Stream Action Functions =====

// Like a live stream (uses #a tag for persistence across stream updates)
async function handleLiveLike(eventId) {
    if (!await ensureLoggedIn()) return;

    // Get stream event to construct the 'a' tag
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    const event = {
        kind: 7,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
            ['a', aTagValue],
            ['e', eventId],
            ['p', streamEvent.pubkey],
            ['t', 'pv69420']
        ],
        content: '+'
    };

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            // Update UI immediately
            const likeCount = document.querySelector(`.live-like-count[data-event-id="${eventId}"]`);
            const likeBtn = document.querySelector(`.action-btn.like[data-event-id="${eventId}"]`);
            if (likeCount) {
                const current = parseInt(likeCount.textContent) || 0;
                likeCount.textContent = current + 1;
            }
            if (likeBtn) likeBtn.classList.add('active');
            showToast('Liked!', 'success');
        }
    } catch (error) {
        console.error('Failed to like live stream:', error);
    }
}

// Dislike a live stream (uses #a tag for persistence across stream updates)
async function handleLiveDislike(eventId) {
    if (!await ensureLoggedIn()) return;

    // Get stream event to construct the 'a' tag
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    const event = {
        kind: 7,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
            ['a', aTagValue],
            ['e', eventId],
            ['p', streamEvent.pubkey],
            ['t', 'pv69420']
        ],
        content: '-'
    };

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            // Update UI immediately
            const dislikeCount = document.querySelector(`.live-dislike-count[data-event-id="${eventId}"]`);
            const dislikeBtn = document.querySelector(`.action-btn.dislike[data-event-id="${eventId}"]`);
            if (dislikeCount) {
                const current = parseInt(dislikeCount.textContent) || 0;
                dislikeCount.textContent = current + 1;
            }
            if (dislikeBtn) dislikeBtn.classList.add('active');
            showToast('Disliked!', 'success');
        }
    } catch (error) {
        console.error('Failed to dislike live stream:', error);
    }
}

// Load reactions for a live stream (queries by #a tag for persistence)
async function loadLiveStreamReactions(eventId) {
    // Get stream event to construct the 'a' tag
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    // Query by both #a and #e tags to catch all reactions
    const filter = {
        kinds: [7],
        '#a': [aTagValue],
        limit: 200
    };

    let likes = 0;
    let dislikes = 0;
    let userReaction = null;
    const seenReactions = new Set();

    requestEventsStream(filter, (event) => {
        // Deduplicate by event id
        if (seenReactions.has(event.id)) return;
        seenReactions.add(event.id);

        if (event.content === '+' || event.content === '👍') {
            likes++;
            if (currentUser && event.pubkey === currentUser.pubkey) {
                userReaction = 'like';
            }
        } else if (event.content === '-' || event.content === '👎') {
            dislikes++;
            if (currentUser && event.pubkey === currentUser.pubkey) {
                userReaction = 'dislike';
            }
        }
    }, () => {
        // Update UI
        const likeCount = document.querySelector(`.live-like-count[data-event-id="${eventId}"]`);
        const dislikeCount = document.querySelector(`.live-dislike-count[data-event-id="${eventId}"]`);
        const likeBtn = document.querySelector(`.action-btn.like[data-event-id="${eventId}"]`);
        const dislikeBtn = document.querySelector(`.action-btn.dislike[data-event-id="${eventId}"]`);

        if (likeCount) likeCount.textContent = formatNumber(likes);
        if (dislikeCount) dislikeCount.textContent = formatNumber(dislikes);

        if (userReaction === 'like' && likeBtn) likeBtn.classList.add('active');
        if (userReaction === 'dislike' && dislikeBtn) dislikeBtn.classList.add('active');
    });
}

// Live stream zap goal tracking
let liveStreamZapSubscription = null;
let liveStreamZapTotal = 0;

async function initLiveStreamZapGoal(eventId, zapGoal) {
    liveStreamZapTotal = 0;

    // Get stream event to construct the 'a' tag for persistence
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    // Get the goal_since timestamp (if goal was reset, only count zaps after that)
    const goalSince = liveData.zapGoalSince || 0;

    // Query by #a tag for persistence across stream updates
    const filter = {
        kinds: [9735],
        '#a': [aTagValue],
        limit: 500
    };

    // If there's a goal_since, add it to the filter
    if (goalSince > 0) {
        filter.since = goalSince;
    }

    const processedZaps = new Set();

    requestEventsStream(filter, (event) => {
        if (processedZaps.has(event.id)) return;
        processedZaps.add(event.id);

        // Double-check timestamp if goal_since is set (some relays may not respect 'since')
        if (goalSince > 0 && event.created_at < goalSince) return;

        const amount = getZapAmount(event);
        if (amount > 0) {
            liveStreamZapTotal += amount;
        }
    }, () => {
        // Update the display with initial total
        updateZapGoalDisplay(liveStreamZapTotal, zapGoal, false);

        // Subscribe to new zaps in real-time
        subscribeLiveStreamZaps(aTagValue, zapGoal, processedZaps, goalSince);
    });
}

function subscribeLiveStreamZaps(aTagValue, zapGoal, processedZaps, goalSince = 0) {
    // Clean up any existing subscription
    if (liveStreamZapSubscription) {
        try {
            liveStreamZapSubscription.close();
        } catch (e) { }
    }

    // Subscribe using #a tag for persistence across stream updates
    // Use goalSince if set (for reset goals), otherwise use current time
    const sinceTime = goalSince > 0 ? goalSince : Math.floor(Date.now() / 1000);
    const filter = {
        kinds: [9735],
        '#a': [aTagValue],
        since: sinceTime
    };

    // Create a subscription for new zaps
    liveStreamZapSubscription = {
        active: true,
        close: () => { liveStreamZapSubscription.active = false; }
    };

    // Poll for new zaps every 5 seconds
    const pollInterval = setInterval(() => {
        if (!liveStreamZapSubscription || !liveStreamZapSubscription.active) {
            clearInterval(pollInterval);
            return;
        }

        // Check if we're still on the live stream page
        if (!document.getElementById('live-zap-goal')) {
            clearInterval(pollInterval);
            return;
        }

        requestEventsStream(filter, (event) => {
            if (processedZaps.has(event.id)) return;
            processedZaps.add(event.id);

            // Double-check timestamp if goalSince is set
            if (goalSince > 0 && event.created_at < goalSince) return;

            const amount = getZapAmount(event);
            if (amount > 0) {
                liveStreamZapTotal += amount;
                updateZapGoalDisplay(liveStreamZapTotal, zapGoal, true);
            }
        }, () => { });
    }, 5000);
}

function getZapAmount(zapEvent) {
    try {
        const bolt11Tag = zapEvent.tags.find(tag => tag[0] === 'bolt11');
        if (bolt11Tag && bolt11Tag[1]) {
            return extractAmountFromBolt11(bolt11Tag[1]);
        }
    } catch (e) {
        console.error('Error extracting zap amount:', e);
    }
    return 0;
}

// Track if goal reached message has been shown
let zapGoalReachedMessageShown = false;

function updateZapGoalDisplay(currentAmount, goalAmount, animate) {
    const zapGoalEl = document.getElementById('live-zap-goal');
    const currentAmountEl = document.getElementById('zap-current-amount');
    const fillEl = document.getElementById('zap-goal-fill');
    const resetFormEl = document.getElementById('zap-goal-reset-form');

    if (!zapGoalEl || !currentAmountEl || !fillEl) return;

    const percentage = Math.min((currentAmount / goalAmount) * 100, 100);
    const wasGoalReached = zapGoalEl.classList.contains('goal-reached');

    currentAmountEl.textContent = formatSats(currentAmount);
    fillEl.style.width = `${percentage}%`;

    if (animate) {
        // Add pulse animation class
        zapGoalEl.classList.add('zap-received');

        // Remove animation class after it completes
        setTimeout(() => {
            zapGoalEl.classList.remove('zap-received');
        }, 600);
    }

    // Add goal reached state and show reset form for stream owner
    if (percentage >= 100) {
        zapGoalEl.classList.add('goal-reached');
        // Show reset form for stream owner
        if (resetFormEl) {
            resetFormEl.classList.add('visible');
        }
        // Add chat message when goal is first reached
        if (!wasGoalReached && !zapGoalReachedMessageShown) {
            zapGoalReachedMessageShown = true;
            addZapGoalReachedMessage(goalAmount);
        }
    } else {
        zapGoalEl.classList.remove('goal-reached');
        if (resetFormEl) {
            resetFormEl.classList.remove('visible');
        }
    }
}

// Add goal reached message to live chat
function addZapGoalReachedMessage(goalAmount) {
    const container = document.getElementById('live-chat-messages');
    if (!container) return;

    const messageHTML = `
        <div class="chat-message goal-reached-notification" data-timestamp="${Math.floor(Date.now() / 1000)}">
            <div class="chat-message-content">
                <svg class="celebration-icon" width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                    <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/>
                    <circle cx="8" cy="10" r="1.5"/>
                    <circle cx="16" cy="10" r="1.5"/>
                    <path d="M8 15c0 0 2 3 4 3s4-3 4-3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
                Zap goal reached! ${formatSatsExact(goalAmount)} sats!
            </div>
        </div>
    `;

    container.insertAdjacentHTML('beforeend', messageHTML);

    // Auto-scroll to show the message
    if (container.scrollHeight - container.scrollTop - container.clientHeight < 150) {
        container.scrollTop = container.scrollHeight;
    }
}

// Add new zap goal announcement message to live chat
function addNewZapGoalMessage(goalAmount) {
    const container = document.getElementById('live-chat-messages');
    if (!container) return;

    const messageHTML = `
        <div class="chat-message new-goal-notification" data-timestamp="${Math.floor(Date.now() / 1000)}">
            <div class="chat-message-content">
                <svg class="zap-icon" width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                </svg>
                New zap goal: ${formatSatsExact(goalAmount)} sats!
            </div>
        </div>
    `;

    container.insertAdjacentHTML('beforeend', messageHTML);

    // Auto-scroll to show the message
    if (container.scrollHeight - container.scrollTop - container.clientHeight < 150) {
        container.scrollTop = container.scrollHeight;
    }
}

// Reset zap goal to a new amount (stream owner only)
async function resetZapGoal() {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const zapGoalEl = document.getElementById('live-zap-goal');
    const newGoalInput = document.getElementById('new-zap-goal-input');

    if (!zapGoalEl || !newGoalInput) return;

    const newGoal = parseInt(newGoalInput.value);
    if (!newGoal || newGoal < 1) {
        alert(t('alert.enterValidGoalAmount'));
        return;
    }

    const eventId = zapGoalEl.dataset.eventId;
    const pubkey = zapGoalEl.dataset.pubkey;
    const dTag = zapGoalEl.dataset.dtag;

    // Verify ownership
    if (pubkey !== currentUser.pubkey) {
        alert(t('alert.canOnlyResetOwnGoals'));
        return;
    }

    // Fetch the current event
    let event = allEvents.get(eventId);
    if (!event) {
        event = await fetchLiveEvent(eventId);
    }

    if (!event) {
        alert(t('alert.streamEventNotFound'));
        return;
    }

    const liveData = parseLiveEvent(event);
    if (!liveData) {
        alert(t('alert.invalidStreamData'));
        return;
    }

    try {
        // Build updated event tags (copy existing, update goal)
        const eventTags = [
            ['d', dTag],
            ['title', liveData.title],
            ['summary', liveData.summary || ''],
            ['streaming', liveData.streamUrl || ''],
            ['status', liveData.status],
            ['starts', String(liveData.starts)],
            ['t', 'pv69420'],
        ];

        // Add ends tag if stream has ended
        if (liveData.ends) {
            eventTags.push(['ends', String(liveData.ends)]);
        }

        // Add thumbnail
        if (liveData.thumbnail) {
            eventTags.push(['image', liveData.thumbnail]);
        }

        // Add content tags
        (liveData.tags || []).forEach(tag => {
            eventTags.push(['t', tag.toLowerCase()]);
        });

        // Add NSFW tag if applicable
        if (liveData.isNSFW) {
            eventTags.push(['content-warning', 'NSFW']);
        }

        // Add new zap goal with timestamp for when this goal started
        const goalSinceTimestamp = Math.floor(Date.now() / 1000);
        eventTags.push(['goal', String(newGoal)]);
        eventTags.push(['goal_since', String(goalSinceTimestamp)]);

        // Add host participant
        eventTags.push(['p', currentUser.pubkey, '', 'Host']);

        const newEvent = {
            kind: NIP53_LIVE_EVENT_KIND,
            created_at: Math.floor(Date.now() / 1000),
            tags: eventTags,
            content: ''
        };

        const signedEvent = await signEvent(newEvent);
        if (!signedEvent) {
            throw new Error('Failed to sign event');
        }

        await publishEvent(signedEvent);

        // Update UI immediately
        const targetEl = document.getElementById('zap-target-amount');
        if (targetEl) {
            targetEl.textContent = formatSatsExact(newGoal);
        }

        // Update data attributes
        zapGoalEl.dataset.goal = newGoal;

        // Reset visual state
        zapGoalEl.classList.remove('goal-reached');
        const resetFormEl = document.getElementById('zap-goal-reset-form');
        if (resetFormEl) {
            resetFormEl.classList.remove('visible');
        }

        // Reset the goal reached message flag so it can trigger again
        zapGoalReachedMessageShown = false;

        // Reset zap counter to 0 for new goal (previous zaps don't count)
        liveStreamZapTotal = 0;
        updateZapGoalDisplay(0, newGoal, false);

        // Clear input
        newGoalInput.value = '';

        // Update in allEvents
        allEvents.delete(eventId);
        allEvents.set(signedEvent.id, signedEvent);

        // Restart zap tracking with the new goal_since timestamp
        const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${pubkey}:${dTag}`;
        subscribeLiveStreamZaps(aTagValue, newGoal, new Set(), goalSinceTimestamp);

    } catch (error) {
        console.error('Failed to reset zap goal:', error);
        alert(t('alert.failedResetZapGoal'));
    }
}

// Load zap goal results for ended streams (uses #a tag for persistence)
async function loadEndedStreamZapGoal(eventId, zapGoal) {
    // Get stream event to construct the 'a' tag
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    let totalZaps = 0;

    const filter = {
        kinds: [9735],
        '#a': [aTagValue],
        limit: 500
    };

    requestEventsStream(filter, (event) => {
        const amount = getZapAmount(event);
        if (amount > 0) {
            totalZaps += amount;
        }
    }, () => {
        // Update the ended stream overlay display
        const currentEl = document.getElementById('ended-zap-current');
        const fillEl = document.getElementById('ended-zap-goal-fill');
        const statusEl = document.getElementById('ended-zap-goal-status');
        const containerEl = document.getElementById('ended-zap-goal');

        if (!currentEl || !fillEl) return;

        const percentage = Math.min((totalZaps / zapGoal) * 100, 100);

        currentEl.textContent = formatSats(totalZaps);
        fillEl.style.width = `${percentage}%`;

        // Show status message
        if (statusEl) {
            if (percentage >= 100) {
                statusEl.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 4px;"><circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="8" cy="10" r="1.5"/><circle cx="16" cy="10" r="1.5"/><path d="M8 15c0 0 2 3 4 3s4-3 4-3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>Goal Reached!';
                statusEl.style.color = '#ffd700';
                if (containerEl) containerEl.classList.add('goal-reached');
            } else {
                statusEl.textContent = `${Math.round(percentage)}% of goal`;
                statusEl.style.color = 'rgba(255, 255, 255, 0.7)';
            }
        }
    });
}

// Share live stream with embed support
function shareLiveStream(eventId) {
    currentShareEventId = eventId;
    const isLocal = window.location.protocol === 'file:';
    const baseUrl = isLocal ? window.location.href.split('#')[0] : window.location.origin;
    const shareUrl = `${baseUrl}/#/live/${eventId}`;
    document.getElementById('shareUrlInput').value = shareUrl;

    // Reset to link tab
    switchShareTab('link');

    // Generate embed code for live stream
    updateLiveStreamEmbedCode(eventId);

    // Hide the fallback note since live streams don't use blossom hosts
    const fallbackNote = document.getElementById('embedFallbackNote');
    if (fallbackNote) fallbackNote.style.display = 'none';

    // Record share event for analytics
    recordVideoShare(eventId);

    document.getElementById('shareModal').classList.add('active');
}

// Update embed code for live stream
function updateLiveStreamEmbedCode(eventId) {
    const sizeSelect = document.getElementById('embedSizeSelect');
    const selectedSize = sizeSelect?.value || 'responsive';

    const isLocal = window.location.protocol === 'file:';
    const baseUrl = isLocal ? window.location.href.split('#')[0] : window.location.origin;
    const embedUrl = `${baseUrl}/embed-live.html?id=${eventId}`;

    let embedCode;
    if (selectedSize === 'responsive') {
        embedCode = `<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="${embedUrl}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;" allowfullscreen></iframe>
</div>`;
    } else {
        const [width, height] = selectedSize.split('x');
        embedCode = `<iframe width="${width}" height="${height}" src="${embedUrl}" frameborder="0" allowfullscreen></iframe>`;
    }

    const embedCodeInput = document.getElementById('embedCodeInput');
    if (embedCodeInput) {
        embedCodeInput.value = embedCode;
    }
}

// Load "Also Live" section with recommendation-based related live streams
async function loadAlsoLive(currentStreamerPubkey, currentDTag, tags) {
    const alsoLiveSection = document.getElementById('also-live-section');
    const alsoLiveGrid = document.getElementById('also-live-grid');

    if (!alsoLiveSection || !alsoLiveGrid) return;

    const filter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        '#t': ['pv69420'],
        limit: 50
    };

    const otherLiveStreams = [];

    // Use the existing userFollowsCache for current user's follows (already loaded on login)
    const userFollowingSet = userFollowsCache || new Set();

    requestEventsStream(filter, (event) => {
        const liveData = parseLiveEvent(event);

        if (!liveData || !isLiveStreamActive(liveData)) return;

        // Exclude current stream by pubkey + d-tag (unique identifier for replaceable events)
        if (event.pubkey === currentStreamerPubkey && liveData.dTag === currentDTag) return;

        // Exclude current user's own streams when logged in
        if (currentUser && event.pubkey === currentUser.pubkey) return;

        // Skip muted users and content filtered by keywords
        const filterResult = shouldFilterLiveContent(event, liveData);
        if (filterResult && filterResult.filtered) return;

        // Calculate recommendation score
        let score = 0;

        // Check for tag overlap (related streams by topic)
        const streamTags = liveData.tags || [];
        const matchingTags = tags.filter(tag => streamTags.includes(tag));
        score += matchingTags.length * 10; // +10 per matching tag

        // Boost if user follows this streamer
        if (userFollowingSet.has(event.pubkey)) {
            score += 25;
        }

        // Add viewer count as a tiebreaker (normalized)
        const viewers = liveData.currentParticipants || 0;
        score += Math.min(viewers / 10, 5); // Cap at +5 for popular streams

        otherLiveStreams.push({ event, liveData, score, matchingTags: matchingTags.length });
    }, async () => {
        if (otherLiveStreams.length === 0) {
            alsoLiveSection.style.display = 'none';
            return;
        }

        // Sort by recommendation score (highest first)
        otherLiveStreams.sort((a, b) => b.score - a.score);

        // Save scroll position before showing section to prevent page jump
        const scrollY = window.scrollY;

        // Show section
        alsoLiveSection.style.display = 'block';
        alsoLiveGrid.innerHTML = '';

        // Show up to 6 streams - use the standard createLiveStreamCard for consistent UI and filtering
        const streamsToShow = otherLiveStreams.slice(0, 6);
        const liveEventIds = [];

        for (const { event, liveData } of streamsToShow) {
            const profile = await fetchUserProfile(event.pubkey);
            // Use standard live stream card which handles NSFW, community warnings, etc.
            const card = createLiveStreamCard(event, liveData, profile);
            alsoLiveGrid.insertAdjacentHTML('beforeend', card);
            liveEventIds.push(event.id);
        }

        // Restore scroll position after all cards are added
        window.scrollTo(0, scrollY);

        // Load actual viewer counts for Also Live streams
        if (liveEventIds.length > 0) {
            loadLiveStreamCardsViewers(liveEventIds);
            // Load boosts for live streams
            liveEventIds.forEach(id => {
                if (!boostsCache.has(id)) {
                    loadBoostsForVideo(id);
                }
            });
        }
    });
}

// Helper function to filter live content (similar to video filtering)
function shouldFilterLiveContent(event, liveData) {
    if (!liveData) return { filtered: false };

    // Check muted users
    if (shouldHideMutedContent(event.pubkey)) {
        return { filtered: true, reason: 'muted' };
    }

    // Check content filter keywords in title and summary using existing matchesFilterPacks
    const textToCheck = `${liveData.title || ''} ${liveData.summary || ''}`;
    const filterResult = matchesFilterPacks(textToCheck);
    if (filterResult.matches) {
        return { filtered: true, reason: 'keyword' };
    }

    return { filtered: false };
}
