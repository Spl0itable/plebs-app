//          ____  _      _
//  ┌───┐  |  _ \| | ___| |__  ___
//  │ ▷ │  | |_) | |/ _ \ '_ \/ __|
//  └───┘  |  __/| |  __/ |_) \__ \
//         |_|   |_|\___|_.__/|___/

// ===== INTERNATIONALIZATION (i18n) SYSTEM =====
// Supported languages with native names
const SUPPORTED_LANGUAGES = {
    en: 'English',
    es: 'Español',
    fr: 'Français',
    de: 'Deutsch',
    pt: 'Português',
    ru: 'Русский',
    zh: '中文',
    ja: '日本語',
    ko: '한국어',
    ar: 'العربية',
    hi: 'हिन्दी',
    it: 'Italiano'
};

// Current language (default to English, will be updated on init)
let currentLanguage = 'en';

// Translations object - organized by language code
const translations = {
    en: {
        // Navigation & Header
        'nav.home': 'Home',
        'nav.following': 'Following',
        'nav.myVideos': 'My Videos',
        'nav.liked': 'Liked',
        'nav.history': 'History',
        'nav.topics': 'TOPICS',
        'nav.live': 'Live',
        'nav.bitcoin': 'Bitcoin',
        'nav.nostr': 'Nostr',
        'nav.technology': 'Technology',
        'nav.gaming': 'Gaming',
        'nav.tutorials': 'Tutorials',
        'nav.podcasts': 'Podcasts',
        'nav.music': 'Music',
        'nav.nsfw': 'NSFW',
        'nav.about': 'About',
        'nav.contact': 'Contact',
        'nav.terms': 'Terms',
        'nav.privacy': 'Privacy',
        'nav.faq': 'FAQ',
        'nav.dmca': 'DMCA',
        'header.search': 'Search videos...',
        'header.notifications': 'Notifications',
        'header.settings': 'Settings',
        'header.create': 'Create',
        'header.admin': 'Admin',
        'header.viewProfile': 'View Profile',
        'header.logout': 'Logout',
        // Login Modal
        'login.title': 'Login with Nostr',
        'login.extension': 'Login with Extension',
        'login.extensionDesc': 'Use Alby, nos2x, or other Nostr browser extensions',
        'login.connect': 'Nostr Connect',
        'login.connectDesc': 'Connect with remote signers like Amber, nsec.app',
        'login.privateKey': 'Private Key',
        'login.privateKeyDesc': 'Enter your nsec or hex private key (local only)',
        'login.newToNostr': 'New to Nostr?',
        'login.createAccount': 'Create Account',
        'login.createAccountDesc': 'Get started with a new Nostr identity to use on Plebs',
        // Connect Modal
        'connect.title': 'Connect with Nostr',
        'connect.option1': 'Option 1: Use this connection string',
        'connect.option1Desc': 'Copy and paste this into any NIP-46 compatible app (nsec.app, Amber, etc.)',
        'connect.copyString': 'Copy Connection String',
        'connect.showQR': 'Show QR Code',
        'connect.listening': 'Listening for connection...',
        'connect.option2': 'Option 2: Paste a bunker URL',
        'connect.option2Desc': 'If you already have a bunker:// URL from a remote signer',
        'connect.withBunker': 'Connect with Bunker',
        'connect.popularSigners': 'Popular NIP-46 signers:',
        'connect.webSigner': 'Web-based signer',
        'connect.androidApp': 'Android app',
        'connect.builtInSigner': 'Built-in signer',
        // Private Key Modal
        'privateKey.title': 'Login with Private Key',
        'privateKey.warning': 'Security Warning',
        'privateKey.warningText': 'Your private key will be stored locally in your browser. For better security, consider using a browser extension or Nostr Connect instead.',
        'privateKey.label': 'Private Key (nsec or hex)',
        'privateKey.showKey': 'Show key',
        'privateKey.login': 'Login',
        // Signup Modal
        'signup.title': 'Create Nostr Account',
        'signup.whatIsNostr': 'What is Nostr?',
        'signup.nostrExplanation': 'Nostr is a decentralized social protocol that gives you ownership of your identity and content. Unlike traditional platforms, no company can ban you, censor your content, or shut down your account.',
        'signup.whyPlebs': 'Why does Plebs use Nostr?',
        'signup.plebsExplanation': 'Plebs is built on Nostr to provide censorship-resistant video sharing. Your videos, comments, and interactions are stored across a network of relays, not on our servers. Your Nostr identity works across hundreds of other apps too!',
        'signup.howItWorks': 'How it works',
        'signup.keysIdentity': 'Your keys = Your identity.',
        'signup.keysIdentityDesc': "You'll get a private key (nsec) that proves you own your account.",
        'signup.keepSecret': 'Keep your private key secret!',
        'signup.keepSecretDesc': "It's like a password that can never be reset.",
        'signup.oneIdentity': 'One identity, many apps.',
        'signup.oneIdentityDesc': 'Use the same account on Damus, Primal, Amethyst, and more.',
        'signup.gotIt': "Got it, let's create my account",
        'signup.username': 'Username',
        'signup.usernamePlaceholder': 'Choose a display name',
        'signup.about': 'About (optional)',
        'signup.aboutPlaceholder': 'Tell others about yourself',
        'signup.profilePicture': 'Profile Picture (optional)',
        'signup.uploadPhoto': 'Upload Photo',
        'signup.remove': 'Remove',
        'signup.avatarHint': 'Square images work best. Max 5MB.',
        'signup.uploading': 'Uploading...',
        'signup.lightningAddress': 'Lightning Address (optional)',
        'signup.lightningPlaceholder': 'you@walletofsatoshi.com',
        'signup.lightningHint': 'Add a Lightning address to receive zaps (Bitcoin tips) on your videos and profile.',
        'signup.yourUsername': 'Your Username',
        'signup.yourBio': 'Your bio will appear here',
        'signup.createAccountBtn': 'Create Account',
        'signup.termsAgree': 'By creating an account, you agree to our',
        'signup.success': 'Account Created Successfully!',
        'signup.yourPrivateKey': 'Your Private Key (nsec)',
        'signup.keyWarning': 'This is the ONLY way to access your account. Save it somewhere safe!',
        'signup.copyPrivateKey': 'Copy Private Key',
        'signup.howToUseKey': 'How to use your private key',
        'signup.continueToPlebs': 'Continue to Plebs',
        // Notifications
        'notifications.title': 'Notifications',
        'notifications.settings': 'Notification Settings',
        'notifications.reactions': 'Reactions (likes/dislikes)',
        'notifications.replies': 'Comments & Replies',
        'notifications.zaps': 'Zaps',
        'notifications.chatMentions': 'Live Chat Mentions',
        'notifications.newFollowers': 'New Followers',
        'notifications.syncNote': 'Settings are synced across devices via Nostr',
        // Settings Modal
        'settings.title': 'Settings',
        'settings.language': 'Language',
        'settings.languageDesc': 'Choose your preferred language',
        'settings.saveToNostr': 'Save to Nostr',
        'settings.saveToNostrDesc': 'Sync settings across all Plebs instances',
        'settings.darkMode': 'Dark Mode',
        'settings.darkModeDesc': 'Switch between light and dark theme',
        'settings.contentWarnings': 'Content Warning Preferences',
        'settings.showNSFW': 'Show NSFW warnings',
        'settings.showNSFWDesc': 'Display age verification for NSFW content',
        'settings.showCommunity': 'Show community warnings',
        'settings.showCommunityDesc': 'Display warnings for flagged or heavily downvoted content',
        'settings.showFollowsReport': 'Show warnings from followed reports',
        'settings.showFollowsReportDesc': 'Display warnings when 5+ people you follow have reported content',
        'settings.filterPacks': 'Content Filter Packs',
        'settings.filterPacksDesc': 'Enable filter packs to automatically hide content matching specific keywords.',
        'settings.customKeywords': 'Custom Keyword Filter',
        'settings.customKeywordsPlaceholder': 'Enter keywords or phrases separated by commas',
        'settings.customKeywordsDesc': 'Add your own keywords to filter out (comma-separated)',
        'settings.mutedUsers': 'Muted Users',
        'settings.mutedUsersDesc': "Users you've muted won't appear in your feed or comments.",
        'settings.blossomSettings': 'Blossom Server Settings',
        'settings.premiumBlossom': 'Premium Blossom Server (NostrMedia.com)',
        'settings.premiumBlossomDesc': 'Use NostrMedia.com if you are a subscribed user',
        'settings.customBlossom': 'Custom Blossom Servers',
        'settings.customBlossomDesc': 'Add your own Blossom servers (comma-separated)',
        'settings.relaySettings': 'Relay Settings',
        'settings.useWotRelays': 'Use Web of Trust Relays',
        'settings.useWotRelaysDesc': 'Connect to Web of Trust relays for better spam filtering',
        'settings.saveSettings': 'Save Settings',
        'settings.resetDefaults': 'Reset to Defaults',
        // Upload Modal
        'upload.title': 'Upload Video',
        'upload.videoFile': 'Video File',
        'upload.recordFromCamera': 'Record from Camera',
        'upload.stop': 'Stop',
        'upload.recordHint': 'Record a vertical video (up to 60 seconds)',
        'upload.or': 'or',
        'upload.clickToSelect': 'Click to select video or drag and drop',
        'upload.fileTypes': 'MP4, AVI, MOV, etc (max 2GB input, will compress to <100MB)',
        'upload.preparing': 'Preparing...',
        'upload.thumbnail': 'Thumbnail',
        'upload.thumbnailOptional': '(optional)',
        'upload.thumbnailHint': 'Click to select or auto-generate from video',
        'upload.uploading': 'Uploading...',
        'upload.titleLabel': 'Title',
        'upload.titlePlaceholder': 'Enter video title',
        'upload.description': 'Description',
        'upload.descriptionPlaceholder': 'Tell viewers about your video',
        'upload.tags': 'Tags (comma separated)',
        'upload.tagsPlaceholder': 'bitcoin, nostr, tutorial',
        'upload.markNSFW': 'Mark as NSFW (18+)',
        'upload.nsfwHint': 'Content containing adult material should be marked as NSFW',
        'upload.saveDraft': 'Save as Draft',
        'upload.publish': 'Publish',
        'upload.selectVideo': 'Select a video to upload',
        'upload.termsNote': 'By uploading, you accept our',
        // Create Modal
        'create.title': 'Create',
        'create.goLive': 'Go Live',
        'create.goLiveDesc': 'Start a live stream or schedule one',
        'create.uploadVideo': 'Upload Video',
        'create.uploadVideoDesc': 'Upload a video from your device',
        'create.createShort': 'Create Short',
        'create.createShortDesc': 'Upload a vertical video (under 60s)',
        // Go Live Modal
        'goLive.title': 'Go Live',
        'goLive.when': 'When do you want to go live?',
        'goLive.now': 'Go Live Now',
        'goLive.schedule': 'Schedule Stream',
        'goLive.scheduleDateTime': 'Schedule Date & Time',
        'goLive.streamThumbnail': 'Stream Thumbnail',
        'goLive.streamTitle': 'Stream Title',
        'goLive.streamTitlePlaceholder': 'Enter your stream title',
        'goLive.streamUrl': 'Stream URL (RTMP, HLS, or WebRTC)',
        'goLive.zapGoal': 'Zap Goal (optional)',
        'goLive.setupGuide': 'Stream Setup Guide',
        'goLive.cancel': 'Cancel',
        'goLive.goLiveBtn': 'Go Live',
        // Edit Stream Modal
        'editStream.title': 'Edit Stream',
        'editStream.changeThumbnail': 'Change Thumbnail',
        'editStream.saveChanges': 'Save Changes',
        // NSFW Warning Modal
        'nsfw.title': 'Age Verification Required',
        'nsfw.warning': 'This content is marked as NSFW (Not Safe For Work) and may contain adult material. You must be 18 years or older to view this content.',
        'nsfw.cancel': 'Cancel',
        'nsfw.confirm': 'I am 18+ years old',
        'nsfw.remember': "Don't ask again (Remember my choice)",
        // Community Warning Modal
        'community.title': 'Community Warning',
        'community.warning': 'This video has been flagged and/or heavily downvoted by the community. This might be due to:',
        'community.inappropriate': 'Inappropriate content not properly marked as NSFW',
        'community.suspicious': 'New or suspicious user details',
        'community.misleading': 'Misleading or false information',
        'community.spam': 'Spam or low-quality content',
        'community.harmful': 'Potentially harmful or illegal content',
        'community.caution': 'Proceed with caution.',
        'community.goBack': 'Go Back',
        'community.viewAnyway': 'View Anyway',
        // Report Modal
        'report.title': 'Report Video',
        'report.titleComment': 'Report Comment',
        'report.selectReason': 'Select a reason for reporting this content:',
        'report.nudity': 'Nudity or Sexual Content',
        'report.nudityDesc': 'Contains sexual or explicit imagery not marked as NSFW',
        'report.hate': 'Hate Speech or Harassment',
        'report.hateDesc': 'Promotes violence, hate, or harassment against individuals or groups',
        'report.illegal': 'Illegal Content',
        'report.illegalDesc': 'Content that may violate laws or regulations',
        'report.spam': 'Spam or Misleading',
        'report.spamDesc': 'Deceptive content, scams, or repetitive spam',
        'report.impersonation': 'Impersonation',
        'report.impersonationDesc': 'Pretending to be someone else',
        'report.other': 'Other',
        'report.otherDesc': 'Other violation not listed above',
        'report.additionalDetails': 'Additional details (optional)',
        'report.detailsPlaceholder': "Provide more context about why you're reporting this video...",
        'report.cancel': 'Cancel',
        'report.submit': 'Submit Report',
        // Share Modal
        'share.title': 'Share Video',
        'share.link': 'Link',
        'share.embed': 'Embed',
        'share.shareWith': 'Share this video with others:',
        'share.copy': 'Copy',
        'share.copied': 'Copied to clipboard!',
        'share.embedVideo': 'Embed this video on your website:',
        'share.size': 'Size:',
        'share.responsive': 'Responsive (Default)',
        'share.size1280x720': '1280 × 720 (HD)',
        'share.embedCopied': 'Embed code copied!',
        'share.fallbackNote': 'Includes automatic fallback to mirror servers if primary source fails.',
        // Edit Video Modal
        'editVideo.title': 'Edit Video',
        'editVideo.video': 'Video',
        'editVideo.replaceVideo': 'Replace Video',
        // Edit Profile Modal
        'editProfile.title': 'Edit Profile',
        'editProfile.displayName': 'Display Name',
        'editProfile.displayNamePlaceholder': 'Your display name',
        'editProfile.about': 'About',
        'editProfile.aboutPlaceholder': 'Tell others about yourself',
        'editProfile.picture': 'Profile Picture',
        'editProfile.pictureUrl': 'Or enter image URL directly:',
        'editProfile.nip05': 'NIP-05 Identifier (optional)',
        'editProfile.nip05Hint': 'A verified Nostr address for identity verification.',
        'editProfile.website': 'Website (optional)',
        'editProfile.saveChanges': 'Save Changes',
        // Confirmation Modal
        'confirm.title': 'Confirm Action',
        'confirm.message': 'Are you sure you want to proceed?',
        'confirm.cancel': 'Cancel',
        'confirm.confirm': 'Confirm',
        // Filter Packs
        'filter.racism': 'Racism & Hate Speech',
        'filter.racismDesc': 'Filters racial slurs, ethnic hate speech, and discriminatory content',
        'filter.sexualExplicit': 'Sexually Explicit',
        'filter.sexualExplicitDesc': 'Filters pornographic terms and sexually explicit content',
        'filter.violence': 'Violence & Gore',
        'filter.violenceDesc': 'Filters graphic violence, gore, and violent threats',
        'filter.drugs': 'Drugs & Substances',
        'filter.drugsDesc': 'Filters drug-related content and substance abuse',
        'filter.spam': 'Spam & Scams',
        'filter.spamDesc': 'Filters common spam, scam, and promotional content',
        'filter.crypto': 'Cryptocurrency',
        'filter.cryptoDesc': 'Filters cryptocurrency promotion, trading signals, and token shilling',
        'filter.politics': 'Political Content',
        'filter.politicsDesc': 'Filters partisan political content and divisive rhetoric',
        'filter.profanity': 'Strong Profanity',
        'filter.profanityDesc': 'Filters strong profanity and vulgar language',
        // Toast Messages
        'toast.loggedIn': 'Logged in successfully!',
        'toast.settingsSaved': 'Settings saved successfully!',
        'toast.settingsLocal': 'Settings saved locally. Could not save to Nostr.',
        'toast.settingsLocalOnly': 'Settings saved locally!',
        'toast.settingsReset': 'Settings reset to defaults!',
        'toast.avatarUploaded': 'Avatar uploaded successfully!',
        'toast.profileUpdated': 'Profile updated successfully!',
        'toast.copied': 'Copied to clipboard!',
        'toast.copyFailed': 'Failed to copy. Please copy manually.',
        'toast.installExtension': 'Please install a Nostr browser extension like Alby or nos2x',
        'toast.loginFailed': 'Failed to login with extension. Please try again.',
        'toast.invalidKey': 'Invalid private key. Please check and try again.',
        'toast.enterKey': 'Please enter your private key',
        'toast.enterUsername': 'Please enter a username',
        'toast.accountCreated': 'Welcome to Plebs! You are now logged in.',
        'toast.keyCopied': 'Private key copied to clipboard!',
        'toast.unmuted': 'User unmuted',
        'toast.unmuteFailed': 'Failed to unmute user',
        'toast.selectImage': 'Please select an image file',
        'toast.imageTooLarge': 'Image must be less than 5MB',
        'toast.avatarFailed': 'Failed to upload avatar. Please try again.',
        'toast.mustBeLoggedIn': 'You must be logged in to edit your profile',
        'toast.enterDisplayName': 'Please enter a display name',
        'toast.profileFailed': 'Failed to save profile. Please try again.',
        'toast.invalidBunker': 'Please enter a valid bunker URL',
        'toast.connectFailed': 'Failed to connect',
        'toast.showingFiltered': 'Showing filtered content',
        'toast.reportSubmitted': 'Report submitted successfully',
        'toast.draftSaved': 'Draft saved! You can continue later from My Videos.',
        'toast.draftLoaded': 'Draft loaded. Complete your upload and publish.',
        'toast.draftDeleted': 'Draft deleted',
        'toast.languageChanged': 'Language changed',
        'toast.videoBlocked': 'Video blocked and published to Nostr',
        'toast.waitForUpload': 'Please wait for video upload to complete',
        'toast.enterTitle': 'Please enter a title',
        'toast.publishing': 'Publishing video to Nostr...',
        // Video Page
        'video.views': 'views',
        'video.view': 'view',
        'video.followers': 'followers',
        'video.follower': 'follower',
        'video.videos': 'videos',
        'video.follow': 'Follow',
        'video.unfollow': 'Unfollow',
        'video.mute': 'Mute',
        'video.unmute': 'Unmute',
        'video.share': 'Share',
        'video.report': 'Report',
        'video.edit': 'Edit',
        'video.delete': 'Delete',
        'video.comments': 'Comments',
        'video.writeComment': 'Write a comment...',
        'video.postComment': 'Post',
        'video.sortNewest': 'Newest',
        'video.sortOldest': 'Oldest',
        'video.sortTop': 'Top',
        'video.noComments': 'No comments yet. Be the first to comment!',
        'video.loadMore': 'Load more comments',
        'video.reply': 'Reply',
        'video.showReplies': 'Show replies',
        'video.hideReplies': 'Hide replies',
        'video.zap': 'Zap',
        'video.boost': 'Boost',
        'video.sats': 'sats',
        // Empty States
        'empty.noVideos': 'No videos found.',
        'empty.noLikedVideos': "You haven't liked any videos yet.",
        'empty.noHistory': 'No watch history yet. Start watching videos to build your history.',
        'empty.noFollowing': 'No videos from users you follow yet.',
        'empty.noMatching': 'No matching videos found.',
        'empty.noTrending': 'No trending videos',
        'empty.noUsers': 'No matching users found.',
        'empty.noActivity': 'No recent activity.',
        'empty.loginToView': 'Please login to view your liked videos.',
        // Time
        'time.justNow': 'just now',
        'time.minuteAgo': '1 minute ago',
        'time.minutesAgo': '{n} minutes ago',
        'time.hourAgo': '1 hour ago',
        'time.hoursAgo': '{n} hours ago',
        'time.dayAgo': '1 day ago',
        'time.daysAgo': '{n} days ago',
        'time.weekAgo': '1 week ago',
        'time.weeksAgo': '{n} weeks ago',
        'time.monthAgo': '1 month ago',
        'time.monthsAgo': '{n} months ago',
        'time.yearAgo': '1 year ago',
        'time.yearsAgo': '{n} years ago',
        // Live Stream
        'live.live': 'LIVE',
        'live.scheduled': 'Scheduled',
        'live.ended': 'Stream Ended',
        'live.viewers': 'viewers',
        'live.viewer': 'viewer',
        'live.chat': 'Live Chat',
        'live.sendMessage': 'Send a message...',
        'live.send': 'Send',
        // Misc
        'misc.loading': 'Loading...',
        'misc.error': 'Error',
        'misc.retry': 'Retry',
        'misc.close': 'Close',
        'misc.back': 'Back',
        'misc.search': 'Search',
        'misc.searchResults': 'Search Results',
        'misc.videos': 'Videos',
        'misc.users': 'Users',
        'misc.trending': 'Trending',
        'misc.remove': 'Remove',
        // Common actions
        'common.cancel': 'Cancel',
        'common.uploading': 'Uploading...',
        'common.saveChanges': 'Save Changes',
        'common.close': 'Close',
        // Aria labels for accessibility
        'aria.toggleMenu': 'Toggle menu',
        'aria.mainNavigation': 'Main navigation',
        'aria.videoContent': 'Video content',
        'aria.loadingContent': 'Loading content',
        // Additional notification keys
        'notifications.settingsTitle': 'Notification Settings',
        // Additional settings keys
        'settings.contentWarning': 'Content Warning Preferences',
        'settings.showNsfwWarnings': 'Show NSFW warnings',
        'settings.showNsfwWarningsDesc': 'Display age verification for NSFW content',
        'settings.showCommunityWarnings': 'Show community warnings',
        'settings.showCommunityWarningsDesc': 'Display warnings for flagged or heavily downvoted content',
        'settings.showFollowsReportWarnings': 'Show warnings from followed reports',
        'settings.showFollowsReportWarningsDesc': 'Display warnings when 5+ people you follow have reported content',
        'settings.customKeywordFilter': 'Custom Keyword Filter',
        'settings.customKeywordFilterPlaceholder': 'Enter keywords or phrases separated by commas\nExample: spam, unwanted content, specific phrase',
        'settings.customKeywordFilterDesc': 'Add your own keywords to filter out (comma-separated)',
        'settings.blossomServer': 'Blossom Server Settings',
        'settings.customBlossomServers': 'Custom Blossom Servers',
        'settings.customBlossomServersPlaceholder': 'Enter server URLs separated by commas\nExample: https://blossom.example.com, https://another.example.com',
        'settings.customBlossomServersDesc': 'Add your own Blossom servers (comma-separated)',
        // Additional upload keys
        'upload.backToCreate': 'Back to Create',
        'upload.fileHint': 'MP4, AVI, MOV, etc (max 2GB input, will compress to <100MB)',
        'upload.remove': 'Remove',
        'upload.optional': '(optional)',
        'upload.removeVideo': 'Remove and upload different video',
        'upload.removeThumbnail': 'Remove and upload different thumbnail',
        'upload.markNsfw': 'Mark as NSFW (18+)',
        'upload.nsfwDesc': 'Content containing adult material should be marked as NSFW',
        'upload.termsNotice': 'By uploading, you accept our <a href="#/terms" style="color: var(--accent);">Terms of Service</a> and <a href="#/privacy" style="color: var(--accent);">Privacy Policy</a>',
        'upload.qualityHigh': 'High',
        // Additional Go Live keys
        'goLive.backToCreate': 'Back to Create',
        'goLive.whenLive': 'When do you want to go live?',
        'goLive.goLiveNow': 'Go Live Now',
        'goLive.scheduleStream': 'Schedule Stream',
        'goLive.scheduleDateTimeHint': 'Users can join the stream page early to chat before it starts',
        'goLive.clickToSelectThumbnail': 'Click to select a thumbnail image',
        'goLive.thumbnailFormats': 'JPG, PNG, WebP (recommended 1280x720)',
        'goLive.removeThumbnail': 'Remove and upload different thumbnail',
        'goLive.description': 'Description',
        'goLive.descriptionPlaceholder': 'Tell viewers what your stream is about',
        'goLive.tags': 'Tags (comma separated)',
        'goLive.tagsPlaceholder': 'gaming, bitcoin, tutorial',
        'goLive.streamUrlPlaceholder': 'https://your-streaming-service.com/stream.m3u8',
        'goLive.streamUrlHint': 'Use services like zap.stream, OBS Ninja, Cloudflare Stream, or any RTMP/HLS provider',
        'goLive.zapGoalPlaceholder': 'e.g. 10000',
        'goLive.zapGoalHint': 'Set a goal for Bitcoin tips (in sats) to be displayed on your stream',
        'goLive.setupGuideTitle': 'Stream Setup Guide',
        'goLive.setupGuideDesc': 'To go live, you need a streaming URL from a service provider:',
        'goLive.zapStreamDesc': 'Cheap Nostr-native streaming',
        'goLive.obsDesc': 'any RTMP ingest server',
        'goLive.otherProviders': 'Cloudflare Stream, Mux, or other HLS providers',
        'goLive.goLiveButton': 'Go Live',
        // Additional Edit Stream keys
        'editStream.titleLabel': 'Title',
        // NSFW Modal
        'nsfw.description': 'This content is marked as NSFW (Not Safe For Work) and may contain adult material. You must be 18 years or older to view this content.',
        // Community Warning Modal
        'communityWarning.title': 'Community Warning',
        'communityWarning.description': 'This video has been flagged and/or heavily downvoted by the community. This might be due to:',
        'communityWarning.reason1': 'Inappropriate content not properly marked as NSFW',
        'communityWarning.reason2': 'New or suspicious user details',
        'communityWarning.reason3': 'Misleading or false information',
        'communityWarning.reason4': 'Spam or low-quality content',
        'communityWarning.reason5': 'Potentially harmful or illegal content',
        'communityWarning.proceed': 'Proceed with caution.',
        'communityWarning.goBack': 'Go Back',
        'communityWarning.viewAnyway': 'View Anyway',
        // Additional Report keys
        'report.description': 'Select a reason for reporting this content:',
        'report.hateSpeech': 'Hate Speech or Harassment',
        'report.hateSpeechDesc': 'Promotes violence, hate, or harassment against individuals or groups',
        'report.additionalDetailsPlaceholder': 'Provide more context about why you\'re reporting this video...',
        // Additional Share keys
        'share.shareWithOthers': 'Share this video with others:',
        'share.copiedToClipboard': 'Copied to clipboard!',
        'share.embedOnWebsite': 'Embed this video on your website:',
        'share.embedCodeCopied': 'Embed code copied!',
        'share.fallbackNote': 'Includes automatic fallback to mirror servers if primary source fails.',
        // Additional Edit Video keys
        'editVideo.replaceNote': 'Click "Replace Video" to upload a new video file.',
        // Additional Edit Profile keys
        'editProfile.profilePicture': 'Profile Picture',
        'editProfile.uploadPhoto': 'Upload Photo',
        'editProfile.avatarHint': 'Square images work best. Max 5MB.',
        'editProfile.orEnterUrl': 'Or enter image URL directly:',
        'editProfile.lightningAddress': 'Lightning Address',
        'editProfile.lightningAddressHint': 'Add a Lightning address to receive zaps (Bitcoin tips) on your videos and profile.',
        'editProfile.pictureUrlPlaceholder': 'https://example.com/avatar.jpg',
        'editProfile.lightningPlaceholder': 'you@walletofsatoshi.com',
        'editProfile.nip05Placeholder': 'you@domain.com',
        'editProfile.websitePlaceholder': 'https://yourwebsite.com',
        // Additional navigation keys
        'nav.liveStreams': 'Live Streams',
        'nav.github': 'GitHub',
        // Additional connect keys
        'connect.or': 'OR',
        'connect.bunkerPlaceholder': 'bunker://...',
        // Additional private key keys
        'privateKey.placeholder': 'nsec1...',
        // Additional upload keys
        'upload.preparing': 'Preparing...',
        // Dynamic JavaScript text - Buttons and Status
        'button.hideQR': 'Hide QR Code',
        'button.showQR': 'Show QR Code',
        'button.copied': 'Copied!',
        'button.showLess': 'Show Less',
        'button.showMore': 'Show More',
        'button.creatingAccount': 'Creating account...',
        'button.submitting': 'Submitting...',
        'button.scheduleStream': 'Schedule Stream',
        'button.goLive': 'Go Live',
        'button.creatingStream': 'Creating stream...',
        'button.continueCustomAmount': 'Continue with Custom Amount',
        'button.recordFromCamera': 'Record from Camera',
        'button.requestingCamera': 'Requesting camera...',
        'button.recording': 'Recording...',
        // Status messages
        'status.saving': 'Saving...',
        'status.saved': 'Saved!',
        'status.uploading': 'Uploading...',
        'status.uploadComplete': 'Upload complete!',
        'status.uploadingToNostrBuild': 'Uploading to nostr.build...',
        'status.publishingChanges': 'Publishing changes...',
        'status.removingOldVersion': 'Removing old version...',
        'status.validatingThumbnail': 'Validating thumbnail...',
        'status.uploadingThumbnail': 'Uploading thumbnail...',
        'status.thumbnailUploaded': 'Thumbnail uploaded!',
        'status.processingVideo': 'Processing video...',
        'status.compressingVideo': 'Compressing video...',
        'status.uploadingVideo': 'Uploading video...',
        'status.videoUploaded': 'Video uploaded successfully!',
        'status.processing': 'Processing...',
        'status.generatingThumbnail': 'Generating thumbnail...',
        'status.generatingPreview': 'Generating preview...',
        'status.uploadingPreview': 'Uploading preview...',
        'status.publishing': 'Publishing...',
        'status.publishingToNostr': 'Publishing to Nostr...',
        'status.publishingVideoToNostr': 'Publishing video to Nostr...',
        'status.generatingPoW': 'Generating proof of work...',
        'status.posting': 'Posting...',
        'status.processingVideoAndThumbnail': 'Processing video and thumbnail...',
        'status.uploadFailed': 'Upload failed - please try again',
        'status.selectVideoToUpload': 'Select a video to upload',
        'status.waitingForVideoUpload': 'Waiting for video upload...',
        'status.selectVideoAndThumbnail': 'Select video and thumbnail to publish',
        'status.ready': 'Ready ✓',
        'status.failed': 'Failed ✗',
        'status.fromDraft': 'From draft',
        'status.startingNow': 'Starting now!',
        'status.ended': 'ENDED',
        'status.thumbnailReady': 'Ready',
        'status.thumbnailFailed': 'Failed',
        'status.uploadFailedRetry': 'Upload failed. Please try again.',
        // Publish button text
        'publish.video': 'Publish Video',
        'publish.autoThumbnail': 'Publish Video (auto-thumbnail)',
        // Report modal dynamic titles
        'report.titleComment': 'Report Comment',
        'report.titleUser': 'Report User',
        'report.titleVideo': 'Report Video',
        'report.descComment': 'Select a reason for reporting this comment:',
        'report.descUser': 'Select a reason for reporting this user:',
        'report.descVideo': 'Select a reason for reporting this content:',
        // Empty states - extended
        'empty.noMutedUsers': 'No muted users.',
        'empty.noVideosToMonitor': 'No videos found to monitor.',
        'empty.noRecentActivity': 'No recent activity.',
        'empty.failedLoadNotifications': 'Failed to load notifications',
        'empty.loginToViewLiked': 'Please <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">login</a> to view your liked videos.',
        'empty.loginToViewFollowing': 'Please <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">login</a> to view who you are following.',
        'empty.loginToViewVideos': 'Please <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">login</a> to view your videos.',
        'empty.loginToViewAnalytics': 'Please <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">login</a> to view your analytics.',
        'empty.noLikedVideosYet': "You haven't liked any videos yet.",
        'empty.noLikedVideosFound': 'No liked videos found.',
        'empty.noFullLengthLikedVideos': 'No full-length liked videos found.',
        'empty.noWatchHistory': 'No watch history yet. Start watching videos to build your history.',
        'empty.noVideosInHistory': 'No videos found in history.',
        'empty.noFullLengthHistory': 'No full-length videos in history.',
        'empty.noMatchingVideos': 'No matching videos found.',
        'empty.noFullLengthVideos': 'No full-length videos found.',
        'empty.failedLoadTrending': 'Failed to load trending videos.',
        'empty.noTrendingVideos': 'No trending videos found.',
        'empty.noMatchingUsers': 'No matching users found.',
        'empty.unableLoadProfiles': 'Unable to load user profiles.',
        'empty.noFollowingVideos': 'No videos from users you follow yet.',
        'empty.noFullLengthFollowing': 'No full-length videos from users you follow yet.',
        'empty.failedLoadFollowing': 'Failed to load following. Please try again.',
        'empty.noVideosUploadFirst': 'No videos found. Upload your first video!',
        'empty.noFullLengthUploaded': 'No full-length videos found.',
        'empty.noMatchingLiveStreams': 'No matching live streams found.',
        'empty.noMatchingShorts': 'No matching shorts found.',
        'empty.noVideosForTag': 'No videos found for this tag.',
        'empty.noFullLengthForTag': 'No full-length videos found for this tag.',
        'empty.noUploadedVideos': 'No videos uploaded yet.',
        'empty.noVideosFound': 'No videos found.',
        'empty.failedLoadProfile': 'Failed to load profile. Please try again.',
        'empty.noComments': 'No comments yet. Be the first to comment!',
        'empty.failedLoadComments': 'Failed to load comments',
        'empty.noLiveNow': 'No one is live right now. Be the first!',
        // Error messages
        'error.videoNotFound': 'Video not found.',
        'error.contentNotAvailable': 'This content is not available.',
        'error.invalidVideoData': 'Invalid video data.',
        'error.videoNotAvailable': 'Video not available. The file may have been removed.',
        'error.failedLoadVideo': 'Failed to load video. Please try again.',
        'error.failedLoadVideoShort': 'Failed to load video. The file may have been removed.',
        'error.liveStreamNotFound': 'Live stream not found.',
        'error.invalidLiveStreamData': 'Invalid live stream data.',
        'error.failedLoadLiveStream': 'Failed to load live stream.',
        // Button & Action Labels
        'button.follow': 'Follow',
        'button.unfollow': 'Unfollow',
        'button.mute': 'Mute',
        'button.unmute': 'Unmute',
        'button.muteUser': 'Mute user',
        'button.unmuteUser': 'Unmute user',
        'button.confirm': 'Confirm',
        'button.cancel': 'Cancel',
        'button.close': 'Close',
        'button.boost': 'Boost',
        'button.zap': 'Zap',
        'button.viewMore': 'View More',
        'button.viewAnalytics': 'View Analytics',
        'button.backToMyVideos': 'Back to My Videos',
        'button.editDraft': 'Edit draft',
        'button.deleteDraft': 'Delete draft',
        'button.editVideo': 'Edit video',
        'button.deleteVideo': 'Delete video',
        'button.editShort': 'Edit short',
        'button.deleteShort': 'Delete short',
        'button.editStream': 'Edit stream',
        'button.endStream': 'End stream',
        'button.reset': 'Reset',
        'button.download': 'Download',
        'button.watchRecording': 'Watch Recording',
        'button.show': 'Show',
        'button.login': 'Login',
        'button.toggleChat': 'Toggle chat',
        'button.blockVideo': 'Block Video',
        'button.blockUser': 'Block User',
        'button.unblock': 'Unblock',
        'button.removeFromHistory': 'Remove from history',
        // Stats & Counts
        'stat.views': 'views',
        'stat.viewsCount': '{count} views',
        'stat.videos': 'videos',
        'stat.video': 'video',
        'stat.followers': 'followers',
        'stat.follower': 'follower',
        'stat.following': 'Following',
        'stat.subscribers': 'subscribers',
        'stat.comments': 'Comments',
        'stat.liveCount': '{count} live',
        'stat.percentOfGoal': '{percent}% of goal',
        'stat.netGrowth': 'Net Growth',
        'stat.newFollowers': 'New Followers',
        'stat.unfollowed': 'Unfollowed',
        'stat.lastUpdated': 'Last updated: {date}',
        // Content Badges
        'badge.nsfw': 'NSFW',
        'badge.live': 'LIVE',
        'badge.ended': 'ENDED',
        'badge.scheduled': 'SCHEDULED',
        'badge.warning': 'WARNING',
        'badge.communityWarning': 'COMMUNITY WARNING',
        'badge.verifiedNip05': 'Verified NIP-05',
        'badge.streamer': 'Streamer',
        'badge.clickToView': 'Click to view',
        // Actions
        'action.report': 'Report',
        'action.reportComment': 'Report comment',
        'action.reportVideo': 'Report this video',
        'action.reportStream': 'Report this stream',
        'action.like': 'Like',
        'action.dislike': 'Dislike',
        'action.reply': 'Reply',
        // Placeholders
        'placeholder.searchHistory': 'Search history...',
        'placeholder.searchUsers': 'Search users...',
        'placeholder.searchMyVideos': 'Search my videos...',
        'placeholder.eventId': 'Enter event ID (hex or nevent/note)',
        'placeholder.pubkey': 'Enter pubkey (hex or npub)',
        'placeholder.customAmount': 'Custom amount',
        'placeholder.chatEnded': 'Chat is closed - stream has ended',
        'placeholder.addComment': 'Add a comment...',
        'placeholder.setNewGoal': 'Set new goal (sats)',
        // Video & Content
        'video.untitledVideo': 'Untitled Video',
        'video.untitledShort': 'Untitled Short',
        'video.upNext': 'Up next',
        'video.noVideosYet': 'No videos yet',
        'video.noShortsYet': 'No shorts yet',
        'video.noLiveStreamsYet': 'No live streams yet',
        'video.noBlockedVideos': 'No blocked videos',
        'video.noBlockedUsers': 'No blocked users',
        // Stream Messages
        'stream.ended': 'This stream has ended. Chat is now closed.',
        'stream.welcomeChat': 'Welcome to the live chat!',
        'stream.goalReached': 'Goal Reached!',
        'stream.zapGoalReached': 'Zap goal reached! {amount} sats!',
        // Muted/Hidden Content
        'muted.messageFromMutedUser': 'Message from muted user',
        'muted.commentFromMutedUserHidden': 'Comment from muted user hidden',
        'muted.commentHidden': 'Comment hidden ({packs})',
        'muted.messageHidden': 'Message hidden ({packs})',
        'muted.commentReportedByFollows': 'Comment reported by people you follow',
        'muted.messageReportedByFollows': 'Message reported by people you follow',
        'muted.commentHeavilyDownvoted': 'Comment heavily downvoted by community',
        'muted.messageHeavilyDownvoted': 'Message heavily downvoted',
        // Admin & Lists
        'list.blockedVideos': 'Blocked Videos',
        'list.blockedUsers': 'Blocked Users',
        // Errors & Alerts (Camera)
        'alert.cameraNotSupported': 'Camera access is not supported in this browser. Please use a modern browser like Chrome, Firefox, or Safari.',
        'alert.noCameraFound': 'No camera found on this device. Please connect a camera or use the file upload option instead.',
        'alert.cameraAccessDenied': 'Camera access was denied. Please allow camera permissions in your browser settings and try again.',
        'alert.cameraInUse': 'Camera is in use by another application. Please close other apps using the camera and try again.',
        'alert.cameraUnableAccess': 'Unable to access camera with current settings. Please try using the file upload option instead.',
        'alert.cameraUnableAccessWithError': 'Unable to access camera: {error}\n\nPlease use the file upload option instead.',
        // Errors & Alerts (Forms)
        'alert.fillRequiredFields': 'Please fill in all required fields',
        'alert.uploadThumbnail': 'Please upload a thumbnail image for your stream',
        'alert.failedCreateStream': 'Failed to create live stream. Please try again.',
        'alert.failedUpdateStream': 'Failed to update stream. Please try again.',
        'alert.streamNotFound': 'Could not find stream to edit',
        'alert.canOnlyEditOwnStreams': 'You can only edit your own streams',
        'alert.invalidStreamData': 'Invalid stream data',
        'alert.enterValidGoalAmount': 'Please enter a valid goal amount',
        'alert.canOnlyResetOwnGoals': 'You can only reset goals on your own streams',
        'alert.streamEventNotFound': 'Could not find stream event',
        'alert.failedResetZapGoal': 'Failed to reset zap goal. Please try again.',
        'alert.cannotBlockAdmin': 'Cannot block the admin account',
        'alert.analyticsLoadFailed': 'Failed to load analytics. Please try again.',
        // Errors (Video)
        'alert.cannotReplaceShortWithVideo': 'Cannot replace a Short with a regular video. Please upload a vertical video (60 seconds or less).',
        'alert.cannotReplaceVideoWithShort': 'Cannot replace a regular video with a Short. Please upload a horizontal/landscape video.',
        'alert.shortsRequireVertical': 'This video appears to be horizontal (landscape). Shorts must be vertical (portrait) videos. Please use "Upload Video" for horizontal videos.',
        // Zap Messages
        'zap.cannotZapYourself': 'You cannot zap yourself',
        'zap.cannotZapOwnContent': 'You cannot zap your own content',
        'zap.cannotZapOwnComment': 'You cannot zap your own comment',
        'zap.zapAmount': 'Zap {value} sats',
        // Status Messages (Progress)
        'status.loadingVideo': 'Loading video...',
        'status.loading': 'Loading...',
        'status.compressingProgress': 'Compressing... {progress}%',
        'status.uploadingProgress': 'Uploading... {progress}%',
        'status.uploadingServers': 'Uploading... ({completed}/{total} servers)',
        'status.publishedSuccess': 'Published {type} successfully!',
        // Warnings
        'warning.webmFormat': 'Note: Your browser will output WebM format (may not play on iOS). For iOS-compatible MP4, use Chrome on Windows/Mac.',
        // Footer
        'footer.lastUpdated': 'Last updated: December 2024',
    },
    es: {
        // Navigation & Header
        'nav.home': 'Inicio', 'nav.following': 'Siguiendo', 'nav.myVideos': 'Mis Videos', 'nav.liked': 'Me Gusta', 'nav.history': 'Historial', 'nav.topics': 'TEMAS', 'nav.live': 'En Vivo', 'nav.bitcoin': 'Bitcoin', 'nav.nostr': 'Nostr', 'nav.technology': 'Tecnología', 'nav.gaming': 'Juegos', 'nav.tutorials': 'Tutoriales', 'nav.podcasts': 'Podcasts', 'nav.music': 'Música', 'nav.nsfw': 'NSFW', 'nav.about': 'Acerca de', 'nav.contact': 'Contacto', 'nav.terms': 'Términos', 'nav.privacy': 'Privacidad', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.playlists': 'Listas', 'nav.downloads': 'Descargas', 'nav.subscriptions': 'Suscripciones', 'nav.trending': 'Tendencias', 'nav.explore': 'Explorar', 'nav.categories': 'Categorías', 'nav.liveStreams': 'Transmisiones en Vivo', 'nav.github': 'GitHub',
        'header.search': 'Buscar videos...', 'header.notifications': 'Notificaciones', 'header.settings': 'Configuración', 'header.create': 'Crear', 'header.admin': 'Admin', 'header.viewProfile': 'Ver Perfil', 'header.logout': 'Cerrar Sesión',
        // Login Modal
        'login.title': 'Iniciar Sesión con Nostr', 'login.extension': 'Iniciar con Extensión', 'login.extensionDesc': 'Usa Alby, nos2x u otras extensiones Nostr', 'login.connect': 'Nostr Connect', 'login.connectDesc': 'Conectar con firmantes remotos como Amber, nsec.app', 'login.privateKey': 'Clave Privada', 'login.privateKeyDesc': 'Ingresa tu nsec o clave hex (solo local)', 'login.newToNostr': '¿Nuevo en Nostr?', 'login.createAccount': 'Crear Cuenta', 'login.createAccountDesc': 'Comienza con una nueva identidad Nostr para usar en Plebs',
        // Connect Modal
        'connect.title': 'Conectar con Nostr', 'connect.option1': 'Opción 1: Usa esta cadena de conexión', 'connect.option1Desc': 'Copia y pega esto en cualquier app compatible con NIP-46 (nsec.app, Amber, etc.)', 'connect.copyString': 'Copiar Cadena de Conexión', 'connect.showQR': 'Mostrar Código QR', 'connect.listening': 'Esperando conexión...', 'connect.option2': 'Opción 2: Pegar una URL bunker', 'connect.option2Desc': 'Si ya tienes una URL bunker:// de un firmante remoto', 'connect.withBunker': 'Conectar con Bunker', 'connect.popularSigners': 'Firmantes NIP-46 populares:', 'connect.webSigner': 'Firmante web', 'connect.androidApp': 'App Android', 'connect.builtInSigner': 'Firmante integrado', 'connect.or': 'O', 'connect.bunkerPlaceholder': 'bunker://...',
        // Private Key Modal
        'privateKey.title': 'Iniciar con Clave Privada', 'privateKey.warning': 'Advertencia de Seguridad', 'privateKey.warningText': 'Tu clave privada se almacenará localmente en tu navegador. Para mayor seguridad, considera usar una extensión de navegador o Nostr Connect.', 'privateKey.label': 'Clave Privada (nsec o hex)', 'privateKey.showKey': 'Mostrar clave', 'privateKey.login': 'Iniciar Sesión', 'privateKey.placeholder': 'nsec1...',
        // Signup Modal
        'signup.title': 'Crear Cuenta Nostr', 'signup.whatIsNostr': '¿Qué es Nostr?', 'signup.nostrExplanation': 'Nostr es un protocolo social descentralizado que te da propiedad de tu identidad y contenido. A diferencia de las plataformas tradicionales, ninguna empresa puede banearte, censurar tu contenido o cerrar tu cuenta.', 'signup.whyPlebs': '¿Por qué Plebs usa Nostr?', 'signup.plebsExplanation': 'Plebs está construido sobre Nostr para proporcionar compartición de videos resistente a la censura. Tus videos, comentarios e interacciones se almacenan en una red de relays, no en nuestros servidores. ¡Tu identidad Nostr funciona en cientos de otras apps también!', 'signup.howItWorks': 'Cómo funciona', 'signup.keysIdentity': 'Tus claves = Tu identidad.', 'signup.keysIdentityDesc': 'Obtendrás una clave privada (nsec) que prueba que eres dueño de tu cuenta.', 'signup.keepSecret': '¡Mantén tu clave privada en secreto!', 'signup.keepSecretDesc': 'Es como una contraseña que nunca se puede restablecer.', 'signup.oneIdentity': 'Una identidad, muchas apps.', 'signup.oneIdentityDesc': 'Usa la misma cuenta en Damus, Primal, Amethyst y más.', 'signup.gotIt': 'Entendido, vamos a crear mi cuenta', 'signup.username': 'Nombre de Usuario', 'signup.usernamePlaceholder': 'Elige un nombre para mostrar', 'signup.about': 'Acerca de (opcional)', 'signup.aboutPlaceholder': 'Cuéntale a otros sobre ti', 'signup.profilePicture': 'Foto de Perfil (opcional)', 'signup.uploadPhoto': 'Subir Foto', 'signup.remove': 'Eliminar', 'signup.avatarHint': 'Las imágenes cuadradas funcionan mejor. Máx 5MB.', 'signup.uploading': 'Subiendo...', 'signup.lightningAddress': 'Dirección Lightning (opcional)', 'signup.lightningPlaceholder': 'tu@walletofsatoshi.com', 'signup.lightningHint': 'Agrega una dirección Lightning para recibir zaps (propinas de Bitcoin) en tus videos y perfil.', 'signup.yourUsername': 'Tu Nombre de Usuario', 'signup.yourBio': 'Tu biografía aparecerá aquí', 'signup.createAccountBtn': 'Crear Cuenta', 'signup.termsAgree': 'Al crear una cuenta, aceptas nuestros', 'signup.success': '¡Cuenta Creada Exitosamente!', 'signup.yourPrivateKey': 'Tu Clave Privada (nsec)', 'signup.keyWarning': 'Esta es la ÚNICA forma de acceder a tu cuenta. ¡Guárdala en un lugar seguro!', 'signup.copyPrivateKey': 'Copiar Clave Privada', 'signup.howToUseKey': 'Cómo usar tu clave privada', 'signup.continueToPlebs': 'Continuar a Plebs', 'signup.step1': 'Guárdala de forma segura:', 'signup.step1Desc': 'Almacena tu nsec en un administrador de contraseñas, escríbela o guárdala en un archivo encriptado. ¡Nunca la compartas públicamente!', 'signup.step2': 'Para iniciar sesión de nuevo:', 'signup.step2Desc': 'Haz clic en "Clave Privada" en la pantalla de inicio de sesión y pega tu nsec. Funciona como una contraseña.', 'signup.step3': 'Usar en otras apps:', 'signup.step3Desc': '¡Tu nsec funciona en todas las apps Nostr - Damus, Primal, Amethyst y cientos más!', 'signup.step4': 'Considera una app de firmante:', 'signup.step4Desc': 'Para mayor seguridad, usa apps como Amber (Android) o una extensión de navegador como Alby para administrar tus claves.',
        // Notifications
        'notifications.title': 'Notificaciones', 'notifications.settings': 'Configuración de Notificaciones', 'notifications.reactions': 'Reacciones (me gusta/no me gusta)', 'notifications.replies': 'Comentarios y Respuestas', 'notifications.zaps': 'Zaps', 'notifications.chatMentions': 'Menciones en Chat en Vivo', 'notifications.newFollowers': 'Nuevos Seguidores', 'notifications.syncNote': 'La configuración se sincroniza entre dispositivos vía Nostr', 'notifications.settingsTitle': 'Configuración de Notificaciones',
        // Settings Modal
        'settings.title': 'Configuración', 'settings.language': 'Idioma', 'settings.languageDesc': 'Elige tu idioma preferido', 'settings.saveToNostr': 'Guardar en Nostr', 'settings.saveToNostrDesc': 'Sincronizar configuración en todas las instancias de Plebs', 'settings.darkMode': 'Modo Oscuro', 'settings.darkModeDesc': 'Cambiar entre tema claro y oscuro', 'settings.contentWarnings': 'Preferencias de Advertencias de Contenido', 'settings.showNSFW': 'Mostrar advertencias NSFW', 'settings.showNSFWDesc': 'Mostrar verificación de edad para contenido NSFW', 'settings.showCommunity': 'Mostrar advertencias de la comunidad', 'settings.showCommunityDesc': 'Mostrar advertencias para contenido marcado o con muchos votos negativos', 'settings.showFollowsReport': 'Mostrar advertencias de reportes de seguidos', 'settings.showFollowsReportDesc': 'Mostrar advertencias cuando 5+ personas que sigues han reportado contenido', 'settings.filterPacks': 'Paquetes de Filtros de Contenido', 'settings.filterPacksDesc': 'Habilita paquetes de filtros para ocultar automáticamente contenido que coincida con palabras clave específicas.', 'settings.customKeywords': 'Filtro de Palabras Clave Personalizado', 'settings.customKeywordsPlaceholder': 'Ingresa palabras clave o frases separadas por comas', 'settings.customKeywordsDesc': 'Agrega tus propias palabras clave para filtrar (separadas por comas)', 'settings.mutedUsers': 'Usuarios Silenciados', 'settings.mutedUsersDesc': 'Los usuarios que silencies no aparecerán en tu feed o comentarios.', 'settings.blossomSettings': 'Configuración del Servidor Blossom', 'settings.premiumBlossom': 'Servidor Blossom Premium (NostrMedia.com)', 'settings.premiumBlossomDesc': 'Usa NostrMedia.com si eres usuario suscrito', 'settings.customBlossom': 'Servidores Blossom Personalizados', 'settings.customBlossomDesc': 'Agrega tus propios servidores Blossom (separados por comas)', 'settings.relaySettings': 'Configuración de Relays', 'settings.useWotRelays': 'Usar Relays Web of Trust', 'settings.useWotRelaysDesc': 'Conectar a relays Web of Trust para mejor filtrado de spam', 'settings.saveSettings': 'Guardar Configuración', 'settings.resetDefaults': 'Restablecer Valores',
        // Upload Modal
        'upload.title': 'Subir Video', 'upload.videoFile': 'Archivo de Video', 'upload.recordFromCamera': 'Grabar desde Cámara', 'upload.stop': 'Detener', 'upload.recordHint': 'Graba un video vertical (hasta 60 segundos)', 'upload.or': 'o', 'upload.clickToSelect': 'Haz clic para seleccionar video o arrastra y suelta', 'upload.fileTypes': 'MP4, AVI, MOV, etc (máx 2GB entrada, se comprimirá a <100MB)', 'upload.preparing': 'Preparando...', 'upload.thumbnail': 'Miniatura', 'upload.thumbnailHint': 'Haz clic para seleccionar o auto-generar del video', 'upload.uploading': 'Subiendo...', 'upload.titleLabel': 'Título', 'upload.titlePlaceholder': 'Ingresa el título del video', 'upload.descriptionLabel': 'Descripción', 'upload.descriptionPlaceholder': 'Cuéntale a los espectadores sobre tu video', 'upload.tagsLabel': 'Etiquetas (separadas por comas)', 'upload.tagsPlaceholder': 'bitcoin, nostr, tutorial', 'upload.markNsfw': 'Marcar como NSFW (18+)', 'upload.nsfwDesc': 'El contenido que contiene material adulto debe marcarse como NSFW', 'upload.saveDraft': 'Guardar como Borrador', 'upload.publish': 'Publicar', 'upload.selectVideo': 'Selecciona un video para subir', 'upload.optional': '(opcional)', 'upload.remove': 'Eliminar', 'upload.removeThumbnail': 'Eliminar y subir diferente miniatura', 'upload.removeVideo': 'Eliminar y subir diferente video', 'upload.qualityHigh': 'Alta', 'upload.backToCreate': 'Volver a Crear',
        // Create Modal
        'create.title': 'Crear', 'create.goLive': 'En Vivo', 'create.goLiveDesc': 'Inicia una transmisión en vivo o programa una', 'create.uploadVideo': 'Subir Video', 'create.uploadVideoDesc': 'Sube un video desde tu dispositivo', 'create.createShort': 'Crear Short', 'create.createShortDesc': 'Sube un video vertical (menos de 60s)',
        // Go Live Modal
        'goLive.title': 'En Vivo', 'goLive.when': '¿Cuándo quieres transmitir en vivo?', 'goLive.now': 'Transmitir Ahora', 'goLive.schedule': 'Programar Transmisión', 'goLive.scheduleDateTime': 'Fecha y Hora Programada', 'goLive.streamThumbnail': 'Miniatura de Transmisión', 'goLive.streamTitle': 'Título de Transmisión', 'goLive.streamTitlePlaceholder': 'Ingresa el título de tu transmisión', 'goLive.description': 'Descripción', 'goLive.descriptionPlaceholder': 'Cuéntale a los espectadores de qué trata tu transmisión', 'goLive.tags': 'Etiquetas (separadas por comas)', 'goLive.tagsPlaceholder': 'gaming, bitcoin, tutorial', 'goLive.streamUrl': 'URL de Transmisión (RTMP, HLS o WebRTC)', 'goLive.streamUrlPlaceholder': 'https://tu-servicio-streaming.com/stream.m3u8', 'goLive.streamUrlHint': 'Usa servicios como zap.stream, OBS Ninja, Cloudflare Stream o cualquier proveedor RTMP/HLS', 'goLive.zapGoal': 'Meta de Zaps (opcional)', 'goLive.zapGoalPlaceholder': 'ej. 10000', 'goLive.zapGoalHint': 'Establece una meta de propinas de Bitcoin (en sats) para mostrar en tu transmisión', 'goLive.setupGuide': 'Guía de Configuración de Transmisión', 'goLive.setupGuideDesc': 'Para transmitir en vivo, necesitas una URL de streaming de un proveedor de servicios:', 'goLive.cancel': 'Cancelar', 'goLive.goLiveBtn': 'Transmitir',
        // Edit Stream Modal
        'editStream.title': 'Editar Transmisión', 'editStream.changeThumbnail': 'Cambiar Miniatura', 'editStream.titleLabel': 'Título', 'editStream.saveChanges': 'Guardar Cambios',
        // NSFW Warning Modal
        'nsfw.title': 'Verificación de Edad Requerida', 'nsfw.description': 'Este contenido está marcado como NSFW (No Seguro Para el Trabajo) y puede contener material adulto. Debes tener 18 años o más para ver este contenido.', 'nsfw.confirm': 'Tengo 18+ años', 'nsfw.remember': 'No preguntar de nuevo (Recordar mi elección)',
        // Community Warning Modal
        'communityWarning.title': 'Advertencia de la Comunidad', 'communityWarning.description': 'Este video ha sido marcado y/o tiene muchos votos negativos de la comunidad. Esto puede ser debido a:', 'communityWarning.reason1': 'Contenido inapropiado no marcado correctamente como NSFW', 'communityWarning.reason2': 'Detalles de usuario nuevos o sospechosos', 'communityWarning.reason3': 'Información engañosa o falsa', 'communityWarning.reason4': 'Spam o contenido de baja calidad', 'communityWarning.reason5': 'Contenido potencialmente dañino o ilegal', 'communityWarning.proceed': 'Procede con precaución.', 'communityWarning.goBack': 'Volver', 'communityWarning.viewAnyway': 'Ver de Todos Modos',
        // Report Modal
        'report.title': 'Reportar Video', 'report.description': 'Selecciona una razón para reportar este contenido:', 'report.nudity': 'Desnudez o Contenido Sexual', 'report.nudityDesc': 'Contiene imágenes sexuales o explícitas no marcadas como NSFW', 'report.hate': 'Discurso de Odio o Acoso', 'report.hateDesc': 'Promueve violencia, odio o acoso contra individuos o grupos', 'report.illegal': 'Contenido Ilegal', 'report.illegalDesc': 'Contenido que puede violar leyes o regulaciones', 'report.spam': 'Spam o Engañoso', 'report.spamDesc': 'Contenido engañoso, estafas o spam repetitivo', 'report.impersonation': 'Suplantación de Identidad', 'report.impersonationDesc': 'Pretender ser otra persona', 'report.other': 'Otro', 'report.otherDesc': 'Otra violación no listada arriba', 'report.additionalDetails': 'Detalles adicionales (opcional)', 'report.detailsPlaceholder': 'Proporciona más contexto sobre por qué estás reportando este video...', 'report.cancel': 'Cancelar', 'report.submit': 'Enviar Reporte',
        // Share Modal
        'share.title': 'Compartir Video', 'share.link': 'Enlace', 'share.embed': 'Incrustar', 'share.shareWith': 'Comparte este video con otros:', 'share.copy': 'Copiar', 'share.copied': '¡Copiado al portapapeles!', 'share.embedOnWebsite': 'Incrusta este video en tu sitio web:', 'share.size': 'Tamaño:', 'share.responsive': 'Responsivo (Por defecto)', 'share.size1280x720': '1280 × 720 (HD)', 'share.embedCodeCopied': '¡Código de incrustación copiado!', 'share.fallbackNote': 'Incluye respaldo automático a servidores espejo si la fuente principal falla.',
        // Edit Video Modal
        'editVideo.title': 'Editar Video', 'editVideo.video': 'Video', 'editVideo.currentVideo': 'Video Actual', 'editVideo.replaceVideo': 'Reemplazar Video', 'editVideo.thumbnail': 'Miniatura', 'editVideo.currentThumbnail': 'Miniatura Actual', 'editVideo.changeThumbnail': 'Cambiar Miniatura', 'editVideo.titleLabel': 'Título', 'editVideo.descriptionLabel': 'Descripción', 'editVideo.tagsLabel': 'Etiquetas (separadas por comas)', 'editVideo.cancel': 'Cancelar', 'editVideo.saveChanges': 'Guardar Cambios',
        // Edit Profile Modal
        'editProfile.title': 'Editar Perfil', 'editProfile.displayName': 'Nombre para Mostrar', 'editProfile.displayNamePlaceholder': 'Tu nombre para mostrar', 'editProfile.about': 'Acerca de', 'editProfile.aboutPlaceholder': 'Cuéntale a otros sobre ti', 'editProfile.picture': 'Foto de Perfil', 'editProfile.pictureUrl': 'O ingresa la URL de imagen directamente:', 'editProfile.pictureUrlPlaceholder': 'https://ejemplo.com/avatar.jpg', 'editProfile.lightningPlaceholder': 'tu@walletofsatoshi.com', 'editProfile.nip05': 'Identificador NIP-05 (opcional)', 'editProfile.nip05Placeholder': 'tu@dominio.com', 'editProfile.nip05Hint': 'Una dirección Nostr verificada para verificación de identidad.', 'editProfile.website': 'Sitio Web (opcional)', 'editProfile.websitePlaceholder': 'https://tusitio.com', 'editProfile.lightning': 'Dirección Lightning (opcional)', 'editProfile.saveChanges': 'Guardar Cambios',
        // Confirmation Modal
        'confirm.title': 'Confirmar Acción', 'confirm.message': '¿Estás seguro de que quieres continuar?', 'confirm.cancel': 'Cancelar', 'confirm.confirm': 'Confirmar',
        // Video Page
        'video.views': 'vistas', 'video.view': 'vista', 'video.followers': 'seguidores', 'video.follower': 'seguidor', 'video.follow': 'Seguir', 'video.unfollow': 'Dejar de Seguir', 'video.share': 'Compartir', 'video.comments': 'Comentarios', 'video.writeComment': 'Escribe un comentario...', 'video.noComments': 'Sin comentarios aún. ¡Sé el primero!', 'video.reply': 'Responder', 'video.report': 'Reportar', 'video.mute': 'Silenciar Usuario',
        // Toast Messages
        'toast.loggedIn': '¡Sesión iniciada!', 'toast.settingsSaved': '¡Configuración guardada!', 'toast.languageChanged': 'Idioma cambiado', 'toast.copied': '¡Copiado!', 'toast.reported': 'Reporte enviado', 'toast.followed': 'Siguiendo', 'toast.unfollowed': 'Dejaste de seguir',
        // Time
        'time.justNow': 'ahora mismo', 'time.minuteAgo': 'hace 1 minuto', 'time.minutesAgo': 'hace {n} minutos', 'time.hourAgo': 'hace 1 hora', 'time.hoursAgo': 'hace {n} horas', 'time.dayAgo': 'hace 1 día', 'time.daysAgo': 'hace {n} días', 'time.weekAgo': 'hace 1 semana', 'time.weeksAgo': 'hace {n} semanas', 'time.monthAgo': 'hace 1 mes', 'time.monthsAgo': 'hace {n} meses', 'time.yearAgo': 'hace 1 año', 'time.yearsAgo': 'hace {n} años',
        // Empty States
        'empty.noVideos': 'No se encontraron videos.', 'empty.noLikedVideos': 'Aún no has dado me gusta a ningún video.', 'empty.noHistory': 'Sin historial de reproducción.', 'empty.noFollowing': 'No estás siguiendo a nadie todavía.', 'empty.noNotifications': 'No hay notificaciones.',
        // Misc
        'misc.loading': 'Cargando...', 'misc.close': 'Cerrar', 'misc.back': 'Volver', 'misc.search': 'Buscar', 'misc.searchResults': 'Resultados de Búsqueda', 'misc.videos': 'Videos', 'misc.users': 'Usuarios', 'misc.trending': 'Tendencias', 'misc.remove': 'Eliminar',
        // Common
        'common.cancel': 'Cancelar', 'common.uploading': 'Subiendo...', 'common.saveChanges': 'Guardar Cambios', 'common.close': 'Cerrar',
        // Aria Labels
        'aria.toggleMenu': 'Alternar menú', 'aria.mainNavigation': 'Navegación principal', 'aria.videoContent': 'Contenido de video', 'aria.loadingContent': 'Cargando contenido',
        // Dynamic JavaScript text
        'button.hideQR': 'Ocultar Código QR', 'button.showQR': 'Mostrar Código QR', 'button.copied': '¡Copiado!', 'button.showLess': 'Ver Menos', 'button.showMore': 'Ver Más', 'button.creatingAccount': 'Creando cuenta...', 'button.submitting': 'Enviando...', 'button.scheduleStream': 'Programar Transmisión', 'button.goLive': 'Transmitir', 'button.creatingStream': 'Creando transmisión...', 'button.continueCustomAmount': 'Continuar con Cantidad Personalizada', 'button.recordFromCamera': 'Grabar desde Cámara', 'button.requestingCamera': 'Solicitando cámara...', 'button.recording': 'Grabando...',
        'status.saving': 'Guardando...', 'status.saved': '¡Guardado!', 'status.uploading': 'Subiendo...', 'status.uploadComplete': '¡Subida completa!', 'status.uploadingToNostrBuild': 'Subiendo a nostr.build...', 'status.publishingChanges': 'Publicando cambios...', 'status.removingOldVersion': 'Eliminando versión anterior...', 'status.validatingThumbnail': 'Validando miniatura...', 'status.uploadingThumbnail': 'Subiendo miniatura...', 'status.thumbnailUploaded': '¡Miniatura subida!', 'status.processingVideo': 'Procesando video...', 'status.compressingVideo': 'Comprimiendo video...', 'status.uploadingVideo': 'Subiendo video...', 'status.videoUploaded': '¡Video subido exitosamente!', 'status.processing': 'Procesando...', 'status.generatingThumbnail': 'Generando miniatura...', 'status.generatingPreview': 'Generando vista previa...', 'status.uploadingPreview': 'Subiendo vista previa...', 'status.publishing': 'Publicando...', 'status.publishingToNostr': 'Publicando en Nostr...', 'status.publishingVideoToNostr': 'Publicando video en Nostr...', 'status.generatingPoW': 'Generando prueba de trabajo...', 'status.posting': 'Publicando...', 'status.processingVideoAndThumbnail': 'Procesando video y miniatura...', 'status.uploadFailed': 'Subida fallida - intenta de nuevo', 'status.selectVideoToUpload': 'Selecciona un video para subir', 'status.waitingForVideoUpload': 'Esperando subida de video...', 'status.selectVideoAndThumbnail': 'Selecciona video y miniatura para publicar', 'status.ready': 'Listo ✓', 'status.failed': 'Fallido ✗', 'status.fromDraft': 'Desde borrador', 'status.startingNow': '¡Comenzando ahora!', 'status.ended': 'TERMINADO', 'status.thumbnailReady': 'Listo', 'status.thumbnailFailed': 'Fallido', 'status.uploadFailedRetry': 'Subida fallida. Intenta de nuevo.',
        'publish.video': 'Publicar Video', 'publish.autoThumbnail': 'Publicar Video (miniatura automática)',
        'report.titleComment': 'Reportar Comentario', 'report.titleUser': 'Reportar Usuario', 'report.titleVideo': 'Reportar Video', 'report.descComment': 'Selecciona una razón para reportar este comentario:', 'report.descUser': 'Selecciona una razón para reportar este usuario:', 'report.descVideo': 'Selecciona una razón para reportar este contenido:',
        'empty.noMutedUsers': 'Sin usuarios silenciados.', 'empty.noVideosToMonitor': 'No se encontraron videos para monitorear.', 'empty.noRecentActivity': 'Sin actividad reciente.', 'empty.failedLoadNotifications': 'Error al cargar notificaciones', 'empty.loginToViewLiked': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">inicia sesión</a> para ver tus videos favoritos.', 'empty.loginToViewFollowing': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">inicia sesión</a> para ver a quién sigues.', 'empty.loginToViewVideos': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">inicia sesión</a> para ver tus videos.', 'empty.loginToViewAnalytics': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">inicia sesión</a> para ver tus estadísticas.', 'empty.noLikedVideosYet': 'Aún no has dado me gusta a ningún video.', 'empty.noLikedVideosFound': 'No se encontraron videos favoritos.', 'empty.noFullLengthLikedVideos': 'No se encontraron videos largos favoritos.', 'empty.noWatchHistory': 'Sin historial de reproducción. Comienza a ver videos para crear tu historial.', 'empty.noVideosInHistory': 'No se encontraron videos en el historial.', 'empty.noFullLengthHistory': 'No se encontraron videos largos en el historial.', 'empty.noMatchingVideos': 'No se encontraron videos coincidentes.', 'empty.noFullLengthVideos': 'No se encontraron videos largos.', 'empty.failedLoadTrending': 'Error al cargar videos en tendencia.', 'empty.noTrendingVideos': 'No se encontraron videos en tendencia.', 'empty.noMatchingUsers': 'No se encontraron usuarios coincidentes.', 'empty.unableLoadProfiles': 'No se pudieron cargar los perfiles.', 'empty.noFollowingVideos': 'Aún no hay videos de usuarios que sigues.', 'empty.noFullLengthFollowing': 'No hay videos largos de usuarios que sigues.', 'empty.failedLoadFollowing': 'Error al cargar seguidos. Intenta de nuevo.', 'empty.noVideosUploadFirst': 'No se encontraron videos. ¡Sube tu primer video!', 'empty.noFullLengthUploaded': 'No se encontraron videos largos.', 'empty.noMatchingLiveStreams': 'No se encontraron transmisiones coincidentes.', 'empty.noMatchingShorts': 'No se encontraron shorts coincidentes.', 'empty.noVideosForTag': 'No se encontraron videos para esta etiqueta.', 'empty.noFullLengthForTag': 'No se encontraron videos largos para esta etiqueta.', 'empty.noUploadedVideos': 'Aún no hay videos subidos.', 'empty.noVideosFound': 'No se encontraron videos.', 'empty.failedLoadProfile': 'Error al cargar perfil. Intenta de nuevo.', 'empty.noComments': '¡Sin comentarios aún. Sé el primero en comentar!', 'empty.failedLoadComments': 'Error al cargar comentarios', 'empty.noLiveNow': '¡Nadie está en vivo ahora. Sé el primero!',
        'error.videoNotFound': 'Video no encontrado.', 'error.contentNotAvailable': 'Este contenido no está disponible.', 'error.invalidVideoData': 'Datos de video inválidos.', 'error.videoNotAvailable': 'Video no disponible. El archivo puede haber sido eliminado.', 'error.failedLoadVideo': 'Error al cargar video. Intenta de nuevo.', 'error.failedLoadVideoShort': 'Error al cargar video. El archivo puede haber sido eliminado.', 'error.liveStreamNotFound': 'Transmisión en vivo no encontrada.', 'error.invalidLiveStreamData': 'Datos de transmisión inválidos.', 'error.failedLoadLiveStream': 'Error al cargar transmisión en vivo.',
        // New Button & Action Labels
        'button.follow': 'Seguir', 'button.unfollow': 'Dejar de seguir', 'button.mute': 'Silenciar', 'button.unmute': 'Quitar silencio', 'button.muteUser': 'Silenciar usuario', 'button.unmuteUser': 'Quitar silencio al usuario', 'button.confirm': 'Confirmar', 'button.cancel': 'Cancelar', 'button.close': 'Cerrar', 'button.boost': 'Impulsar', 'button.zap': 'Zap', 'button.viewMore': 'Ver más', 'button.viewAnalytics': 'Ver estadísticas', 'button.backToMyVideos': 'Volver a Mis Videos', 'button.editDraft': 'Editar borrador', 'button.deleteDraft': 'Eliminar borrador', 'button.editVideo': 'Editar video', 'button.deleteVideo': 'Eliminar video', 'button.editShort': 'Editar short', 'button.deleteShort': 'Eliminar short', 'button.editStream': 'Editar transmisión', 'button.endStream': 'Finalizar transmisión', 'button.reset': 'Restablecer', 'button.download': 'Descargar', 'button.watchRecording': 'Ver grabación', 'button.show': 'Mostrar', 'button.login': 'Iniciar sesión', 'button.toggleChat': 'Alternar chat', 'button.blockVideo': 'Bloquear video', 'button.blockUser': 'Bloquear usuario', 'button.unblock': 'Desbloquear', 'button.removeFromHistory': 'Eliminar del historial',
        // New Stats & Counts
        'stat.views': 'vistas', 'stat.viewsCount': '{count} vistas', 'stat.videos': 'videos', 'stat.video': 'video', 'stat.followers': 'seguidores', 'stat.follower': 'seguidor', 'stat.following': 'Siguiendo', 'stat.subscribers': 'suscriptores', 'stat.comments': 'Comentarios', 'stat.liveCount': '{count} en vivo', 'stat.percentOfGoal': '{percent}% del objetivo', 'stat.netGrowth': 'Crecimiento neto', 'stat.newFollowers': 'Nuevos seguidores', 'stat.unfollowed': 'Dejaron de seguir', 'stat.lastUpdated': 'Última actualización: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'EN VIVO', 'badge.ended': 'TERMINADO', 'badge.scheduled': 'PROGRAMADO', 'badge.warning': 'ADVERTENCIA', 'badge.communityWarning': 'ADVERTENCIA DE LA COMUNIDAD', 'badge.verifiedNip05': 'NIP-05 verificado', 'badge.streamer': 'Streamer', 'badge.clickToView': 'Clic para ver',
        // New Actions
        'action.report': 'Reportar', 'action.reportComment': 'Reportar comentario', 'action.reportVideo': 'Reportar este video', 'action.reportStream': 'Reportar esta transmisión', 'action.like': 'Me gusta', 'action.dislike': 'No me gusta', 'action.reply': 'Responder',
        // New Placeholders
        'placeholder.searchHistory': 'Buscar historial...', 'placeholder.searchUsers': 'Buscar usuarios...', 'placeholder.searchMyVideos': 'Buscar mis videos...', 'placeholder.eventId': 'Ingresa ID del evento (hex o nevent/note)', 'placeholder.pubkey': 'Ingresa pubkey (hex o npub)', 'placeholder.customAmount': 'Cantidad personalizada', 'placeholder.chatEnded': 'Chat cerrado - la transmisión ha terminado', 'placeholder.addComment': 'Agrega un comentario...', 'placeholder.setNewGoal': 'Establecer nuevo objetivo (sats)',
        // New Video & Content
        'video.untitledVideo': 'Video sin título', 'video.untitledShort': 'Short sin título', 'video.upNext': 'A continuación', 'video.noVideosYet': 'Aún no hay videos', 'video.noShortsYet': 'Aún no hay shorts', 'video.noLiveStreamsYet': 'Aún no hay transmisiones en vivo', 'video.noBlockedVideos': 'No hay videos bloqueados', 'video.noBlockedUsers': 'No hay usuarios bloqueados',
        // New Stream Messages
        'stream.ended': 'Esta transmisión ha terminado. El chat está cerrado.', 'stream.welcomeChat': '¡Bienvenido al chat en vivo!', 'stream.goalReached': '¡Objetivo alcanzado!', 'stream.zapGoalReached': '¡Objetivo de zap alcanzado! ¡{amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Mensaje de usuario silenciado', 'muted.commentFromMutedUserHidden': 'Comentario de usuario silenciado oculto', 'muted.commentHidden': 'Comentario oculto ({packs})', 'muted.messageHidden': 'Mensaje oculto ({packs})', 'muted.commentReportedByFollows': 'Comentario reportado por personas que sigues', 'muted.messageReportedByFollows': 'Mensaje reportado por personas que sigues', 'muted.commentHeavilyDownvoted': 'Comentario muy negativo por la comunidad', 'muted.messageHeavilyDownvoted': 'Mensaje muy negativo',
        // New Admin & Lists
        'list.blockedVideos': 'Videos bloqueados', 'list.blockedUsers': 'Usuarios bloqueados',
        // New Errors & Alerts
        'alert.cameraNotSupported': 'El acceso a la cámara no es compatible con este navegador. Por favor usa un navegador moderno como Chrome, Firefox o Safari.', 'alert.noCameraFound': 'No se encontró cámara en este dispositivo. Por favor conecta una cámara o usa la opción de subir archivo.', 'alert.cameraAccessDenied': 'Acceso a la cámara denegado. Por favor permite los permisos de cámara en tu navegador e intenta de nuevo.', 'alert.cameraInUse': 'La cámara está siendo usada por otra aplicación. Por favor cierra otras apps que usen la cámara e intenta de nuevo.', 'alert.cameraUnableAccess': 'No se puede acceder a la cámara con la configuración actual. Por favor intenta usar la opción de subir archivo.', 'alert.cameraUnableAccessWithError': 'No se puede acceder a la cámara: {error}\n\nPor favor usa la opción de subir archivo.', 'alert.fillRequiredFields': 'Por favor completa todos los campos requeridos', 'alert.uploadThumbnail': 'Por favor sube una imagen de miniatura para tu transmisión', 'alert.failedCreateStream': 'Error al crear la transmisión en vivo. Por favor intenta de nuevo.', 'alert.failedUpdateStream': 'Error al actualizar la transmisión. Por favor intenta de nuevo.', 'alert.streamNotFound': 'No se encontró la transmisión para editar', 'alert.canOnlyEditOwnStreams': 'Solo puedes editar tus propias transmisiones', 'alert.invalidStreamData': 'Datos de transmisión inválidos', 'alert.enterValidGoalAmount': 'Por favor ingresa una cantidad de objetivo válida', 'alert.canOnlyResetOwnGoals': 'Solo puedes restablecer objetivos en tus propias transmisiones', 'alert.streamEventNotFound': 'No se encontró el evento de transmisión', 'alert.failedResetZapGoal': 'Error al restablecer el objetivo de zap. Por favor intenta de nuevo.', 'alert.cannotBlockAdmin': 'No se puede bloquear la cuenta de administrador', 'alert.analyticsLoadFailed': 'Error al cargar estadísticas. Por favor intenta de nuevo.', 'alert.cannotReplaceShortWithVideo': 'No se puede reemplazar un Short con un video regular. Por favor sube un video vertical (60 segundos o menos).', 'alert.cannotReplaceVideoWithShort': 'No se puede reemplazar un video regular con un Short. Por favor sube un video horizontal/paisaje.', 'alert.shortsRequireVertical': 'Este video parece ser horizontal (paisaje). Los Shorts deben ser videos verticales (retrato). Por favor usa "Subir Video" para videos horizontales.',
        // New Zap Messages
        'zap.cannotZapYourself': 'No puedes enviarte zap a ti mismo', 'zap.cannotZapOwnContent': 'No puedes enviar zap a tu propio contenido', 'zap.cannotZapOwnComment': 'No puedes enviar zap a tu propio comentario', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'Cargando video...', 'status.loading': 'Cargando...', 'status.compressingProgress': 'Comprimiendo... {progress}%', 'status.uploadingProgress': 'Subiendo... {progress}%', 'status.uploadingServers': 'Subiendo... ({completed}/{total} servidores)', 'status.publishedSuccess': '¡{type} publicado exitosamente!',
        // New Warnings
        'warning.webmFormat': 'Nota: Tu navegador producirá formato WebM (puede no reproducirse en iOS). Para MP4 compatible con iOS, usa Chrome en Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Última actualización: Diciembre 2024',
    },
    fr: {
        // Navigation & Header
        'nav.home': 'Accueil', 'nav.following': 'Abonnements', 'nav.myVideos': 'Mes Vidéos', 'nav.liked': 'Aimés', 'nav.history': 'Historique', 'nav.topics': 'SUJETS', 'nav.live': 'En Direct', 'nav.bitcoin': 'Bitcoin', 'nav.nostr': 'Nostr', 'nav.technology': 'Technologie', 'nav.gaming': 'Jeux', 'nav.tutorials': 'Tutoriels', 'nav.podcasts': 'Podcasts', 'nav.music': 'Musique', 'nav.nsfw': 'NSFW', 'nav.about': 'À Propos', 'nav.contact': 'Contact', 'nav.terms': 'Conditions', 'nav.privacy': 'Confidentialité', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.playlists': 'Playlists', 'nav.downloads': 'Téléchargements', 'nav.subscriptions': 'Abonnements', 'nav.trending': 'Tendances', 'nav.explore': 'Explorer', 'nav.categories': 'Catégories', 'nav.liveStreams': 'Diffusions en Direct', 'nav.github': 'GitHub',
        'header.search': 'Rechercher des vidéos...', 'header.notifications': 'Notifications', 'header.settings': 'Paramètres', 'header.create': 'Créer', 'header.admin': 'Admin', 'header.viewProfile': 'Voir le Profil', 'header.logout': 'Déconnexion',
        // Login Modal
        'login.title': 'Connexion avec Nostr', 'login.extension': 'Connexion avec Extension', 'login.extensionDesc': 'Utilisez Alby, nos2x ou d\'autres extensions Nostr', 'login.connect': 'Nostr Connect', 'login.connectDesc': 'Connectez-vous avec des signataires distants comme Amber, nsec.app', 'login.privateKey': 'Clé Privée', 'login.privateKeyDesc': 'Entrez votre nsec ou clé hex (local uniquement)', 'login.newToNostr': 'Nouveau sur Nostr?', 'login.createAccount': 'Créer un Compte', 'login.createAccountDesc': 'Commencez avec une nouvelle identité Nostr pour utiliser sur Plebs',
        // Connect Modal
        'connect.title': 'Connexion avec Nostr', 'connect.option1': 'Option 1: Utilisez cette chaîne de connexion', 'connect.option1Desc': 'Copiez et collez ceci dans n\'importe quelle app compatible NIP-46 (nsec.app, Amber, etc.)', 'connect.copyString': 'Copier la Chaîne de Connexion', 'connect.showQR': 'Afficher le Code QR', 'connect.listening': 'En attente de connexion...', 'connect.option2': 'Option 2: Coller une URL bunker', 'connect.option2Desc': 'Si vous avez déjà une URL bunker:// d\'un signataire distant', 'connect.withBunker': 'Connecter avec Bunker', 'connect.popularSigners': 'Signataires NIP-46 populaires:', 'connect.webSigner': 'Signataire web', 'connect.androidApp': 'App Android', 'connect.builtInSigner': 'Signataire intégré', 'connect.or': 'OU', 'connect.bunkerPlaceholder': 'bunker://...',
        // Private Key Modal
        'privateKey.title': 'Connexion avec Clé Privée', 'privateKey.warning': 'Avertissement de Sécurité', 'privateKey.warningText': 'Votre clé privée sera stockée localement dans votre navigateur. Pour plus de sécurité, envisagez d\'utiliser une extension de navigateur ou Nostr Connect.', 'privateKey.label': 'Clé Privée (nsec ou hex)', 'privateKey.showKey': 'Afficher la clé', 'privateKey.login': 'Connexion', 'privateKey.placeholder': 'nsec1...',
        // Signup Modal
        'signup.title': 'Créer un Compte Nostr', 'signup.whatIsNostr': 'Qu\'est-ce que Nostr?', 'signup.nostrExplanation': 'Nostr est un protocole social décentralisé qui vous donne la propriété de votre identité et de votre contenu. Contrairement aux plateformes traditionnelles, aucune entreprise ne peut vous bannir, censurer votre contenu ou fermer votre compte.', 'signup.whyPlebs': 'Pourquoi Plebs utilise Nostr?', 'signup.plebsExplanation': 'Plebs est construit sur Nostr pour fournir un partage de vidéos résistant à la censure. Vos vidéos, commentaires et interactions sont stockés sur un réseau de relais, pas sur nos serveurs. Votre identité Nostr fonctionne sur des centaines d\'autres apps aussi!', 'signup.howItWorks': 'Comment ça marche', 'signup.keysIdentity': 'Vos clés = Votre identité.', 'signup.keysIdentityDesc': 'Vous obtiendrez une clé privée (nsec) qui prouve que vous êtes propriétaire de votre compte.', 'signup.keepSecret': 'Gardez votre clé privée secrète!', 'signup.keepSecretDesc': 'C\'est comme un mot de passe qui ne peut jamais être réinitialisé.', 'signup.oneIdentity': 'Une identité, plusieurs apps.', 'signup.oneIdentityDesc': 'Utilisez le même compte sur Damus, Primal, Amethyst et plus.', 'signup.gotIt': 'Compris, créons mon compte', 'signup.username': 'Nom d\'utilisateur', 'signup.usernamePlaceholder': 'Choisissez un nom d\'affichage', 'signup.about': 'À propos (optionnel)', 'signup.aboutPlaceholder': 'Parlez de vous aux autres', 'signup.profilePicture': 'Photo de Profil (optionnel)', 'signup.uploadPhoto': 'Télécharger une Photo', 'signup.remove': 'Supprimer', 'signup.avatarHint': 'Les images carrées fonctionnent mieux. Max 5Mo.', 'signup.uploading': 'Téléchargement...', 'signup.lightningAddress': 'Adresse Lightning (optionnel)', 'signup.lightningPlaceholder': 'vous@walletofsatoshi.com', 'signup.lightningHint': 'Ajoutez une adresse Lightning pour recevoir des zaps (pourboires Bitcoin) sur vos vidéos et profil.', 'signup.yourUsername': 'Votre Nom d\'utilisateur', 'signup.yourBio': 'Votre bio apparaîtra ici', 'signup.createAccountBtn': 'Créer le Compte', 'signup.termsAgree': 'En créant un compte, vous acceptez nos', 'signup.success': 'Compte Créé avec Succès!', 'signup.yourPrivateKey': 'Votre Clé Privée (nsec)', 'signup.keyWarning': 'C\'est la SEULE façon d\'accéder à votre compte. Gardez-la en sécurité!', 'signup.copyPrivateKey': 'Copier la Clé Privée', 'signup.howToUseKey': 'Comment utiliser votre clé privée', 'signup.continueToPlebs': 'Continuer vers Plebs',
        // Notifications
        'notifications.title': 'Notifications', 'notifications.settings': 'Paramètres de Notifications', 'notifications.reactions': 'Réactions (j\'aime/je n\'aime pas)', 'notifications.replies': 'Commentaires & Réponses', 'notifications.zaps': 'Zaps', 'notifications.chatMentions': 'Mentions en Chat en Direct', 'notifications.newFollowers': 'Nouveaux Abonnés', 'notifications.syncNote': 'Les paramètres sont synchronisés entre appareils via Nostr',
        // Settings Modal
        'settings.title': 'Paramètres', 'settings.language': 'Langue', 'settings.languageDesc': 'Choisissez votre langue préférée', 'settings.saveToNostr': 'Enregistrer sur Nostr', 'settings.saveToNostrDesc': 'Synchroniser les paramètres sur toutes les instances Plebs', 'settings.darkMode': 'Mode Sombre', 'settings.darkModeDesc': 'Basculer entre thème clair et sombre', 'settings.saveSettings': 'Enregistrer les Paramètres', 'settings.resetDefaults': 'Réinitialiser',
        // Upload Modal
        'upload.title': 'Télécharger une Vidéo', 'upload.videoFile': 'Fichier Vidéo', 'upload.clickToSelect': 'Cliquez pour sélectionner une vidéo ou glissez-déposez', 'upload.fileTypes': 'MP4, AVI, MOV, etc (max 2Go entrée, sera compressé à <100Mo)', 'upload.preparing': 'Préparation...', 'upload.thumbnail': 'Miniature', 'upload.thumbnailHint': 'Cliquez pour sélectionner ou auto-générer depuis la vidéo', 'upload.uploading': 'Téléchargement...', 'upload.titleLabel': 'Titre', 'upload.titlePlaceholder': 'Entrez le titre de la vidéo', 'upload.descriptionLabel': 'Description', 'upload.descriptionPlaceholder': 'Parlez de votre vidéo aux spectateurs', 'upload.tagsLabel': 'Tags (séparés par des virgules)', 'upload.tagsPlaceholder': 'bitcoin, nostr, tutoriel', 'upload.markNsfw': 'Marquer comme NSFW (18+)', 'upload.nsfwDesc': 'Le contenu pour adultes doit être marqué comme NSFW', 'upload.saveDraft': 'Enregistrer comme Brouillon', 'upload.publish': 'Publier', 'upload.selectVideo': 'Sélectionnez une vidéo à télécharger', 'upload.optional': '(optionnel)', 'upload.remove': 'Supprimer', 'upload.qualityHigh': 'Haute',
        // Create Modal
        'create.title': 'Créer', 'create.goLive': 'En Direct', 'create.goLiveDesc': 'Démarrer une diffusion en direct ou en programmer une', 'create.uploadVideo': 'Télécharger une Vidéo', 'create.uploadVideoDesc': 'Télécharger une vidéo depuis votre appareil', 'create.createShort': 'Créer un Short', 'create.createShortDesc': 'Télécharger une vidéo verticale (moins de 60s)',
        // Go Live Modal
        'goLive.title': 'En Direct', 'goLive.when': 'Quand voulez-vous diffuser en direct?', 'goLive.now': 'Diffuser Maintenant', 'goLive.schedule': 'Programmer une Diffusion', 'goLive.streamTitle': 'Titre de la Diffusion', 'goLive.streamTitlePlaceholder': 'Entrez le titre de votre diffusion', 'goLive.description': 'Description', 'goLive.descriptionPlaceholder': 'Dites aux spectateurs de quoi parle votre diffusion', 'goLive.tags': 'Tags (séparés par des virgules)', 'goLive.tagsPlaceholder': 'gaming, bitcoin, tutoriel', 'goLive.streamUrl': 'URL de Diffusion (RTMP, HLS ou WebRTC)', 'goLive.streamUrlPlaceholder': 'https://votre-service-streaming.com/stream.m3u8', 'goLive.zapGoal': 'Objectif de Zaps (optionnel)', 'goLive.zapGoalPlaceholder': 'ex. 10000', 'goLive.cancel': 'Annuler', 'goLive.goLiveBtn': 'Diffuser',
        // Edit Stream Modal
        'editStream.title': 'Modifier la Diffusion', 'editStream.changeThumbnail': 'Changer la Miniature', 'editStream.titleLabel': 'Titre', 'editStream.saveChanges': 'Enregistrer les Modifications',
        // NSFW Warning Modal
        'nsfw.title': 'Vérification d\'Âge Requise', 'nsfw.description': 'Ce contenu est marqué comme NSFW et peut contenir du matériel pour adultes. Vous devez avoir 18 ans ou plus pour voir ce contenu.', 'nsfw.confirm': 'J\'ai 18 ans ou plus', 'nsfw.remember': 'Ne plus demander (Mémoriser mon choix)',
        // Community Warning Modal
        'communityWarning.title': 'Avertissement de la Communauté', 'communityWarning.description': 'Cette vidéo a été signalée et/ou fortement désapprouvée par la communauté.', 'communityWarning.goBack': 'Retour', 'communityWarning.viewAnyway': 'Voir Quand Même',
        // Report Modal
        'report.title': 'Signaler la Vidéo', 'report.description': 'Sélectionnez une raison pour signaler ce contenu:', 'report.nudity': 'Nudité ou Contenu Sexuel', 'report.nudityDesc': 'Contient des images sexuelles ou explicites non marquées comme NSFW', 'report.hate': 'Discours de Haine ou Harcèlement', 'report.hateDesc': 'Promeut la violence, la haine ou le harcèlement', 'report.illegal': 'Contenu Illégal', 'report.illegalDesc': 'Contenu pouvant violer les lois', 'report.spam': 'Spam ou Trompeur', 'report.spamDesc': 'Contenu trompeur, arnaques ou spam répétitif', 'report.impersonation': 'Usurpation d\'Identité', 'report.impersonationDesc': 'Se faire passer pour quelqu\'un d\'autre', 'report.other': 'Autre', 'report.otherDesc': 'Autre violation non listée', 'report.cancel': 'Annuler', 'report.submit': 'Soumettre le Signalement',
        // Share Modal
        'share.title': 'Partager la Vidéo', 'share.link': 'Lien', 'share.embed': 'Intégrer', 'share.shareWith': 'Partagez cette vidéo avec d\'autres:', 'share.copy': 'Copier', 'share.copied': 'Copié dans le presse-papiers!', 'share.embedOnWebsite': 'Intégrez cette vidéo sur votre site web:', 'share.size': 'Taille:', 'share.responsive': 'Responsive (Par défaut)', 'share.size1280x720': '1280 × 720 (HD)', 'share.embedCodeCopied': 'Code d\'intégration copié!',
        // Edit Video Modal
        'editVideo.title': 'Modifier la Vidéo', 'editVideo.video': 'Vidéo', 'editVideo.replaceVideo': 'Remplacer la Vidéo', 'editVideo.thumbnail': 'Miniature', 'editVideo.changeThumbnail': 'Changer la Miniature', 'editVideo.titleLabel': 'Titre', 'editVideo.descriptionLabel': 'Description', 'editVideo.tagsLabel': 'Tags (séparés par des virgules)', 'editVideo.cancel': 'Annuler', 'editVideo.saveChanges': 'Enregistrer les Modifications',
        // Edit Profile Modal
        'editProfile.title': 'Modifier le Profil', 'editProfile.displayName': 'Nom d\'Affichage', 'editProfile.displayNamePlaceholder': 'Votre nom d\'affichage', 'editProfile.about': 'À propos', 'editProfile.aboutPlaceholder': 'Parlez de vous aux autres', 'editProfile.picture': 'Photo de Profil', 'editProfile.pictureUrl': 'Ou entrez l\'URL de l\'image directement:', 'editProfile.nip05': 'Identifiant NIP-05 (optionnel)', 'editProfile.nip05Hint': 'Une adresse Nostr vérifiée pour la vérification d\'identité.', 'editProfile.website': 'Site Web (optionnel)', 'editProfile.saveChanges': 'Enregistrer les Modifications',
        // Confirmation Modal
        'confirm.title': 'Confirmer l\'Action', 'confirm.message': 'Êtes-vous sûr de vouloir continuer?', 'confirm.cancel': 'Annuler', 'confirm.confirm': 'Confirmer',
        // Video Page
        'video.views': 'vues', 'video.view': 'vue', 'video.followers': 'abonnés', 'video.follower': 'abonné', 'video.follow': 'S\'abonner', 'video.unfollow': 'Se désabonner', 'video.share': 'Partager', 'video.comments': 'Commentaires', 'video.writeComment': 'Écrire un commentaire...', 'video.noComments': 'Pas encore de commentaires. Soyez le premier!',
        // Toast Messages
        'toast.loggedIn': 'Connexion réussie!', 'toast.settingsSaved': 'Paramètres enregistrés!', 'toast.languageChanged': 'Langue modifiée', 'toast.copied': 'Copié!',
        // Time
        'time.justNow': 'à l\'instant', 'time.minuteAgo': 'il y a 1 minute', 'time.minutesAgo': 'il y a {n} minutes', 'time.hourAgo': 'il y a 1 heure', 'time.hoursAgo': 'il y a {n} heures', 'time.dayAgo': 'il y a 1 jour', 'time.daysAgo': 'il y a {n} jours',
        // Empty States
        'empty.noVideos': 'Aucune vidéo trouvée.', 'empty.noLikedVideos': 'Vous n\'avez encore aimé aucune vidéo.', 'empty.noHistory': 'Pas d\'historique.',
        // Misc
        'misc.loading': 'Chargement...', 'misc.close': 'Fermer', 'misc.back': 'Retour', 'misc.search': 'Rechercher',
        // Common
        'common.cancel': 'Annuler', 'common.uploading': 'Téléchargement...', 'common.saveChanges': 'Enregistrer les Modifications', 'common.close': 'Fermer',
        // Aria Labels
        'aria.toggleMenu': 'Basculer le menu', 'aria.mainNavigation': 'Navigation principale', 'aria.videoContent': 'Contenu vidéo', 'aria.loadingContent': 'Chargement du contenu',
        // Dynamic JavaScript text
        'button.hideQR': 'Masquer le Code QR', 'button.showQR': 'Afficher le Code QR', 'button.copied': 'Copié!', 'button.showLess': 'Voir Moins', 'button.showMore': 'Voir Plus', 'button.creatingAccount': 'Création du compte...', 'button.submitting': 'Envoi en cours...', 'button.scheduleStream': 'Programmer la Diffusion', 'button.goLive': 'Diffuser', 'button.creatingStream': 'Création de la diffusion...', 'button.continueCustomAmount': 'Continuer avec Montant Personnalisé', 'button.recordFromCamera': 'Enregistrer depuis la Caméra', 'button.requestingCamera': 'Demande de caméra...', 'button.recording': 'Enregistrement...',
        'status.saving': 'Enregistrement...', 'status.saved': 'Enregistré!', 'status.uploading': 'Téléchargement...', 'status.uploadComplete': 'Téléchargement terminé!', 'status.uploadingToNostrBuild': 'Téléchargement vers nostr.build...', 'status.publishingChanges': 'Publication des modifications...', 'status.removingOldVersion': 'Suppression de l\'ancienne version...', 'status.validatingThumbnail': 'Validation de la miniature...', 'status.uploadingThumbnail': 'Téléchargement de la miniature...', 'status.thumbnailUploaded': 'Miniature téléchargée!', 'status.processingVideo': 'Traitement de la vidéo...', 'status.compressingVideo': 'Compression de la vidéo...', 'status.uploadingVideo': 'Téléchargement de la vidéo...', 'status.videoUploaded': 'Vidéo téléchargée avec succès!', 'status.processing': 'Traitement...', 'status.generatingThumbnail': 'Génération de la miniature...', 'status.generatingPreview': 'Génération de l\'aperçu...', 'status.uploadingPreview': 'Téléchargement de l\'aperçu...', 'status.publishing': 'Publication...', 'status.publishingToNostr': 'Publication sur Nostr...', 'status.publishingVideoToNostr': 'Publication de la vidéo sur Nostr...', 'status.generatingPoW': 'Génération de la preuve de travail...', 'status.posting': 'Publication...', 'status.processingVideoAndThumbnail': 'Traitement de la vidéo et de la miniature...', 'status.uploadFailed': 'Échec du téléchargement - réessayez', 'status.selectVideoToUpload': 'Sélectionnez une vidéo à télécharger', 'status.waitingForVideoUpload': 'En attente du téléchargement de la vidéo...', 'status.selectVideoAndThumbnail': 'Sélectionnez vidéo et miniature pour publier', 'status.ready': 'Prêt ✓', 'status.failed': 'Échoué ✗', 'status.fromDraft': 'Depuis le brouillon', 'status.startingNow': 'Démarrage maintenant!', 'status.ended': 'TERMINÉ', 'status.thumbnailReady': 'Prêt', 'status.thumbnailFailed': 'Échoué', 'status.uploadFailedRetry': 'Échec du téléchargement. Veuillez réessayer.',
        'publish.video': 'Publier la Vidéo', 'publish.autoThumbnail': 'Publier la Vidéo (miniature auto)',
        'report.titleComment': 'Signaler le Commentaire', 'report.titleUser': 'Signaler l\'Utilisateur', 'report.titleVideo': 'Signaler la Vidéo', 'report.descComment': 'Sélectionnez une raison pour signaler ce commentaire:', 'report.descUser': 'Sélectionnez une raison pour signaler cet utilisateur:', 'report.descVideo': 'Sélectionnez une raison pour signaler ce contenu:',
        'empty.noMutedUsers': 'Aucun utilisateur en sourdine.', 'empty.noVideosToMonitor': 'Aucune vidéo à surveiller.', 'empty.noRecentActivity': 'Aucune activité récente.', 'empty.failedLoadNotifications': 'Échec du chargement des notifications', 'empty.loginToViewLiked': 'Veuillez <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">vous connecter</a> pour voir vos vidéos aimées.', 'empty.loginToViewFollowing': 'Veuillez <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">vous connecter</a> pour voir qui vous suivez.', 'empty.loginToViewVideos': 'Veuillez <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">vous connecter</a> pour voir vos vidéos.', 'empty.loginToViewAnalytics': 'Veuillez <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">vous connecter</a> pour voir vos statistiques.', 'empty.noLikedVideosYet': 'Vous n\'avez encore aimé aucune vidéo.', 'empty.noLikedVideosFound': 'Aucune vidéo aimée trouvée.', 'empty.noFullLengthLikedVideos': 'Aucune vidéo longue aimée trouvée.', 'empty.noWatchHistory': 'Pas d\'historique. Commencez à regarder des vidéos.', 'empty.noVideosInHistory': 'Aucune vidéo dans l\'historique.', 'empty.noFullLengthHistory': 'Aucune vidéo longue dans l\'historique.', 'empty.noMatchingVideos': 'Aucune vidéo correspondante trouvée.', 'empty.noFullLengthVideos': 'Aucune vidéo longue trouvée.', 'empty.failedLoadTrending': 'Échec du chargement des tendances.', 'empty.noTrendingVideos': 'Aucune vidéo tendance trouvée.', 'empty.noMatchingUsers': 'Aucun utilisateur correspondant trouvé.', 'empty.unableLoadProfiles': 'Impossible de charger les profils.', 'empty.noFollowingVideos': 'Pas encore de vidéos des utilisateurs que vous suivez.', 'empty.noFullLengthFollowing': 'Pas de vidéos longues des utilisateurs que vous suivez.', 'empty.failedLoadFollowing': 'Échec du chargement. Veuillez réessayer.', 'empty.noVideosUploadFirst': 'Aucune vidéo. Téléchargez votre première vidéo!', 'empty.noFullLengthUploaded': 'Aucune vidéo longue trouvée.', 'empty.noMatchingLiveStreams': 'Aucune diffusion correspondante trouvée.', 'empty.noMatchingShorts': 'Aucun short correspondant trouvé.', 'empty.noVideosForTag': 'Aucune vidéo pour ce tag.', 'empty.noFullLengthForTag': 'Aucune vidéo longue pour ce tag.', 'empty.noUploadedVideos': 'Pas encore de vidéos téléchargées.', 'empty.noVideosFound': 'Aucune vidéo trouvée.', 'empty.failedLoadProfile': 'Échec du chargement du profil. Réessayez.', 'empty.noComments': 'Pas encore de commentaires. Soyez le premier!', 'empty.failedLoadComments': 'Échec du chargement des commentaires', 'empty.noLiveNow': 'Personne n\'est en direct. Soyez le premier!',
        'error.videoNotFound': 'Vidéo non trouvée.', 'error.contentNotAvailable': 'Ce contenu n\'est pas disponible.', 'error.invalidVideoData': 'Données vidéo invalides.', 'error.videoNotAvailable': 'Vidéo non disponible. Le fichier a peut-être été supprimé.', 'error.failedLoadVideo': 'Échec du chargement. Veuillez réessayer.', 'error.failedLoadVideoShort': 'Échec du chargement. Fichier peut-être supprimé.', 'error.liveStreamNotFound': 'Diffusion en direct non trouvée.', 'error.invalidLiveStreamData': 'Données de diffusion invalides.', 'error.failedLoadLiveStream': 'Échec du chargement de la diffusion.',
        // New Button & Action Labels
        'button.follow': 'Suivre', 'button.unfollow': 'Ne plus suivre', 'button.mute': 'Mettre en sourdine', 'button.unmute': 'Réactiver le son', 'button.muteUser': 'Mettre l\'utilisateur en sourdine', 'button.unmuteUser': 'Réactiver l\'utilisateur', 'button.confirm': 'Confirmer', 'button.cancel': 'Annuler', 'button.close': 'Fermer', 'button.boost': 'Booster', 'button.zap': 'Zap', 'button.viewMore': 'Voir plus', 'button.viewAnalytics': 'Voir les statistiques', 'button.backToMyVideos': 'Retour à Mes Vidéos', 'button.editDraft': 'Modifier le brouillon', 'button.deleteDraft': 'Supprimer le brouillon', 'button.editVideo': 'Modifier la vidéo', 'button.deleteVideo': 'Supprimer la vidéo', 'button.editShort': 'Modifier le short', 'button.deleteShort': 'Supprimer le short', 'button.editStream': 'Modifier la diffusion', 'button.endStream': 'Terminer la diffusion', 'button.reset': 'Réinitialiser', 'button.download': 'Télécharger', 'button.watchRecording': 'Regarder l\'enregistrement', 'button.show': 'Afficher', 'button.login': 'Connexion', 'button.toggleChat': 'Basculer le chat', 'button.blockVideo': 'Bloquer la vidéo', 'button.blockUser': 'Bloquer l\'utilisateur', 'button.unblock': 'Débloquer', 'button.removeFromHistory': 'Supprimer de l\'historique',
        // New Stats & Counts
        'stat.views': 'vues', 'stat.viewsCount': '{count} vues', 'stat.videos': 'vidéos', 'stat.video': 'vidéo', 'stat.followers': 'abonnés', 'stat.follower': 'abonné', 'stat.following': 'Abonnements', 'stat.subscribers': 'abonnés', 'stat.comments': 'Commentaires', 'stat.liveCount': '{count} en direct', 'stat.percentOfGoal': '{percent}% de l\'objectif', 'stat.netGrowth': 'Croissance nette', 'stat.newFollowers': 'Nouveaux abonnés', 'stat.unfollowed': 'Désabonnements', 'stat.lastUpdated': 'Dernière mise à jour: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'EN DIRECT', 'badge.ended': 'TERMINÉ', 'badge.scheduled': 'PROGRAMMÉ', 'badge.warning': 'AVERTISSEMENT', 'badge.communityWarning': 'AVERTISSEMENT COMMUNAUTAIRE', 'badge.verifiedNip05': 'NIP-05 vérifié', 'badge.streamer': 'Streamer', 'badge.clickToView': 'Cliquer pour voir',
        // New Actions
        'action.report': 'Signaler', 'action.reportComment': 'Signaler le commentaire', 'action.reportVideo': 'Signaler cette vidéo', 'action.reportStream': 'Signaler cette diffusion', 'action.like': 'J\'aime', 'action.dislike': 'Je n\'aime pas', 'action.reply': 'Répondre',
        // New Placeholders
        'placeholder.searchHistory': 'Rechercher dans l\'historique...', 'placeholder.searchUsers': 'Rechercher des utilisateurs...', 'placeholder.searchMyVideos': 'Rechercher mes vidéos...', 'placeholder.eventId': 'Entrer l\'ID d\'événement (hex ou nevent/note)', 'placeholder.pubkey': 'Entrer pubkey (hex ou npub)', 'placeholder.customAmount': 'Montant personnalisé', 'placeholder.chatEnded': 'Chat fermé - la diffusion est terminée', 'placeholder.addComment': 'Ajouter un commentaire...', 'placeholder.setNewGoal': 'Définir un nouvel objectif (sats)',
        // New Video & Content
        'video.untitledVideo': 'Vidéo sans titre', 'video.untitledShort': 'Short sans titre', 'video.upNext': 'À suivre', 'video.noVideosYet': 'Pas encore de vidéos', 'video.noShortsYet': 'Pas encore de shorts', 'video.noLiveStreamsYet': 'Pas encore de diffusions en direct', 'video.noBlockedVideos': 'Aucune vidéo bloquée', 'video.noBlockedUsers': 'Aucun utilisateur bloqué',
        // New Stream Messages
        'stream.ended': 'Cette diffusion est terminée. Le chat est maintenant fermé.', 'stream.welcomeChat': 'Bienvenue dans le chat en direct!', 'stream.goalReached': 'Objectif atteint!', 'stream.zapGoalReached': 'Objectif de zap atteint! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Message d\'un utilisateur en sourdine', 'muted.commentFromMutedUserHidden': 'Commentaire d\'un utilisateur en sourdine masqué', 'muted.commentHidden': 'Commentaire masqué ({packs})', 'muted.messageHidden': 'Message masqué ({packs})', 'muted.commentReportedByFollows': 'Commentaire signalé par des personnes que vous suivez', 'muted.messageReportedByFollows': 'Message signalé par des personnes que vous suivez', 'muted.commentHeavilyDownvoted': 'Commentaire fortement négativé par la communauté', 'muted.messageHeavilyDownvoted': 'Message fortement négativé',
        // New Admin & Lists
        'list.blockedVideos': 'Vidéos bloquées', 'list.blockedUsers': 'Utilisateurs bloqués',
        // New Alerts
        'alert.cameraNotSupported': 'L\'accès à la caméra n\'est pas pris en charge dans ce navigateur. Veuillez utiliser un navigateur moderne comme Chrome, Firefox ou Safari.', 'alert.noCameraFound': 'Aucune caméra trouvée sur cet appareil. Veuillez connecter une caméra ou utiliser l\'option de téléchargement de fichier.', 'alert.cameraAccessDenied': 'L\'accès à la caméra a été refusé. Veuillez autoriser les permissions de caméra dans les paramètres de votre navigateur.', 'alert.cameraInUse': 'La caméra est utilisée par une autre application. Veuillez fermer les autres apps utilisant la caméra.', 'alert.cameraUnableAccess': 'Impossible d\'accéder à la caméra avec les paramètres actuels. Veuillez essayer l\'option de téléchargement.', 'alert.cameraUnableAccessWithError': 'Impossible d\'accéder à la caméra: {error}\n\nVeuillez utiliser l\'option de téléchargement.', 'alert.fillRequiredFields': 'Veuillez remplir tous les champs requis', 'alert.uploadThumbnail': 'Veuillez télécharger une miniature pour votre diffusion', 'alert.failedCreateStream': 'Échec de la création de la diffusion. Veuillez réessayer.', 'alert.failedUpdateStream': 'Échec de la mise à jour. Veuillez réessayer.', 'alert.streamNotFound': 'Diffusion introuvable', 'alert.canOnlyEditOwnStreams': 'Vous ne pouvez modifier que vos propres diffusions', 'alert.invalidStreamData': 'Données de diffusion invalides', 'alert.enterValidGoalAmount': 'Veuillez entrer un montant d\'objectif valide', 'alert.canOnlyResetOwnGoals': 'Vous ne pouvez réinitialiser que vos propres objectifs', 'alert.streamEventNotFound': 'Événement de diffusion introuvable', 'alert.failedResetZapGoal': 'Échec de la réinitialisation de l\'objectif zap. Veuillez réessayer.', 'alert.cannotBlockAdmin': 'Impossible de bloquer le compte admin', 'alert.analyticsLoadFailed': 'Échec du chargement des statistiques. Veuillez réessayer.', 'alert.cannotReplaceShortWithVideo': 'Impossible de remplacer un Short par une vidéo normale. Veuillez télécharger une vidéo verticale (60 secondes ou moins).', 'alert.cannotReplaceVideoWithShort': 'Impossible de remplacer une vidéo par un Short. Veuillez télécharger une vidéo horizontale.', 'alert.shortsRequireVertical': 'Cette vidéo semble être horizontale. Les Shorts doivent être des vidéos verticales. Veuillez utiliser "Télécharger une Vidéo" pour les vidéos horizontales.',
        // New Zap Messages
        'zap.cannotZapYourself': 'Vous ne pouvez pas vous zapper vous-même', 'zap.cannotZapOwnContent': 'Vous ne pouvez pas zapper votre propre contenu', 'zap.cannotZapOwnComment': 'Vous ne pouvez pas zapper votre propre commentaire', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'Chargement de la vidéo...', 'status.loading': 'Chargement...', 'status.compressingProgress': 'Compression... {progress}%', 'status.uploadingProgress': 'Téléchargement... {progress}%', 'status.uploadingServers': 'Téléchargement... ({completed}/{total} serveurs)', 'status.publishedSuccess': '{type} publié avec succès!',
        // New Warnings
        'warning.webmFormat': 'Note: Votre navigateur produira le format WebM (peut ne pas fonctionner sur iOS). Pour MP4 compatible iOS, utilisez Chrome sur Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Dernière mise à jour: Décembre 2024',
    },
    de: {
        // Navigation & Header
        'nav.home': 'Startseite', 'nav.following': 'Abonniert', 'nav.myVideos': 'Meine Videos', 'nav.liked': 'Gefällt mir', 'nav.history': 'Verlauf', 'nav.topics': 'THEMEN', 'nav.live': 'Live', 'nav.bitcoin': 'Bitcoin', 'nav.nostr': 'Nostr', 'nav.technology': 'Technologie', 'nav.gaming': 'Gaming', 'nav.tutorials': 'Tutorials', 'nav.podcasts': 'Podcasts', 'nav.music': 'Musik', 'nav.nsfw': 'NSFW', 'nav.about': 'Über', 'nav.contact': 'Kontakt', 'nav.terms': 'AGB', 'nav.privacy': 'Datenschutz', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.playlists': 'Playlists', 'nav.downloads': 'Downloads', 'nav.subscriptions': 'Abonnements', 'nav.trending': 'Trends', 'nav.explore': 'Entdecken', 'nav.categories': 'Kategorien', 'nav.liveStreams': 'Live-Streams', 'nav.github': 'GitHub',
        'header.search': 'Videos suchen...', 'header.notifications': 'Benachrichtigungen', 'header.settings': 'Einstellungen', 'header.create': 'Erstellen', 'header.admin': 'Admin', 'header.viewProfile': 'Profil anzeigen', 'header.logout': 'Abmelden',
        // Login Modal
        'login.title': 'Mit Nostr anmelden', 'login.extension': 'Mit Erweiterung anmelden', 'login.extensionDesc': 'Verwenden Sie Alby, nos2x oder andere Nostr-Erweiterungen', 'login.connect': 'Nostr Connect', 'login.connectDesc': 'Mit Remote-Signern wie Amber, nsec.app verbinden', 'login.privateKey': 'Privater Schlüssel', 'login.privateKeyDesc': 'Geben Sie Ihren nsec oder hex-Schlüssel ein (nur lokal)', 'login.newToNostr': 'Neu bei Nostr?', 'login.createAccount': 'Konto erstellen', 'login.createAccountDesc': 'Starten Sie mit einer neuen Nostr-Identität für Plebs',
        // Connect Modal
        'connect.title': 'Mit Nostr verbinden', 'connect.option1': 'Option 1: Verwenden Sie diese Verbindungszeichenfolge', 'connect.option1Desc': 'Kopieren Sie dies in eine NIP-46 kompatible App (nsec.app, Amber, etc.)', 'connect.copyString': 'Verbindungsstring kopieren', 'connect.showQR': 'QR-Code anzeigen', 'connect.listening': 'Warte auf Verbindung...', 'connect.option2': 'Option 2: Bunker-URL einfügen', 'connect.option2Desc': 'Falls Sie bereits eine bunker:// URL von einem Remote-Signer haben', 'connect.withBunker': 'Mit Bunker verbinden', 'connect.or': 'ODER', 'connect.bunkerPlaceholder': 'bunker://...',
        // Private Key Modal
        'privateKey.title': 'Mit privatem Schlüssel anmelden', 'privateKey.warning': 'Sicherheitswarnung', 'privateKey.warningText': 'Ihr privater Schlüssel wird lokal in Ihrem Browser gespeichert. Für mehr Sicherheit verwenden Sie eine Browsererweiterung oder Nostr Connect.', 'privateKey.label': 'Privater Schlüssel (nsec oder hex)', 'privateKey.showKey': 'Schlüssel anzeigen', 'privateKey.login': 'Anmelden', 'privateKey.placeholder': 'nsec1...',
        // Signup Modal
        'signup.title': 'Nostr-Konto erstellen', 'signup.whatIsNostr': 'Was ist Nostr?', 'signup.nostrExplanation': 'Nostr ist ein dezentrales soziales Protokoll, das Ihnen die Kontrolle über Ihre Identität und Inhalte gibt. Anders als bei herkömmlichen Plattformen kann Sie kein Unternehmen sperren, zensieren oder Ihr Konto schließen.', 'signup.whyPlebs': 'Warum verwendet Plebs Nostr?', 'signup.plebsExplanation': 'Plebs basiert auf Nostr, um zensurresistentes Video-Sharing zu ermöglichen. Ihre Videos, Kommentare und Interaktionen werden in einem Netzwerk von Relays gespeichert, nicht auf unseren Servern.', 'signup.howItWorks': 'So funktioniert es', 'signup.keysIdentity': 'Ihre Schlüssel = Ihre Identität.', 'signup.keysIdentityDesc': 'Sie erhalten einen privaten Schlüssel (nsec), der beweist, dass Sie der Besitzer Ihres Kontos sind.', 'signup.keepSecret': 'Halten Sie Ihren privaten Schlüssel geheim!', 'signup.keepSecretDesc': 'Er ist wie ein Passwort, das niemals zurückgesetzt werden kann.', 'signup.oneIdentity': 'Eine Identität, viele Apps.', 'signup.oneIdentityDesc': 'Verwenden Sie dasselbe Konto auf Damus, Primal, Amethyst und mehr.', 'signup.gotIt': 'Verstanden, Konto erstellen', 'signup.username': 'Benutzername', 'signup.usernamePlaceholder': 'Wählen Sie einen Anzeigenamen', 'signup.about': 'Über mich (optional)', 'signup.aboutPlaceholder': 'Erzählen Sie anderen von sich', 'signup.profilePicture': 'Profilbild (optional)', 'signup.uploadPhoto': 'Foto hochladen', 'signup.remove': 'Entfernen', 'signup.avatarHint': 'Quadratische Bilder funktionieren am besten. Max 5MB.', 'signup.uploading': 'Wird hochgeladen...', 'signup.lightningAddress': 'Lightning-Adresse (optional)', 'signup.lightningPlaceholder': 'du@walletofsatoshi.com', 'signup.lightningHint': 'Fügen Sie eine Lightning-Adresse hinzu, um Zaps (Bitcoin-Trinkgelder) zu erhalten.', 'signup.yourUsername': 'Ihr Benutzername', 'signup.yourBio': 'Ihre Bio erscheint hier', 'signup.createAccountBtn': 'Konto erstellen', 'signup.termsAgree': 'Mit der Erstellung eines Kontos akzeptieren Sie unsere', 'signup.success': 'Konto erfolgreich erstellt!', 'signup.yourPrivateKey': 'Ihr privater Schlüssel (nsec)', 'signup.keyWarning': 'Dies ist die EINZIGE Möglichkeit, auf Ihr Konto zuzugreifen. Bewahren Sie ihn sicher auf!', 'signup.copyPrivateKey': 'Privaten Schlüssel kopieren', 'signup.howToUseKey': 'So verwenden Sie Ihren privaten Schlüssel', 'signup.continueToPlebs': 'Weiter zu Plebs',
        // Notifications
        'notifications.title': 'Benachrichtigungen', 'notifications.settings': 'Benachrichtigungseinstellungen', 'notifications.reactions': 'Reaktionen (Gefällt mir/Gefällt mir nicht)', 'notifications.replies': 'Kommentare & Antworten', 'notifications.zaps': 'Zaps', 'notifications.chatMentions': 'Live-Chat-Erwähnungen', 'notifications.newFollowers': 'Neue Abonnenten', 'notifications.syncNote': 'Einstellungen werden über Nostr zwischen Geräten synchronisiert',
        // Settings Modal
        'settings.title': 'Einstellungen', 'settings.language': 'Sprache', 'settings.languageDesc': 'Wählen Sie Ihre bevorzugte Sprache', 'settings.saveToNostr': 'Auf Nostr speichern', 'settings.saveToNostrDesc': 'Einstellungen über alle Plebs-Instanzen synchronisieren', 'settings.darkMode': 'Dunkelmodus', 'settings.darkModeDesc': 'Zwischen hellem und dunklem Design wechseln', 'settings.saveSettings': 'Einstellungen speichern', 'settings.resetDefaults': 'Zurücksetzen',
        // Upload Modal
        'upload.title': 'Video hochladen', 'upload.videoFile': 'Videodatei', 'upload.clickToSelect': 'Klicken zum Auswählen oder per Drag & Drop', 'upload.fileTypes': 'MP4, AVI, MOV, etc (max 2GB Eingabe, wird auf <100MB komprimiert)', 'upload.preparing': 'Vorbereitung...', 'upload.thumbnail': 'Thumbnail', 'upload.thumbnailHint': 'Klicken zum Auswählen oder automatisch aus Video generieren', 'upload.uploading': 'Wird hochgeladen...', 'upload.titleLabel': 'Titel', 'upload.titlePlaceholder': 'Videotitel eingeben', 'upload.descriptionLabel': 'Beschreibung', 'upload.descriptionPlaceholder': 'Erzählen Sie den Zuschauern von Ihrem Video', 'upload.tagsLabel': 'Tags (kommagetrennt)', 'upload.tagsPlaceholder': 'bitcoin, nostr, tutorial', 'upload.markNsfw': 'Als NSFW markieren (18+)', 'upload.nsfwDesc': 'Inhalte für Erwachsene sollten als NSFW markiert werden', 'upload.saveDraft': 'Als Entwurf speichern', 'upload.publish': 'Veröffentlichen', 'upload.selectVideo': 'Video zum Hochladen auswählen', 'upload.optional': '(optional)', 'upload.remove': 'Entfernen', 'upload.qualityHigh': 'Hoch',
        // Create Modal
        'create.title': 'Erstellen', 'create.goLive': 'Live gehen', 'create.goLiveDesc': 'Starten oder planen Sie einen Livestream', 'create.uploadVideo': 'Video hochladen', 'create.uploadVideoDesc': 'Laden Sie ein Video von Ihrem Gerät hoch', 'create.createShort': 'Short erstellen', 'create.createShortDesc': 'Laden Sie ein vertikales Video hoch (unter 60s)',
        // Go Live Modal
        'goLive.title': 'Live gehen', 'goLive.when': 'Wann möchten Sie live gehen?', 'goLive.now': 'Jetzt live gehen', 'goLive.schedule': 'Stream planen', 'goLive.streamTitle': 'Stream-Titel', 'goLive.streamTitlePlaceholder': 'Geben Sie Ihren Stream-Titel ein', 'goLive.description': 'Beschreibung', 'goLive.descriptionPlaceholder': 'Erzählen Sie den Zuschauern, worum es in Ihrem Stream geht', 'goLive.tags': 'Tags (kommagetrennt)', 'goLive.tagsPlaceholder': 'gaming, bitcoin, tutorial', 'goLive.streamUrl': 'Stream-URL (RTMP, HLS oder WebRTC)', 'goLive.streamUrlPlaceholder': 'https://ihr-streaming-dienst.com/stream.m3u8', 'goLive.zapGoal': 'Zap-Ziel (optional)', 'goLive.zapGoalPlaceholder': 'z.B. 10000', 'goLive.cancel': 'Abbrechen', 'goLive.goLiveBtn': 'Live gehen',
        // Edit Stream Modal
        'editStream.title': 'Stream bearbeiten', 'editStream.changeThumbnail': 'Thumbnail ändern', 'editStream.titleLabel': 'Titel', 'editStream.saveChanges': 'Änderungen speichern',
        // NSFW Warning Modal
        'nsfw.title': 'Altersverifikation erforderlich', 'nsfw.description': 'Dieser Inhalt ist als NSFW gekennzeichnet und kann Material für Erwachsene enthalten. Sie müssen 18 Jahre oder älter sein.', 'nsfw.confirm': 'Ich bin 18 Jahre oder älter', 'nsfw.remember': 'Nicht mehr fragen (Meine Wahl merken)',
        // Community Warning Modal
        'communityWarning.title': 'Community-Warnung', 'communityWarning.description': 'Dieses Video wurde von der Community markiert und/oder stark negativ bewertet.', 'communityWarning.goBack': 'Zurück', 'communityWarning.viewAnyway': 'Trotzdem ansehen',
        // Report Modal
        'report.title': 'Video melden', 'report.description': 'Wählen Sie einen Grund für die Meldung dieses Inhalts:', 'report.nudity': 'Nacktheit oder sexuelle Inhalte', 'report.nudityDesc': 'Enthält sexuelle oder explizite Bilder, die nicht als NSFW gekennzeichnet sind', 'report.hate': 'Hassrede oder Belästigung', 'report.hateDesc': 'Fördert Gewalt, Hass oder Belästigung', 'report.illegal': 'Illegaler Inhalt', 'report.illegalDesc': 'Inhalt, der möglicherweise gegen Gesetze verstößt', 'report.spam': 'Spam oder irreführend', 'report.spamDesc': 'Irreführender Inhalt, Betrug oder wiederholter Spam', 'report.impersonation': 'Identitätsdiebstahl', 'report.impersonationDesc': 'Gibt sich als jemand anderes aus', 'report.other': 'Sonstiges', 'report.otherDesc': 'Andere nicht aufgeführte Verstöße', 'report.cancel': 'Abbrechen', 'report.submit': 'Meldung absenden',
        // Share Modal
        'share.title': 'Video teilen', 'share.link': 'Link', 'share.embed': 'Einbetten', 'share.shareWith': 'Teilen Sie dieses Video mit anderen:', 'share.copy': 'Kopieren', 'share.copied': 'In Zwischenablage kopiert!', 'share.embedOnWebsite': 'Betten Sie dieses Video auf Ihrer Website ein:', 'share.size': 'Größe:', 'share.responsive': 'Responsiv (Standard)', 'share.size1280x720': '1280 × 720 (HD)', 'share.embedCodeCopied': 'Einbettungscode kopiert!',
        // Edit Video Modal
        'editVideo.title': 'Video bearbeiten', 'editVideo.video': 'Video', 'editVideo.replaceVideo': 'Video ersetzen', 'editVideo.thumbnail': 'Thumbnail', 'editVideo.changeThumbnail': 'Thumbnail ändern', 'editVideo.titleLabel': 'Titel', 'editVideo.descriptionLabel': 'Beschreibung', 'editVideo.tagsLabel': 'Tags (kommagetrennt)', 'editVideo.cancel': 'Abbrechen', 'editVideo.saveChanges': 'Änderungen speichern',
        // Edit Profile Modal
        'editProfile.title': 'Profil bearbeiten', 'editProfile.displayName': 'Anzeigename', 'editProfile.displayNamePlaceholder': 'Ihr Anzeigename', 'editProfile.about': 'Über mich', 'editProfile.aboutPlaceholder': 'Erzählen Sie anderen von sich', 'editProfile.picture': 'Profilbild', 'editProfile.pictureUrl': 'Oder geben Sie die Bild-URL direkt ein:', 'editProfile.nip05': 'NIP-05 Kennung (optional)', 'editProfile.nip05Hint': 'Eine verifizierte Nostr-Adresse zur Identitätsverifizierung.', 'editProfile.website': 'Website (optional)', 'editProfile.saveChanges': 'Änderungen speichern',
        // Confirmation Modal
        'confirm.title': 'Aktion bestätigen', 'confirm.message': 'Sind Sie sicher, dass Sie fortfahren möchten?', 'confirm.cancel': 'Abbrechen', 'confirm.confirm': 'Bestätigen',
        // Video Page
        'video.views': 'Aufrufe', 'video.view': 'Aufruf', 'video.followers': 'Abonnenten', 'video.follower': 'Abonnent', 'video.follow': 'Abonnieren', 'video.unfollow': 'Deabonnieren', 'video.share': 'Teilen', 'video.comments': 'Kommentare', 'video.writeComment': 'Kommentar schreiben...', 'video.noComments': 'Noch keine Kommentare. Seien Sie der Erste!',
        // Toast Messages
        'toast.loggedIn': 'Erfolgreich angemeldet!', 'toast.settingsSaved': 'Einstellungen gespeichert!', 'toast.languageChanged': 'Sprache geändert', 'toast.copied': 'Kopiert!',
        // Time
        'time.justNow': 'gerade eben', 'time.minuteAgo': 'vor 1 Minute', 'time.minutesAgo': 'vor {n} Minuten', 'time.hourAgo': 'vor 1 Stunde', 'time.hoursAgo': 'vor {n} Stunden', 'time.dayAgo': 'vor 1 Tag', 'time.daysAgo': 'vor {n} Tagen',
        // Empty States
        'empty.noVideos': 'Keine Videos gefunden.', 'empty.noLikedVideos': 'Sie haben noch keine Videos geliked.', 'empty.noHistory': 'Kein Verlauf.',
        // Misc
        'misc.loading': 'Laden...', 'misc.close': 'Schließen', 'misc.back': 'Zurück', 'misc.search': 'Suchen',
        // Common
        'common.cancel': 'Abbrechen', 'common.uploading': 'Wird hochgeladen...', 'common.saveChanges': 'Änderungen speichern', 'common.close': 'Schließen',
        // Aria Labels
        'aria.toggleMenu': 'Menü umschalten', 'aria.mainNavigation': 'Hauptnavigation', 'aria.videoContent': 'Videoinhalt', 'aria.loadingContent': 'Inhalt wird geladen',
        // Dynamic JavaScript text
        'button.hideQR': 'QR-Code ausblenden', 'button.showQR': 'QR-Code anzeigen', 'button.copied': 'Kopiert!', 'button.showLess': 'Weniger anzeigen', 'button.showMore': 'Mehr anzeigen', 'button.creatingAccount': 'Konto wird erstellt...', 'button.submitting': 'Wird gesendet...', 'button.scheduleStream': 'Stream planen', 'button.goLive': 'Live gehen', 'button.creatingStream': 'Stream wird erstellt...', 'button.continueCustomAmount': 'Mit benutzerdefiniertem Betrag fortfahren', 'button.recordFromCamera': 'Von Kamera aufnehmen', 'button.requestingCamera': 'Kamera wird angefragt...', 'button.recording': 'Aufnahme...',
        'status.saving': 'Wird gespeichert...', 'status.saved': 'Gespeichert!', 'status.uploading': 'Wird hochgeladen...', 'status.uploadComplete': 'Upload abgeschlossen!', 'status.uploadingToNostrBuild': 'Wird auf nostr.build hochgeladen...', 'status.publishingChanges': 'Änderungen werden veröffentlicht...', 'status.removingOldVersion': 'Alte Version wird entfernt...', 'status.validatingThumbnail': 'Thumbnail wird validiert...', 'status.uploadingThumbnail': 'Thumbnail wird hochgeladen...', 'status.thumbnailUploaded': 'Thumbnail hochgeladen!', 'status.processingVideo': 'Video wird verarbeitet...', 'status.compressingVideo': 'Video wird komprimiert...', 'status.uploadingVideo': 'Video wird hochgeladen...', 'status.videoUploaded': 'Video erfolgreich hochgeladen!', 'status.processing': 'Wird verarbeitet...', 'status.generatingThumbnail': 'Thumbnail wird generiert...', 'status.generatingPreview': 'Vorschau wird generiert...', 'status.uploadingPreview': 'Vorschau wird hochgeladen...', 'status.publishing': 'Wird veröffentlicht...', 'status.publishingToNostr': 'Wird auf Nostr veröffentlicht...', 'status.publishingVideoToNostr': 'Video wird auf Nostr veröffentlicht...', 'status.generatingPoW': 'Proof of Work wird generiert...', 'status.posting': 'Wird gepostet...', 'status.processingVideoAndThumbnail': 'Video und Thumbnail werden verarbeitet...', 'status.uploadFailed': 'Upload fehlgeschlagen - erneut versuchen', 'status.selectVideoToUpload': 'Video zum Hochladen auswählen', 'status.waitingForVideoUpload': 'Warten auf Video-Upload...', 'status.selectVideoAndThumbnail': 'Video und Thumbnail zum Veröffentlichen auswählen', 'status.ready': 'Bereit ✓', 'status.failed': 'Fehlgeschlagen ✗', 'status.fromDraft': 'Aus Entwurf', 'status.startingNow': 'Startet jetzt!', 'status.ended': 'BEENDET', 'status.thumbnailReady': 'Bereit', 'status.thumbnailFailed': 'Fehlgeschlagen', 'status.uploadFailedRetry': 'Upload fehlgeschlagen. Bitte erneut versuchen.',
        'publish.video': 'Video veröffentlichen', 'publish.autoThumbnail': 'Video veröffentlichen (Auto-Thumbnail)',
        'report.titleComment': 'Kommentar melden', 'report.titleUser': 'Benutzer melden', 'report.titleVideo': 'Video melden', 'report.descComment': 'Wählen Sie einen Grund für die Meldung dieses Kommentars:', 'report.descUser': 'Wählen Sie einen Grund für die Meldung dieses Benutzers:', 'report.descVideo': 'Wählen Sie einen Grund für die Meldung dieses Inhalts:',
        'empty.noMutedUsers': 'Keine stummgeschalteten Benutzer.', 'empty.noVideosToMonitor': 'Keine Videos zum Überwachen gefunden.', 'empty.noRecentActivity': 'Keine aktuelle Aktivität.', 'empty.failedLoadNotifications': 'Benachrichtigungen konnten nicht geladen werden', 'empty.loginToViewLiked': 'Bitte <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">anmelden</a>, um Ihre gelikten Videos zu sehen.', 'empty.loginToViewFollowing': 'Bitte <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">anmelden</a>, um zu sehen, wem Sie folgen.', 'empty.loginToViewVideos': 'Bitte <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">anmelden</a>, um Ihre Videos zu sehen.', 'empty.loginToViewAnalytics': 'Bitte <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">anmelden</a>, um Ihre Statistiken zu sehen.', 'empty.noLikedVideosYet': 'Sie haben noch keine Videos geliked.', 'empty.noLikedVideosFound': 'Keine gelikten Videos gefunden.', 'empty.noFullLengthLikedVideos': 'Keine langen gelikten Videos gefunden.', 'empty.noWatchHistory': 'Kein Verlauf. Beginnen Sie Videos anzusehen.', 'empty.noVideosInHistory': 'Keine Videos im Verlauf gefunden.', 'empty.noFullLengthHistory': 'Keine langen Videos im Verlauf.', 'empty.noMatchingVideos': 'Keine passenden Videos gefunden.', 'empty.noFullLengthVideos': 'Keine langen Videos gefunden.', 'empty.failedLoadTrending': 'Trending konnte nicht geladen werden.', 'empty.noTrendingVideos': 'Keine Trend-Videos gefunden.', 'empty.noMatchingUsers': 'Keine passenden Benutzer gefunden.', 'empty.unableLoadProfiles': 'Profile konnten nicht geladen werden.', 'empty.noFollowingVideos': 'Noch keine Videos von Benutzern, denen Sie folgen.', 'empty.noFullLengthFollowing': 'Keine langen Videos von gefolgten Benutzern.', 'empty.failedLoadFollowing': 'Laden fehlgeschlagen. Bitte erneut versuchen.', 'empty.noVideosUploadFirst': 'Keine Videos gefunden. Laden Sie Ihr erstes Video hoch!', 'empty.noFullLengthUploaded': 'Keine langen Videos gefunden.', 'empty.noMatchingLiveStreams': 'Keine passenden Livestreams gefunden.', 'empty.noMatchingShorts': 'Keine passenden Shorts gefunden.', 'empty.noVideosForTag': 'Keine Videos für diesen Tag gefunden.', 'empty.noFullLengthForTag': 'Keine langen Videos für diesen Tag.', 'empty.noUploadedVideos': 'Noch keine Videos hochgeladen.', 'empty.noVideosFound': 'Keine Videos gefunden.', 'empty.failedLoadProfile': 'Profil konnte nicht geladen werden. Erneut versuchen.', 'empty.noComments': 'Noch keine Kommentare. Seien Sie der Erste!', 'empty.failedLoadComments': 'Kommentare konnten nicht geladen werden', 'empty.noLiveNow': 'Niemand ist gerade live. Seien Sie der Erste!',
        'error.videoNotFound': 'Video nicht gefunden.', 'error.contentNotAvailable': 'Dieser Inhalt ist nicht verfügbar.', 'error.invalidVideoData': 'Ungültige Videodaten.', 'error.videoNotAvailable': 'Video nicht verfügbar. Die Datei wurde möglicherweise entfernt.', 'error.failedLoadVideo': 'Video konnte nicht geladen werden. Bitte erneut versuchen.', 'error.failedLoadVideoShort': 'Video konnte nicht geladen werden. Datei möglicherweise entfernt.', 'error.liveStreamNotFound': 'Livestream nicht gefunden.', 'error.invalidLiveStreamData': 'Ungültige Livestream-Daten.', 'error.failedLoadLiveStream': 'Livestream konnte nicht geladen werden.',
        // New Button & Action Labels
        'button.follow': 'Folgen', 'button.unfollow': 'Entfolgen', 'button.mute': 'Stummschalten', 'button.unmute': 'Stummschaltung aufheben', 'button.muteUser': 'Benutzer stummschalten', 'button.unmuteUser': 'Stummschaltung aufheben', 'button.confirm': 'Bestätigen', 'button.cancel': 'Abbrechen', 'button.close': 'Schließen', 'button.boost': 'Boosten', 'button.zap': 'Zap', 'button.viewMore': 'Mehr anzeigen', 'button.viewAnalytics': 'Statistiken anzeigen', 'button.backToMyVideos': 'Zurück zu Meinen Videos', 'button.editDraft': 'Entwurf bearbeiten', 'button.deleteDraft': 'Entwurf löschen', 'button.editVideo': 'Video bearbeiten', 'button.deleteVideo': 'Video löschen', 'button.editShort': 'Short bearbeiten', 'button.deleteShort': 'Short löschen', 'button.editStream': 'Stream bearbeiten', 'button.endStream': 'Stream beenden', 'button.reset': 'Zurücksetzen', 'button.download': 'Herunterladen', 'button.watchRecording': 'Aufnahme ansehen', 'button.show': 'Anzeigen', 'button.login': 'Anmelden', 'button.toggleChat': 'Chat umschalten', 'button.blockVideo': 'Video blockieren', 'button.blockUser': 'Benutzer blockieren', 'button.unblock': 'Entsperren', 'button.removeFromHistory': 'Aus Verlauf entfernen',
        // New Stats & Counts
        'stat.views': 'Aufrufe', 'stat.viewsCount': '{count} Aufrufe', 'stat.videos': 'Videos', 'stat.video': 'Video', 'stat.followers': 'Abonnenten', 'stat.follower': 'Abonnent', 'stat.following': 'Abonniert', 'stat.subscribers': 'Abonnenten', 'stat.comments': 'Kommentare', 'stat.liveCount': '{count} live', 'stat.percentOfGoal': '{percent}% des Ziels', 'stat.netGrowth': 'Nettowachstum', 'stat.newFollowers': 'Neue Abonnenten', 'stat.unfollowed': 'Entfolgt', 'stat.lastUpdated': 'Zuletzt aktualisiert: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'LIVE', 'badge.ended': 'BEENDET', 'badge.scheduled': 'GEPLANT', 'badge.warning': 'WARNUNG', 'badge.communityWarning': 'COMMUNITY-WARNUNG', 'badge.verifiedNip05': 'NIP-05 verifiziert', 'badge.streamer': 'Streamer', 'badge.clickToView': 'Klicken zum Ansehen',
        // New Actions
        'action.report': 'Melden', 'action.reportComment': 'Kommentar melden', 'action.reportVideo': 'Video melden', 'action.reportStream': 'Stream melden', 'action.like': 'Gefällt mir', 'action.dislike': 'Gefällt mir nicht', 'action.reply': 'Antworten',
        // New Placeholders
        'placeholder.searchHistory': 'Verlauf durchsuchen...', 'placeholder.searchUsers': 'Benutzer suchen...', 'placeholder.searchMyVideos': 'Meine Videos durchsuchen...', 'placeholder.eventId': 'Event-ID eingeben (hex oder nevent/note)', 'placeholder.pubkey': 'Pubkey eingeben (hex oder npub)', 'placeholder.customAmount': 'Benutzerdefinierter Betrag', 'placeholder.chatEnded': 'Chat geschlossen - Stream beendet', 'placeholder.addComment': 'Kommentar hinzufügen...', 'placeholder.setNewGoal': 'Neues Ziel setzen (sats)',
        // New Video & Content
        'video.untitledVideo': 'Video ohne Titel', 'video.untitledShort': 'Short ohne Titel', 'video.upNext': 'Als nächstes', 'video.noVideosYet': 'Noch keine Videos', 'video.noShortsYet': 'Noch keine Shorts', 'video.noLiveStreamsYet': 'Noch keine Livestreams', 'video.noBlockedVideos': 'Keine blockierten Videos', 'video.noBlockedUsers': 'Keine blockierten Benutzer',
        // New Stream Messages
        'stream.ended': 'Dieser Stream ist beendet. Der Chat ist jetzt geschlossen.', 'stream.welcomeChat': 'Willkommen im Live-Chat!', 'stream.goalReached': 'Ziel erreicht!', 'stream.zapGoalReached': 'Zap-Ziel erreicht! {amount} Sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Nachricht von stummgeschaltetem Benutzer', 'muted.commentFromMutedUserHidden': 'Kommentar von stummgeschaltetem Benutzer ausgeblendet', 'muted.commentHidden': 'Kommentar ausgeblendet ({packs})', 'muted.messageHidden': 'Nachricht ausgeblendet ({packs})', 'muted.commentReportedByFollows': 'Kommentar von Personen gemeldet, denen Sie folgen', 'muted.messageReportedByFollows': 'Nachricht von Personen gemeldet, denen Sie folgen', 'muted.commentHeavilyDownvoted': 'Kommentar stark negativ bewertet', 'muted.messageHeavilyDownvoted': 'Nachricht stark negativ bewertet',
        // New Admin & Lists
        'list.blockedVideos': 'Blockierte Videos', 'list.blockedUsers': 'Blockierte Benutzer',
        // New Alerts
        'alert.cameraNotSupported': 'Kamerazugriff wird in diesem Browser nicht unterstützt. Bitte verwenden Sie einen modernen Browser wie Chrome, Firefox oder Safari.', 'alert.noCameraFound': 'Keine Kamera gefunden. Bitte schließen Sie eine Kamera an oder verwenden Sie die Datei-Upload-Option.', 'alert.cameraAccessDenied': 'Kamerazugriff verweigert. Bitte erlauben Sie Kameraberechtigungen in Ihren Browsereinstellungen.', 'alert.cameraInUse': 'Kamera wird von einer anderen Anwendung verwendet. Bitte schließen Sie andere Apps, die die Kamera verwenden.', 'alert.cameraUnableAccess': 'Zugriff auf Kamera mit aktuellen Einstellungen nicht möglich. Bitte verwenden Sie die Upload-Option.', 'alert.cameraUnableAccessWithError': 'Kamerazugriff nicht möglich: {error}\n\nBitte verwenden Sie die Upload-Option.', 'alert.fillRequiredFields': 'Bitte füllen Sie alle erforderlichen Felder aus', 'alert.uploadThumbnail': 'Bitte laden Sie ein Thumbnail für Ihren Stream hoch', 'alert.failedCreateStream': 'Stream konnte nicht erstellt werden. Bitte versuchen Sie es erneut.', 'alert.failedUpdateStream': 'Aktualisierung fehlgeschlagen. Bitte versuchen Sie es erneut.', 'alert.streamNotFound': 'Stream nicht gefunden', 'alert.canOnlyEditOwnStreams': 'Sie können nur Ihre eigenen Streams bearbeiten', 'alert.invalidStreamData': 'Ungültige Stream-Daten', 'alert.enterValidGoalAmount': 'Bitte geben Sie einen gültigen Zielbetrag ein', 'alert.canOnlyResetOwnGoals': 'Sie können nur Ihre eigenen Ziele zurücksetzen', 'alert.streamEventNotFound': 'Stream-Event nicht gefunden', 'alert.failedResetZapGoal': 'Zap-Ziel konnte nicht zurückgesetzt werden. Bitte versuchen Sie es erneut.', 'alert.cannotBlockAdmin': 'Admin-Konto kann nicht blockiert werden', 'alert.analyticsLoadFailed': 'Statistiken konnten nicht geladen werden. Bitte versuchen Sie es erneut.', 'alert.cannotReplaceShortWithVideo': 'Ein Short kann nicht durch ein normales Video ersetzt werden. Bitte laden Sie ein vertikales Video (60 Sekunden oder weniger) hoch.', 'alert.cannotReplaceVideoWithShort': 'Ein normales Video kann nicht durch ein Short ersetzt werden. Bitte laden Sie ein horizontales Video hoch.', 'alert.shortsRequireVertical': 'Dieses Video scheint horizontal zu sein. Shorts müssen vertikale Videos sein. Bitte verwenden Sie "Video hochladen" für horizontale Videos.',
        // New Zap Messages
        'zap.cannotZapYourself': 'Sie können sich nicht selbst zappen', 'zap.cannotZapOwnContent': 'Sie können Ihren eigenen Inhalt nicht zappen', 'zap.cannotZapOwnComment': 'Sie können Ihren eigenen Kommentar nicht zappen', 'zap.zapAmount': 'Zap {value} Sats',
        // New Status Messages
        'status.loadingVideo': 'Video wird geladen...', 'status.loading': 'Wird geladen...', 'status.compressingProgress': 'Komprimieren... {progress}%', 'status.uploadingProgress': 'Hochladen... {progress}%', 'status.uploadingServers': 'Hochladen... ({completed}/{total} Server)', 'status.publishedSuccess': '{type} erfolgreich veröffentlicht!',
        // New Warnings
        'warning.webmFormat': 'Hinweis: Ihr Browser gibt das WebM-Format aus (funktioniert möglicherweise nicht auf iOS). Für iOS-kompatibles MP4 verwenden Sie Chrome auf Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Zuletzt aktualisiert: Dezember 2024',
    },
    pt: {
        // Navigation & Header
        'nav.home': 'Início', 'nav.following': 'Seguindo', 'nav.myVideos': 'Meus Vídeos', 'nav.liked': 'Curtidos', 'nav.history': 'Histórico', 'nav.topics': 'TÓPICOS', 'nav.live': 'Ao Vivo', 'nav.bitcoin': 'Bitcoin', 'nav.nostr': 'Nostr', 'nav.technology': 'Tecnologia', 'nav.gaming': 'Jogos', 'nav.tutorials': 'Tutoriais', 'nav.podcasts': 'Podcasts', 'nav.music': 'Música', 'nav.nsfw': 'NSFW', 'nav.about': 'Sobre', 'nav.contact': 'Contato', 'nav.terms': 'Termos', 'nav.privacy': 'Privacidade', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.playlists': 'Playlists', 'nav.downloads': 'Downloads', 'nav.subscriptions': 'Inscrições', 'nav.trending': 'Em Alta', 'nav.explore': 'Explorar', 'nav.categories': 'Categorias', 'nav.liveStreams': 'Transmissões ao Vivo', 'nav.github': 'GitHub',
        'header.search': 'Pesquisar vídeos...', 'header.notifications': 'Notificações', 'header.settings': 'Configurações', 'header.create': 'Criar', 'header.admin': 'Admin', 'header.viewProfile': 'Ver Perfil', 'header.logout': 'Sair',
        // Login Modal
        'login.title': 'Entrar com Nostr', 'login.extension': 'Entrar com Extensão', 'login.extensionDesc': 'Use Alby, nos2x ou outras extensões Nostr', 'login.connect': 'Nostr Connect', 'login.connectDesc': 'Conecte com assinantes remotos como Amber, nsec.app', 'login.privateKey': 'Chave Privada', 'login.privateKeyDesc': 'Digite sua nsec ou chave hex (somente local)', 'login.newToNostr': 'Novo no Nostr?', 'login.createAccount': 'Criar Conta', 'login.createAccountDesc': 'Comece com uma nova identidade Nostr para usar no Plebs',
        // Connect Modal
        'connect.title': 'Conectar com Nostr', 'connect.option1': 'Opção 1: Use esta string de conexão', 'connect.option1Desc': 'Copie e cole isso em qualquer app compatível com NIP-46 (nsec.app, Amber, etc.)', 'connect.copyString': 'Copiar String de Conexão', 'connect.showQR': 'Mostrar Código QR', 'connect.listening': 'Aguardando conexão...', 'connect.option2': 'Opção 2: Colar uma URL bunker', 'connect.option2Desc': 'Se você já tem uma URL bunker:// de um assinante remoto', 'connect.withBunker': 'Conectar com Bunker', 'connect.or': 'OU', 'connect.bunkerPlaceholder': 'bunker://...',
        // Private Key Modal
        'privateKey.title': 'Entrar com Chave Privada', 'privateKey.warning': 'Aviso de Segurança', 'privateKey.warningText': 'Sua chave privada será armazenada localmente no seu navegador. Para maior segurança, considere usar uma extensão de navegador ou Nostr Connect.', 'privateKey.label': 'Chave Privada (nsec ou hex)', 'privateKey.showKey': 'Mostrar chave', 'privateKey.login': 'Entrar', 'privateKey.placeholder': 'nsec1...',
        // Signup Modal
        'signup.title': 'Criar Conta Nostr', 'signup.whatIsNostr': 'O que é Nostr?', 'signup.nostrExplanation': 'Nostr é um protocolo social descentralizado que dá a você a propriedade de sua identidade e conteúdo. Diferente das plataformas tradicionais, nenhuma empresa pode bani-lo, censurar seu conteúdo ou fechar sua conta.', 'signup.whyPlebs': 'Por que o Plebs usa Nostr?', 'signup.plebsExplanation': 'Plebs é construído no Nostr para fornecer compartilhamento de vídeos resistente à censura. Seus vídeos, comentários e interações são armazenados em uma rede de relays, não em nossos servidores.', 'signup.howItWorks': 'Como funciona', 'signup.keysIdentity': 'Suas chaves = Sua identidade.', 'signup.keysIdentityDesc': 'Você receberá uma chave privada (nsec) que prova que você é dono da sua conta.', 'signup.keepSecret': 'Mantenha sua chave privada em segredo!', 'signup.keepSecretDesc': 'É como uma senha que nunca pode ser redefinida.', 'signup.oneIdentity': 'Uma identidade, vários apps.', 'signup.oneIdentityDesc': 'Use a mesma conta no Damus, Primal, Amethyst e mais.', 'signup.gotIt': 'Entendi, vamos criar minha conta', 'signup.username': 'Nome de Usuário', 'signup.usernamePlaceholder': 'Escolha um nome de exibição', 'signup.about': 'Sobre (opcional)', 'signup.aboutPlaceholder': 'Conte aos outros sobre você', 'signup.profilePicture': 'Foto de Perfil (opcional)', 'signup.uploadPhoto': 'Enviar Foto', 'signup.remove': 'Remover', 'signup.avatarHint': 'Imagens quadradas funcionam melhor. Máx 5MB.', 'signup.uploading': 'Enviando...', 'signup.lightningAddress': 'Endereço Lightning (opcional)', 'signup.lightningPlaceholder': 'voce@walletofsatoshi.com', 'signup.lightningHint': 'Adicione um endereço Lightning para receber zaps (gorjetas em Bitcoin) em seus vídeos e perfil.', 'signup.yourUsername': 'Seu Nome de Usuário', 'signup.yourBio': 'Sua bio aparecerá aqui', 'signup.createAccountBtn': 'Criar Conta', 'signup.termsAgree': 'Ao criar uma conta, você concorda com nossos', 'signup.success': 'Conta Criada com Sucesso!', 'signup.yourPrivateKey': 'Sua Chave Privada (nsec)', 'signup.keyWarning': 'Esta é a ÚNICA forma de acessar sua conta. Guarde-a em segurança!', 'signup.copyPrivateKey': 'Copiar Chave Privada', 'signup.howToUseKey': 'Como usar sua chave privada', 'signup.continueToPlebs': 'Continuar para o Plebs',
        // Notifications
        'notifications.title': 'Notificações', 'notifications.settings': 'Configurações de Notificações', 'notifications.reactions': 'Reações (curtir/não curtir)', 'notifications.replies': 'Comentários & Respostas', 'notifications.zaps': 'Zaps', 'notifications.chatMentions': 'Menções no Chat ao Vivo', 'notifications.newFollowers': 'Novos Seguidores', 'notifications.syncNote': 'Configurações são sincronizadas entre dispositivos via Nostr',
        // Settings Modal
        'settings.title': 'Configurações', 'settings.language': 'Idioma', 'settings.languageDesc': 'Escolha seu idioma preferido', 'settings.saveToNostr': 'Salvar no Nostr', 'settings.saveToNostrDesc': 'Sincronizar configurações em todas as instâncias do Plebs', 'settings.darkMode': 'Modo Escuro', 'settings.darkModeDesc': 'Alternar entre tema claro e escuro', 'settings.saveSettings': 'Salvar Configurações', 'settings.resetDefaults': 'Redefinir',
        // Upload Modal
        'upload.title': 'Enviar Vídeo', 'upload.videoFile': 'Arquivo de Vídeo', 'upload.clickToSelect': 'Clique para selecionar vídeo ou arraste e solte', 'upload.fileTypes': 'MP4, AVI, MOV, etc (máx 2GB entrada, será comprimido para <100MB)', 'upload.preparing': 'Preparando...', 'upload.thumbnail': 'Miniatura', 'upload.thumbnailHint': 'Clique para selecionar ou gerar automaticamente do vídeo', 'upload.uploading': 'Enviando...', 'upload.titleLabel': 'Título', 'upload.titlePlaceholder': 'Digite o título do vídeo', 'upload.descriptionLabel': 'Descrição', 'upload.descriptionPlaceholder': 'Conte aos espectadores sobre seu vídeo', 'upload.tagsLabel': 'Tags (separadas por vírgula)', 'upload.tagsPlaceholder': 'bitcoin, nostr, tutorial', 'upload.markNsfw': 'Marcar como NSFW (18+)', 'upload.nsfwDesc': 'Conteúdo adulto deve ser marcado como NSFW', 'upload.saveDraft': 'Salvar como Rascunho', 'upload.publish': 'Publicar', 'upload.selectVideo': 'Selecione um vídeo para enviar', 'upload.optional': '(opcional)', 'upload.remove': 'Remover', 'upload.qualityHigh': 'Alta',
        // Create Modal
        'create.title': 'Criar', 'create.goLive': 'Ao Vivo', 'create.goLiveDesc': 'Inicie uma transmissão ao vivo ou agende uma', 'create.uploadVideo': 'Enviar Vídeo', 'create.uploadVideoDesc': 'Envie um vídeo do seu dispositivo', 'create.createShort': 'Criar Short', 'create.createShortDesc': 'Envie um vídeo vertical (menos de 60s)',
        // Go Live Modal
        'goLive.title': 'Ao Vivo', 'goLive.when': 'Quando você quer transmitir ao vivo?', 'goLive.now': 'Transmitir Agora', 'goLive.schedule': 'Agendar Transmissão', 'goLive.streamTitle': 'Título da Transmissão', 'goLive.streamTitlePlaceholder': 'Digite o título da sua transmissão', 'goLive.description': 'Descrição', 'goLive.descriptionPlaceholder': 'Conte aos espectadores sobre o que é sua transmissão', 'goLive.tags': 'Tags (separadas por vírgula)', 'goLive.tagsPlaceholder': 'gaming, bitcoin, tutorial', 'goLive.streamUrl': 'URL da Transmissão (RTMP, HLS ou WebRTC)', 'goLive.streamUrlPlaceholder': 'https://seu-servico-streaming.com/stream.m3u8', 'goLive.zapGoal': 'Meta de Zaps (opcional)', 'goLive.zapGoalPlaceholder': 'ex. 10000', 'goLive.cancel': 'Cancelar', 'goLive.goLiveBtn': 'Transmitir',
        // Edit Stream Modal
        'editStream.title': 'Editar Transmissão', 'editStream.changeThumbnail': 'Alterar Miniatura', 'editStream.titleLabel': 'Título', 'editStream.saveChanges': 'Salvar Alterações',
        // NSFW Warning Modal
        'nsfw.title': 'Verificação de Idade Necessária', 'nsfw.description': 'Este conteúdo está marcado como NSFW e pode conter material adulto. Você deve ter 18 anos ou mais para ver este conteúdo.', 'nsfw.confirm': 'Eu tenho 18 anos ou mais', 'nsfw.remember': 'Não perguntar novamente (Lembrar minha escolha)',
        // Community Warning Modal
        'communityWarning.title': 'Aviso da Comunidade', 'communityWarning.description': 'Este vídeo foi sinalizado e/ou teve muitos votos negativos da comunidade.', 'communityWarning.goBack': 'Voltar', 'communityWarning.viewAnyway': 'Ver Mesmo Assim',
        // Report Modal
        'report.title': 'Denunciar Vídeo', 'report.description': 'Selecione um motivo para denunciar este conteúdo:', 'report.nudity': 'Nudez ou Conteúdo Sexual', 'report.nudityDesc': 'Contém imagens sexuais ou explícitas não marcadas como NSFW', 'report.hate': 'Discurso de Ódio ou Assédio', 'report.hateDesc': 'Promove violência, ódio ou assédio', 'report.illegal': 'Conteúdo Ilegal', 'report.illegalDesc': 'Conteúdo que pode violar leis', 'report.spam': 'Spam ou Enganoso', 'report.spamDesc': 'Conteúdo enganoso, golpes ou spam repetitivo', 'report.impersonation': 'Falsificação de Identidade', 'report.impersonationDesc': 'Fingir ser outra pessoa', 'report.other': 'Outro', 'report.otherDesc': 'Outra violação não listada', 'report.cancel': 'Cancelar', 'report.submit': 'Enviar Denúncia',
        // Share Modal
        'share.title': 'Compartilhar Vídeo', 'share.link': 'Link', 'share.embed': 'Incorporar', 'share.shareWith': 'Compartilhe este vídeo com outros:', 'share.copy': 'Copiar', 'share.copied': 'Copiado para a área de transferência!', 'share.embedOnWebsite': 'Incorpore este vídeo no seu site:', 'share.size': 'Tamanho:', 'share.responsive': 'Responsivo (Padrão)', 'share.size1280x720': '1280 × 720 (HD)', 'share.embedCodeCopied': 'Código de incorporação copiado!',
        // Edit Video Modal
        'editVideo.title': 'Editar Vídeo', 'editVideo.video': 'Vídeo', 'editVideo.replaceVideo': 'Substituir Vídeo', 'editVideo.thumbnail': 'Miniatura', 'editVideo.changeThumbnail': 'Alterar Miniatura', 'editVideo.titleLabel': 'Título', 'editVideo.descriptionLabel': 'Descrição', 'editVideo.tagsLabel': 'Tags (separadas por vírgula)', 'editVideo.cancel': 'Cancelar', 'editVideo.saveChanges': 'Salvar Alterações',
        // Edit Profile Modal
        'editProfile.title': 'Editar Perfil', 'editProfile.displayName': 'Nome de Exibição', 'editProfile.displayNamePlaceholder': 'Seu nome de exibição', 'editProfile.about': 'Sobre', 'editProfile.aboutPlaceholder': 'Conte aos outros sobre você', 'editProfile.picture': 'Foto de Perfil', 'editProfile.pictureUrl': 'Ou digite a URL da imagem diretamente:', 'editProfile.nip05': 'Identificador NIP-05 (opcional)', 'editProfile.nip05Hint': 'Um endereço Nostr verificado para verificação de identidade.', 'editProfile.website': 'Site (opcional)', 'editProfile.saveChanges': 'Salvar Alterações',
        // Confirmation Modal
        'confirm.title': 'Confirmar Ação', 'confirm.message': 'Tem certeza que deseja continuar?', 'confirm.cancel': 'Cancelar', 'confirm.confirm': 'Confirmar',
        // Video Page
        'video.views': 'visualizações', 'video.view': 'visualização', 'video.followers': 'seguidores', 'video.follower': 'seguidor', 'video.follow': 'Seguir', 'video.unfollow': 'Deixar de Seguir', 'video.share': 'Compartilhar', 'video.comments': 'Comentários', 'video.writeComment': 'Escrever um comentário...', 'video.noComments': 'Ainda não há comentários. Seja o primeiro!',
        // Toast Messages
        'toast.loggedIn': 'Login realizado!', 'toast.settingsSaved': 'Configurações salvas!', 'toast.languageChanged': 'Idioma alterado', 'toast.copied': 'Copiado!',
        // Time
        'time.justNow': 'agora mesmo', 'time.minuteAgo': 'há 1 minuto', 'time.minutesAgo': 'há {n} minutos', 'time.hourAgo': 'há 1 hora', 'time.hoursAgo': 'há {n} horas', 'time.dayAgo': 'há 1 dia', 'time.daysAgo': 'há {n} dias',
        // Empty States
        'empty.noVideos': 'Nenhum vídeo encontrado.', 'empty.noLikedVideos': 'Você ainda não curtiu nenhum vídeo.', 'empty.noHistory': 'Sem histórico.',
        // Misc
        'misc.loading': 'Carregando...', 'misc.close': 'Fechar', 'misc.back': 'Voltar', 'misc.search': 'Pesquisar',
        // Common
        'common.cancel': 'Cancelar', 'common.uploading': 'Enviando...', 'common.saveChanges': 'Salvar Alterações', 'common.close': 'Fechar',
        // Aria Labels
        'aria.toggleMenu': 'Alternar menu', 'aria.mainNavigation': 'Navegação principal', 'aria.videoContent': 'Conteúdo de vídeo', 'aria.loadingContent': 'Carregando conteúdo',
        // Dynamic JavaScript text
        'button.hideQR': 'Ocultar Código QR', 'button.showQR': 'Mostrar Código QR', 'button.copied': 'Copiado!', 'button.showLess': 'Ver Menos', 'button.showMore': 'Ver Mais', 'button.creatingAccount': 'Criando conta...', 'button.submitting': 'Enviando...', 'button.scheduleStream': 'Agendar Transmissão', 'button.goLive': 'Transmitir', 'button.creatingStream': 'Criando transmissão...', 'button.continueCustomAmount': 'Continuar com Valor Personalizado', 'button.recordFromCamera': 'Gravar da Câmera', 'button.requestingCamera': 'Solicitando câmera...', 'button.recording': 'Gravando...',
        'status.saving': 'Salvando...', 'status.saved': 'Salvo!', 'status.uploading': 'Enviando...', 'status.uploadComplete': 'Envio completo!', 'status.uploadingToNostrBuild': 'Enviando para nostr.build...', 'status.publishingChanges': 'Publicando alterações...', 'status.removingOldVersion': 'Removendo versão antiga...', 'status.validatingThumbnail': 'Validando miniatura...', 'status.uploadingThumbnail': 'Enviando miniatura...', 'status.thumbnailUploaded': 'Miniatura enviada!', 'status.processingVideo': 'Processando vídeo...', 'status.compressingVideo': 'Comprimindo vídeo...', 'status.uploadingVideo': 'Enviando vídeo...', 'status.videoUploaded': 'Vídeo enviado com sucesso!', 'status.processing': 'Processando...', 'status.generatingThumbnail': 'Gerando miniatura...', 'status.generatingPreview': 'Gerando prévia...', 'status.uploadingPreview': 'Enviando prévia...', 'status.publishing': 'Publicando...', 'status.publishingToNostr': 'Publicando no Nostr...', 'status.publishingVideoToNostr': 'Publicando vídeo no Nostr...', 'status.generatingPoW': 'Gerando prova de trabalho...', 'status.posting': 'Postando...', 'status.processingVideoAndThumbnail': 'Processando vídeo e miniatura...', 'status.uploadFailed': 'Envio falhou - tente novamente', 'status.selectVideoToUpload': 'Selecione um vídeo para enviar', 'status.waitingForVideoUpload': 'Aguardando envio do vídeo...', 'status.selectVideoAndThumbnail': 'Selecione vídeo e miniatura para publicar', 'status.ready': 'Pronto ✓', 'status.failed': 'Falhou ✗', 'status.fromDraft': 'Do rascunho', 'status.startingNow': 'Começando agora!', 'status.ended': 'ENCERRADO', 'status.thumbnailReady': 'Pronto', 'status.thumbnailFailed': 'Falhou', 'status.uploadFailedRetry': 'Envio falhou. Tente novamente.',
        'publish.video': 'Publicar Vídeo', 'publish.autoThumbnail': 'Publicar Vídeo (miniatura auto)',
        'report.titleComment': 'Denunciar Comentário', 'report.titleUser': 'Denunciar Usuário', 'report.titleVideo': 'Denunciar Vídeo', 'report.descComment': 'Selecione um motivo para denunciar este comentário:', 'report.descUser': 'Selecione um motivo para denunciar este usuário:', 'report.descVideo': 'Selecione um motivo para denunciar este conteúdo:',
        'empty.noMutedUsers': 'Sem usuários silenciados.', 'empty.noVideosToMonitor': 'Nenhum vídeo para monitorar.', 'empty.noRecentActivity': 'Sem atividade recente.', 'empty.failedLoadNotifications': 'Falha ao carregar notificações', 'empty.loginToViewLiked': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">faça login</a> para ver seus vídeos curtidos.', 'empty.loginToViewFollowing': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">faça login</a> para ver quem você segue.', 'empty.loginToViewVideos': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">faça login</a> para ver seus vídeos.', 'empty.loginToViewAnalytics': 'Por favor <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">faça login</a> para ver suas estatísticas.', 'empty.noLikedVideosYet': 'Você ainda não curtiu nenhum vídeo.', 'empty.noLikedVideosFound': 'Nenhum vídeo curtido encontrado.', 'empty.noFullLengthLikedVideos': 'Nenhum vídeo longo curtido encontrado.', 'empty.noWatchHistory': 'Sem histórico. Comece a assistir vídeos.', 'empty.noVideosInHistory': 'Nenhum vídeo no histórico.', 'empty.noFullLengthHistory': 'Nenhum vídeo longo no histórico.', 'empty.noMatchingVideos': 'Nenhum vídeo correspondente encontrado.', 'empty.noFullLengthVideos': 'Nenhum vídeo longo encontrado.', 'empty.failedLoadTrending': 'Falha ao carregar tendências.', 'empty.noTrendingVideos': 'Nenhum vídeo em alta encontrado.', 'empty.noMatchingUsers': 'Nenhum usuário correspondente encontrado.', 'empty.unableLoadProfiles': 'Não foi possível carregar perfis.', 'empty.noFollowingVideos': 'Ainda não há vídeos de quem você segue.', 'empty.noFullLengthFollowing': 'Nenhum vídeo longo de quem você segue.', 'empty.failedLoadFollowing': 'Falha ao carregar. Tente novamente.', 'empty.noVideosUploadFirst': 'Nenhum vídeo. Envie seu primeiro vídeo!', 'empty.noFullLengthUploaded': 'Nenhum vídeo longo encontrado.', 'empty.noMatchingLiveStreams': 'Nenhuma transmissão correspondente.', 'empty.noMatchingShorts': 'Nenhum short correspondente.', 'empty.noVideosForTag': 'Nenhum vídeo para esta tag.', 'empty.noFullLengthForTag': 'Nenhum vídeo longo para esta tag.', 'empty.noUploadedVideos': 'Nenhum vídeo enviado ainda.', 'empty.noVideosFound': 'Nenhum vídeo encontrado.', 'empty.failedLoadProfile': 'Falha ao carregar perfil. Tente novamente.', 'empty.noComments': 'Sem comentários ainda. Seja o primeiro!', 'empty.failedLoadComments': 'Falha ao carregar comentários', 'empty.noLiveNow': 'Ninguém está ao vivo. Seja o primeiro!',
        'error.videoNotFound': 'Vídeo não encontrado.', 'error.contentNotAvailable': 'Este conteúdo não está disponível.', 'error.invalidVideoData': 'Dados de vídeo inválidos.', 'error.videoNotAvailable': 'Vídeo não disponível. O arquivo pode ter sido removido.', 'error.failedLoadVideo': 'Falha ao carregar vídeo. Tente novamente.', 'error.failedLoadVideoShort': 'Falha ao carregar. Arquivo pode ter sido removido.', 'error.liveStreamNotFound': 'Transmissão ao vivo não encontrada.', 'error.invalidLiveStreamData': 'Dados de transmissão inválidos.', 'error.failedLoadLiveStream': 'Falha ao carregar transmissão.',
        // New Button & Action Labels
        'button.follow': 'Seguir', 'button.unfollow': 'Deixar de seguir', 'button.mute': 'Silenciar', 'button.unmute': 'Reativar som', 'button.muteUser': 'Silenciar usuário', 'button.unmuteUser': 'Reativar usuário', 'button.confirm': 'Confirmar', 'button.cancel': 'Cancelar', 'button.close': 'Fechar', 'button.boost': 'Impulsionar', 'button.zap': 'Zap', 'button.viewMore': 'Ver mais', 'button.viewAnalytics': 'Ver estatísticas', 'button.backToMyVideos': 'Voltar aos Meus Vídeos', 'button.editDraft': 'Editar rascunho', 'button.deleteDraft': 'Excluir rascunho', 'button.editVideo': 'Editar vídeo', 'button.deleteVideo': 'Excluir vídeo', 'button.editShort': 'Editar short', 'button.deleteShort': 'Excluir short', 'button.editStream': 'Editar transmissão', 'button.endStream': 'Encerrar transmissão', 'button.reset': 'Redefinir', 'button.download': 'Baixar', 'button.watchRecording': 'Assistir gravação', 'button.show': 'Mostrar', 'button.login': 'Entrar', 'button.toggleChat': 'Alternar chat', 'button.blockVideo': 'Bloquear vídeo', 'button.blockUser': 'Bloquear usuário', 'button.unblock': 'Desbloquear', 'button.removeFromHistory': 'Remover do histórico',
        // New Stats & Counts
        'stat.views': 'visualizações', 'stat.viewsCount': '{count} visualizações', 'stat.videos': 'vídeos', 'stat.video': 'vídeo', 'stat.followers': 'seguidores', 'stat.follower': 'seguidor', 'stat.following': 'Seguindo', 'stat.subscribers': 'inscritos', 'stat.comments': 'Comentários', 'stat.liveCount': '{count} ao vivo', 'stat.percentOfGoal': '{percent}% da meta', 'stat.netGrowth': 'Crescimento líquido', 'stat.newFollowers': 'Novos seguidores', 'stat.unfollowed': 'Deixaram de seguir', 'stat.lastUpdated': 'Última atualização: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'AO VIVO', 'badge.ended': 'ENCERRADO', 'badge.scheduled': 'AGENDADO', 'badge.warning': 'AVISO', 'badge.communityWarning': 'AVISO DA COMUNIDADE', 'badge.verifiedNip05': 'NIP-05 verificado', 'badge.streamer': 'Streamer', 'badge.clickToView': 'Clique para ver',
        // New Actions
        'action.report': 'Denunciar', 'action.reportComment': 'Denunciar comentário', 'action.reportVideo': 'Denunciar este vídeo', 'action.reportStream': 'Denunciar esta transmissão', 'action.like': 'Curtir', 'action.dislike': 'Não curtir', 'action.reply': 'Responder',
        // New Placeholders
        'placeholder.searchHistory': 'Pesquisar histórico...', 'placeholder.searchUsers': 'Pesquisar usuários...', 'placeholder.searchMyVideos': 'Pesquisar meus vídeos...', 'placeholder.eventId': 'Digite ID do evento (hex ou nevent/note)', 'placeholder.pubkey': 'Digite pubkey (hex ou npub)', 'placeholder.customAmount': 'Valor personalizado', 'placeholder.chatEnded': 'Chat fechado - transmissão encerrada', 'placeholder.addComment': 'Adicione um comentário...', 'placeholder.setNewGoal': 'Definir nova meta (sats)',
        // New Video & Content
        'video.untitledVideo': 'Vídeo sem título', 'video.untitledShort': 'Short sem título', 'video.upNext': 'A seguir', 'video.noVideosYet': 'Ainda não há vídeos', 'video.noShortsYet': 'Ainda não há shorts', 'video.noLiveStreamsYet': 'Ainda não há transmissões ao vivo', 'video.noBlockedVideos': 'Nenhum vídeo bloqueado', 'video.noBlockedUsers': 'Nenhum usuário bloqueado',
        // New Stream Messages
        'stream.ended': 'Esta transmissão terminou. O chat está fechado.', 'stream.welcomeChat': 'Bem-vindo ao chat ao vivo!', 'stream.goalReached': 'Meta atingida!', 'stream.zapGoalReached': 'Meta de zap atingida! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Mensagem de usuário silenciado', 'muted.commentFromMutedUserHidden': 'Comentário de usuário silenciado oculto', 'muted.commentHidden': 'Comentário oculto ({packs})', 'muted.messageHidden': 'Mensagem oculta ({packs})', 'muted.commentReportedByFollows': 'Comentário denunciado por pessoas que você segue', 'muted.messageReportedByFollows': 'Mensagem denunciada por pessoas que você segue', 'muted.commentHeavilyDownvoted': 'Comentário muito negativo pela comunidade', 'muted.messageHeavilyDownvoted': 'Mensagem muito negativa',
        // New Admin & Lists
        'list.blockedVideos': 'Vídeos bloqueados', 'list.blockedUsers': 'Usuários bloqueados',
        // New Alerts
        'alert.cameraNotSupported': 'O acesso à câmera não é suportado neste navegador. Por favor, use um navegador moderno como Chrome, Firefox ou Safari.', 'alert.noCameraFound': 'Nenhuma câmera encontrada neste dispositivo. Por favor, conecte uma câmera ou use a opção de upload de arquivo.', 'alert.cameraAccessDenied': 'Acesso à câmera negado. Por favor, permita as permissões de câmera nas configurações do navegador.', 'alert.cameraInUse': 'A câmera está sendo usada por outro aplicativo. Por favor, feche outros apps que estão usando a câmera.', 'alert.cameraUnableAccess': 'Não foi possível acessar a câmera com as configurações atuais. Por favor, tente usar a opção de upload.', 'alert.cameraUnableAccessWithError': 'Não foi possível acessar a câmera: {error}\n\nPor favor, use a opção de upload.', 'alert.fillRequiredFields': 'Por favor, preencha todos os campos obrigatórios', 'alert.uploadThumbnail': 'Por favor, faça upload de uma miniatura para sua transmissão', 'alert.failedCreateStream': 'Falha ao criar transmissão ao vivo. Por favor, tente novamente.', 'alert.failedUpdateStream': 'Falha ao atualizar. Por favor, tente novamente.', 'alert.streamNotFound': 'Transmissão não encontrada', 'alert.canOnlyEditOwnStreams': 'Você só pode editar suas próprias transmissões', 'alert.invalidStreamData': 'Dados de transmissão inválidos', 'alert.enterValidGoalAmount': 'Por favor, insira um valor de meta válido', 'alert.canOnlyResetOwnGoals': 'Você só pode redefinir suas próprias metas', 'alert.streamEventNotFound': 'Evento de transmissão não encontrado', 'alert.failedResetZapGoal': 'Falha ao redefinir meta de zap. Por favor, tente novamente.', 'alert.cannotBlockAdmin': 'Não é possível bloquear a conta de administrador', 'alert.analyticsLoadFailed': 'Falha ao carregar estatísticas. Por favor, tente novamente.', 'alert.cannotReplaceShortWithVideo': 'Não é possível substituir um Short por um vídeo normal. Por favor, faça upload de um vídeo vertical (60 segundos ou menos).', 'alert.cannotReplaceVideoWithShort': 'Não é possível substituir um vídeo normal por um Short. Por favor, faça upload de um vídeo horizontal.', 'alert.shortsRequireVertical': 'Este vídeo parece ser horizontal. Shorts devem ser vídeos verticais. Por favor, use "Enviar Vídeo" para vídeos horizontais.',
        // New Zap Messages
        'zap.cannotZapYourself': 'Você não pode enviar zap para si mesmo', 'zap.cannotZapOwnContent': 'Você não pode enviar zap para seu próprio conteúdo', 'zap.cannotZapOwnComment': 'Você não pode enviar zap para seu próprio comentário', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'Carregando vídeo...', 'status.loading': 'Carregando...', 'status.compressingProgress': 'Comprimindo... {progress}%', 'status.uploadingProgress': 'Enviando... {progress}%', 'status.uploadingServers': 'Enviando... ({completed}/{total} servidores)', 'status.publishedSuccess': '{type} publicado com sucesso!',
        // New Warnings
        'warning.webmFormat': 'Nota: Seu navegador produzirá formato WebM (pode não funcionar no iOS). Para MP4 compatível com iOS, use Chrome no Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Última atualização: Dezembro 2024',
    },
    ru: {
        // Navigation & Header
        'nav.home': 'Главная', 'nav.following': 'Подписки', 'nav.myVideos': 'Мои Видео', 'nav.liked': 'Понравившиеся', 'nav.history': 'История', 'nav.topics': 'ТЕМЫ', 'nav.live': 'Прямой эфир', 'nav.bitcoin': 'Биткоин', 'nav.nostr': 'Nostr', 'nav.technology': 'Технологии', 'nav.gaming': 'Игры', 'nav.tutorials': 'Уроки', 'nav.podcasts': 'Подкасты', 'nav.music': 'Музыка', 'nav.nsfw': 'NSFW', 'nav.about': 'О нас', 'nav.contact': 'Контакты', 'nav.terms': 'Условия', 'nav.privacy': 'Конфиденциальность', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': 'Трансляции', 'nav.github': 'GitHub',
        'header.search': 'Поиск видео...', 'header.notifications': 'Уведомления', 'header.settings': 'Настройки', 'header.create': 'Создать', 'header.viewProfile': 'Мой профиль', 'header.logout': 'Выйти',
        // Login Modal
        'login.title': 'Вход через Nostr', 'login.extensionButton': 'Войти через расширение Nostr', 'login.extensionDesc': 'Использовать расширение-подписчик (Alby, nos2x и др.)', 'login.orDivider': 'ИЛИ', 'login.nsecLabel': 'Войти с приватным ключом (nsec)', 'login.nsecPlaceholder': 'Введите nsec...', 'login.nsecButton': 'Войти с nsec', 'login.nsecWarning': 'Внимание: Ввод nsec напрямую менее безопасен, чем использование расширения. Рассмотрите NIP-07 расширение для лучшей защиты.', 'login.newToNostr': 'Новичок в Nostr?', 'login.createAccount': 'Создать аккаунт', 'login.learnMore': 'Узнать больше о Nostr',
        // Connect Modal
        'connect.title': 'Подключение к Nostr', 'connect.or': 'ИЛИ', 'connect.extensionButton': 'Подключить расширение Nostr', 'connect.extensionDesc': 'Использовать расширение (Alby, nos2x и др.)', 'connect.nsecLabel': 'Войти с приватным ключом', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'Подключиться с nsec', 'connect.nsecWarning': 'Внимание: Ввод nsec напрямую менее безопасен. Используйте NIP-07 расширение для лучшей защиты.', 'connect.newToNostr': 'Новичок в Nostr?', 'connect.createAccount': 'Создать аккаунт',
        // Private Key Modal
        'privateKey.title': 'Ваш приватный ключ', 'privateKey.warning': 'ВАЖНО: Сохраните это в безопасном месте. Если вы потеряете этот ключ, вы потеряете доступ к аккаунту. Никогда никому его не показывайте!', 'privateKey.show': 'Показать приватный ключ', 'privateKey.hide': 'Скрыть приватный ключ', 'privateKey.copy': 'Копировать', 'privateKey.saved': 'Я сохранил(а) свой ключ', 'privateKey.yourPublicKey': 'Ваш публичный ключ (npub):', 'privateKey.yourPrivateKey': 'Ваш приватный ключ (nsec):',
        // Signup Modal
        'signup.title': 'Создать аккаунт Nostr', 'signup.whatIsNostr': 'Что такое Nostr?', 'signup.nostrDescription': 'Nostr — это децентрализованный протокол, который даёт вам контроль над вашей идентичностью и данными. Нет центрального сервера — ваш аккаунт — это криптографическая пара ключей.', 'signup.whyNostr': 'Почему Nostr?', 'signup.benefit1': 'Владейте своей идентичностью', 'signup.benefit2': 'Нет цензуры', 'signup.benefit3': 'Портативность между платформами', 'signup.createNew': 'Создать новый аккаунт', 'signup.haveAccount': 'Уже есть аккаунт?', 'signup.login': 'Войти', 'signup.createButton': 'Создать аккаунт', 'signup.generating': 'Генерация ключей...', 'signup.displayName': 'Имя', 'signup.displayNamePlaceholder': 'Введите имя', 'signup.username': 'Имя пользователя', 'signup.usernamePlaceholder': 'Введите имя пользователя',
        // Notifications
        'notifications.title': 'Уведомления', 'notifications.empty': 'Пока нет уведомлений', 'notifications.viewAll': 'Смотреть все уведомления', 'notifications.markAllRead': 'Отметить все как прочитанные', 'notifications.settings': 'Настройки уведомлений', 'notifications.loading': 'Загрузка уведомлений...', 'notifications.zap': 'отправил(а) вам зап', 'notifications.like': 'понравился ваш контент', 'notifications.comment': 'оставил(а) комментарий', 'notifications.follow': 'подписался(ась) на вас', 'notifications.repost': 'сделал(а) репост', 'notifications.mention': 'упомянул(а) вас',
        // Settings Modal
        'settings.title': 'Настройки', 'settings.language': 'Язык', 'settings.languageDesc': 'Выберите язык', 'settings.saveToNostr': 'Сохранить в Nostr', 'settings.darkMode': 'Тёмная тема', 'settings.darkModeDesc': 'Переключение тёмной темы', 'settings.autoplay': 'Автовоспроизведение', 'settings.autoplayDesc': 'Автоматически воспроизводить видео', 'settings.saveSettings': 'Сохранить настройки', 'settings.resetDefaults': 'Сбросить', 'settings.notifications': 'Уведомления', 'settings.notificationsDesc': 'Получать push-уведомления', 'settings.quality': 'Качество по умолчанию', 'settings.qualityDesc': 'Качество воспроизведения видео',
        // Upload Modal
        'upload.title': 'Загрузить видео', 'upload.dragDrop': 'Перетащите видеофайл сюда', 'upload.or': 'или', 'upload.browse': 'Выбрать файлы', 'upload.supportedFormats': 'Поддерживаемые форматы: MP4, WebM, MOV', 'upload.maxSize': 'Максимальный размер: 2ГБ', 'upload.videoTitle': 'Название', 'upload.titlePlaceholder': 'Введите название видео', 'upload.description': 'Описание', 'upload.descriptionPlaceholder': 'Опишите ваше видео...', 'upload.tags': 'Теги', 'upload.tagsPlaceholder': 'Добавьте теги через запятую', 'upload.visibility': 'Видимость', 'upload.public': 'Публичное', 'upload.unlisted': 'По ссылке', 'upload.uploadButton': 'Загрузить видео', 'upload.uploading': 'Загрузка...', 'upload.processing': 'Обработка...', 'upload.complete': 'Завершено!', 'upload.error': 'Ошибка загрузки', 'upload.nsfw': 'Контент NSFW', 'upload.nsfwDesc': 'Отметить как контент для взрослых', 'upload.thumbnail': 'Обложка', 'upload.thumbnailDesc': 'Загрузите обложку для видео', 'upload.preparing': 'Подготовка...', 'upload.cancel': 'Отмена', 'upload.progress': 'Прогресс загрузки', 'upload.transcoding': 'Транскодирование', 'upload.complete': 'Завершено', 'upload.status.preparing': 'Подготовка загрузки...', 'upload.status.uploading': 'Загрузка видео...', 'upload.status.transcoding': 'Транскодирование видео...', 'upload.status.complete': 'Загрузка завершена!', 'upload.qualityHigh': 'Высокое', 'upload.qualityMedium': 'Среднее', 'upload.qualityLow': 'Низкое',
        // Create Modal
        'create.title': 'Создать', 'create.uploadVideo': 'Загрузить видео', 'create.uploadDesc': 'Поделиться видео', 'create.goLive': 'Начать трансляцию', 'create.goLiveDesc': 'Запустить прямую трансляцию', 'create.createPost': 'Создать пост', 'create.createPostDesc': 'Поделиться текстом',
        // Go Live Modal
        'goLive.title': 'Начать трансляцию', 'goLive.streamTitle': 'Название трансляции', 'goLive.streamTitlePlaceholder': 'Введите название трансляции', 'goLive.description': 'Описание', 'goLive.descriptionPlaceholder': 'Опишите вашу трансляцию...', 'goLive.category': 'Категория', 'goLive.selectCategory': 'Выберите категорию', 'goLive.tags': 'Теги', 'goLive.tagsPlaceholder': 'Добавьте теги через запятую', 'goLive.startStream': 'Начать трансляцию', 'goLive.streamKey': 'Ключ трансляции', 'goLive.streamUrl': 'URL трансляции', 'goLive.copy': 'Копировать', 'goLive.hideKey': 'Скрыть ключ', 'goLive.showKey': 'Показать ключ', 'goLive.connecting': 'Подключение...', 'goLive.live': 'В ЭФИРЕ', 'goLive.offline': 'Не в сети', 'goLive.viewers': 'зрителей', 'goLive.endStream': 'Завершить трансляцию', 'goLive.nsfw': 'Контент NSFW', 'goLive.nsfwDesc': 'Отметить как контент для взрослых', 'goLive.thumbnail': 'Обложка трансляции', 'goLive.thumbnailDesc': 'Загрузите обложку',
        // Edit Stream Modal
        'editStream.title': 'Редактировать трансляцию', 'editStream.save': 'Сохранить изменения',
        // NSFW Warning Modal
        'nsfw.title': 'Внимание: контент для взрослых', 'nsfw.warning': 'Этот контент отмечен как NSFW (Not Safe For Work) и может содержать материалы для взрослых.', 'nsfw.confirm': 'Подтвердите свой возраст', 'nsfw.confirmAge': 'Мне 18 лет или больше', 'nsfw.cancel': 'Назад', 'nsfw.continue': 'Продолжить', 'nsfw.dontShowAgain': 'Не показывать это предупреждение',
        // Community Warning Modal
        'community.title': 'Правила сообщества', 'community.warning': 'Перед продолжением ознакомьтесь с правилами нашего сообщества.', 'community.guidelines': 'Будьте уважительны и соблюдайте стандарты сообщества.', 'community.accept': 'Принимаю', 'community.decline': 'Отклоняю',
        // Report Modal
        'report.title': 'Пожаловаться на контент', 'report.reason': 'Причина жалобы', 'report.selectReason': 'Выберите причину', 'report.spam': 'Спам или вводящий в заблуждение', 'report.inappropriate': 'Неприемлемый контент', 'report.violence': 'Насилие или опасный контент', 'report.copyright': 'Нарушение авторских прав', 'report.other': 'Другое', 'report.details': 'Дополнительно', 'report.detailsPlaceholder': 'Опишите проблему подробнее...', 'report.submit': 'Отправить жалобу', 'report.cancel': 'Отмена',
        // Share Modal
        'share.title': 'Поделиться', 'share.copyLink': 'Копировать ссылку', 'share.embed': 'Код для вставки', 'share.copyEmbed': 'Копировать код', 'share.social': 'Поделиться в соцсетях', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': 'Email', 'share.copied': 'Скопировано!', 'share.nostr': 'Поделиться в Nostr', 'share.generateImage': 'Создать изображение', 'share.downloadImage': 'Скачать', 'share.shareImage': 'Поделиться', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (квадрат)', 'share.size1080x1920': '1080 × 1920 (сторис)',
        // Edit Video Modal
        'editVideo.title': 'Редактировать видео', 'editVideo.videoTitle': 'Название', 'editVideo.description': 'Описание', 'editVideo.tags': 'Теги', 'editVideo.thumbnail': 'Обложка', 'editVideo.changeThumbnail': 'Изменить обложку', 'editVideo.visibility': 'Видимость', 'editVideo.nsfw': 'Контент NSFW', 'editVideo.save': 'Сохранить изменения', 'editVideo.delete': 'Удалить видео', 'editVideo.confirmDelete': 'Вы уверены, что хотите удалить это видео?',
        // Edit Profile Modal
        'editProfile.title': 'Редактировать профиль', 'editProfile.displayName': 'Имя', 'editProfile.displayNamePlaceholder': 'Введите имя', 'editProfile.username': 'Имя пользователя', 'editProfile.usernamePlaceholder': 'Введите имя пользователя', 'editProfile.about': 'О себе', 'editProfile.aboutPlaceholder': 'Расскажите о себе...', 'editProfile.website': 'Веб-сайт', 'editProfile.websitePlaceholder': 'https://ваш-сайт.com', 'editProfile.lightning': 'Lightning-адрес', 'editProfile.lightningPlaceholder': 'вы@getalby.com', 'editProfile.nip05': 'NIP-05 верификация', 'editProfile.nip05Placeholder': 'вы@домен.com', 'editProfile.avatar': 'Аватар', 'editProfile.changeAvatar': 'Изменить аватар', 'editProfile.banner': 'Баннер', 'editProfile.changeBanner': 'Изменить баннер', 'editProfile.save': 'Сохранить профиль',
        // Confirmation Modal
        'confirm.title': 'Подтвердить действие', 'confirm.message': 'Вы уверены, что хотите продолжить?', 'confirm.confirm': 'Подтвердить', 'confirm.cancel': 'Отмена',
        // Video Page
        'video.views': 'просмотров', 'video.like': 'Нравится', 'video.dislike': 'Не нравится', 'video.share': 'Поделиться', 'video.save': 'Сохранить', 'video.report': 'Пожаловаться', 'video.follow': 'Подписаться', 'video.unfollow': 'Отписаться', 'video.subscribe': 'Подписаться', 'video.subscribed': 'Подписан(а)', 'video.comments': 'Комментарии', 'video.addComment': 'Добавить комментарий...', 'video.reply': 'Ответить', 'video.replies': 'ответов', 'video.loadMore': 'Загрузить ещё', 'video.noComments': 'Комментариев пока нет. Будьте первым!', 'video.zap': 'Зап', 'video.zapAmount': 'Сумма зап (сатоши)', 'video.sendZap': 'Отправить зап', 'video.boost': 'Буст', 'video.description': 'Описание', 'video.showMore': 'Показать больше', 'video.showLess': 'Показать меньше', 'video.publishedOn': 'Опубликовано',
        // Toast Messages
        'toast.loggedIn': 'Вход выполнен!', 'toast.loggedOut': 'Выход выполнен', 'toast.settingsSaved': 'Настройки сохранены!', 'toast.settingsReset': 'Настройки сброшены', 'toast.videoUploaded': 'Видео загружено!', 'toast.videoDeleted': 'Видео удалено', 'toast.profileUpdated': 'Профиль обновлён!', 'toast.linkCopied': 'Ссылка скопирована!', 'toast.embedCopied': 'Код скопирован!', 'toast.zapSent': 'Зап отправлен!', 'toast.followed': 'Вы подписались!', 'toast.unfollowed': 'Вы отписались', 'toast.reported': 'Жалоба отправлена', 'toast.saved': 'Сохранено!', 'toast.error': 'Произошла ошибка', 'toast.networkError': 'Ошибка сети. Попробуйте снова.', 'toast.uploadError': 'Ошибка загрузки. Попробуйте снова.', 'toast.languageChanged': 'Язык изменён', 'toast.commentPosted': 'Комментарий опубликован', 'toast.keyCopied': 'Ключ скопирован!',
        // Time
        'time.now': 'только что', 'time.minutesAgo': '{count} мин. назад', 'time.hoursAgo': '{count} ч. назад', 'time.daysAgo': '{count} дн. назад', 'time.weeksAgo': '{count} нед. назад', 'time.monthsAgo': '{count} мес. назад', 'time.yearsAgo': '{count} г. назад',
        // Empty States
        'empty.noVideos': 'Видео не найдены', 'empty.noVideosDesc': 'Попробуйте другой поиск', 'empty.noFollowing': 'Вы ещё никого не подписаны', 'empty.noFollowingDesc': 'Следите за авторами, чтобы видеть их видео', 'empty.noHistory': 'История пуста', 'empty.noHistoryDesc': 'Посмотренные видео появятся здесь', 'empty.noLiked': 'Понравившихся видео пока нет', 'empty.noLikedDesc': 'Лайкайте видео, и они появятся здесь', 'empty.noResults': 'Результатов не найдено', 'empty.noResultsDesc': 'Попробуйте другие ключевые слова',
        // Misc
        'misc.loading': 'Загрузка...', 'misc.loadingMore': 'Загрузка...', 'misc.refresh': 'Обновить', 'misc.retry': 'Повторить', 'misc.close': 'Закрыть', 'misc.back': 'Назад', 'misc.next': 'Далее', 'misc.previous': 'Назад', 'misc.search': 'Поиск', 'misc.filter': 'Фильтр', 'misc.sort': 'Сортировка', 'misc.newest': 'Новые', 'misc.oldest': 'Старые', 'misc.popular': 'Популярные', 'misc.trending': 'В тренде', 'misc.sats': 'сатоши', 'misc.all': 'Все', 'misc.copiedToClipboard': 'Скопировано!',
        // Common
        'common.submit': 'Отправить', 'common.cancel': 'Отмена', 'common.save': 'Сохранить', 'common.delete': 'Удалить', 'common.edit': 'Редактировать', 'common.close': 'Закрыть', 'common.confirm': 'Подтвердить', 'common.yes': 'Да', 'common.no': 'Нет', 'common.ok': 'ОК', 'common.loading': 'Загрузка...', 'common.uploading': 'Загрузка...', 'common.error': 'Ошибка', 'common.success': 'Успешно',
        // Aria Labels
        'aria.toggleMenu': 'Переключить меню', 'aria.mainNavigation': 'Главная навигация', 'aria.videoContent': 'Видеоконтент', 'aria.loadingContent': 'Загрузка контента', 'aria.closeModal': 'Закрыть окно', 'aria.playVideo': 'Воспроизвести видео', 'aria.pauseVideo': 'Приостановить видео', 'aria.muteVideo': 'Отключить звук', 'aria.unmuteVideo': 'Включить звук', 'aria.fullscreen': 'Полный экран', 'aria.exitFullscreen': 'Выйти из полного экрана', 'aria.settings': 'Настройки', 'aria.notifications': 'Уведомления', 'aria.userMenu': 'Меню пользователя', 'aria.searchInput': 'Поиск видео', 'aria.videoPlayer': 'Видеоплеер',
        // Dynamic JavaScript text
        'button.hideQR': 'Скрыть QR-код', 'button.showQR': 'Показать QR-код', 'button.copied': 'Скопировано!', 'button.showLess': 'Показать меньше', 'button.showMore': 'Показать больше', 'button.creatingAccount': 'Создание аккаунта...', 'button.submitting': 'Отправка...', 'button.scheduleStream': 'Запланировать трансляцию', 'button.goLive': 'Начать трансляцию', 'button.creatingStream': 'Создание трансляции...', 'button.continueCustomAmount': 'Продолжить с произвольной суммой', 'button.recordFromCamera': 'Записать с камеры', 'button.requestingCamera': 'Запрос камеры...', 'button.recording': 'Запись...',
        'status.saving': 'Сохранение...', 'status.saved': 'Сохранено!', 'status.uploading': 'Загрузка...', 'status.uploadComplete': 'Загрузка завершена!', 'status.uploadingToNostrBuild': 'Загрузка на nostr.build...', 'status.publishingChanges': 'Публикация изменений...', 'status.removingOldVersion': 'Удаление старой версии...', 'status.validatingThumbnail': 'Проверка миниатюры...', 'status.uploadingThumbnail': 'Загрузка миниатюры...', 'status.thumbnailUploaded': 'Миниатюра загружена!', 'status.processingVideo': 'Обработка видео...', 'status.compressingVideo': 'Сжатие видео...', 'status.uploadingVideo': 'Загрузка видео...', 'status.videoUploaded': 'Видео успешно загружено!', 'status.processing': 'Обработка...', 'status.generatingThumbnail': 'Генерация миниатюры...', 'status.generatingPreview': 'Генерация превью...', 'status.uploadingPreview': 'Загрузка превью...', 'status.publishing': 'Публикация...', 'status.publishingToNostr': 'Публикация в Nostr...', 'status.publishingVideoToNostr': 'Публикация видео в Nostr...', 'status.generatingPoW': 'Генерация proof of work...', 'status.posting': 'Публикация...', 'status.processingVideoAndThumbnail': 'Обработка видео и миниатюры...', 'status.uploadFailed': 'Ошибка загрузки - попробуйте снова', 'status.selectVideoToUpload': 'Выберите видео для загрузки', 'status.waitingForVideoUpload': 'Ожидание загрузки видео...', 'status.selectVideoAndThumbnail': 'Выберите видео и миниатюру для публикации', 'status.ready': 'Готово ✓', 'status.failed': 'Ошибка ✗', 'status.fromDraft': 'Из черновика', 'status.startingNow': 'Начинается сейчас!', 'status.ended': 'ЗАВЕРШЕНО', 'status.thumbnailReady': 'Готово', 'status.thumbnailFailed': 'Ошибка', 'status.uploadFailedRetry': 'Ошибка загрузки. Попробуйте снова.',
        'publish.video': 'Опубликовать видео', 'publish.autoThumbnail': 'Опубликовать видео (авто-миниатюра)',
        'report.titleComment': 'Пожаловаться на комментарий', 'report.titleUser': 'Пожаловаться на пользователя', 'report.titleVideo': 'Пожаловаться на видео', 'report.descComment': 'Выберите причину жалобы на комментарий:', 'report.descUser': 'Выберите причину жалобы на пользователя:', 'report.descVideo': 'Выберите причину жалобы на контент:',
        'empty.noMutedUsers': 'Нет заглушенных пользователей.', 'empty.noVideosToMonitor': 'Нет видео для мониторинга.', 'empty.noRecentActivity': 'Нет недавней активности.', 'empty.failedLoadNotifications': 'Не удалось загрузить уведомления', 'empty.loginToViewLiked': 'Пожалуйста <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">войдите</a>, чтобы увидеть понравившиеся видео.', 'empty.loginToViewFollowing': 'Пожалуйста <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">войдите</a>, чтобы увидеть подписки.', 'empty.loginToViewVideos': 'Пожалуйста <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">войдите</a>, чтобы увидеть ваши видео.', 'empty.loginToViewAnalytics': 'Пожалуйста <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">войдите</a>, чтобы увидеть статистику.', 'empty.noLikedVideosYet': 'Вы ещё не лайкнули ни одного видео.', 'empty.noLikedVideosFound': 'Понравившиеся видео не найдены.', 'empty.noFullLengthLikedVideos': 'Длинные понравившиеся видео не найдены.', 'empty.noWatchHistory': 'Нет истории. Начните смотреть видео.', 'empty.noVideosInHistory': 'Видео в истории не найдены.', 'empty.noFullLengthHistory': 'Длинные видео в истории не найдены.', 'empty.noMatchingVideos': 'Подходящие видео не найдены.', 'empty.noFullLengthVideos': 'Длинные видео не найдены.', 'empty.failedLoadTrending': 'Не удалось загрузить тренды.', 'empty.noTrendingVideos': 'Трендовые видео не найдены.', 'empty.noMatchingUsers': 'Подходящие пользователи не найдены.', 'empty.unableLoadProfiles': 'Не удалось загрузить профили.', 'empty.noFollowingVideos': 'Пока нет видео от подписок.', 'empty.noFullLengthFollowing': 'Нет длинных видео от подписок.', 'empty.failedLoadFollowing': 'Не удалось загрузить. Попробуйте снова.', 'empty.noVideosUploadFirst': 'Нет видео. Загрузите первое видео!', 'empty.noFullLengthUploaded': 'Длинные видео не найдены.', 'empty.noMatchingLiveStreams': 'Подходящие трансляции не найдены.', 'empty.noMatchingShorts': 'Подходящие шортсы не найдены.', 'empty.noVideosForTag': 'Нет видео для этого тега.', 'empty.noFullLengthForTag': 'Нет длинных видео для этого тега.', 'empty.noUploadedVideos': 'Видео ещё не загружены.', 'empty.noVideosFound': 'Видео не найдены.', 'empty.failedLoadProfile': 'Не удалось загрузить профиль. Попробуйте снова.', 'empty.noComments': 'Пока нет комментариев. Будьте первым!', 'empty.failedLoadComments': 'Не удалось загрузить комментарии', 'empty.noLiveNow': 'Сейчас никто не в эфире. Будьте первым!',
        'error.videoNotFound': 'Видео не найдено.', 'error.contentNotAvailable': 'Этот контент недоступен.', 'error.invalidVideoData': 'Неверные данные видео.', 'error.videoNotAvailable': 'Видео недоступно. Файл мог быть удалён.', 'error.failedLoadVideo': 'Не удалось загрузить видео. Попробуйте снова.', 'error.failedLoadVideoShort': 'Не удалось загрузить. Файл мог быть удалён.', 'error.liveStreamNotFound': 'Трансляция не найдена.', 'error.invalidLiveStreamData': 'Неверные данные трансляции.', 'error.failedLoadLiveStream': 'Не удалось загрузить трансляцию.',
        // New Button & Action Labels
        'button.follow': 'Подписаться', 'button.unfollow': 'Отписаться', 'button.mute': 'Заглушить', 'button.unmute': 'Включить звук', 'button.muteUser': 'Заглушить пользователя', 'button.unmuteUser': 'Включить пользователя', 'button.confirm': 'Подтвердить', 'button.cancel': 'Отмена', 'button.close': 'Закрыть', 'button.boost': 'Продвинуть', 'button.zap': 'Zap', 'button.viewMore': 'Показать ещё', 'button.viewAnalytics': 'Статистика', 'button.backToMyVideos': 'Назад к Моим Видео', 'button.editDraft': 'Редактировать черновик', 'button.deleteDraft': 'Удалить черновик', 'button.editVideo': 'Редактировать видео', 'button.deleteVideo': 'Удалить видео', 'button.editShort': 'Редактировать short', 'button.deleteShort': 'Удалить short', 'button.editStream': 'Редактировать трансляцию', 'button.endStream': 'Завершить трансляцию', 'button.reset': 'Сбросить', 'button.download': 'Скачать', 'button.watchRecording': 'Смотреть запись', 'button.show': 'Показать', 'button.login': 'Войти', 'button.toggleChat': 'Переключить чат', 'button.blockVideo': 'Заблокировать видео', 'button.blockUser': 'Заблокировать пользователя', 'button.unblock': 'Разблокировать', 'button.removeFromHistory': 'Удалить из истории',
        // New Stats & Counts
        'stat.views': 'просмотров', 'stat.viewsCount': '{count} просмотров', 'stat.videos': 'видео', 'stat.video': 'видео', 'stat.followers': 'подписчиков', 'stat.follower': 'подписчик', 'stat.following': 'Подписки', 'stat.subscribers': 'подписчиков', 'stat.comments': 'Комментарии', 'stat.liveCount': '{count} в эфире', 'stat.percentOfGoal': '{percent}% от цели', 'stat.netGrowth': 'Чистый рост', 'stat.newFollowers': 'Новые подписчики', 'stat.unfollowed': 'Отписались', 'stat.lastUpdated': 'Обновлено: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'В ЭФИРЕ', 'badge.ended': 'ЗАВЕРШЕНО', 'badge.scheduled': 'ЗАПЛАНИРОВАНО', 'badge.warning': 'ПРЕДУПРЕЖДЕНИЕ', 'badge.communityWarning': 'ПРЕДУПРЕЖДЕНИЕ СООБЩЕСТВА', 'badge.verifiedNip05': 'NIP-05 подтверждён', 'badge.streamer': 'Стример', 'badge.clickToView': 'Нажмите для просмотра',
        // New Actions
        'action.report': 'Пожаловаться', 'action.reportComment': 'Пожаловаться на комментарий', 'action.reportVideo': 'Пожаловаться на видео', 'action.reportStream': 'Пожаловаться на трансляцию', 'action.like': 'Нравится', 'action.dislike': 'Не нравится', 'action.reply': 'Ответить',
        // New Placeholders
        'placeholder.searchHistory': 'Поиск в истории...', 'placeholder.searchUsers': 'Поиск пользователей...', 'placeholder.searchMyVideos': 'Поиск моих видео...', 'placeholder.eventId': 'Введите ID события (hex или nevent/note)', 'placeholder.pubkey': 'Введите pubkey (hex или npub)', 'placeholder.customAmount': 'Своя сумма', 'placeholder.chatEnded': 'Чат закрыт - трансляция завершена', 'placeholder.addComment': 'Добавить комментарий...', 'placeholder.setNewGoal': 'Установить новую цель (sats)',
        // New Video & Content
        'video.untitledVideo': 'Видео без названия', 'video.untitledShort': 'Short без названия', 'video.upNext': 'Далее', 'video.noVideosYet': 'Пока нет видео', 'video.noShortsYet': 'Пока нет shorts', 'video.noLiveStreamsYet': 'Пока нет трансляций', 'video.noBlockedVideos': 'Нет заблокированных видео', 'video.noBlockedUsers': 'Нет заблокированных пользователей',
        // New Stream Messages
        'stream.ended': 'Трансляция завершена. Чат закрыт.', 'stream.welcomeChat': 'Добро пожаловать в чат!', 'stream.goalReached': 'Цель достигнута!', 'stream.zapGoalReached': 'Цель zap достигнута! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Сообщение от заглушённого пользователя', 'muted.commentFromMutedUserHidden': 'Комментарий от заглушённого пользователя скрыт', 'muted.commentHidden': 'Комментарий скрыт ({packs})', 'muted.messageHidden': 'Сообщение скрыто ({packs})', 'muted.commentReportedByFollows': 'Комментарий отмечен людьми, на которых вы подписаны', 'muted.messageReportedByFollows': 'Сообщение отмечено людьми, на которых вы подписаны', 'muted.commentHeavilyDownvoted': 'Комментарий сильно минусован', 'muted.messageHeavilyDownvoted': 'Сообщение сильно минусовано',
        // New Admin & Lists
        'list.blockedVideos': 'Заблокированные видео', 'list.blockedUsers': 'Заблокированные пользователи',
        // New Alerts
        'alert.cameraNotSupported': 'Доступ к камере не поддерживается в этом браузере. Используйте современный браузер: Chrome, Firefox или Safari.', 'alert.noCameraFound': 'Камера не найдена. Подключите камеру или используйте загрузку файла.', 'alert.cameraAccessDenied': 'Доступ к камере запрещён. Разрешите камеру в настройках браузера.', 'alert.cameraInUse': 'Камера используется другим приложением. Закройте другие приложения.', 'alert.cameraUnableAccess': 'Не удаётся получить доступ к камере. Используйте загрузку файла.', 'alert.cameraUnableAccessWithError': 'Не удаётся получить доступ к камере: {error}\n\nИспользуйте загрузку файла.', 'alert.fillRequiredFields': 'Заполните все обязательные поля', 'alert.uploadThumbnail': 'Загрузите миниатюру для трансляции', 'alert.failedCreateStream': 'Не удалось создать трансляцию. Попробуйте снова.', 'alert.failedUpdateStream': 'Не удалось обновить. Попробуйте снова.', 'alert.streamNotFound': 'Трансляция не найдена', 'alert.canOnlyEditOwnStreams': 'Вы можете редактировать только свои трансляции', 'alert.invalidStreamData': 'Неверные данные трансляции', 'alert.enterValidGoalAmount': 'Введите правильную сумму цели', 'alert.canOnlyResetOwnGoals': 'Вы можете сбрасывать только свои цели', 'alert.streamEventNotFound': 'Событие трансляции не найдено', 'alert.failedResetZapGoal': 'Не удалось сбросить цель zap. Попробуйте снова.', 'alert.cannotBlockAdmin': 'Нельзя заблокировать админа', 'alert.analyticsLoadFailed': 'Не удалось загрузить статистику. Попробуйте снова.', 'alert.cannotReplaceShortWithVideo': 'Нельзя заменить Short обычным видео. Загрузите вертикальное видео (60 секунд или меньше).', 'alert.cannotReplaceVideoWithShort': 'Нельзя заменить видео на Short. Загрузите горизонтальное видео.', 'alert.shortsRequireVertical': 'Это видео горизонтальное. Shorts должны быть вертикальными. Используйте "Загрузить видео" для горизонтальных.',
        // New Zap Messages
        'zap.cannotZapYourself': 'Нельзя отправить zap себе', 'zap.cannotZapOwnContent': 'Нельзя отправить zap своему контенту', 'zap.cannotZapOwnComment': 'Нельзя отправить zap своему комментарию', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'Загрузка видео...', 'status.loading': 'Загрузка...', 'status.compressingProgress': 'Сжатие... {progress}%', 'status.uploadingProgress': 'Загрузка... {progress}%', 'status.uploadingServers': 'Загрузка... ({completed}/{total} серверов)', 'status.publishedSuccess': '{type} успешно опубликовано!',
        // New Warnings
        'warning.webmFormat': 'Примечание: Ваш браузер выводит формат WebM (может не работать на iOS). Для iOS используйте Chrome на Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Обновлено: Декабрь 2024',
    },
    zh: {
        // Navigation & Header
        'nav.home': '首页', 'nav.following': '关注', 'nav.myVideos': '我的视频', 'nav.liked': '已赞', 'nav.history': '历史记录', 'nav.topics': '话题', 'nav.live': '直播', 'nav.bitcoin': '比特币', 'nav.nostr': 'Nostr', 'nav.technology': '科技', 'nav.gaming': '游戏', 'nav.tutorials': '教程', 'nav.podcasts': '播客', 'nav.music': '音乐', 'nav.nsfw': 'NSFW', 'nav.about': '关于', 'nav.contact': '联系', 'nav.terms': '条款', 'nav.privacy': '隐私', 'nav.faq': '常见问题', 'nav.dmca': 'DMCA', 'nav.liveStreams': '直播', 'nav.github': 'GitHub',
        'header.search': '搜索视频...', 'header.notifications': '通知', 'header.settings': '设置', 'header.create': '创建', 'header.viewProfile': '查看主页', 'header.logout': '登出',
        // Login Modal
        'login.title': '使用 Nostr 登录', 'login.extensionButton': '使用 Nostr 扩展登录', 'login.extensionDesc': '使用签名扩展 (Alby, nos2x 等)', 'login.orDivider': '或', 'login.nsecLabel': '使用私钥登录 (nsec)', 'login.nsecPlaceholder': '输入您的 nsec...', 'login.nsecButton': '使用 nsec 登录', 'login.nsecWarning': '警告：直接输入 nsec 不如使用扩展安全。请考虑使用 NIP-07 扩展以获得更好的安全性。', 'login.newToNostr': 'Nostr 新手？', 'login.createAccount': '创建账户', 'login.learnMore': '了解更多关于 Nostr',
        // Connect Modal
        'connect.title': '连接到 Nostr', 'connect.or': '或', 'connect.extensionButton': '连接 Nostr 扩展', 'connect.extensionDesc': '使用扩展 (Alby, nos2x 等)', 'connect.nsecLabel': '使用私钥登录', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': '使用 nsec 连接', 'connect.nsecWarning': '警告：直接输入 nsec 安全性较低。请使用 NIP-07 扩展以获得更好的安全性。', 'connect.newToNostr': 'Nostr 新手？', 'connect.createAccount': '创建账户',
        // Private Key Modal
        'privateKey.title': '您的私钥', 'privateKey.warning': '重要：请将此保存在安全的地方。如果您丢失此密钥，您将失去对账户的访问权限。切勿与任何人分享！', 'privateKey.show': '显示私钥', 'privateKey.hide': '隐藏私钥', 'privateKey.copy': '复制', 'privateKey.saved': '我已保存我的密钥', 'privateKey.yourPublicKey': '您的公钥 (npub)：', 'privateKey.yourPrivateKey': '您的私钥 (nsec)：',
        // Signup Modal
        'signup.title': '创建 Nostr 账户', 'signup.whatIsNostr': '什么是 Nostr？', 'signup.nostrDescription': 'Nostr 是一个去中心化协议，让您掌控自己的身份和数据。没有中央服务器 - 您的账户就是一对加密密钥。', 'signup.whyNostr': '为什么选择 Nostr？', 'signup.benefit1': '掌控您的身份', 'signup.benefit2': '无审查', 'signup.benefit3': '跨平台可移植', 'signup.createNew': '创建新账户', 'signup.haveAccount': '已有账户？', 'signup.login': '登录', 'signup.createButton': '创建账户', 'signup.generating': '正在生成密钥...', 'signup.displayName': '显示名称', 'signup.displayNamePlaceholder': '输入显示名称', 'signup.username': '用户名', 'signup.usernamePlaceholder': '输入用户名',
        // Notifications
        'notifications.title': '通知', 'notifications.empty': '暂无通知', 'notifications.viewAll': '查看全部通知', 'notifications.markAllRead': '全部标记为已读', 'notifications.settings': '通知设置', 'notifications.loading': '加载通知中...', 'notifications.zap': '给您发送了打赏', 'notifications.like': '喜欢了您的内容', 'notifications.comment': '评论了', 'notifications.follow': '关注了您', 'notifications.repost': '转发了', 'notifications.mention': '提到了您',
        // Settings Modal
        'settings.title': '设置', 'settings.language': '语言', 'settings.languageDesc': '选择您的语言', 'settings.saveToNostr': '保存到 Nostr', 'settings.darkMode': '深色模式', 'settings.darkModeDesc': '切换深色/浅色主题', 'settings.autoplay': '自动播放', 'settings.autoplayDesc': '自动播放视频', 'settings.saveSettings': '保存设置', 'settings.resetDefaults': '重置默认', 'settings.notifications': '通知', 'settings.notificationsDesc': '接收推送通知', 'settings.quality': '默认质量', 'settings.qualityDesc': '视频播放质量',
        // Upload Modal
        'upload.title': '上传视频', 'upload.dragDrop': '拖放视频文件到此处', 'upload.or': '或', 'upload.browse': '浏览文件', 'upload.supportedFormats': '支持格式：MP4、WebM、MOV', 'upload.maxSize': '最大文件大小：2GB', 'upload.videoTitle': '标题', 'upload.titlePlaceholder': '输入视频标题', 'upload.description': '描述', 'upload.descriptionPlaceholder': '描述您的视频...', 'upload.tags': '标签', 'upload.tagsPlaceholder': '添加标签，用逗号分隔', 'upload.visibility': '可见性', 'upload.public': '公开', 'upload.unlisted': '不公开', 'upload.uploadButton': '上传视频', 'upload.uploading': '上传中...', 'upload.processing': '处理中...', 'upload.complete': '完成！', 'upload.error': '上传失败', 'upload.nsfw': 'NSFW 内容', 'upload.nsfwDesc': '标记为成人内容', 'upload.thumbnail': '缩略图', 'upload.thumbnailDesc': '上传视频缩略图', 'upload.preparing': '准备中...', 'upload.cancel': '取消', 'upload.progress': '上传进度', 'upload.transcoding': '转码中', 'upload.status.preparing': '准备上传...', 'upload.status.uploading': '上传视频中...', 'upload.status.transcoding': '转码视频中...', 'upload.status.complete': '上传完成！', 'upload.qualityHigh': '高', 'upload.qualityMedium': '中', 'upload.qualityLow': '低',
        // Create Modal
        'create.title': '创建', 'create.uploadVideo': '上传视频', 'create.uploadDesc': '分享视频', 'create.goLive': '开始直播', 'create.goLiveDesc': '开始直播', 'create.createPost': '创建帖子', 'create.createPostDesc': '分享文字帖子',
        // Go Live Modal
        'goLive.title': '开始直播', 'goLive.streamTitle': '直播标题', 'goLive.streamTitlePlaceholder': '输入直播标题', 'goLive.description': '描述', 'goLive.descriptionPlaceholder': '描述您的直播...', 'goLive.category': '分类', 'goLive.selectCategory': '选择分类', 'goLive.tags': '标签', 'goLive.tagsPlaceholder': '添加标签，用逗号分隔', 'goLive.startStream': '开始直播', 'goLive.streamKey': '直播密钥', 'goLive.streamUrl': '直播 URL', 'goLive.copy': '复制', 'goLive.hideKey': '隐藏密钥', 'goLive.showKey': '显示密钥', 'goLive.connecting': '连接中...', 'goLive.live': '直播中', 'goLive.offline': '离线', 'goLive.viewers': '观众', 'goLive.endStream': '结束直播', 'goLive.nsfw': 'NSFW 内容', 'goLive.nsfwDesc': '标记为成人内容', 'goLive.thumbnail': '直播缩略图', 'goLive.thumbnailDesc': '上传缩略图',
        // Edit Stream Modal
        'editStream.title': '编辑直播', 'editStream.save': '保存更改',
        // NSFW Warning Modal
        'nsfw.title': '成人内容警告', 'nsfw.warning': '此内容已被标记为 NSFW（工作场所不宜），可能包含成人内容。', 'nsfw.confirm': '确认您的年龄', 'nsfw.confirmAge': '我已年满 18 岁', 'nsfw.cancel': '返回', 'nsfw.continue': '继续', 'nsfw.dontShowAgain': '不再显示此警告',
        // Community Warning Modal
        'community.title': '社区准则', 'community.warning': '继续前请查看我们的社区准则。', 'community.guidelines': '请尊重他人并遵循社区标准。', 'community.accept': '接受', 'community.decline': '拒绝',
        // Report Modal
        'report.title': '举报内容', 'report.reason': '举报原因', 'report.selectReason': '选择原因', 'report.spam': '垃圾信息或误导', 'report.inappropriate': '不当内容', 'report.violence': '暴力或危险内容', 'report.copyright': '版权侵犯', 'report.other': '其他', 'report.details': '详细信息', 'report.detailsPlaceholder': '提供更多详情...', 'report.submit': '提交举报', 'report.cancel': '取消',
        // Share Modal
        'share.title': '分享', 'share.copyLink': '复制链接', 'share.embed': '嵌入代码', 'share.copyEmbed': '复制嵌入代码', 'share.social': '分享到社交媒体', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': '邮件', 'share.copied': '已复制！', 'share.nostr': '分享到 Nostr', 'share.generateImage': '生成图片', 'share.downloadImage': '下载', 'share.shareImage': '分享', 'share.size1280x720': '1280 × 720 (高清)', 'share.size1080x1080': '1080 × 1080 (方形)', 'share.size1080x1920': '1080 × 1920 (故事)',
        // Edit Video Modal
        'editVideo.title': '编辑视频', 'editVideo.videoTitle': '标题', 'editVideo.description': '描述', 'editVideo.tags': '标签', 'editVideo.thumbnail': '缩略图', 'editVideo.changeThumbnail': '更改缩略图', 'editVideo.visibility': '可见性', 'editVideo.nsfw': 'NSFW 内容', 'editVideo.save': '保存更改', 'editVideo.delete': '删除视频', 'editVideo.confirmDelete': '确定要删除此视频吗？',
        // Edit Profile Modal
        'editProfile.title': '编辑个人资料', 'editProfile.displayName': '显示名称', 'editProfile.displayNamePlaceholder': '输入显示名称', 'editProfile.username': '用户名', 'editProfile.usernamePlaceholder': '输入用户名', 'editProfile.about': '简介', 'editProfile.aboutPlaceholder': '介绍一下自己...', 'editProfile.website': '网站', 'editProfile.websitePlaceholder': 'https://yourwebsite.com', 'editProfile.lightning': '闪电地址', 'editProfile.lightningPlaceholder': 'you@getalby.com', 'editProfile.nip05': 'NIP-05 验证', 'editProfile.nip05Placeholder': 'you@domain.com', 'editProfile.avatar': '头像', 'editProfile.changeAvatar': '更改头像', 'editProfile.banner': '横幅', 'editProfile.changeBanner': '更改横幅', 'editProfile.save': '保存个人资料',
        // Confirmation Modal
        'confirm.title': '确认操作', 'confirm.message': '确定要继续吗？', 'confirm.confirm': '确认', 'confirm.cancel': '取消',
        // Video Page
        'video.views': '次观看', 'video.like': '点赞', 'video.dislike': '踩', 'video.share': '分享', 'video.save': '保存', 'video.report': '举报', 'video.follow': '关注', 'video.unfollow': '取消关注', 'video.subscribe': '订阅', 'video.subscribed': '已订阅', 'video.comments': '评论', 'video.addComment': '添加评论...', 'video.reply': '回复', 'video.replies': '条回复', 'video.loadMore': '加载更多', 'video.noComments': '暂无评论。成为第一个评论的人！', 'video.zap': '打赏', 'video.zapAmount': '打赏金额 (聪)', 'video.sendZap': '发送打赏', 'video.boost': '推广', 'video.description': '描述', 'video.showMore': '展开', 'video.showLess': '收起', 'video.publishedOn': '发布于',
        // Toast Messages
        'toast.loggedIn': '登录成功！', 'toast.loggedOut': '已登出', 'toast.settingsSaved': '设置已保存！', 'toast.settingsReset': '设置已重置', 'toast.videoUploaded': '视频已上传！', 'toast.videoDeleted': '视频已删除', 'toast.profileUpdated': '个人资料已更新！', 'toast.linkCopied': '链接已复制！', 'toast.embedCopied': '嵌入代码已复制！', 'toast.zapSent': '打赏已发送！', 'toast.followed': '已关注！', 'toast.unfollowed': '已取消关注', 'toast.reported': '举报已提交', 'toast.saved': '已保存！', 'toast.error': '发生错误', 'toast.networkError': '网络错误。请重试。', 'toast.uploadError': '上传失败。请重试。', 'toast.languageChanged': '语言已更改', 'toast.commentPosted': '评论已发布', 'toast.keyCopied': '密钥已复制！',
        // Time
        'time.now': '刚刚', 'time.minutesAgo': '{count} 分钟前', 'time.hoursAgo': '{count} 小时前', 'time.daysAgo': '{count} 天前', 'time.weeksAgo': '{count} 周前', 'time.monthsAgo': '{count} 个月前', 'time.yearsAgo': '{count} 年前',
        // Empty States
        'empty.noVideos': '没有找到视频', 'empty.noVideosDesc': '尝试其他搜索词', 'empty.noFollowing': '您还没有关注任何人', 'empty.noFollowingDesc': '关注创作者以查看他们的视频', 'empty.noHistory': '没有观看历史', 'empty.noHistoryDesc': '您观看的视频将显示在这里', 'empty.noLiked': '还没有喜欢的视频', 'empty.noLikedDesc': '喜欢视频后将显示在这里', 'empty.noResults': '没有找到结果', 'empty.noResultsDesc': '尝试其他关键词',
        // Misc
        'misc.loading': '加载中...', 'misc.loadingMore': '加载更多...', 'misc.refresh': '刷新', 'misc.retry': '重试', 'misc.close': '关闭', 'misc.back': '返回', 'misc.next': '下一步', 'misc.previous': '上一步', 'misc.search': '搜索', 'misc.filter': '筛选', 'misc.sort': '排序', 'misc.newest': '最新', 'misc.oldest': '最早', 'misc.popular': '热门', 'misc.trending': '趋势', 'misc.sats': '聪', 'misc.all': '全部', 'misc.copiedToClipboard': '已复制到剪贴板！',
        // Common
        'common.submit': '提交', 'common.cancel': '取消', 'common.save': '保存', 'common.delete': '删除', 'common.edit': '编辑', 'common.close': '关闭', 'common.confirm': '确认', 'common.yes': '是', 'common.no': '否', 'common.ok': '确定', 'common.loading': '加载中...', 'common.uploading': '上传中...', 'common.error': '错误', 'common.success': '成功',
        // Aria Labels
        'aria.toggleMenu': '切换菜单', 'aria.mainNavigation': '主导航', 'aria.videoContent': '视频内容', 'aria.loadingContent': '加载内容中', 'aria.closeModal': '关闭弹窗', 'aria.playVideo': '播放视频', 'aria.pauseVideo': '暂停视频', 'aria.muteVideo': '静音', 'aria.unmuteVideo': '取消静音', 'aria.fullscreen': '全屏', 'aria.exitFullscreen': '退出全屏', 'aria.settings': '设置', 'aria.notifications': '通知', 'aria.userMenu': '用户菜单', 'aria.searchInput': '搜索视频', 'aria.videoPlayer': '视频播放器',
        // Dynamic JavaScript text
        'button.hideQR': '隐藏二维码', 'button.showQR': '显示二维码', 'button.copied': '已复制！', 'button.showLess': '显示更少', 'button.showMore': '显示更多', 'button.creatingAccount': '创建账户中...', 'button.submitting': '提交中...', 'button.scheduleStream': '计划直播', 'button.goLive': '开始直播', 'button.creatingStream': '创建直播中...', 'button.continueCustomAmount': '使用自定义金额继续', 'button.recordFromCamera': '从摄像头录制', 'button.requestingCamera': '请求摄像头...', 'button.recording': '录制中...',
        'status.saving': '保存中...', 'status.saved': '已保存！', 'status.uploading': '上传中...', 'status.uploadComplete': '上传完成！', 'status.uploadingToNostrBuild': '上传到nostr.build...', 'status.publishingChanges': '发布更改...', 'status.removingOldVersion': '删除旧版本...', 'status.validatingThumbnail': '验证缩略图...', 'status.uploadingThumbnail': '上传缩略图...', 'status.thumbnailUploaded': '缩略图已上传！', 'status.processingVideo': '处理视频中...', 'status.compressingVideo': '压缩视频中...', 'status.uploadingVideo': '上传视频中...', 'status.videoUploaded': '视频上传成功！', 'status.processing': '处理中...', 'status.generatingThumbnail': '生成缩略图...', 'status.generatingPreview': '生成预览...', 'status.uploadingPreview': '上传预览...', 'status.publishing': '发布中...', 'status.publishingToNostr': '发布到Nostr...', 'status.publishingVideoToNostr': '发布视频到Nostr...', 'status.generatingPoW': '生成工作量证明...', 'status.posting': '发布中...', 'status.processingVideoAndThumbnail': '处理视频和缩略图...', 'status.uploadFailed': '上传失败 - 请重试', 'status.selectVideoToUpload': '选择要上传的视频', 'status.waitingForVideoUpload': '等待视频上传...', 'status.selectVideoAndThumbnail': '选择视频和缩略图进行发布', 'status.ready': '准备就绪 ✓', 'status.failed': '失败 ✗', 'status.fromDraft': '来自草稿', 'status.startingNow': '即将开始！', 'status.ended': '已结束', 'status.thumbnailReady': '就绪', 'status.thumbnailFailed': '失败', 'status.uploadFailedRetry': '上传失败，请重试。',
        'publish.video': '发布视频', 'publish.autoThumbnail': '发布视频（自动缩略图）',
        'report.titleComment': '举报评论', 'report.titleUser': '举报用户', 'report.titleVideo': '举报视频', 'report.descComment': '选择举报此评论的原因：', 'report.descUser': '选择举报此用户的原因：', 'report.descVideo': '选择举报此内容的原因：',
        'empty.noMutedUsers': '没有屏蔽的用户。', 'empty.noVideosToMonitor': '没有要监控的视频。', 'empty.noRecentActivity': '没有最近活动。', 'empty.failedLoadNotifications': '加载通知失败', 'empty.loginToViewLiked': '请<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">登录</a>查看您喜欢的视频。', 'empty.loginToViewFollowing': '请<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">登录</a>查看您的关注。', 'empty.loginToViewVideos': '请<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">登录</a>查看您的视频。', 'empty.loginToViewAnalytics': '请<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">登录</a>查看您的统计数据。', 'empty.noLikedVideosYet': '您还没有喜欢任何视频。', 'empty.noLikedVideosFound': '未找到喜欢的视频。', 'empty.noFullLengthLikedVideos': '未找到喜欢的长视频。', 'empty.noWatchHistory': '没有观看历史。开始观看视频吧。', 'empty.noVideosInHistory': '历史记录中没有视频。', 'empty.noFullLengthHistory': '历史记录中没有长视频。', 'empty.noMatchingVideos': '未找到匹配的视频。', 'empty.noFullLengthVideos': '未找到长视频。', 'empty.failedLoadTrending': '加载热门视频失败。', 'empty.noTrendingVideos': '未找到热门视频。', 'empty.noMatchingUsers': '未找到匹配的用户。', 'empty.unableLoadProfiles': '无法加载用户资料。', 'empty.noFollowingVideos': '您关注的用户还没有视频。', 'empty.noFullLengthFollowing': '关注用户没有长视频。', 'empty.failedLoadFollowing': '加载失败，请重试。', 'empty.noVideosUploadFirst': '没有视频。上传您的第一个视频！', 'empty.noFullLengthUploaded': '未找到长视频。', 'empty.noMatchingLiveStreams': '未找到匹配的直播。', 'empty.noMatchingShorts': '未找到匹配的短视频。', 'empty.noVideosForTag': '此标签没有视频。', 'empty.noFullLengthForTag': '此标签没有长视频。', 'empty.noUploadedVideos': '还没有上传视频。', 'empty.noVideosFound': '未找到视频。', 'empty.failedLoadProfile': '加载个人资料失败，请重试。', 'empty.noComments': '还没有评论，成为第一个！', 'empty.failedLoadComments': '加载评论失败', 'empty.noLiveNow': '现在没有人在直播，成为第一个！',
        'error.videoNotFound': '视频未找到。', 'error.contentNotAvailable': '此内容不可用。', 'error.invalidVideoData': '视频数据无效。', 'error.videoNotAvailable': '视频不可用，文件可能已被删除。', 'error.failedLoadVideo': '加载视频失败，请重试。', 'error.failedLoadVideoShort': '加载失败，文件可能已被删除。', 'error.liveStreamNotFound': '直播未找到。', 'error.invalidLiveStreamData': '直播数据无效。', 'error.failedLoadLiveStream': '加载直播失败。',
        // New Button & Action Labels
        'button.follow': '关注', 'button.unfollow': '取消关注', 'button.mute': '静音', 'button.unmute': '取消静音', 'button.muteUser': '屏蔽用户', 'button.unmuteUser': '取消屏蔽', 'button.confirm': '确认', 'button.cancel': '取消', 'button.close': '关闭', 'button.boost': '推广', 'button.zap': 'Zap', 'button.viewMore': '查看更多', 'button.viewAnalytics': '查看统计', 'button.backToMyVideos': '返回我的视频', 'button.editDraft': '编辑草稿', 'button.deleteDraft': '删除草稿', 'button.editVideo': '编辑视频', 'button.deleteVideo': '删除视频', 'button.editShort': '编辑短视频', 'button.deleteShort': '删除短视频', 'button.editStream': '编辑直播', 'button.endStream': '结束直播', 'button.reset': '重置', 'button.download': '下载', 'button.watchRecording': '观看录像', 'button.show': '显示', 'button.login': '登录', 'button.toggleChat': '切换聊天', 'button.blockVideo': '屏蔽视频', 'button.blockUser': '屏蔽用户', 'button.unblock': '解除屏蔽', 'button.removeFromHistory': '从历史记录中删除',
        // New Stats & Counts
        'stat.views': '次观看', 'stat.viewsCount': '{count} 次观看', 'stat.videos': '个视频', 'stat.video': '个视频', 'stat.followers': '位粉丝', 'stat.follower': '位粉丝', 'stat.following': '关注中', 'stat.subscribers': '位订阅者', 'stat.comments': '评论', 'stat.liveCount': '{count} 直播中', 'stat.percentOfGoal': '目标的{percent}%', 'stat.netGrowth': '净增长', 'stat.newFollowers': '新粉丝', 'stat.unfollowed': '取消关注', 'stat.lastUpdated': '最后更新: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': '直播中', 'badge.ended': '已结束', 'badge.scheduled': '已预定', 'badge.warning': '警告', 'badge.communityWarning': '社区警告', 'badge.verifiedNip05': 'NIP-05 已验证', 'badge.streamer': '主播', 'badge.clickToView': '点击查看',
        // New Actions
        'action.report': '举报', 'action.reportComment': '举报评论', 'action.reportVideo': '举报此视频', 'action.reportStream': '举报此直播', 'action.like': '喜欢', 'action.dislike': '不喜欢', 'action.reply': '回复',
        // New Placeholders
        'placeholder.searchHistory': '搜索历史...', 'placeholder.searchUsers': '搜索用户...', 'placeholder.searchMyVideos': '搜索我的视频...', 'placeholder.eventId': '输入事件ID (hex或nevent/note)', 'placeholder.pubkey': '输入pubkey (hex或npub)', 'placeholder.customAmount': '自定义金额', 'placeholder.chatEnded': '聊天已关闭 - 直播已结束', 'placeholder.addComment': '添加评论...', 'placeholder.setNewGoal': '设置新目标 (sats)',
        // New Video & Content
        'video.untitledVideo': '无标题视频', 'video.untitledShort': '无标题短视频', 'video.upNext': '接下来', 'video.noVideosYet': '暂无视频', 'video.noShortsYet': '暂无短视频', 'video.noLiveStreamsYet': '暂无直播', 'video.noBlockedVideos': '无屏蔽视频', 'video.noBlockedUsers': '无屏蔽用户',
        // New Stream Messages
        'stream.ended': '直播已结束。聊天已关闭。', 'stream.welcomeChat': '欢迎来到直播聊天！', 'stream.goalReached': '目标达成！', 'stream.zapGoalReached': 'Zap目标达成！{amount} sats！',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': '来自已静音用户的消息', 'muted.commentFromMutedUserHidden': '已静音用户的评论已隐藏', 'muted.commentHidden': '评论已隐藏 ({packs})', 'muted.messageHidden': '消息已隐藏 ({packs})', 'muted.commentReportedByFollows': '您关注的人举报了此评论', 'muted.messageReportedByFollows': '您关注的人举报了此消息', 'muted.commentHeavilyDownvoted': '评论被社区大量踩', 'muted.messageHeavilyDownvoted': '消息被大量踩',
        // New Admin & Lists
        'list.blockedVideos': '屏蔽的视频', 'list.blockedUsers': '屏蔽的用户',
        // New Alerts
        'alert.cameraNotSupported': '此浏览器不支持摄像头访问。请使用Chrome、Firefox或Safari等现代浏览器。', 'alert.noCameraFound': '未找到摄像头。请连接摄像头或使用文件上传选项。', 'alert.cameraAccessDenied': '摄像头访问被拒绝。请在浏览器设置中允许摄像头权限。', 'alert.cameraInUse': '摄像头正被其他应用程序使用。请关闭其他使用摄像头的应用。', 'alert.cameraUnableAccess': '无法访问摄像头。请尝试使用上传选项。', 'alert.cameraUnableAccessWithError': '无法访问摄像头: {error}\n\n请使用上传选项。', 'alert.fillRequiredFields': '请填写所有必填字段', 'alert.uploadThumbnail': '请上传直播缩略图', 'alert.failedCreateStream': '创建直播失败。请重试。', 'alert.failedUpdateStream': '更新失败。请重试。', 'alert.streamNotFound': '未找到直播', 'alert.canOnlyEditOwnStreams': '您只能编辑自己的直播', 'alert.invalidStreamData': '直播数据无效', 'alert.enterValidGoalAmount': '请输入有效的目标金额', 'alert.canOnlyResetOwnGoals': '您只能重置自己的目标', 'alert.streamEventNotFound': '未找到直播事件', 'alert.failedResetZapGoal': '重置zap目标失败。请重试。', 'alert.cannotBlockAdmin': '无法屏蔽管理员账户', 'alert.analyticsLoadFailed': '加载统计失败。请重试。', 'alert.cannotReplaceShortWithVideo': '无法用普通视频替换短视频。请上传竖版视频（60秒或更短）。', 'alert.cannotReplaceVideoWithShort': '无法用短视频替换普通视频。请上传横版视频。', 'alert.shortsRequireVertical': '此视频为横版。短视频必须是竖版视频。请使用"上传视频"上传横版视频。',
        // New Zap Messages
        'zap.cannotZapYourself': '不能给自己发Zap', 'zap.cannotZapOwnContent': '不能给自己的内容发Zap', 'zap.cannotZapOwnComment': '不能给自己的评论发Zap', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': '加载视频中...', 'status.loading': '加载中...', 'status.compressingProgress': '压缩中... {progress}%', 'status.uploadingProgress': '上传中... {progress}%', 'status.uploadingServers': '上传中... ({completed}/{total} 服务器)', 'status.publishedSuccess': '{type} 发布成功！',
        // New Warnings
        'warning.webmFormat': '注意：您的浏览器将输出WebM格式（可能无法在iOS上播放）。如需iOS兼容的MP4，请在Windows/Mac上使用Chrome。',
        // New Footer
        'footer.lastUpdated': '最后更新: 2024年12月',
    },
    ja: {
        // Navigation & Header
        'nav.home': 'ホーム', 'nav.following': 'フォロー中', 'nav.myVideos': 'マイ動画', 'nav.liked': 'いいね', 'nav.history': '履歴', 'nav.topics': 'トピック', 'nav.live': 'ライブ', 'nav.bitcoin': 'ビットコイン', 'nav.nostr': 'Nostr', 'nav.technology': 'テクノロジー', 'nav.gaming': 'ゲーム', 'nav.tutorials': 'チュートリアル', 'nav.podcasts': 'ポッドキャスト', 'nav.music': '音楽', 'nav.nsfw': 'NSFW', 'nav.about': '概要', 'nav.contact': 'お問い合わせ', 'nav.terms': '利用規約', 'nav.privacy': 'プライバシー', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': 'ライブ配信', 'nav.github': 'GitHub',
        'header.search': '動画を検索...', 'header.notifications': '通知', 'header.settings': '設定', 'header.create': '作成', 'header.viewProfile': 'プロフィール', 'header.logout': 'ログアウト',
        // Login Modal
        'login.title': 'Nostrでログイン', 'login.extensionButton': 'Nostr拡張機能でログイン', 'login.extensionDesc': '署名拡張機能を使用 (Alby, nos2x など)', 'login.orDivider': 'または', 'login.nsecLabel': '秘密鍵でログイン (nsec)', 'login.nsecPlaceholder': 'nsecを入力...', 'login.nsecButton': 'nsecでログイン', 'login.nsecWarning': '警告：nsecの直接入力は拡張機能を使用するより安全性が低くなります。より良いセキュリティのためにNIP-07拡張機能をご検討ください。', 'login.newToNostr': 'Nostrが初めてですか？', 'login.createAccount': 'アカウント作成', 'login.learnMore': 'Nostrについて詳しく',
        // Connect Modal
        'connect.title': 'Nostrに接続', 'connect.or': 'または', 'connect.extensionButton': 'Nostr拡張機能を接続', 'connect.extensionDesc': '拡張機能を使用 (Alby, nos2x など)', 'connect.nsecLabel': '秘密鍵でログイン', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'nsecで接続', 'connect.nsecWarning': '警告：nsecの直接入力は安全性が低くなります。より良いセキュリティのためにNIP-07拡張機能をご使用ください。', 'connect.newToNostr': 'Nostrが初めてですか？', 'connect.createAccount': 'アカウント作成',
        // Private Key Modal
        'privateKey.title': 'あなたの秘密鍵', 'privateKey.warning': '重要：これを安全な場所に保存してください。この鍵を紛失すると、アカウントにアクセスできなくなります。絶対に誰にも共有しないでください！', 'privateKey.show': '秘密鍵を表示', 'privateKey.hide': '秘密鍵を隠す', 'privateKey.copy': 'コピー', 'privateKey.saved': '鍵を保存しました', 'privateKey.yourPublicKey': 'あなたの公開鍵 (npub):', 'privateKey.yourPrivateKey': 'あなたの秘密鍵 (nsec):',
        // Signup Modal
        'signup.title': 'Nostrアカウント作成', 'signup.whatIsNostr': 'Nostrとは？', 'signup.nostrDescription': 'Nostrは分散型プロトコルで、あなた自身のアイデンティティとデータを管理できます。中央サーバーはなく、アカウントは暗号鍵ペアです。', 'signup.whyNostr': 'なぜNostr？', 'signup.benefit1': 'アイデンティティの所有', 'signup.benefit2': '検閲なし', 'signup.benefit3': 'プラットフォーム間で移植可能', 'signup.createNew': '新規アカウント作成', 'signup.haveAccount': 'アカウントをお持ちですか？', 'signup.login': 'ログイン', 'signup.createButton': 'アカウント作成', 'signup.generating': '鍵を生成中...', 'signup.displayName': '表示名', 'signup.displayNamePlaceholder': '表示名を入力', 'signup.username': 'ユーザー名', 'signup.usernamePlaceholder': 'ユーザー名を入力',
        // Notifications
        'notifications.title': '通知', 'notifications.empty': '通知はありません', 'notifications.viewAll': 'すべての通知を見る', 'notifications.markAllRead': 'すべて既読にする', 'notifications.settings': '通知設定', 'notifications.loading': '通知を読み込み中...', 'notifications.zap': 'Zapを送りました', 'notifications.like': 'いいねしました', 'notifications.comment': 'コメントしました', 'notifications.follow': 'フォローしました', 'notifications.repost': 'リポストしました', 'notifications.mention': 'メンションしました',
        // Settings Modal
        'settings.title': '設定', 'settings.language': '言語', 'settings.languageDesc': '言語を選択', 'settings.saveToNostr': 'Nostrに保存', 'settings.darkMode': 'ダークモード', 'settings.darkModeDesc': 'ダーク/ライトテーマを切り替え', 'settings.autoplay': '自動再生', 'settings.autoplayDesc': '動画を自動再生', 'settings.saveSettings': '設定を保存', 'settings.resetDefaults': 'リセット', 'settings.notifications': '通知', 'settings.notificationsDesc': 'プッシュ通知を受け取る', 'settings.quality': 'デフォルト画質', 'settings.qualityDesc': '動画再生の画質',
        // Upload Modal
        'upload.title': '動画をアップロード', 'upload.dragDrop': 'ここに動画ファイルをドロップ', 'upload.or': 'または', 'upload.browse': 'ファイルを選択', 'upload.supportedFormats': '対応形式: MP4, WebM, MOV', 'upload.maxSize': '最大ファイルサイズ: 2GB', 'upload.videoTitle': 'タイトル', 'upload.titlePlaceholder': '動画タイトルを入力', 'upload.description': '説明', 'upload.descriptionPlaceholder': '動画の説明...', 'upload.tags': 'タグ', 'upload.tagsPlaceholder': 'カンマ区切りでタグを追加', 'upload.visibility': '公開設定', 'upload.public': '公開', 'upload.unlisted': '限定公開', 'upload.uploadButton': '動画をアップロード', 'upload.uploading': 'アップロード中...', 'upload.processing': '処理中...', 'upload.complete': '完了！', 'upload.error': 'アップロード失敗', 'upload.nsfw': 'NSFWコンテンツ', 'upload.nsfwDesc': 'アダルトコンテンツとしてマーク', 'upload.thumbnail': 'サムネイル', 'upload.thumbnailDesc': 'サムネイルをアップロード', 'upload.preparing': '準備中...', 'upload.cancel': 'キャンセル', 'upload.progress': 'アップロード進捗', 'upload.transcoding': 'トランスコード中', 'upload.status.preparing': 'アップロード準備中...', 'upload.status.uploading': '動画をアップロード中...', 'upload.status.transcoding': '動画をトランスコード中...', 'upload.status.complete': 'アップロード完了！', 'upload.qualityHigh': '高', 'upload.qualityMedium': '中', 'upload.qualityLow': '低',
        // Create Modal
        'create.title': '作成', 'create.uploadVideo': '動画をアップロード', 'create.uploadDesc': '動画を共有', 'create.goLive': 'ライブ配信', 'create.goLiveDesc': 'ライブ配信を開始', 'create.createPost': '投稿を作成', 'create.createPostDesc': 'テキスト投稿を共有',
        // Go Live Modal
        'goLive.title': 'ライブ配信', 'goLive.streamTitle': '配信タイトル', 'goLive.streamTitlePlaceholder': '配信タイトルを入力', 'goLive.description': '説明', 'goLive.descriptionPlaceholder': '配信の説明...', 'goLive.category': 'カテゴリ', 'goLive.selectCategory': 'カテゴリを選択', 'goLive.tags': 'タグ', 'goLive.tagsPlaceholder': 'カンマ区切りでタグを追加', 'goLive.startStream': '配信開始', 'goLive.streamKey': 'ストリームキー', 'goLive.streamUrl': 'ストリームURL', 'goLive.copy': 'コピー', 'goLive.hideKey': 'キーを隠す', 'goLive.showKey': 'キーを表示', 'goLive.connecting': '接続中...', 'goLive.live': 'ライブ中', 'goLive.offline': 'オフライン', 'goLive.viewers': '視聴者', 'goLive.endStream': '配信終了', 'goLive.nsfw': 'NSFWコンテンツ', 'goLive.nsfwDesc': 'アダルトコンテンツとしてマーク', 'goLive.thumbnail': '配信サムネイル', 'goLive.thumbnailDesc': 'サムネイルをアップロード',
        // Edit Stream Modal
        'editStream.title': '配信を編集', 'editStream.save': '変更を保存',
        // NSFW Warning Modal
        'nsfw.title': 'アダルトコンテンツの警告', 'nsfw.warning': 'このコンテンツはNSFW（職場閲覧注意）としてマークされており、アダルトコンテンツを含む可能性があります。', 'nsfw.confirm': '年齢を確認', 'nsfw.confirmAge': '18歳以上です', 'nsfw.cancel': '戻る', 'nsfw.continue': '続行', 'nsfw.dontShowAgain': 'この警告を表示しない',
        // Community Warning Modal
        'community.title': 'コミュニティガイドライン', 'community.warning': '続行する前にコミュニティガイドラインをご確認ください。', 'community.guidelines': '他者を尊重し、コミュニティ基準に従ってください。', 'community.accept': '同意する', 'community.decline': '同意しない',
        // Report Modal
        'report.title': 'コンテンツを報告', 'report.reason': '報告理由', 'report.selectReason': '理由を選択', 'report.spam': 'スパムまたは誤解を招く内容', 'report.inappropriate': '不適切なコンテンツ', 'report.violence': '暴力的または危険なコンテンツ', 'report.copyright': '著作権侵害', 'report.other': 'その他', 'report.details': '詳細', 'report.detailsPlaceholder': '詳細を入力...', 'report.submit': '報告を送信', 'report.cancel': 'キャンセル',
        // Share Modal
        'share.title': '共有', 'share.copyLink': 'リンクをコピー', 'share.embed': '埋め込みコード', 'share.copyEmbed': '埋め込みコードをコピー', 'share.social': 'SNSでシェア', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': 'メール', 'share.copied': 'コピーしました！', 'share.nostr': 'Nostrでシェア', 'share.generateImage': '画像を生成', 'share.downloadImage': 'ダウンロード', 'share.shareImage': 'シェア', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (正方形)', 'share.size1080x1920': '1080 × 1920 (ストーリー)',
        // Edit Video Modal
        'editVideo.title': '動画を編集', 'editVideo.videoTitle': 'タイトル', 'editVideo.description': '説明', 'editVideo.tags': 'タグ', 'editVideo.thumbnail': 'サムネイル', 'editVideo.changeThumbnail': 'サムネイルを変更', 'editVideo.visibility': '公開設定', 'editVideo.nsfw': 'NSFWコンテンツ', 'editVideo.save': '変更を保存', 'editVideo.delete': '動画を削除', 'editVideo.confirmDelete': 'この動画を削除しますか？',
        // Edit Profile Modal
        'editProfile.title': 'プロフィールを編集', 'editProfile.displayName': '表示名', 'editProfile.displayNamePlaceholder': '表示名を入力', 'editProfile.username': 'ユーザー名', 'editProfile.usernamePlaceholder': 'ユーザー名を入力', 'editProfile.about': '自己紹介', 'editProfile.aboutPlaceholder': '自己紹介を入力...', 'editProfile.website': 'ウェブサイト', 'editProfile.websitePlaceholder': 'https://yourwebsite.com', 'editProfile.lightning': 'Lightningアドレス', 'editProfile.lightningPlaceholder': 'you@getalby.com', 'editProfile.nip05': 'NIP-05認証', 'editProfile.nip05Placeholder': 'you@domain.com', 'editProfile.avatar': 'アバター', 'editProfile.changeAvatar': 'アバターを変更', 'editProfile.banner': 'バナー', 'editProfile.changeBanner': 'バナーを変更', 'editProfile.save': 'プロフィールを保存',
        // Confirmation Modal
        'confirm.title': '操作を確認', 'confirm.message': '続行しますか？', 'confirm.confirm': '確認', 'confirm.cancel': 'キャンセル',
        // Video Page
        'video.views': '回視聴', 'video.like': 'いいね', 'video.dislike': '低評価', 'video.share': '共有', 'video.save': '保存', 'video.report': '報告', 'video.follow': 'フォロー', 'video.unfollow': 'フォロー解除', 'video.subscribe': '登録', 'video.subscribed': '登録済み', 'video.comments': 'コメント', 'video.addComment': 'コメントを追加...', 'video.reply': '返信', 'video.replies': '件の返信', 'video.loadMore': 'もっと見る', 'video.noComments': 'コメントはありません。最初のコメントを投稿しましょう！', 'video.zap': 'Zap', 'video.zapAmount': 'Zap金額 (sats)', 'video.sendZap': 'Zapを送る', 'video.boost': 'ブースト', 'video.description': '説明', 'video.showMore': 'もっと見る', 'video.showLess': '折りたたむ', 'video.publishedOn': '公開日',
        // Toast Messages
        'toast.loggedIn': 'ログインしました！', 'toast.loggedOut': 'ログアウトしました', 'toast.settingsSaved': '設定を保存しました！', 'toast.settingsReset': '設定をリセットしました', 'toast.videoUploaded': '動画をアップロードしました！', 'toast.videoDeleted': '動画を削除しました', 'toast.profileUpdated': 'プロフィールを更新しました！', 'toast.linkCopied': 'リンクをコピーしました！', 'toast.embedCopied': '埋め込みコードをコピーしました！', 'toast.zapSent': 'Zapを送りました！', 'toast.followed': 'フォローしました！', 'toast.unfollowed': 'フォロー解除しました', 'toast.reported': '報告を送信しました', 'toast.saved': '保存しました！', 'toast.error': 'エラーが発生しました', 'toast.networkError': 'ネットワークエラー。再試行してください。', 'toast.uploadError': 'アップロードに失敗しました。再試行してください。', 'toast.languageChanged': '言語を変更しました', 'toast.commentPosted': 'コメントを投稿しました', 'toast.keyCopied': '鍵をコピーしました！',
        // Time
        'time.now': 'たった今', 'time.minutesAgo': '{count}分前', 'time.hoursAgo': '{count}時間前', 'time.daysAgo': '{count}日前', 'time.weeksAgo': '{count}週間前', 'time.monthsAgo': '{count}ヶ月前', 'time.yearsAgo': '{count}年前',
        // Empty States
        'empty.noVideos': '動画が見つかりません', 'empty.noVideosDesc': '別の検索をお試しください', 'empty.noFollowing': 'まだ誰もフォローしていません', 'empty.noFollowingDesc': 'クリエイターをフォローして動画を見る', 'empty.noHistory': '視聴履歴はありません', 'empty.noHistoryDesc': '視聴した動画がここに表示されます', 'empty.noLiked': 'いいねした動画はありません', 'empty.noLikedDesc': 'いいねした動画がここに表示されます', 'empty.noResults': '結果が見つかりません', 'empty.noResultsDesc': '別のキーワードをお試しください',
        // Misc
        'misc.loading': '読み込み中...', 'misc.loadingMore': 'さらに読み込み中...', 'misc.refresh': '更新', 'misc.retry': '再試行', 'misc.close': '閉じる', 'misc.back': '戻る', 'misc.next': '次へ', 'misc.previous': '前へ', 'misc.search': '検索', 'misc.filter': 'フィルター', 'misc.sort': '並び替え', 'misc.newest': '新しい順', 'misc.oldest': '古い順', 'misc.popular': '人気', 'misc.trending': 'トレンド', 'misc.sats': 'sats', 'misc.all': 'すべて', 'misc.copiedToClipboard': 'クリップボードにコピーしました！',
        // Common
        'common.submit': '送信', 'common.cancel': 'キャンセル', 'common.save': '保存', 'common.delete': '削除', 'common.edit': '編集', 'common.close': '閉じる', 'common.confirm': '確認', 'common.yes': 'はい', 'common.no': 'いいえ', 'common.ok': 'OK', 'common.loading': '読み込み中...', 'common.uploading': 'アップロード中...', 'common.error': 'エラー', 'common.success': '成功',
        // Aria Labels
        'aria.toggleMenu': 'メニューを切り替え', 'aria.mainNavigation': 'メインナビゲーション', 'aria.videoContent': '動画コンテンツ', 'aria.loadingContent': 'コンテンツを読み込み中', 'aria.closeModal': 'モーダルを閉じる', 'aria.playVideo': '動画を再生', 'aria.pauseVideo': '動画を一時停止', 'aria.muteVideo': 'ミュート', 'aria.unmuteVideo': 'ミュート解除', 'aria.fullscreen': 'フルスクリーン', 'aria.exitFullscreen': 'フルスクリーン解除', 'aria.settings': '設定', 'aria.notifications': '通知', 'aria.userMenu': 'ユーザーメニュー', 'aria.searchInput': '動画を検索', 'aria.videoPlayer': '動画プレイヤー',
        // Dynamic JavaScript text
        'button.hideQR': 'QRコードを隠す', 'button.showQR': 'QRコードを表示', 'button.copied': 'コピーしました！', 'button.showLess': '少なく表示', 'button.showMore': 'もっと見る', 'button.creatingAccount': 'アカウント作成中...', 'button.submitting': '送信中...', 'button.scheduleStream': '配信を予約', 'button.goLive': 'ライブ開始', 'button.creatingStream': '配信を作成中...', 'button.continueCustomAmount': 'カスタム金額で続行', 'button.recordFromCamera': 'カメラから録画', 'button.requestingCamera': 'カメラを要求中...', 'button.recording': '録画中...',
        'status.saving': '保存中...', 'status.saved': '保存しました！', 'status.uploading': 'アップロード中...', 'status.uploadComplete': 'アップロード完了！', 'status.uploadingToNostrBuild': 'nostr.buildにアップロード中...', 'status.publishingChanges': '変更を公開中...', 'status.removingOldVersion': '古いバージョンを削除中...', 'status.validatingThumbnail': 'サムネイルを検証中...', 'status.uploadingThumbnail': 'サムネイルをアップロード中...', 'status.thumbnailUploaded': 'サムネイルアップロード完了！', 'status.processingVideo': '動画を処理中...', 'status.compressingVideo': '動画を圧縮中...', 'status.uploadingVideo': '動画をアップロード中...', 'status.videoUploaded': '動画のアップロードに成功しました！', 'status.processing': '処理中...', 'status.generatingThumbnail': 'サムネイルを生成中...', 'status.generatingPreview': 'プレビューを生成中...', 'status.uploadingPreview': 'プレビューをアップロード中...', 'status.publishing': '公開中...', 'status.publishingToNostr': 'Nostrに公開中...', 'status.publishingVideoToNostr': '動画をNostrに公開中...', 'status.generatingPoW': 'プルーフオブワークを生成中...', 'status.posting': '投稿中...', 'status.processingVideoAndThumbnail': '動画とサムネイルを処理中...', 'status.uploadFailed': 'アップロード失敗 - 再試行してください', 'status.selectVideoToUpload': 'アップロードする動画を選択', 'status.waitingForVideoUpload': '動画のアップロードを待っています...', 'status.selectVideoAndThumbnail': '公開する動画とサムネイルを選択', 'status.ready': '準備完了 ✓', 'status.failed': '失敗 ✗', 'status.fromDraft': '下書きから', 'status.startingNow': 'まもなく開始！', 'status.ended': '終了', 'status.thumbnailReady': '準備完了', 'status.thumbnailFailed': '失敗', 'status.uploadFailedRetry': 'アップロード失敗。再試行してください。',
        'publish.video': '動画を公開', 'publish.autoThumbnail': '動画を公開（自動サムネイル）',
        'report.titleComment': 'コメントを報告', 'report.titleUser': 'ユーザーを報告', 'report.titleVideo': '動画を報告', 'report.descComment': 'このコメントを報告する理由を選択:', 'report.descUser': 'このユーザーを報告する理由を選択:', 'report.descVideo': 'このコンテンツを報告する理由を選択:',
        'empty.noMutedUsers': 'ミュートしているユーザーはいません。', 'empty.noVideosToMonitor': '監視する動画がありません。', 'empty.noRecentActivity': '最近のアクティビティはありません。', 'empty.failedLoadNotifications': '通知の読み込みに失敗しました', 'empty.loginToViewLiked': '<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">ログイン</a>していいねした動画を見る。', 'empty.loginToViewFollowing': '<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">ログイン</a>してフォローを見る。', 'empty.loginToViewVideos': '<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">ログイン</a>して動画を見る。', 'empty.loginToViewAnalytics': '<a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">ログイン</a>して統計を見る。', 'empty.noLikedVideosYet': 'まだ動画にいいねしていません。', 'empty.noLikedVideosFound': 'いいねした動画が見つかりません。', 'empty.noFullLengthLikedVideos': 'いいねした長編動画が見つかりません。', 'empty.noWatchHistory': '視聴履歴がありません。動画を見てみましょう。', 'empty.noVideosInHistory': '履歴に動画がありません。', 'empty.noFullLengthHistory': '履歴に長編動画がありません。', 'empty.noMatchingVideos': '一致する動画が見つかりません。', 'empty.noFullLengthVideos': '長編動画が見つかりません。', 'empty.failedLoadTrending': 'トレンドの読み込みに失敗しました。', 'empty.noTrendingVideos': 'トレンド動画が見つかりません。', 'empty.noMatchingUsers': '一致するユーザーが見つかりません。', 'empty.unableLoadProfiles': 'プロフィールを読み込めません。', 'empty.noFollowingVideos': 'フォロー中のユーザーの動画がまだありません。', 'empty.noFullLengthFollowing': 'フォロー中の長編動画がありません。', 'empty.failedLoadFollowing': '読み込みに失敗しました。再試行してください。', 'empty.noVideosUploadFirst': '動画がありません。最初の動画をアップロード！', 'empty.noFullLengthUploaded': '長編動画が見つかりません。', 'empty.noMatchingLiveStreams': '一致するライブ配信が見つかりません。', 'empty.noMatchingShorts': '一致するショート動画が見つかりません。', 'empty.noVideosForTag': 'このタグの動画がありません。', 'empty.noFullLengthForTag': 'このタグの長編動画がありません。', 'empty.noUploadedVideos': 'まだ動画がアップロードされていません。', 'empty.noVideosFound': '動画が見つかりません。', 'empty.failedLoadProfile': 'プロフィールの読み込みに失敗しました。再試行してください。', 'empty.noComments': 'まだコメントがありません。最初のコメントを！', 'empty.failedLoadComments': 'コメントの読み込みに失敗しました', 'empty.noLiveNow': '今は誰もライブしていません。最初になりましょう！',
        'error.videoNotFound': '動画が見つかりません。', 'error.contentNotAvailable': 'このコンテンツは利用できません。', 'error.invalidVideoData': '無効な動画データです。', 'error.videoNotAvailable': '動画が利用できません。ファイルが削除された可能性があります。', 'error.failedLoadVideo': '動画の読み込みに失敗しました。再試行してください。', 'error.failedLoadVideoShort': '読み込みに失敗。ファイルが削除された可能性があります。', 'error.liveStreamNotFound': 'ライブ配信が見つかりません。', 'error.invalidLiveStreamData': '無効なライブ配信データです。', 'error.failedLoadLiveStream': 'ライブ配信の読み込みに失敗しました。',
        // New Button & Action Labels
        'button.follow': 'フォロー', 'button.unfollow': 'フォロー解除', 'button.mute': 'ミュート', 'button.unmute': 'ミュート解除', 'button.muteUser': 'ユーザーをミュート', 'button.unmuteUser': 'ミュート解除', 'button.confirm': '確認', 'button.cancel': 'キャンセル', 'button.close': '閉じる', 'button.boost': 'ブースト', 'button.zap': 'Zap', 'button.viewMore': 'もっと見る', 'button.viewAnalytics': '統計を見る', 'button.backToMyVideos': 'マイ動画に戻る', 'button.editDraft': '下書きを編集', 'button.deleteDraft': '下書きを削除', 'button.editVideo': '動画を編集', 'button.deleteVideo': '動画を削除', 'button.editShort': 'ショートを編集', 'button.deleteShort': 'ショートを削除', 'button.editStream': '配信を編集', 'button.endStream': '配信を終了', 'button.reset': 'リセット', 'button.download': 'ダウンロード', 'button.watchRecording': '録画を見る', 'button.show': '表示', 'button.login': 'ログイン', 'button.toggleChat': 'チャット切替', 'button.blockVideo': '動画をブロック', 'button.blockUser': 'ユーザーをブロック', 'button.unblock': 'ブロック解除', 'button.removeFromHistory': '履歴から削除',
        // New Stats & Counts
        'stat.views': '回視聴', 'stat.viewsCount': '{count}回視聴', 'stat.videos': '本の動画', 'stat.video': '本の動画', 'stat.followers': '人のフォロワー', 'stat.follower': '人のフォロワー', 'stat.following': 'フォロー中', 'stat.subscribers': '人の登録者', 'stat.comments': 'コメント', 'stat.liveCount': '{count}件ライブ中', 'stat.percentOfGoal': '目標の{percent}%', 'stat.netGrowth': '純増', 'stat.newFollowers': '新規フォロワー', 'stat.unfollowed': 'フォロー解除', 'stat.lastUpdated': '最終更新: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'ライブ', 'badge.ended': '終了', 'badge.scheduled': '予定', 'badge.warning': '警告', 'badge.communityWarning': 'コミュニティ警告', 'badge.verifiedNip05': 'NIP-05認証済み', 'badge.streamer': '配信者', 'badge.clickToView': 'クリックして表示',
        // New Actions
        'action.report': '報告', 'action.reportComment': 'コメントを報告', 'action.reportVideo': 'この動画を報告', 'action.reportStream': 'この配信を報告', 'action.like': 'いいね', 'action.dislike': '低評価', 'action.reply': '返信',
        // New Placeholders
        'placeholder.searchHistory': '履歴を検索...', 'placeholder.searchUsers': 'ユーザーを検索...', 'placeholder.searchMyVideos': 'マイ動画を検索...', 'placeholder.eventId': 'イベントID入力 (hex or nevent/note)', 'placeholder.pubkey': 'pubkey入力 (hex or npub)', 'placeholder.customAmount': 'カスタム金額', 'placeholder.chatEnded': 'チャット終了 - 配信は終了しました', 'placeholder.addComment': 'コメントを追加...', 'placeholder.setNewGoal': '新しい目標を設定 (sats)',
        // New Video & Content
        'video.untitledVideo': '無題の動画', 'video.untitledShort': '無題のショート', 'video.upNext': '次の動画', 'video.noVideosYet': '動画はまだありません', 'video.noShortsYet': 'ショートはまだありません', 'video.noLiveStreamsYet': 'ライブ配信はまだありません', 'video.noBlockedVideos': 'ブロックされた動画はありません', 'video.noBlockedUsers': 'ブロックされたユーザーはいません',
        // New Stream Messages
        'stream.ended': 'この配信は終了しました。チャットは閉鎖されました。', 'stream.welcomeChat': 'ライブチャットへようこそ！', 'stream.goalReached': '目標達成！', 'stream.zapGoalReached': 'Zap目標達成！{amount} sats！',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'ミュートされたユーザーからのメッセージ', 'muted.commentFromMutedUserHidden': 'ミュートされたユーザーのコメントは非表示', 'muted.commentHidden': 'コメントは非表示 ({packs})', 'muted.messageHidden': 'メッセージは非表示 ({packs})', 'muted.commentReportedByFollows': 'フォロー中のユーザーが報告したコメント', 'muted.messageReportedByFollows': 'フォロー中のユーザーが報告したメッセージ', 'muted.commentHeavilyDownvoted': 'コミュニティで大量に低評価されたコメント', 'muted.messageHeavilyDownvoted': '大量に低評価されたメッセージ',
        // New Admin & Lists
        'list.blockedVideos': 'ブロックされた動画', 'list.blockedUsers': 'ブロックされたユーザー',
        // New Alerts
        'alert.cameraNotSupported': 'このブラウザではカメラアクセスがサポートされていません。Chrome、Firefox、Safariなどの最新ブラウザをお使いください。', 'alert.noCameraFound': 'カメラが見つかりません。カメラを接続するか、ファイルアップロードをお使いください。', 'alert.cameraAccessDenied': 'カメラアクセスが拒否されました。ブラウザ設定でカメラを許可してください。', 'alert.cameraInUse': 'カメラは他のアプリで使用中です。他のアプリを閉じてください。', 'alert.cameraUnableAccess': 'カメラにアクセスできません。ファイルアップロードをお試しください。', 'alert.cameraUnableAccessWithError': 'カメラにアクセスできません: {error}\n\nファイルアップロードをお使いください。', 'alert.fillRequiredFields': '必須項目をすべて入力してください', 'alert.uploadThumbnail': '配信のサムネイルをアップロードしてください', 'alert.failedCreateStream': '配信の作成に失敗しました。再度お試しください。', 'alert.failedUpdateStream': '更新に失敗しました。再度お試しください。', 'alert.streamNotFound': '配信が見つかりません', 'alert.canOnlyEditOwnStreams': '自分の配信のみ編集できます', 'alert.invalidStreamData': '配信データが無効です', 'alert.enterValidGoalAmount': '有効な目標金額を入力してください', 'alert.canOnlyResetOwnGoals': '自分の目標のみリセットできます', 'alert.streamEventNotFound': '配信イベントが見つかりません', 'alert.failedResetZapGoal': 'Zap目標のリセットに失敗しました。再度お試しください。', 'alert.cannotBlockAdmin': '管理者アカウントはブロックできません', 'alert.analyticsLoadFailed': '統計の読み込みに失敗しました。再度お試しください。', 'alert.cannotReplaceShortWithVideo': 'ショートを通常動画で置き換えることはできません。縦動画（60秒以下）をアップロードしてください。', 'alert.cannotReplaceVideoWithShort': '通常動画をショートで置き換えることはできません。横動画をアップロードしてください。', 'alert.shortsRequireVertical': 'この動画は横動画のようです。ショートは縦動画である必要があります。横動画には「動画をアップロード」をお使いください。',
        // New Zap Messages
        'zap.cannotZapYourself': '自分にZapを送ることはできません', 'zap.cannotZapOwnContent': '自分のコンテンツにZapを送ることはできません', 'zap.cannotZapOwnComment': '自分のコメントにZapを送ることはできません', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': '動画を読み込み中...', 'status.loading': '読み込み中...', 'status.compressingProgress': '圧縮中... {progress}%', 'status.uploadingProgress': 'アップロード中... {progress}%', 'status.uploadingServers': 'アップロード中... ({completed}/{total} サーバー)', 'status.publishedSuccess': '{type}が正常に公開されました！',
        // New Warnings
        'warning.webmFormat': '注意: ブラウザはWebM形式で出力します（iOSでは再生できない場合があります）。iOS互換のMP4にはWindows/MacのChromeをお使いください。',
        // New Footer
        'footer.lastUpdated': '最終更新: 2024年12月',
    },
    ko: {
        // Navigation & Header
        'nav.home': '홈', 'nav.following': '팔로잉', 'nav.myVideos': '내 동영상', 'nav.liked': '좋아요', 'nav.history': '기록', 'nav.topics': '주제', 'nav.live': '라이브', 'nav.bitcoin': '비트코인', 'nav.nostr': 'Nostr', 'nav.technology': '기술', 'nav.gaming': '게임', 'nav.tutorials': '튜토리얼', 'nav.podcasts': '팟캐스트', 'nav.music': '음악', 'nav.nsfw': 'NSFW', 'nav.about': '소개', 'nav.contact': '문의', 'nav.terms': '약관', 'nav.privacy': '개인정보', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': '라이브 스트림', 'nav.github': 'GitHub',
        'header.search': '동영상 검색...', 'header.notifications': '알림', 'header.settings': '설정', 'header.create': '만들기', 'header.viewProfile': '프로필 보기', 'header.logout': '로그아웃',
        // Login Modal
        'login.title': 'Nostr로 로그인', 'login.extensionButton': 'Nostr 확장 프로그램으로 로그인', 'login.extensionDesc': '서명 확장 프로그램 사용 (Alby, nos2x 등)', 'login.orDivider': '또는', 'login.nsecLabel': '개인 키로 로그인 (nsec)', 'login.nsecPlaceholder': 'nsec 입력...', 'login.nsecButton': 'nsec로 로그인', 'login.nsecWarning': '경고: nsec 직접 입력은 확장 프로그램 사용보다 보안이 낮습니다. 더 나은 보안을 위해 NIP-07 확장 프로그램을 고려하세요.', 'login.newToNostr': 'Nostr이 처음이신가요?', 'login.createAccount': '계정 만들기', 'login.learnMore': 'Nostr에 대해 자세히 알아보기',
        // Connect Modal
        'connect.title': 'Nostr에 연결', 'connect.or': '또는', 'connect.extensionButton': 'Nostr 확장 프로그램 연결', 'connect.extensionDesc': '확장 프로그램 사용 (Alby, nos2x 등)', 'connect.nsecLabel': '개인 키로 로그인', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'nsec로 연결', 'connect.nsecWarning': '경고: nsec 직접 입력은 보안이 낮습니다. 더 나은 보안을 위해 NIP-07 확장 프로그램을 사용하세요.', 'connect.newToNostr': 'Nostr이 처음이신가요?', 'connect.createAccount': '계정 만들기',
        // Private Key Modal
        'privateKey.title': '개인 키', 'privateKey.warning': '중요: 안전한 곳에 저장하세요. 이 키를 잃어버리면 계정에 접근할 수 없습니다. 절대 다른 사람과 공유하지 마세요!', 'privateKey.show': '개인 키 표시', 'privateKey.hide': '개인 키 숨기기', 'privateKey.copy': '복사', 'privateKey.saved': '키를 저장했습니다', 'privateKey.yourPublicKey': '공개 키 (npub):', 'privateKey.yourPrivateKey': '개인 키 (nsec):',
        // Signup Modal
        'signup.title': 'Nostr 계정 만들기', 'signup.whatIsNostr': 'Nostr란?', 'signup.nostrDescription': 'Nostr는 자신의 신원과 데이터를 제어할 수 있는 분산형 프로토콜입니다. 중앙 서버가 없으며 계정은 암호화 키 쌍입니다.', 'signup.whyNostr': '왜 Nostr인가?', 'signup.benefit1': '신원 소유권', 'signup.benefit2': '검열 없음', 'signup.benefit3': '플랫폼 간 이식성', 'signup.createNew': '새 계정 만들기', 'signup.haveAccount': '이미 계정이 있으신가요?', 'signup.login': '로그인', 'signup.createButton': '계정 만들기', 'signup.generating': '키 생성 중...', 'signup.displayName': '표시 이름', 'signup.displayNamePlaceholder': '표시 이름 입력', 'signup.username': '사용자 이름', 'signup.usernamePlaceholder': '사용자 이름 입력',
        // Notifications
        'notifications.title': '알림', 'notifications.empty': '알림이 없습니다', 'notifications.viewAll': '모든 알림 보기', 'notifications.markAllRead': '모두 읽음으로 표시', 'notifications.settings': '알림 설정', 'notifications.loading': '알림 로딩 중...', 'notifications.zap': 'Zap을 보냈습니다', 'notifications.like': '좋아요를 눌렀습니다', 'notifications.comment': '댓글을 달았습니다', 'notifications.follow': '팔로우했습니다', 'notifications.repost': '리포스트했습니다', 'notifications.mention': '멘션했습니다',
        // Settings Modal
        'settings.title': '설정', 'settings.language': '언어', 'settings.languageDesc': '언어 선택', 'settings.saveToNostr': 'Nostr에 저장', 'settings.darkMode': '다크 모드', 'settings.darkModeDesc': '다크/라이트 테마 전환', 'settings.autoplay': '자동 재생', 'settings.autoplayDesc': '동영상 자동 재생', 'settings.saveSettings': '설정 저장', 'settings.resetDefaults': '초기화', 'settings.notifications': '알림', 'settings.notificationsDesc': '푸시 알림 받기', 'settings.quality': '기본 화질', 'settings.qualityDesc': '동영상 재생 화질',
        // Upload Modal
        'upload.title': '동영상 업로드', 'upload.dragDrop': '여기에 동영상 파일을 드롭하세요', 'upload.or': '또는', 'upload.browse': '파일 찾아보기', 'upload.supportedFormats': '지원 형식: MP4, WebM, MOV', 'upload.maxSize': '최대 파일 크기: 2GB', 'upload.videoTitle': '제목', 'upload.titlePlaceholder': '동영상 제목 입력', 'upload.description': '설명', 'upload.descriptionPlaceholder': '동영상 설명...', 'upload.tags': '태그', 'upload.tagsPlaceholder': '쉼표로 구분하여 태그 추가', 'upload.visibility': '공개 설정', 'upload.public': '공개', 'upload.unlisted': '미등록', 'upload.uploadButton': '동영상 업로드', 'upload.uploading': '업로드 중...', 'upload.processing': '처리 중...', 'upload.complete': '완료!', 'upload.error': '업로드 실패', 'upload.nsfw': 'NSFW 콘텐츠', 'upload.nsfwDesc': '성인 콘텐츠로 표시', 'upload.thumbnail': '썸네일', 'upload.thumbnailDesc': '썸네일 업로드', 'upload.preparing': '준비 중...', 'upload.cancel': '취소', 'upload.progress': '업로드 진행률', 'upload.transcoding': '트랜스코딩 중', 'upload.status.preparing': '업로드 준비 중...', 'upload.status.uploading': '동영상 업로드 중...', 'upload.status.transcoding': '동영상 트랜스코딩 중...', 'upload.status.complete': '업로드 완료!', 'upload.qualityHigh': '높음', 'upload.qualityMedium': '중간', 'upload.qualityLow': '낮음',
        // Create Modal
        'create.title': '만들기', 'create.uploadVideo': '동영상 업로드', 'create.uploadDesc': '동영상 공유', 'create.goLive': '라이브 시작', 'create.goLiveDesc': '라이브 스트리밍 시작', 'create.createPost': '게시물 작성', 'create.createPostDesc': '텍스트 게시물 공유',
        // Go Live Modal
        'goLive.title': '라이브 시작', 'goLive.streamTitle': '스트림 제목', 'goLive.streamTitlePlaceholder': '스트림 제목 입력', 'goLive.description': '설명', 'goLive.descriptionPlaceholder': '스트림 설명...', 'goLive.category': '카테고리', 'goLive.selectCategory': '카테고리 선택', 'goLive.tags': '태그', 'goLive.tagsPlaceholder': '쉼표로 구분하여 태그 추가', 'goLive.startStream': '스트림 시작', 'goLive.streamKey': '스트림 키', 'goLive.streamUrl': '스트림 URL', 'goLive.copy': '복사', 'goLive.hideKey': '키 숨기기', 'goLive.showKey': '키 표시', 'goLive.connecting': '연결 중...', 'goLive.live': '라이브', 'goLive.offline': '오프라인', 'goLive.viewers': '시청자', 'goLive.endStream': '스트림 종료', 'goLive.nsfw': 'NSFW 콘텐츠', 'goLive.nsfwDesc': '성인 콘텐츠로 표시', 'goLive.thumbnail': '스트림 썸네일', 'goLive.thumbnailDesc': '썸네일 업로드',
        // Edit Stream Modal
        'editStream.title': '스트림 편집', 'editStream.save': '변경 사항 저장',
        // NSFW Warning Modal
        'nsfw.title': '성인 콘텐츠 경고', 'nsfw.warning': '이 콘텐츠는 NSFW(직장에서 보기 부적절)로 표시되어 있으며 성인 콘텐츠가 포함될 수 있습니다.', 'nsfw.confirm': '나이 확인', 'nsfw.confirmAge': '18세 이상입니다', 'nsfw.cancel': '돌아가기', 'nsfw.continue': '계속', 'nsfw.dontShowAgain': '이 경고 다시 표시 안 함',
        // Community Warning Modal
        'community.title': '커뮤니티 가이드라인', 'community.warning': '계속하기 전에 커뮤니티 가이드라인을 검토하세요.', 'community.guidelines': '다른 사람을 존중하고 커뮤니티 기준을 따르세요.', 'community.accept': '동의', 'community.decline': '거절',
        // Report Modal
        'report.title': '콘텐츠 신고', 'report.reason': '신고 사유', 'report.selectReason': '사유 선택', 'report.spam': '스팸 또는 오해의 소지', 'report.inappropriate': '부적절한 콘텐츠', 'report.violence': '폭력적이거나 위험한 콘텐츠', 'report.copyright': '저작권 침해', 'report.other': '기타', 'report.details': '세부 정보', 'report.detailsPlaceholder': '세부 정보 입력...', 'report.submit': '신고 제출', 'report.cancel': '취소',
        // Share Modal
        'share.title': '공유', 'share.copyLink': '링크 복사', 'share.embed': '임베드 코드', 'share.copyEmbed': '임베드 코드 복사', 'share.social': '소셜 미디어에 공유', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': '이메일', 'share.copied': '복사됨!', 'share.nostr': 'Nostr에 공유', 'share.generateImage': '이미지 생성', 'share.downloadImage': '다운로드', 'share.shareImage': '공유', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (정사각형)', 'share.size1080x1920': '1080 × 1920 (스토리)',
        // Edit Video Modal
        'editVideo.title': '동영상 편집', 'editVideo.videoTitle': '제목', 'editVideo.description': '설명', 'editVideo.tags': '태그', 'editVideo.thumbnail': '썸네일', 'editVideo.changeThumbnail': '썸네일 변경', 'editVideo.visibility': '공개 설정', 'editVideo.nsfw': 'NSFW 콘텐츠', 'editVideo.save': '변경 사항 저장', 'editVideo.delete': '동영상 삭제', 'editVideo.confirmDelete': '이 동영상을 삭제하시겠습니까?',
        // Edit Profile Modal
        'editProfile.title': '프로필 편집', 'editProfile.displayName': '표시 이름', 'editProfile.displayNamePlaceholder': '표시 이름 입력', 'editProfile.username': '사용자 이름', 'editProfile.usernamePlaceholder': '사용자 이름 입력', 'editProfile.about': '소개', 'editProfile.aboutPlaceholder': '자기 소개...', 'editProfile.website': '웹사이트', 'editProfile.websitePlaceholder': 'https://yourwebsite.com', 'editProfile.lightning': 'Lightning 주소', 'editProfile.lightningPlaceholder': 'you@getalby.com', 'editProfile.nip05': 'NIP-05 인증', 'editProfile.nip05Placeholder': 'you@domain.com', 'editProfile.avatar': '아바타', 'editProfile.changeAvatar': '아바타 변경', 'editProfile.banner': '배너', 'editProfile.changeBanner': '배너 변경', 'editProfile.save': '프로필 저장',
        // Confirmation Modal
        'confirm.title': '작업 확인', 'confirm.message': '계속하시겠습니까?', 'confirm.confirm': '확인', 'confirm.cancel': '취소',
        // Video Page
        'video.views': '조회', 'video.like': '좋아요', 'video.dislike': '싫어요', 'video.share': '공유', 'video.save': '저장', 'video.report': '신고', 'video.follow': '팔로우', 'video.unfollow': '언팔로우', 'video.subscribe': '구독', 'video.subscribed': '구독 중', 'video.comments': '댓글', 'video.addComment': '댓글 추가...', 'video.reply': '답글', 'video.replies': '개의 답글', 'video.loadMore': '더 보기', 'video.noComments': '댓글이 없습니다. 첫 번째로 댓글을 달아보세요!', 'video.zap': 'Zap', 'video.zapAmount': 'Zap 금액 (sats)', 'video.sendZap': 'Zap 보내기', 'video.boost': '부스트', 'video.description': '설명', 'video.showMore': '더 보기', 'video.showLess': '접기', 'video.publishedOn': '게시일',
        // Toast Messages
        'toast.loggedIn': '로그인 성공!', 'toast.loggedOut': '로그아웃됨', 'toast.settingsSaved': '설정 저장됨!', 'toast.settingsReset': '설정 초기화됨', 'toast.videoUploaded': '동영상 업로드됨!', 'toast.videoDeleted': '동영상 삭제됨', 'toast.profileUpdated': '프로필 업데이트됨!', 'toast.linkCopied': '링크 복사됨!', 'toast.embedCopied': '임베드 코드 복사됨!', 'toast.zapSent': 'Zap 전송됨!', 'toast.followed': '팔로우함!', 'toast.unfollowed': '언팔로우함', 'toast.reported': '신고 제출됨', 'toast.saved': '저장됨!', 'toast.error': '오류 발생', 'toast.networkError': '네트워크 오류. 다시 시도하세요.', 'toast.uploadError': '업로드 실패. 다시 시도하세요.', 'toast.languageChanged': '언어가 변경됨', 'toast.commentPosted': '댓글 게시됨', 'toast.keyCopied': '키 복사됨!',
        // Time
        'time.now': '방금 전', 'time.minutesAgo': '{count}분 전', 'time.hoursAgo': '{count}시간 전', 'time.daysAgo': '{count}일 전', 'time.weeksAgo': '{count}주 전', 'time.monthsAgo': '{count}개월 전', 'time.yearsAgo': '{count}년 전',
        // Empty States
        'empty.noVideos': '동영상을 찾을 수 없습니다', 'empty.noVideosDesc': '다른 검색어를 시도하세요', 'empty.noFollowing': '아직 팔로우하는 사람이 없습니다', 'empty.noFollowingDesc': '크리에이터를 팔로우하여 동영상을 보세요', 'empty.noHistory': '시청 기록이 없습니다', 'empty.noHistoryDesc': '시청한 동영상이 여기에 표시됩니다', 'empty.noLiked': '좋아요한 동영상이 없습니다', 'empty.noLikedDesc': '좋아요한 동영상이 여기에 표시됩니다', 'empty.noResults': '결과를 찾을 수 없습니다', 'empty.noResultsDesc': '다른 키워드를 시도하세요',
        // Misc
        'misc.loading': '로딩 중...', 'misc.loadingMore': '더 로딩 중...', 'misc.refresh': '새로고침', 'misc.retry': '다시 시도', 'misc.close': '닫기', 'misc.back': '뒤로', 'misc.next': '다음', 'misc.previous': '이전', 'misc.search': '검색', 'misc.filter': '필터', 'misc.sort': '정렬', 'misc.newest': '최신순', 'misc.oldest': '오래된순', 'misc.popular': '인기', 'misc.trending': '트렌딩', 'misc.sats': 'sats', 'misc.all': '전체', 'misc.copiedToClipboard': '클립보드에 복사됨!',
        // Common
        'common.submit': '제출', 'common.cancel': '취소', 'common.save': '저장', 'common.delete': '삭제', 'common.edit': '편집', 'common.close': '닫기', 'common.confirm': '확인', 'common.yes': '예', 'common.no': '아니오', 'common.ok': '확인', 'common.loading': '로딩 중...', 'common.uploading': '업로드 중...', 'common.error': '오류', 'common.success': '성공',
        // Aria Labels
        'aria.toggleMenu': '메뉴 전환', 'aria.mainNavigation': '메인 내비게이션', 'aria.videoContent': '동영상 콘텐츠', 'aria.loadingContent': '콘텐츠 로딩 중', 'aria.closeModal': '모달 닫기', 'aria.playVideo': '동영상 재생', 'aria.pauseVideo': '동영상 일시정지', 'aria.muteVideo': '음소거', 'aria.unmuteVideo': '음소거 해제', 'aria.fullscreen': '전체 화면', 'aria.exitFullscreen': '전체 화면 종료', 'aria.settings': '설정', 'aria.notifications': '알림', 'aria.userMenu': '사용자 메뉴', 'aria.searchInput': '동영상 검색', 'aria.videoPlayer': '동영상 플레이어',
        // Dynamic JavaScript text
        'button.hideQR': 'QR 코드 숨기기', 'button.showQR': 'QR 코드 보기', 'button.copied': '복사됨!', 'button.showLess': '간략히 보기', 'button.showMore': '더 보기', 'button.creatingAccount': '계정 생성 중...', 'button.submitting': '제출 중...', 'button.scheduleStream': '스트림 예약', 'button.goLive': '라이브 시작', 'button.creatingStream': '스트림 생성 중...', 'button.continueCustomAmount': '맞춤 금액으로 계속', 'button.recordFromCamera': '카메라로 녹화', 'button.requestingCamera': '카메라 요청 중...', 'button.recording': '녹화 중...',
        'status.saving': '저장 중...', 'status.saved': '저장됨!', 'status.uploading': '업로드 중...', 'status.uploadComplete': '업로드 완료!', 'status.uploadingToNostrBuild': 'nostr.build에 업로드 중...', 'status.publishingChanges': '변경 사항 게시 중...', 'status.removingOldVersion': '이전 버전 제거 중...', 'status.validatingThumbnail': '썸네일 검증 중...', 'status.uploadingThumbnail': '썸네일 업로드 중...', 'status.thumbnailUploaded': '썸네일 업로드됨!', 'status.processingVideo': '동영상 처리 중...', 'status.compressingVideo': '동영상 압축 중...', 'status.uploadingVideo': '동영상 업로드 중...', 'status.videoUploaded': '동영상 업로드 성공!', 'status.processing': '처리 중...', 'status.generatingThumbnail': '썸네일 생성 중...', 'status.generatingPreview': '미리보기 생성 중...', 'status.uploadingPreview': '미리보기 업로드 중...', 'status.publishing': '게시 중...', 'status.publishingToNostr': 'Nostr에 게시 중...', 'status.publishingVideoToNostr': 'Nostr에 동영상 게시 중...', 'status.generatingPoW': '작업 증명 생성 중...', 'status.posting': '게시 중...', 'status.processingVideoAndThumbnail': '동영상과 썸네일 처리 중...', 'status.uploadFailed': '업로드 실패 - 다시 시도하세요', 'status.selectVideoToUpload': '업로드할 동영상 선택', 'status.waitingForVideoUpload': '동영상 업로드 대기 중...', 'status.selectVideoAndThumbnail': '게시할 동영상과 썸네일 선택', 'status.ready': '준비 완료 ✓', 'status.failed': '실패 ✗', 'status.fromDraft': '임시저장에서', 'status.startingNow': '곧 시작!', 'status.ended': '종료됨', 'status.thumbnailReady': '준비됨', 'status.thumbnailFailed': '실패', 'status.uploadFailedRetry': '업로드 실패. 다시 시도하세요.',
        'publish.video': '동영상 게시', 'publish.autoThumbnail': '동영상 게시 (자동 썸네일)',
        'report.titleComment': '댓글 신고', 'report.titleUser': '사용자 신고', 'report.titleVideo': '동영상 신고', 'report.descComment': '댓글을 신고하는 이유를 선택하세요:', 'report.descUser': '사용자를 신고하는 이유를 선택하세요:', 'report.descVideo': '콘텐츠를 신고하는 이유를 선택하세요:',
        'empty.noMutedUsers': '뮤트된 사용자가 없습니다.', 'empty.noVideosToMonitor': '모니터링할 동영상이 없습니다.', 'empty.noRecentActivity': '최근 활동이 없습니다.', 'empty.failedLoadNotifications': '알림 로드 실패', 'empty.loginToViewLiked': '좋아요한 동영상을 보려면 <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">로그인</a>하세요.', 'empty.loginToViewFollowing': '팔로잉을 보려면 <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">로그인</a>하세요.', 'empty.loginToViewVideos': '동영상을 보려면 <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">로그인</a>하세요.', 'empty.loginToViewAnalytics': '통계를 보려면 <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">로그인</a>하세요.', 'empty.noLikedVideosYet': '아직 좋아요한 동영상이 없습니다.', 'empty.noLikedVideosFound': '좋아요한 동영상을 찾을 수 없습니다.', 'empty.noFullLengthLikedVideos': '좋아요한 긴 동영상을 찾을 수 없습니다.', 'empty.noWatchHistory': '시청 기록이 없습니다. 동영상을 시청해보세요.', 'empty.noVideosInHistory': '기록에 동영상이 없습니다.', 'empty.noFullLengthHistory': '기록에 긴 동영상이 없습니다.', 'empty.noMatchingVideos': '일치하는 동영상을 찾을 수 없습니다.', 'empty.noFullLengthVideos': '긴 동영상을 찾을 수 없습니다.', 'empty.failedLoadTrending': '트렌딩 로드 실패.', 'empty.noTrendingVideos': '트렌딩 동영상을 찾을 수 없습니다.', 'empty.noMatchingUsers': '일치하는 사용자를 찾을 수 없습니다.', 'empty.unableLoadProfiles': '프로필을 로드할 수 없습니다.', 'empty.noFollowingVideos': '팔로우하는 사용자의 동영상이 없습니다.', 'empty.noFullLengthFollowing': '팔로우하는 사용자의 긴 동영상이 없습니다.', 'empty.failedLoadFollowing': '로드 실패. 다시 시도하세요.', 'empty.noVideosUploadFirst': '동영상이 없습니다. 첫 동영상을 업로드하세요!', 'empty.noFullLengthUploaded': '긴 동영상을 찾을 수 없습니다.', 'empty.noMatchingLiveStreams': '일치하는 라이브 스트림을 찾을 수 없습니다.', 'empty.noMatchingShorts': '일치하는 쇼츠를 찾을 수 없습니다.', 'empty.noVideosForTag': '이 태그의 동영상이 없습니다.', 'empty.noFullLengthForTag': '이 태그의 긴 동영상이 없습니다.', 'empty.noUploadedVideos': '아직 업로드된 동영상이 없습니다.', 'empty.noVideosFound': '동영상을 찾을 수 없습니다.', 'empty.failedLoadProfile': '프로필 로드 실패. 다시 시도하세요.', 'empty.noComments': '아직 댓글이 없습니다. 첫 댓글을 달아보세요!', 'empty.failedLoadComments': '댓글 로드 실패', 'empty.noLiveNow': '현재 라이브 중인 사람이 없습니다. 첫 번째가 되어보세요!',
        'error.videoNotFound': '동영상을 찾을 수 없습니다.', 'error.contentNotAvailable': '이 콘텐츠를 사용할 수 없습니다.', 'error.invalidVideoData': '잘못된 동영상 데이터입니다.', 'error.videoNotAvailable': '동영상을 사용할 수 없습니다. 파일이 삭제되었을 수 있습니다.', 'error.failedLoadVideo': '동영상 로드 실패. 다시 시도하세요.', 'error.failedLoadVideoShort': '로드 실패. 파일이 삭제되었을 수 있습니다.', 'error.liveStreamNotFound': '라이브 스트림을 찾을 수 없습니다.', 'error.invalidLiveStreamData': '잘못된 라이브 스트림 데이터입니다.', 'error.failedLoadLiveStream': '라이브 스트림 로드 실패.',
        // New Button & Action Labels
        'button.follow': '팔로우', 'button.unfollow': '언팔로우', 'button.mute': '음소거', 'button.unmute': '음소거 해제', 'button.muteUser': '사용자 음소거', 'button.unmuteUser': '음소거 해제', 'button.confirm': '확인', 'button.cancel': '취소', 'button.close': '닫기', 'button.boost': '부스트', 'button.zap': 'Zap', 'button.viewMore': '더 보기', 'button.viewAnalytics': '통계 보기', 'button.backToMyVideos': '내 동영상으로 돌아가기', 'button.editDraft': '초안 편집', 'button.deleteDraft': '초안 삭제', 'button.editVideo': '동영상 편집', 'button.deleteVideo': '동영상 삭제', 'button.editShort': '쇼츠 편집', 'button.deleteShort': '쇼츠 삭제', 'button.editStream': '방송 편집', 'button.endStream': '방송 종료', 'button.reset': '초기화', 'button.download': '다운로드', 'button.watchRecording': '녹화 보기', 'button.show': '표시', 'button.login': '로그인', 'button.toggleChat': '채팅 전환', 'button.blockVideo': '동영상 차단', 'button.blockUser': '사용자 차단', 'button.unblock': '차단 해제', 'button.removeFromHistory': '기록에서 삭제',
        // New Stats & Counts
        'stat.views': '조회', 'stat.viewsCount': '{count}회 조회', 'stat.videos': '개 동영상', 'stat.video': '개 동영상', 'stat.followers': '팔로워', 'stat.follower': '팔로워', 'stat.following': '팔로잉', 'stat.subscribers': '구독자', 'stat.comments': '댓글', 'stat.liveCount': '{count}개 라이브', 'stat.percentOfGoal': '목표의 {percent}%', 'stat.netGrowth': '순증가', 'stat.newFollowers': '신규 팔로워', 'stat.unfollowed': '언팔로우', 'stat.lastUpdated': '최종 업데이트: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': '라이브', 'badge.ended': '종료됨', 'badge.scheduled': '예정됨', 'badge.warning': '경고', 'badge.communityWarning': '커뮤니티 경고', 'badge.verifiedNip05': 'NIP-05 인증됨', 'badge.streamer': '스트리머', 'badge.clickToView': '클릭하여 보기',
        // New Actions
        'action.report': '신고', 'action.reportComment': '댓글 신고', 'action.reportVideo': '이 동영상 신고', 'action.reportStream': '이 방송 신고', 'action.like': '좋아요', 'action.dislike': '싫어요', 'action.reply': '답글',
        // New Placeholders
        'placeholder.searchHistory': '기록 검색...', 'placeholder.searchUsers': '사용자 검색...', 'placeholder.searchMyVideos': '내 동영상 검색...', 'placeholder.eventId': '이벤트 ID 입력 (hex 또는 nevent/note)', 'placeholder.pubkey': 'pubkey 입력 (hex 또는 npub)', 'placeholder.customAmount': '사용자 지정 금액', 'placeholder.chatEnded': '채팅 종료 - 방송이 종료되었습니다', 'placeholder.addComment': '댓글 추가...', 'placeholder.setNewGoal': '새 목표 설정 (sats)',
        // New Video & Content
        'video.untitledVideo': '제목 없는 동영상', 'video.untitledShort': '제목 없는 쇼츠', 'video.upNext': '다음 동영상', 'video.noVideosYet': '아직 동영상이 없습니다', 'video.noShortsYet': '아직 쇼츠가 없습니다', 'video.noLiveStreamsYet': '아직 라이브 방송이 없습니다', 'video.noBlockedVideos': '차단된 동영상 없음', 'video.noBlockedUsers': '차단된 사용자 없음',
        // New Stream Messages
        'stream.ended': '이 방송이 종료되었습니다. 채팅이 닫혔습니다.', 'stream.welcomeChat': '라이브 채팅에 오신 것을 환영합니다!', 'stream.goalReached': '목표 달성!', 'stream.zapGoalReached': 'Zap 목표 달성! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': '음소거된 사용자의 메시지', 'muted.commentFromMutedUserHidden': '음소거된 사용자의 댓글이 숨겨짐', 'muted.commentHidden': '댓글이 숨겨짐 ({packs})', 'muted.messageHidden': '메시지가 숨겨짐 ({packs})', 'muted.commentReportedByFollows': '팔로우하는 사람들이 신고한 댓글', 'muted.messageReportedByFollows': '팔로우하는 사람들이 신고한 메시지', 'muted.commentHeavilyDownvoted': '커뮤니티에서 많이 비추천된 댓글', 'muted.messageHeavilyDownvoted': '많이 비추천된 메시지',
        // New Admin & Lists
        'list.blockedVideos': '차단된 동영상', 'list.blockedUsers': '차단된 사용자',
        // New Alerts
        'alert.cameraNotSupported': '이 브라우저에서는 카메라 액세스가 지원되지 않습니다. Chrome, Firefox, Safari 등 최신 브라우저를 사용하세요.', 'alert.noCameraFound': '카메라를 찾을 수 없습니다. 카메라를 연결하거나 파일 업로드 옵션을 사용하세요.', 'alert.cameraAccessDenied': '카메라 액세스가 거부되었습니다. 브라우저 설정에서 카메라를 허용하세요.', 'alert.cameraInUse': '카메라가 다른 애플리케이션에서 사용 중입니다. 다른 앱을 닫아주세요.', 'alert.cameraUnableAccess': '카메라에 액세스할 수 없습니다. 파일 업로드 옵션을 시도하세요.', 'alert.cameraUnableAccessWithError': '카메라에 액세스할 수 없습니다: {error}\n\n파일 업로드 옵션을 사용하세요.', 'alert.fillRequiredFields': '모든 필수 필드를 입력하세요', 'alert.uploadThumbnail': '방송 썸네일을 업로드하세요', 'alert.failedCreateStream': '라이브 방송 생성 실패. 다시 시도하세요.', 'alert.failedUpdateStream': '업데이트 실패. 다시 시도하세요.', 'alert.streamNotFound': '방송을 찾을 수 없습니다', 'alert.canOnlyEditOwnStreams': '자신의 방송만 편집할 수 있습니다', 'alert.invalidStreamData': '잘못된 방송 데이터', 'alert.enterValidGoalAmount': '유효한 목표 금액을 입력하세요', 'alert.canOnlyResetOwnGoals': '자신의 목표만 초기화할 수 있습니다', 'alert.streamEventNotFound': '방송 이벤트를 찾을 수 없습니다', 'alert.failedResetZapGoal': 'Zap 목표 초기화 실패. 다시 시도하세요.', 'alert.cannotBlockAdmin': '관리자 계정은 차단할 수 없습니다', 'alert.analyticsLoadFailed': '통계 로드 실패. 다시 시도하세요.', 'alert.cannotReplaceShortWithVideo': '쇼츠를 일반 동영상으로 대체할 수 없습니다. 세로 동영상(60초 이하)을 업로드하세요.', 'alert.cannotReplaceVideoWithShort': '일반 동영상을 쇼츠로 대체할 수 없습니다. 가로 동영상을 업로드하세요.', 'alert.shortsRequireVertical': '이 동영상은 가로 동영상인 것 같습니다. 쇼츠는 세로 동영상이어야 합니다. 가로 동영상은 "동영상 업로드"를 사용하세요.',
        // New Zap Messages
        'zap.cannotZapYourself': '자신에게 Zap을 보낼 수 없습니다', 'zap.cannotZapOwnContent': '자신의 콘텐츠에 Zap을 보낼 수 없습니다', 'zap.cannotZapOwnComment': '자신의 댓글에 Zap을 보낼 수 없습니다', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': '동영상 로딩 중...', 'status.loading': '로딩 중...', 'status.compressingProgress': '압축 중... {progress}%', 'status.uploadingProgress': '업로드 중... {progress}%', 'status.uploadingServers': '업로드 중... ({completed}/{total} 서버)', 'status.publishedSuccess': '{type}이(가) 성공적으로 게시되었습니다!',
        // New Warnings
        'warning.webmFormat': '참고: 브라우저는 WebM 형식을 출력합니다(iOS에서 재생되지 않을 수 있음). iOS 호환 MP4의 경우 Windows/Mac의 Chrome을 사용하세요.',
        // New Footer
        'footer.lastUpdated': '최종 업데이트: 2024년 12월',
    },
    ar: {
        // Navigation & Header
        'nav.home': 'الرئيسية', 'nav.following': 'المتابَعون', 'nav.myVideos': 'مقاطعي', 'nav.liked': 'الإعجابات', 'nav.history': 'السجل', 'nav.topics': 'المواضيع', 'nav.live': 'مباشر', 'nav.bitcoin': 'بتكوين', 'nav.nostr': 'Nostr', 'nav.technology': 'تقنية', 'nav.gaming': 'ألعاب', 'nav.tutorials': 'دروس', 'nav.podcasts': 'بودكاست', 'nav.music': 'موسيقى', 'nav.nsfw': 'NSFW', 'nav.about': 'حول', 'nav.contact': 'اتصل', 'nav.terms': 'الشروط', 'nav.privacy': 'الخصوصية', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': 'البث المباشر', 'nav.github': 'GitHub',
        'header.search': 'بحث عن مقاطع...', 'header.notifications': 'الإشعارات', 'header.settings': 'الإعدادات', 'header.create': 'إنشاء', 'header.viewProfile': 'عرض الملف', 'header.logout': 'تسجيل خروج',
        // Login Modal
        'login.title': 'تسجيل الدخول عبر Nostr', 'login.extensionButton': 'تسجيل الدخول بإضافة Nostr', 'login.extensionDesc': 'استخدم إضافة التوقيع (Alby, nos2x, إلخ)', 'login.orDivider': 'أو', 'login.nsecLabel': 'تسجيل الدخول بالمفتاح الخاص (nsec)', 'login.nsecPlaceholder': 'أدخل nsec...', 'login.nsecButton': 'تسجيل الدخول بـ nsec', 'login.nsecWarning': 'تحذير: إدخال nsec مباشرة أقل أماناً من استخدام الإضافة. يرجى استخدام إضافة NIP-07 للحصول على أمان أفضل.', 'login.newToNostr': 'جديد على Nostr؟', 'login.createAccount': 'إنشاء حساب', 'login.learnMore': 'تعرف على المزيد عن Nostr',
        // Connect Modal
        'connect.title': 'الاتصال بـ Nostr', 'connect.or': 'أو', 'connect.extensionButton': 'توصيل إضافة Nostr', 'connect.extensionDesc': 'استخدم إضافة (Alby, nos2x, إلخ)', 'connect.nsecLabel': 'تسجيل الدخول بالمفتاح الخاص', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'الاتصال بـ nsec', 'connect.nsecWarning': 'تحذير: إدخال nsec مباشرة أقل أماناً. استخدم إضافة NIP-07 للحصول على أمان أفضل.', 'connect.newToNostr': 'جديد على Nostr؟', 'connect.createAccount': 'إنشاء حساب',
        // Private Key Modal
        'privateKey.title': 'مفتاحك الخاص', 'privateKey.warning': 'مهم: احفظ هذا في مكان آمن. إذا فقدت هذا المفتاح، ستفقد الوصول إلى حسابك. لا تشاركه مع أي شخص!', 'privateKey.show': 'إظهار المفتاح الخاص', 'privateKey.hide': 'إخفاء المفتاح الخاص', 'privateKey.copy': 'نسخ', 'privateKey.saved': 'لقد حفظت مفتاحي', 'privateKey.yourPublicKey': 'مفتاحك العام (npub):', 'privateKey.yourPrivateKey': 'مفتاحك الخاص (nsec):',
        // Signup Modal
        'signup.title': 'إنشاء حساب Nostr', 'signup.whatIsNostr': 'ما هو Nostr؟', 'signup.nostrDescription': 'Nostr هو بروتوكول لامركزي يمنحك التحكم في هويتك وبياناتك. لا يوجد خادم مركزي - حسابك هو زوج من المفاتيح المشفرة.', 'signup.whyNostr': 'لماذا Nostr؟', 'signup.benefit1': 'امتلك هويتك', 'signup.benefit2': 'بدون رقابة', 'signup.benefit3': 'قابلية النقل عبر المنصات', 'signup.createNew': 'إنشاء حساب جديد', 'signup.haveAccount': 'لديك حساب؟', 'signup.login': 'تسجيل الدخول', 'signup.createButton': 'إنشاء حساب', 'signup.generating': 'جاري إنشاء المفاتيح...', 'signup.displayName': 'الاسم المعروض', 'signup.displayNamePlaceholder': 'أدخل الاسم المعروض', 'signup.username': 'اسم المستخدم', 'signup.usernamePlaceholder': 'أدخل اسم المستخدم',
        // Notifications
        'notifications.title': 'الإشعارات', 'notifications.empty': 'لا توجد إشعارات', 'notifications.viewAll': 'عرض جميع الإشعارات', 'notifications.markAllRead': 'تحديد الكل كمقروء', 'notifications.settings': 'إعدادات الإشعارات', 'notifications.loading': 'جاري تحميل الإشعارات...', 'notifications.zap': 'أرسل لك زاب', 'notifications.like': 'أعجب بالمحتوى', 'notifications.comment': 'علق', 'notifications.follow': 'تابعك', 'notifications.repost': 'أعاد النشر', 'notifications.mention': 'ذكرك',
        // Settings Modal
        'settings.title': 'الإعدادات', 'settings.language': 'اللغة', 'settings.languageDesc': 'اختر لغتك', 'settings.saveToNostr': 'حفظ في Nostr', 'settings.darkMode': 'الوضع الداكن', 'settings.darkModeDesc': 'تبديل السمة الداكنة/الفاتحة', 'settings.autoplay': 'التشغيل التلقائي', 'settings.autoplayDesc': 'تشغيل الفيديو تلقائياً', 'settings.saveSettings': 'حفظ الإعدادات', 'settings.resetDefaults': 'إعادة تعيين', 'settings.notifications': 'الإشعارات', 'settings.notificationsDesc': 'تلقي إشعارات الدفع', 'settings.quality': 'الجودة الافتراضية', 'settings.qualityDesc': 'جودة تشغيل الفيديو',
        // Upload Modal
        'upload.title': 'رفع فيديو', 'upload.dragDrop': 'اسحب وأفلت ملف الفيديو هنا', 'upload.or': 'أو', 'upload.browse': 'تصفح الملفات', 'upload.supportedFormats': 'الصيغ المدعومة: MP4, WebM, MOV', 'upload.maxSize': 'الحجم الأقصى: 2GB', 'upload.videoTitle': 'العنوان', 'upload.titlePlaceholder': 'أدخل عنوان الفيديو', 'upload.description': 'الوصف', 'upload.descriptionPlaceholder': 'صف الفيديو...', 'upload.tags': 'الوسوم', 'upload.tagsPlaceholder': 'أضف وسوماً مفصولة بفواصل', 'upload.visibility': 'الظهور', 'upload.public': 'عام', 'upload.unlisted': 'غير مدرج', 'upload.uploadButton': 'رفع الفيديو', 'upload.uploading': 'جاري الرفع...', 'upload.processing': 'جاري المعالجة...', 'upload.complete': 'اكتمل!', 'upload.error': 'فشل الرفع', 'upload.nsfw': 'محتوى للبالغين', 'upload.nsfwDesc': 'تحديد كمحتوى للبالغين', 'upload.thumbnail': 'الصورة المصغرة', 'upload.thumbnailDesc': 'رفع صورة مصغرة', 'upload.preparing': 'جاري التحضير...', 'upload.cancel': 'إلغاء', 'upload.progress': 'تقدم الرفع', 'upload.transcoding': 'التحويل', 'upload.status.preparing': 'جاري تحضير الرفع...', 'upload.status.uploading': 'جاري رفع الفيديو...', 'upload.status.transcoding': 'جاري تحويل الفيديو...', 'upload.status.complete': 'اكتمل الرفع!', 'upload.qualityHigh': 'عالية', 'upload.qualityMedium': 'متوسطة', 'upload.qualityLow': 'منخفضة',
        // Create Modal
        'create.title': 'إنشاء', 'create.uploadVideo': 'رفع فيديو', 'create.uploadDesc': 'مشاركة فيديو', 'create.goLive': 'بث مباشر', 'create.goLiveDesc': 'بدء بث مباشر', 'create.createPost': 'إنشاء منشور', 'create.createPostDesc': 'مشاركة نص',
        // Go Live Modal
        'goLive.title': 'بث مباشر', 'goLive.streamTitle': 'عنوان البث', 'goLive.streamTitlePlaceholder': 'أدخل عنوان البث', 'goLive.description': 'الوصف', 'goLive.descriptionPlaceholder': 'صف البث...', 'goLive.category': 'الفئة', 'goLive.selectCategory': 'اختر فئة', 'goLive.tags': 'الوسوم', 'goLive.tagsPlaceholder': 'أضف وسوماً مفصولة بفواصل', 'goLive.startStream': 'بدء البث', 'goLive.streamKey': 'مفتاح البث', 'goLive.streamUrl': 'رابط البث', 'goLive.copy': 'نسخ', 'goLive.hideKey': 'إخفاء المفتاح', 'goLive.showKey': 'إظهار المفتاح', 'goLive.connecting': 'جاري الاتصال...', 'goLive.live': 'مباشر', 'goLive.offline': 'غير متصل', 'goLive.viewers': 'مشاهدين', 'goLive.endStream': 'إنهاء البث', 'goLive.nsfw': 'محتوى للبالغين', 'goLive.nsfwDesc': 'تحديد كمحتوى للبالغين', 'goLive.thumbnail': 'صورة البث', 'goLive.thumbnailDesc': 'رفع صورة مصغرة',
        // Edit Stream Modal
        'editStream.title': 'تعديل البث', 'editStream.save': 'حفظ التغييرات',
        // NSFW Warning Modal
        'nsfw.title': 'تحذير: محتوى للبالغين', 'nsfw.warning': 'تم تحديد هذا المحتوى كـ NSFW وقد يحتوي على محتوى للبالغين.', 'nsfw.confirm': 'تأكيد عمرك', 'nsfw.confirmAge': 'عمري 18 سنة أو أكثر', 'nsfw.cancel': 'رجوع', 'nsfw.continue': 'متابعة', 'nsfw.dontShowAgain': 'عدم إظهار هذا التحذير مرة أخرى',
        // Community Warning Modal
        'community.title': 'إرشادات المجتمع', 'community.warning': 'يرجى مراجعة إرشادات المجتمع قبل المتابعة.', 'community.guidelines': 'كن محترماً واتبع معايير المجتمع.', 'community.accept': 'قبول', 'community.decline': 'رفض',
        // Report Modal
        'report.title': 'الإبلاغ عن محتوى', 'report.reason': 'سبب الإبلاغ', 'report.selectReason': 'اختر سبباً', 'report.spam': 'بريد مزعج أو مضلل', 'report.inappropriate': 'محتوى غير لائق', 'report.violence': 'محتوى عنيف أو خطير', 'report.copyright': 'انتهاك حقوق النشر', 'report.other': 'آخر', 'report.details': 'التفاصيل', 'report.detailsPlaceholder': 'قدم مزيداً من التفاصيل...', 'report.submit': 'إرسال البلاغ', 'report.cancel': 'إلغاء',
        // Share Modal
        'share.title': 'مشاركة', 'share.copyLink': 'نسخ الرابط', 'share.embed': 'كود التضمين', 'share.copyEmbed': 'نسخ كود التضمين', 'share.social': 'مشاركة على الشبكات الاجتماعية', 'share.twitter': 'تويتر', 'share.facebook': 'فيسبوك', 'share.reddit': 'ريديت', 'share.telegram': 'تيليجرام', 'share.whatsapp': 'واتساب', 'share.email': 'بريد إلكتروني', 'share.copied': 'تم النسخ!', 'share.nostr': 'مشاركة على Nostr', 'share.generateImage': 'إنشاء صورة', 'share.downloadImage': 'تحميل', 'share.shareImage': 'مشاركة', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (مربع)', 'share.size1080x1920': '1080 × 1920 (قصص)',
        // Edit Video Modal
        'editVideo.title': 'تعديل الفيديو', 'editVideo.videoTitle': 'العنوان', 'editVideo.description': 'الوصف', 'editVideo.tags': 'الوسوم', 'editVideo.thumbnail': 'الصورة المصغرة', 'editVideo.changeThumbnail': 'تغيير الصورة المصغرة', 'editVideo.visibility': 'الظهور', 'editVideo.nsfw': 'محتوى للبالغين', 'editVideo.save': 'حفظ التغييرات', 'editVideo.delete': 'حذف الفيديو', 'editVideo.confirmDelete': 'هل أنت متأكد من حذف هذا الفيديو؟',
        // Edit Profile Modal
        'editProfile.title': 'تعديل الملف الشخصي', 'editProfile.displayName': 'الاسم المعروض', 'editProfile.displayNamePlaceholder': 'أدخل الاسم المعروض', 'editProfile.username': 'اسم المستخدم', 'editProfile.usernamePlaceholder': 'أدخل اسم المستخدم', 'editProfile.about': 'نبذة', 'editProfile.aboutPlaceholder': 'أخبرنا عن نفسك...', 'editProfile.website': 'الموقع', 'editProfile.websitePlaceholder': 'https://yourwebsite.com', 'editProfile.lightning': 'عنوان Lightning', 'editProfile.lightningPlaceholder': 'you@getalby.com', 'editProfile.nip05': 'توثيق NIP-05', 'editProfile.nip05Placeholder': 'you@domain.com', 'editProfile.avatar': 'الصورة الرمزية', 'editProfile.changeAvatar': 'تغيير الصورة الرمزية', 'editProfile.banner': 'الغلاف', 'editProfile.changeBanner': 'تغيير الغلاف', 'editProfile.save': 'حفظ الملف الشخصي',
        // Confirmation Modal
        'confirm.title': 'تأكيد الإجراء', 'confirm.message': 'هل أنت متأكد من المتابعة؟', 'confirm.confirm': 'تأكيد', 'confirm.cancel': 'إلغاء',
        // Video Page
        'video.views': 'مشاهدات', 'video.like': 'إعجاب', 'video.dislike': 'عدم إعجاب', 'video.share': 'مشاركة', 'video.save': 'حفظ', 'video.report': 'إبلاغ', 'video.follow': 'متابعة', 'video.unfollow': 'إلغاء المتابعة', 'video.subscribe': 'اشتراك', 'video.subscribed': 'مشترك', 'video.comments': 'التعليقات', 'video.addComment': 'أضف تعليقاً...', 'video.reply': 'رد', 'video.replies': 'ردود', 'video.loadMore': 'تحميل المزيد', 'video.noComments': 'لا توجد تعليقات. كن أول من يعلق!', 'video.zap': 'زاب', 'video.zapAmount': 'مبلغ الزاب (ساتوشي)', 'video.sendZap': 'إرسال زاب', 'video.boost': 'تعزيز', 'video.description': 'الوصف', 'video.showMore': 'عرض المزيد', 'video.showLess': 'عرض أقل', 'video.publishedOn': 'نُشر في',
        // Toast Messages
        'toast.loggedIn': 'تم تسجيل الدخول!', 'toast.loggedOut': 'تم تسجيل الخروج', 'toast.settingsSaved': 'تم حفظ الإعدادات!', 'toast.settingsReset': 'تم إعادة تعيين الإعدادات', 'toast.videoUploaded': 'تم رفع الفيديو!', 'toast.videoDeleted': 'تم حذف الفيديو', 'toast.profileUpdated': 'تم تحديث الملف الشخصي!', 'toast.linkCopied': 'تم نسخ الرابط!', 'toast.embedCopied': 'تم نسخ كود التضمين!', 'toast.zapSent': 'تم إرسال الزاب!', 'toast.followed': 'تمت المتابعة!', 'toast.unfollowed': 'تم إلغاء المتابعة', 'toast.reported': 'تم إرسال البلاغ', 'toast.saved': 'تم الحفظ!', 'toast.error': 'حدث خطأ', 'toast.networkError': 'خطأ في الشبكة. حاول مرة أخرى.', 'toast.uploadError': 'فشل الرفع. حاول مرة أخرى.', 'toast.languageChanged': 'تم تغيير اللغة', 'toast.commentPosted': 'تم نشر التعليق', 'toast.keyCopied': 'تم نسخ المفتاح!',
        // Time
        'time.now': 'الآن', 'time.minutesAgo': 'منذ {count} دقيقة', 'time.hoursAgo': 'منذ {count} ساعة', 'time.daysAgo': 'منذ {count} يوم', 'time.weeksAgo': 'منذ {count} أسبوع', 'time.monthsAgo': 'منذ {count} شهر', 'time.yearsAgo': 'منذ {count} سنة',
        // Empty States
        'empty.noVideos': 'لم يتم العثور على فيديوهات', 'empty.noVideosDesc': 'جرب بحثاً آخر', 'empty.noFollowing': 'لم تتابع أي شخص بعد', 'empty.noFollowingDesc': 'تابع المبدعين لمشاهدة فيديوهاتهم', 'empty.noHistory': 'لا يوجد سجل مشاهدة', 'empty.noHistoryDesc': 'الفيديوهات التي تشاهدها ستظهر هنا', 'empty.noLiked': 'لا توجد فيديوهات أعجبتك', 'empty.noLikedDesc': 'الفيديوهات التي تعجبك ستظهر هنا', 'empty.noResults': 'لم يتم العثور على نتائج', 'empty.noResultsDesc': 'جرب كلمات مفتاحية أخرى',
        // Misc
        'misc.loading': 'جار التحميل...', 'misc.loadingMore': 'جار تحميل المزيد...', 'misc.refresh': 'تحديث', 'misc.retry': 'إعادة المحاولة', 'misc.close': 'إغلاق', 'misc.back': 'رجوع', 'misc.next': 'التالي', 'misc.previous': 'السابق', 'misc.search': 'بحث', 'misc.filter': 'تصفية', 'misc.sort': 'ترتيب', 'misc.newest': 'الأحدث', 'misc.oldest': 'الأقدم', 'misc.popular': 'الأكثر شعبية', 'misc.trending': 'الرائج', 'misc.sats': 'ساتوشي', 'misc.all': 'الكل', 'misc.copiedToClipboard': 'تم النسخ!',
        // Common
        'common.submit': 'إرسال', 'common.cancel': 'إلغاء', 'common.save': 'حفظ', 'common.delete': 'حذف', 'common.edit': 'تعديل', 'common.close': 'إغلاق', 'common.confirm': 'تأكيد', 'common.yes': 'نعم', 'common.no': 'لا', 'common.ok': 'حسناً', 'common.loading': 'جار التحميل...', 'common.uploading': 'جار الرفع...', 'common.error': 'خطأ', 'common.success': 'نجاح',
        // Aria Labels
        'aria.toggleMenu': 'تبديل القائمة', 'aria.mainNavigation': 'التنقل الرئيسي', 'aria.videoContent': 'محتوى الفيديو', 'aria.loadingContent': 'جار تحميل المحتوى', 'aria.closeModal': 'إغلاق النافذة', 'aria.playVideo': 'تشغيل الفيديو', 'aria.pauseVideo': 'إيقاف الفيديو', 'aria.muteVideo': 'كتم الصوت', 'aria.unmuteVideo': 'إلغاء الكتم', 'aria.fullscreen': 'ملء الشاشة', 'aria.exitFullscreen': 'الخروج من ملء الشاشة', 'aria.settings': 'الإعدادات', 'aria.notifications': 'الإشعارات', 'aria.userMenu': 'قائمة المستخدم', 'aria.searchInput': 'بحث عن فيديو', 'aria.videoPlayer': 'مشغل الفيديو',
        // Dynamic JavaScript text
        'button.hideQR': 'إخفاء رمز QR', 'button.showQR': 'إظهار رمز QR', 'button.copied': 'تم النسخ!', 'button.showLess': 'إظهار أقل', 'button.showMore': 'إظهار المزيد', 'button.creatingAccount': 'جار إنشاء الحساب...', 'button.submitting': 'جار الإرسال...', 'button.scheduleStream': 'جدولة البث', 'button.goLive': 'بدء البث', 'button.creatingStream': 'جار إنشاء البث...', 'button.continueCustomAmount': 'متابعة بمبلغ مخصص', 'button.recordFromCamera': 'تسجيل من الكاميرا', 'button.requestingCamera': 'جار طلب الكاميرا...', 'button.recording': 'جار التسجيل...',
        'status.saving': 'جار الحفظ...', 'status.saved': 'تم الحفظ!', 'status.uploading': 'جار الرفع...', 'status.uploadComplete': 'اكتمل الرفع!', 'status.uploadingToNostrBuild': 'جار الرفع إلى nostr.build...', 'status.publishingChanges': 'جار نشر التغييرات...', 'status.removingOldVersion': 'جار إزالة النسخة القديمة...', 'status.validatingThumbnail': 'جار التحقق من الصورة المصغرة...', 'status.uploadingThumbnail': 'جار رفع الصورة المصغرة...', 'status.thumbnailUploaded': 'تم رفع الصورة المصغرة!', 'status.processingVideo': 'جار معالجة الفيديو...', 'status.compressingVideo': 'جار ضغط الفيديو...', 'status.uploadingVideo': 'جار رفع الفيديو...', 'status.videoUploaded': 'تم رفع الفيديو بنجاح!', 'status.processing': 'جار المعالجة...', 'status.generatingThumbnail': 'جار إنشاء الصورة المصغرة...', 'status.generatingPreview': 'جار إنشاء المعاينة...', 'status.uploadingPreview': 'جار رفع المعاينة...', 'status.publishing': 'جار النشر...', 'status.publishingToNostr': 'جار النشر على Nostr...', 'status.publishingVideoToNostr': 'جار نشر الفيديو على Nostr...', 'status.generatingPoW': 'جار إنشاء إثبات العمل...', 'status.posting': 'جار النشر...', 'status.processingVideoAndThumbnail': 'جار معالجة الفيديو والصورة المصغرة...', 'status.uploadFailed': 'فشل الرفع - حاول مجدداً', 'status.selectVideoToUpload': 'اختر فيديو للرفع', 'status.waitingForVideoUpload': 'في انتظار رفع الفيديو...', 'status.selectVideoAndThumbnail': 'اختر الفيديو والصورة المصغرة للنشر', 'status.ready': 'جاهز ✓', 'status.failed': 'فشل ✗', 'status.fromDraft': 'من المسودة', 'status.startingNow': 'يبدأ الآن!', 'status.ended': 'انتهى', 'status.thumbnailReady': 'جاهز', 'status.thumbnailFailed': 'فشل', 'status.uploadFailedRetry': 'فشل الرفع. حاول مجدداً.',
        'publish.video': 'نشر الفيديو', 'publish.autoThumbnail': 'نشر الفيديو (صورة مصغرة تلقائية)',
        'report.titleComment': 'الإبلاغ عن تعليق', 'report.titleUser': 'الإبلاغ عن مستخدم', 'report.titleVideo': 'الإبلاغ عن فيديو', 'report.descComment': 'اختر سبب الإبلاغ عن هذا التعليق:', 'report.descUser': 'اختر سبب الإبلاغ عن هذا المستخدم:', 'report.descVideo': 'اختر سبب الإبلاغ عن هذا المحتوى:',
        'empty.noMutedUsers': 'لا يوجد مستخدمون مكتومون.', 'empty.noVideosToMonitor': 'لا توجد فيديوهات للمراقبة.', 'empty.noRecentActivity': 'لا يوجد نشاط حديث.', 'empty.failedLoadNotifications': 'فشل تحميل الإشعارات', 'empty.loginToViewLiked': 'يرجى <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">تسجيل الدخول</a> لعرض الفيديوهات المفضلة.', 'empty.loginToViewFollowing': 'يرجى <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">تسجيل الدخول</a> لعرض المتابَعين.', 'empty.loginToViewVideos': 'يرجى <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">تسجيل الدخول</a> لعرض فيديوهاتك.', 'empty.loginToViewAnalytics': 'يرجى <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">تسجيل الدخول</a> لعرض الإحصائيات.', 'empty.noLikedVideosYet': 'لم تعجب بأي فيديو بعد.', 'empty.noLikedVideosFound': 'لم يتم العثور على فيديوهات مفضلة.', 'empty.noFullLengthLikedVideos': 'لم يتم العثور على فيديوهات طويلة مفضلة.', 'empty.noWatchHistory': 'لا يوجد سجل مشاهدة. ابدأ مشاهدة الفيديوهات.', 'empty.noVideosInHistory': 'لا توجد فيديوهات في السجل.', 'empty.noFullLengthHistory': 'لا توجد فيديوهات طويلة في السجل.', 'empty.noMatchingVideos': 'لم يتم العثور على فيديوهات مطابقة.', 'empty.noFullLengthVideos': 'لم يتم العثور على فيديوهات طويلة.', 'empty.failedLoadTrending': 'فشل تحميل الرائج.', 'empty.noTrendingVideos': 'لم يتم العثور على فيديوهات رائجة.', 'empty.noMatchingUsers': 'لم يتم العثور على مستخدمين مطابقين.', 'empty.unableLoadProfiles': 'تعذر تحميل الملفات الشخصية.', 'empty.noFollowingVideos': 'لا توجد فيديوهات من المتابَعين.', 'empty.noFullLengthFollowing': 'لا توجد فيديوهات طويلة من المتابَعين.', 'empty.failedLoadFollowing': 'فشل التحميل. حاول مجدداً.', 'empty.noVideosUploadFirst': 'لا توجد فيديوهات. ارفع أول فيديو!', 'empty.noFullLengthUploaded': 'لم يتم العثور على فيديوهات طويلة.', 'empty.noMatchingLiveStreams': 'لم يتم العثور على بث مباشر مطابق.', 'empty.noMatchingShorts': 'لم يتم العثور على فيديوهات قصيرة مطابقة.', 'empty.noVideosForTag': 'لا توجد فيديوهات لهذا الوسم.', 'empty.noFullLengthForTag': 'لا توجد فيديوهات طويلة لهذا الوسم.', 'empty.noUploadedVideos': 'لم يتم رفع فيديوهات بعد.', 'empty.noVideosFound': 'لم يتم العثور على فيديوهات.', 'empty.failedLoadProfile': 'فشل تحميل الملف الشخصي. حاول مجدداً.', 'empty.noComments': 'لا توجد تعليقات بعد. كن أول من يعلق!', 'empty.failedLoadComments': 'فشل تحميل التعليقات', 'empty.noLiveNow': 'لا أحد يبث مباشرة الآن. كن الأول!',
        'error.videoNotFound': 'الفيديو غير موجود.', 'error.contentNotAvailable': 'هذا المحتوى غير متاح.', 'error.invalidVideoData': 'بيانات الفيديو غير صالحة.', 'error.videoNotAvailable': 'الفيديو غير متاح. ربما تم حذف الملف.', 'error.failedLoadVideo': 'فشل تحميل الفيديو. حاول مجدداً.', 'error.failedLoadVideoShort': 'فشل التحميل. ربما تم حذف الملف.', 'error.liveStreamNotFound': 'البث المباشر غير موجود.', 'error.invalidLiveStreamData': 'بيانات البث المباشر غير صالحة.', 'error.failedLoadLiveStream': 'فشل تحميل البث المباشر.',
        // New Button & Action Labels
        'button.follow': 'متابعة', 'button.unfollow': 'إلغاء المتابعة', 'button.mute': 'كتم', 'button.unmute': 'إلغاء الكتم', 'button.muteUser': 'كتم المستخدم', 'button.unmuteUser': 'إلغاء كتم المستخدم', 'button.confirm': 'تأكيد', 'button.cancel': 'إلغاء', 'button.close': 'إغلاق', 'button.boost': 'تعزيز', 'button.zap': 'Zap', 'button.viewMore': 'عرض المزيد', 'button.viewAnalytics': 'عرض الإحصائيات', 'button.backToMyVideos': 'العودة إلى فيديوهاتي', 'button.editDraft': 'تعديل المسودة', 'button.deleteDraft': 'حذف المسودة', 'button.editVideo': 'تعديل الفيديو', 'button.deleteVideo': 'حذف الفيديو', 'button.editShort': 'تعديل الشورت', 'button.deleteShort': 'حذف الشورت', 'button.editStream': 'تعديل البث', 'button.endStream': 'إنهاء البث', 'button.reset': 'إعادة تعيين', 'button.download': 'تحميل', 'button.watchRecording': 'مشاهدة التسجيل', 'button.show': 'عرض', 'button.login': 'تسجيل الدخول', 'button.toggleChat': 'تبديل الدردشة', 'button.blockVideo': 'حظر الفيديو', 'button.blockUser': 'حظر المستخدم', 'button.unblock': 'إلغاء الحظر', 'button.removeFromHistory': 'إزالة من السجل',
        // New Stats & Counts
        'stat.views': 'مشاهدات', 'stat.viewsCount': '{count} مشاهدة', 'stat.videos': 'فيديوهات', 'stat.video': 'فيديو', 'stat.followers': 'متابعين', 'stat.follower': 'متابع', 'stat.following': 'متابَعون', 'stat.subscribers': 'مشتركين', 'stat.comments': 'تعليقات', 'stat.liveCount': '{count} مباشر', 'stat.percentOfGoal': '{percent}% من الهدف', 'stat.netGrowth': 'النمو الصافي', 'stat.newFollowers': 'متابعون جدد', 'stat.unfollowed': 'إلغاء المتابعة', 'stat.lastUpdated': 'آخر تحديث: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'مباشر', 'badge.ended': 'انتهى', 'badge.scheduled': 'مجدول', 'badge.warning': 'تحذير', 'badge.communityWarning': 'تحذير المجتمع', 'badge.verifiedNip05': 'NIP-05 موثق', 'badge.streamer': 'مذيع', 'badge.clickToView': 'انقر للعرض',
        // New Actions
        'action.report': 'إبلاغ', 'action.reportComment': 'الإبلاغ عن التعليق', 'action.reportVideo': 'الإبلاغ عن الفيديو', 'action.reportStream': 'الإبلاغ عن البث', 'action.like': 'إعجاب', 'action.dislike': 'عدم إعجاب', 'action.reply': 'رد',
        // New Placeholders
        'placeholder.searchHistory': 'البحث في السجل...', 'placeholder.searchUsers': 'البحث عن مستخدمين...', 'placeholder.searchMyVideos': 'البحث في فيديوهاتي...', 'placeholder.eventId': 'أدخل معرف الحدث (hex أو nevent/note)', 'placeholder.pubkey': 'أدخل pubkey (hex أو npub)', 'placeholder.customAmount': 'مبلغ مخصص', 'placeholder.chatEnded': 'الدردشة مغلقة - انتهى البث', 'placeholder.addComment': 'أضف تعليقاً...', 'placeholder.setNewGoal': 'تعيين هدف جديد (sats)',
        // New Video & Content
        'video.untitledVideo': 'فيديو بدون عنوان', 'video.untitledShort': 'شورت بدون عنوان', 'video.upNext': 'التالي', 'video.noVideosYet': 'لا توجد فيديوهات بعد', 'video.noShortsYet': 'لا توجد شورتات بعد', 'video.noLiveStreamsYet': 'لا توجد بثوث مباشرة بعد', 'video.noBlockedVideos': 'لا توجد فيديوهات محظورة', 'video.noBlockedUsers': 'لا يوجد مستخدمون محظورون',
        // New Stream Messages
        'stream.ended': 'انتهى هذا البث. الدردشة مغلقة الآن.', 'stream.welcomeChat': 'مرحباً في الدردشة المباشرة!', 'stream.goalReached': 'تم تحقيق الهدف!', 'stream.zapGoalReached': 'تم تحقيق هدف Zap! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'رسالة من مستخدم مكتوم', 'muted.commentFromMutedUserHidden': 'تعليق من مستخدم مكتوم مخفي', 'muted.commentHidden': 'تعليق مخفي ({packs})', 'muted.messageHidden': 'رسالة مخفية ({packs})', 'muted.commentReportedByFollows': 'تعليق أبلغ عنه أشخاص تتابعهم', 'muted.messageReportedByFollows': 'رسالة أبلغ عنها أشخاص تتابعهم', 'muted.commentHeavilyDownvoted': 'تعليق حصل على تصويتات سلبية كثيرة', 'muted.messageHeavilyDownvoted': 'رسالة حصلت على تصويتات سلبية كثيرة',
        // New Admin & Lists
        'list.blockedVideos': 'فيديوهات محظورة', 'list.blockedUsers': 'مستخدمون محظورون',
        // New Alerts
        'alert.cameraNotSupported': 'الوصول إلى الكاميرا غير مدعوم في هذا المتصفح. يرجى استخدام متصفح حديث مثل Chrome أو Firefox أو Safari.', 'alert.noCameraFound': 'لم يتم العثور على كاميرا. يرجى توصيل كاميرا أو استخدام خيار رفع الملفات.', 'alert.cameraAccessDenied': 'تم رفض الوصول إلى الكاميرا. يرجى السماح بأذونات الكاميرا في إعدادات المتصفح.', 'alert.cameraInUse': 'الكاميرا قيد الاستخدام بواسطة تطبيق آخر. يرجى إغلاق التطبيقات الأخرى.', 'alert.cameraUnableAccess': 'لا يمكن الوصول إلى الكاميرا. يرجى استخدام خيار الرفع.', 'alert.cameraUnableAccessWithError': 'لا يمكن الوصول إلى الكاميرا: {error}\n\nيرجى استخدام خيار الرفع.', 'alert.fillRequiredFields': 'يرجى ملء جميع الحقول المطلوبة', 'alert.uploadThumbnail': 'يرجى رفع صورة مصغرة للبث', 'alert.failedCreateStream': 'فشل إنشاء البث المباشر. يرجى المحاولة مرة أخرى.', 'alert.failedUpdateStream': 'فشل التحديث. يرجى المحاولة مرة أخرى.', 'alert.streamNotFound': 'لم يتم العثور على البث', 'alert.canOnlyEditOwnStreams': 'يمكنك فقط تعديل بثوثك', 'alert.invalidStreamData': 'بيانات البث غير صالحة', 'alert.enterValidGoalAmount': 'يرجى إدخال مبلغ هدف صالح', 'alert.canOnlyResetOwnGoals': 'يمكنك فقط إعادة تعيين أهدافك', 'alert.streamEventNotFound': 'لم يتم العثور على حدث البث', 'alert.failedResetZapGoal': 'فشل إعادة تعيين هدف Zap. يرجى المحاولة مرة أخرى.', 'alert.cannotBlockAdmin': 'لا يمكن حظر حساب المشرف', 'alert.analyticsLoadFailed': 'فشل تحميل الإحصائيات. يرجى المحاولة مرة أخرى.', 'alert.cannotReplaceShortWithVideo': 'لا يمكن استبدال شورت بفيديو عادي. يرجى رفع فيديو عمودي (60 ثانية أو أقل).', 'alert.cannotReplaceVideoWithShort': 'لا يمكن استبدال فيديو عادي بشورت. يرجى رفع فيديو أفقي.', 'alert.shortsRequireVertical': 'يبدو أن هذا الفيديو أفقي. يجب أن تكون الشورتات فيديوهات عمودية. يرجى استخدام "رفع فيديو" للفيديوهات الأفقية.',
        // New Zap Messages
        'zap.cannotZapYourself': 'لا يمكنك إرسال Zap لنفسك', 'zap.cannotZapOwnContent': 'لا يمكنك إرسال Zap للمحتوى الخاص بك', 'zap.cannotZapOwnComment': 'لا يمكنك إرسال Zap لتعليقك', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'جاري تحميل الفيديو...', 'status.loading': 'جاري التحميل...', 'status.compressingProgress': 'جاري الضغط... {progress}%', 'status.uploadingProgress': 'جاري الرفع... {progress}%', 'status.uploadingServers': 'جاري الرفع... ({completed}/{total} خوادم)', 'status.publishedSuccess': 'تم نشر {type} بنجاح!',
        // New Warnings
        'warning.webmFormat': 'ملاحظة: سيخرج متصفحك بتنسيق WebM (قد لا يعمل على iOS). للحصول على MP4 متوافق مع iOS، استخدم Chrome على Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'آخر تحديث: ديسمبر 2024',
    },
    hi: {
        // Navigation & Header
        'nav.home': 'होम', 'nav.following': 'फॉलोइंग', 'nav.myVideos': 'मेरे वीडियो', 'nav.liked': 'पसंद किए', 'nav.history': 'इतिहास', 'nav.topics': 'विषय', 'nav.live': 'लाइव', 'nav.bitcoin': 'बिटकॉइन', 'nav.nostr': 'Nostr', 'nav.technology': 'तकनीक', 'nav.gaming': 'गेमिंग', 'nav.tutorials': 'ट्यूटोरियल', 'nav.podcasts': 'पॉडकास्ट', 'nav.music': 'संगीत', 'nav.nsfw': 'NSFW', 'nav.about': 'के बारे में', 'nav.contact': 'संपर्क', 'nav.terms': 'शर्तें', 'nav.privacy': 'गोपनीयता', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': 'लाइव स्ट्रीम', 'nav.github': 'GitHub',
        'header.search': 'वीडियो खोजें...', 'header.notifications': 'सूचनाएं', 'header.settings': 'सेटिंग्स', 'header.create': 'बनाएं', 'header.viewProfile': 'प्रोफ़ाइल देखें', 'header.logout': 'लॉग आउट',
        // Login Modal
        'login.title': 'Nostr से लॉग इन करें', 'login.extensionButton': 'Nostr एक्सटेंशन से लॉग इन करें', 'login.extensionDesc': 'साइनिंग एक्सटेंशन का उपयोग करें (Alby, nos2x, आदि)', 'login.orDivider': 'या', 'login.nsecLabel': 'प्राइवेट की से लॉग इन करें (nsec)', 'login.nsecPlaceholder': 'nsec दर्ज करें...', 'login.nsecButton': 'nsec से लॉग इन करें', 'login.nsecWarning': 'चेतावनी: nsec सीधे दर्ज करना एक्सटेंशन की तुलना में कम सुरक्षित है। बेहतर सुरक्षा के लिए NIP-07 एक्सटेंशन का उपयोग करें।', 'login.newToNostr': 'Nostr पर नए हैं?', 'login.createAccount': 'खाता बनाएं', 'login.learnMore': 'Nostr के बारे में और जानें',
        // Connect Modal
        'connect.title': 'Nostr से कनेक्ट करें', 'connect.or': 'या', 'connect.extensionButton': 'Nostr एक्सटेंशन कनेक्ट करें', 'connect.extensionDesc': 'एक्सटेंशन का उपयोग करें (Alby, nos2x, आदि)', 'connect.nsecLabel': 'प्राइवेट की से लॉग इन करें', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'nsec से कनेक्ट करें', 'connect.nsecWarning': 'चेतावनी: nsec सीधे दर्ज करना कम सुरक्षित है। बेहतर सुरक्षा के लिए NIP-07 एक्सटेंशन का उपयोग करें।', 'connect.newToNostr': 'Nostr पर नए हैं?', 'connect.createAccount': 'खाता बनाएं',
        // Private Key Modal
        'privateKey.title': 'आपकी प्राइवेट की', 'privateKey.warning': 'महत्वपूर्ण: इसे सुरक्षित जगह पर सहेजें। यदि आप यह की खो देते हैं, तो आप अपने खाते तक पहुंच खो देंगे। इसे किसी के साथ साझा न करें!', 'privateKey.show': 'प्राइवेट की दिखाएं', 'privateKey.hide': 'प्राइवेट की छुपाएं', 'privateKey.copy': 'कॉपी करें', 'privateKey.saved': 'मैंने अपनी की सहेज ली है', 'privateKey.yourPublicKey': 'आपकी पब्लिक की (npub):', 'privateKey.yourPrivateKey': 'आपकी प्राइवेट की (nsec):',
        // Signup Modal
        'signup.title': 'Nostr खाता बनाएं', 'signup.whatIsNostr': 'Nostr क्या है?', 'signup.nostrDescription': 'Nostr एक विकेंद्रीकृत प्रोटोकॉल है जो आपको अपनी पहचान और डेटा पर नियंत्रण देता है। कोई केंद्रीय सर्वर नहीं - आपका खाता एक क्रिप्टोग्राफिक की पेयर है।', 'signup.whyNostr': 'Nostr क्यों?', 'signup.benefit1': 'अपनी पहचान के मालिक बनें', 'signup.benefit2': 'कोई सेंसरशिप नहीं', 'signup.benefit3': 'प्लेटफॉर्म के बीच पोर्टेबिलिटी', 'signup.createNew': 'नया खाता बनाएं', 'signup.haveAccount': 'पहले से खाता है?', 'signup.login': 'लॉग इन करें', 'signup.createButton': 'खाता बनाएं', 'signup.generating': 'कीज़ जनरेट हो रही हैं...', 'signup.displayName': 'प्रदर्शित नाम', 'signup.displayNamePlaceholder': 'प्रदर्शित नाम दर्ज करें', 'signup.username': 'उपयोगकर्ता नाम', 'signup.usernamePlaceholder': 'उपयोगकर्ता नाम दर्ज करें',
        // Notifications
        'notifications.title': 'सूचनाएं', 'notifications.empty': 'कोई सूचना नहीं', 'notifications.viewAll': 'सभी सूचनाएं देखें', 'notifications.markAllRead': 'सभी को पढ़ा हुआ चिह्नित करें', 'notifications.settings': 'सूचना सेटिंग्स', 'notifications.loading': 'सूचनाएं लोड हो रही हैं...', 'notifications.zap': 'ने आपको ज़ैप भेजा', 'notifications.like': 'ने आपकी सामग्री पसंद की', 'notifications.comment': 'ने टिप्पणी की', 'notifications.follow': 'ने आपको फॉलो किया', 'notifications.repost': 'ने रीपोस्ट किया', 'notifications.mention': 'ने आपका उल्लेख किया',
        // Settings Modal
        'settings.title': 'सेटिंग्स', 'settings.language': 'भाषा', 'settings.languageDesc': 'भाषा चुनें', 'settings.saveToNostr': 'Nostr पर सहेजें', 'settings.darkMode': 'डार्क मोड', 'settings.darkModeDesc': 'डार्क/लाइट थीम टॉगल करें', 'settings.autoplay': 'ऑटोप्ले', 'settings.autoplayDesc': 'वीडियो ऑटो-प्ले करें', 'settings.saveSettings': 'सेटिंग्स सहेजें', 'settings.resetDefaults': 'रीसेट', 'settings.notifications': 'सूचनाएं', 'settings.notificationsDesc': 'पुश सूचनाएं प्राप्त करें', 'settings.quality': 'डिफ़ॉल्ट गुणवत्ता', 'settings.qualityDesc': 'वीडियो प्लेबैक गुणवत्ता',
        // Upload Modal
        'upload.title': 'वीडियो अपलोड करें', 'upload.dragDrop': 'वीडियो फ़ाइल यहाँ ड्रैग और ड्रॉप करें', 'upload.or': 'या', 'upload.browse': 'फ़ाइलें ब्राउज़ करें', 'upload.supportedFormats': 'समर्थित प्रारूप: MP4, WebM, MOV', 'upload.maxSize': 'अधिकतम आकार: 2GB', 'upload.videoTitle': 'शीर्षक', 'upload.titlePlaceholder': 'वीडियो शीर्षक दर्ज करें', 'upload.description': 'विवरण', 'upload.descriptionPlaceholder': 'अपने वीडियो का वर्णन करें...', 'upload.tags': 'टैग्स', 'upload.tagsPlaceholder': 'अल्पविराम से अलग टैग जोड़ें', 'upload.visibility': 'दृश्यता', 'upload.public': 'सार्वजनिक', 'upload.unlisted': 'असूचीबद्ध', 'upload.uploadButton': 'वीडियो अपलोड करें', 'upload.uploading': 'अपलोड हो रहा है...', 'upload.processing': 'प्रोसेस हो रहा है...', 'upload.complete': 'पूर्ण!', 'upload.error': 'अपलोड विफल', 'upload.nsfw': 'NSFW सामग्री', 'upload.nsfwDesc': 'वयस्क सामग्री के रूप में चिह्नित करें', 'upload.thumbnail': 'थंबनेल', 'upload.thumbnailDesc': 'थंबनेल अपलोड करें', 'upload.preparing': 'तैयारी हो रही है...', 'upload.cancel': 'रद्द करें', 'upload.progress': 'अपलोड प्रगति', 'upload.transcoding': 'ट्रांसकोडिंग', 'upload.status.preparing': 'अपलोड की तैयारी...', 'upload.status.uploading': 'वीडियो अपलोड हो रहा है...', 'upload.status.transcoding': 'वीडियो ट्रांसकोड हो रहा है...', 'upload.status.complete': 'अपलोड पूर्ण!', 'upload.qualityHigh': 'उच्च', 'upload.qualityMedium': 'मध्यम', 'upload.qualityLow': 'निम्न',
        // Create Modal
        'create.title': 'बनाएं', 'create.uploadVideo': 'वीडियो अपलोड करें', 'create.uploadDesc': 'वीडियो साझा करें', 'create.goLive': 'लाइव जाएं', 'create.goLiveDesc': 'लाइव स्ट्रीम शुरू करें', 'create.createPost': 'पोस्ट बनाएं', 'create.createPostDesc': 'टेक्स्ट पोस्ट साझा करें',
        // Go Live Modal
        'goLive.title': 'लाइव जाएं', 'goLive.streamTitle': 'स्ट्रीम शीर्षक', 'goLive.streamTitlePlaceholder': 'स्ट्रीम शीर्षक दर्ज करें', 'goLive.description': 'विवरण', 'goLive.descriptionPlaceholder': 'अपनी स्ट्रीम का वर्णन करें...', 'goLive.category': 'श्रेणी', 'goLive.selectCategory': 'श्रेणी चुनें', 'goLive.tags': 'टैग्स', 'goLive.tagsPlaceholder': 'अल्पविराम से अलग टैग जोड़ें', 'goLive.startStream': 'स्ट्रीम शुरू करें', 'goLive.streamKey': 'स्ट्रीम की', 'goLive.streamUrl': 'स्ट्रीम URL', 'goLive.copy': 'कॉपी करें', 'goLive.hideKey': 'की छुपाएं', 'goLive.showKey': 'की दिखाएं', 'goLive.connecting': 'कनेक्ट हो रहा है...', 'goLive.live': 'लाइव', 'goLive.offline': 'ऑफलाइन', 'goLive.viewers': 'दर्शक', 'goLive.endStream': 'स्ट्रीम समाप्त करें', 'goLive.nsfw': 'NSFW सामग्री', 'goLive.nsfwDesc': 'वयस्क सामग्री के रूप में चिह्नित करें', 'goLive.thumbnail': 'स्ट्रीम थंबनेल', 'goLive.thumbnailDesc': 'थंबनेल अपलोड करें',
        // Edit Stream Modal
        'editStream.title': 'स्ट्रीम संपादित करें', 'editStream.save': 'परिवर्तन सहेजें',
        // NSFW Warning Modal
        'nsfw.title': 'वयस्क सामग्री चेतावनी', 'nsfw.warning': 'यह सामग्री NSFW के रूप में चिह्नित है और इसमें वयस्क सामग्री हो सकती है।', 'nsfw.confirm': 'अपनी आयु पुष्टि करें', 'nsfw.confirmAge': 'मेरी आयु 18 वर्ष या उससे अधिक है', 'nsfw.cancel': 'वापस जाएं', 'nsfw.continue': 'जारी रखें', 'nsfw.dontShowAgain': 'यह चेतावनी फिर न दिखाएं',
        // Community Warning Modal
        'community.title': 'समुदाय दिशानिर्देश', 'community.warning': 'कृपया जारी रखने से पहले हमारे समुदाय दिशानिर्देशों की समीक्षा करें।', 'community.guidelines': 'सम्मानजनक रहें और समुदाय मानकों का पालन करें।', 'community.accept': 'स्वीकार करें', 'community.decline': 'अस्वीकार करें',
        // Report Modal
        'report.title': 'सामग्री की रिपोर्ट करें', 'report.reason': 'रिपोर्ट का कारण', 'report.selectReason': 'कारण चुनें', 'report.spam': 'स्पैम या भ्रामक', 'report.inappropriate': 'अनुचित सामग्री', 'report.violence': 'हिंसक या खतरनाक सामग्री', 'report.copyright': 'कॉपीराइट उल्लंघन', 'report.other': 'अन्य', 'report.details': 'विवरण', 'report.detailsPlaceholder': 'अधिक विवरण प्रदान करें...', 'report.submit': 'रिपोर्ट सबमिट करें', 'report.cancel': 'रद्द करें',
        // Share Modal
        'share.title': 'साझा करें', 'share.copyLink': 'लिंक कॉपी करें', 'share.embed': 'एम्बेड कोड', 'share.copyEmbed': 'एम्बेड कोड कॉपी करें', 'share.social': 'सोशल मीडिया पर साझा करें', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': 'ईमेल', 'share.copied': 'कॉपी हो गया!', 'share.nostr': 'Nostr पर साझा करें', 'share.generateImage': 'इमेज जनरेट करें', 'share.downloadImage': 'डाउनलोड', 'share.shareImage': 'साझा करें', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (वर्गाकार)', 'share.size1080x1920': '1080 × 1920 (स्टोरी)',
        // Edit Video Modal
        'editVideo.title': 'वीडियो संपादित करें', 'editVideo.videoTitle': 'शीर्षक', 'editVideo.description': 'विवरण', 'editVideo.tags': 'टैग्स', 'editVideo.thumbnail': 'थंबनेल', 'editVideo.changeThumbnail': 'थंबनेल बदलें', 'editVideo.visibility': 'दृश्यता', 'editVideo.nsfw': 'NSFW सामग्री', 'editVideo.save': 'परिवर्तन सहेजें', 'editVideo.delete': 'वीडियो हटाएं', 'editVideo.confirmDelete': 'क्या आप वाकई इस वीडियो को हटाना चाहते हैं?',
        // Edit Profile Modal
        'editProfile.title': 'प्रोफ़ाइल संपादित करें', 'editProfile.displayName': 'प्रदर्शित नाम', 'editProfile.displayNamePlaceholder': 'प्रदर्शित नाम दर्ज करें', 'editProfile.username': 'उपयोगकर्ता नाम', 'editProfile.usernamePlaceholder': 'उपयोगकर्ता नाम दर्ज करें', 'editProfile.about': 'परिचय', 'editProfile.aboutPlaceholder': 'अपने बारे में बताएं...', 'editProfile.website': 'वेबसाइट', 'editProfile.websitePlaceholder': 'https://yourwebsite.com', 'editProfile.lightning': 'Lightning पता', 'editProfile.lightningPlaceholder': 'you@getalby.com', 'editProfile.nip05': 'NIP-05 सत्यापन', 'editProfile.nip05Placeholder': 'you@domain.com', 'editProfile.avatar': 'अवतार', 'editProfile.changeAvatar': 'अवतार बदलें', 'editProfile.banner': 'बैनर', 'editProfile.changeBanner': 'बैनर बदलें', 'editProfile.save': 'प्रोफ़ाइल सहेजें',
        // Confirmation Modal
        'confirm.title': 'कार्रवाई पुष्टि करें', 'confirm.message': 'क्या आप वाकई जारी रखना चाहते हैं?', 'confirm.confirm': 'पुष्टि करें', 'confirm.cancel': 'रद्द करें',
        // Video Page
        'video.views': 'बार देखा गया', 'video.like': 'पसंद', 'video.dislike': 'नापसंद', 'video.share': 'साझा करें', 'video.save': 'सहेजें', 'video.report': 'रिपोर्ट करें', 'video.follow': 'फॉलो करें', 'video.unfollow': 'अनफॉलो', 'video.subscribe': 'सब्सक्राइब', 'video.subscribed': 'सब्सक्राइब्ड', 'video.comments': 'टिप्पणियाँ', 'video.addComment': 'टिप्पणी जोड़ें...', 'video.reply': 'जवाब दें', 'video.replies': 'जवाब', 'video.loadMore': 'और लोड करें', 'video.noComments': 'कोई टिप्पणी नहीं। पहले टिप्पणी करें!', 'video.zap': 'ज़ैप', 'video.zapAmount': 'ज़ैप राशि (सैट्स)', 'video.sendZap': 'ज़ैप भेजें', 'video.boost': 'बूस्ट', 'video.description': 'विवरण', 'video.showMore': 'और दिखाएं', 'video.showLess': 'कम दिखाएं', 'video.publishedOn': 'प्रकाशित',
        // Toast Messages
        'toast.loggedIn': 'लॉग इन सफल!', 'toast.loggedOut': 'लॉग आउट हो गए', 'toast.settingsSaved': 'सेटिंग्स सहेजी गईं!', 'toast.settingsReset': 'सेटिंग्स रीसेट हो गईं', 'toast.videoUploaded': 'वीडियो अपलोड हो गया!', 'toast.videoDeleted': 'वीडियो हटाया गया', 'toast.profileUpdated': 'प्रोफ़ाइल अपडेट हो गई!', 'toast.linkCopied': 'लिंक कॉपी हो गया!', 'toast.embedCopied': 'एम्बेड कोड कॉपी हो गया!', 'toast.zapSent': 'ज़ैप भेजा गया!', 'toast.followed': 'फॉलो किया!', 'toast.unfollowed': 'अनफॉलो किया', 'toast.reported': 'रिपोर्ट सबमिट हो गई', 'toast.saved': 'सहेजा गया!', 'toast.error': 'त्रुटि हुई', 'toast.networkError': 'नेटवर्क त्रुटि। पुनः प्रयास करें।', 'toast.uploadError': 'अपलोड विफल। पुनः प्रयास करें।', 'toast.languageChanged': 'भाषा बदली गई', 'toast.commentPosted': 'टिप्पणी पोस्ट हो गई', 'toast.keyCopied': 'की कॉपी हो गई!',
        // Time
        'time.now': 'अभी', 'time.minutesAgo': '{count} मिनट पहले', 'time.hoursAgo': '{count} घंटे पहले', 'time.daysAgo': '{count} दिन पहले', 'time.weeksAgo': '{count} सप्ताह पहले', 'time.monthsAgo': '{count} महीने पहले', 'time.yearsAgo': '{count} साल पहले',
        // Empty States
        'empty.noVideos': 'कोई वीडियो नहीं मिला', 'empty.noVideosDesc': 'अलग खोज करके देखें', 'empty.noFollowing': 'आप किसी को फॉलो नहीं कर रहे', 'empty.noFollowingDesc': 'क्रिएटर्स को फॉलो करें उनके वीडियो देखने के लिए', 'empty.noHistory': 'कोई देखने का इतिहास नहीं', 'empty.noHistoryDesc': 'जो वीडियो आप देखते हैं वे यहाँ दिखाई देंगे', 'empty.noLiked': 'कोई पसंद किए गए वीडियो नहीं', 'empty.noLikedDesc': 'जो वीडियो आप पसंद करते हैं वे यहाँ दिखाई देंगे', 'empty.noResults': 'कोई परिणाम नहीं मिला', 'empty.noResultsDesc': 'अलग कीवर्ड आज़माएं',
        // Misc
        'misc.loading': 'लोड हो रहा है...', 'misc.loadingMore': 'और लोड हो रहा है...', 'misc.refresh': 'रिफ्रेश', 'misc.retry': 'पुनः प्रयास', 'misc.close': 'बंद करें', 'misc.back': 'वापस', 'misc.next': 'अगला', 'misc.previous': 'पिछला', 'misc.search': 'खोजें', 'misc.filter': 'फ़िल्टर', 'misc.sort': 'क्रमबद्ध करें', 'misc.newest': 'नवीनतम', 'misc.oldest': 'पुराने', 'misc.popular': 'लोकप्रिय', 'misc.trending': 'ट्रेंडिंग', 'misc.sats': 'सैट्स', 'misc.all': 'सभी', 'misc.copiedToClipboard': 'क्लिपबोर्ड पर कॉपी हो गया!',
        // Common
        'common.submit': 'सबमिट', 'common.cancel': 'रद्द करें', 'common.save': 'सहेजें', 'common.delete': 'हटाएं', 'common.edit': 'संपादित करें', 'common.close': 'बंद करें', 'common.confirm': 'पुष्टि करें', 'common.yes': 'हाँ', 'common.no': 'नहीं', 'common.ok': 'ठीक है', 'common.loading': 'लोड हो रहा है...', 'common.uploading': 'अपलोड हो रहा है...', 'common.error': 'त्रुटि', 'common.success': 'सफल',
        // Aria Labels
        'aria.toggleMenu': 'मेनू टॉगल करें', 'aria.mainNavigation': 'मुख्य नेविगेशन', 'aria.videoContent': 'वीडियो सामग्री', 'aria.loadingContent': 'सामग्री लोड हो रही है', 'aria.closeModal': 'मोडल बंद करें', 'aria.playVideo': 'वीडियो चलाएं', 'aria.pauseVideo': 'वीडियो रोकें', 'aria.muteVideo': 'म्यूट करें', 'aria.unmuteVideo': 'अनम्यूट करें', 'aria.fullscreen': 'फुल स्क्रीन', 'aria.exitFullscreen': 'फुल स्क्रीन से बाहर', 'aria.settings': 'सेटिंग्स', 'aria.notifications': 'सूचनाएं', 'aria.userMenu': 'उपयोगकर्ता मेनू', 'aria.searchInput': 'वीडियो खोजें', 'aria.videoPlayer': 'वीडियो प्लेयर',
        // Dynamic JavaScript text
        'button.hideQR': 'QR कोड छुपाएं', 'button.showQR': 'QR कोड दिखाएं', 'button.copied': 'कॉपी हो गया!', 'button.showLess': 'कम दिखाएं', 'button.showMore': 'और दिखाएं', 'button.creatingAccount': 'खाता बनाया जा रहा है...', 'button.submitting': 'सबमिट हो रहा है...', 'button.scheduleStream': 'स्ट्रीम शेड्यूल करें', 'button.goLive': 'लाइव जाएं', 'button.creatingStream': 'स्ट्रीम बनाई जा रही है...', 'button.continueCustomAmount': 'कस्टम राशि के साथ जारी रखें', 'button.recordFromCamera': 'कैमरे से रिकॉर्ड करें', 'button.requestingCamera': 'कैमरा मांगा जा रहा है...', 'button.recording': 'रिकॉर्ड हो रहा है...',
        'status.saving': 'सहेजा जा रहा है...', 'status.saved': 'सहेज लिया गया!', 'status.uploading': 'अपलोड हो रहा है...', 'status.uploadComplete': 'अपलोड पूर्ण!', 'status.uploadingToNostrBuild': 'nostr.build पर अपलोड हो रहा है...', 'status.publishingChanges': 'परिवर्तन प्रकाशित हो रहे हैं...', 'status.removingOldVersion': 'पुराना संस्करण हटाया जा रहा है...', 'status.validatingThumbnail': 'थंबनेल सत्यापित हो रहा है...', 'status.uploadingThumbnail': 'थंबनेल अपलोड हो रहा है...', 'status.thumbnailUploaded': 'थंबनेल अपलोड हो गया!', 'status.processingVideo': 'वीडियो प्रोसेस हो रहा है...', 'status.compressingVideo': 'वीडियो कंप्रेस हो रहा है...', 'status.uploadingVideo': 'वीडियो अपलोड हो रहा है...', 'status.videoUploaded': 'वीडियो सफलतापूर्वक अपलोड हो गया!', 'status.processing': 'प्रोसेस हो रहा है...', 'status.generatingThumbnail': 'थंबनेल बनाया जा रहा है...', 'status.generatingPreview': 'प्रीव्यू बनाया जा रहा है...', 'status.uploadingPreview': 'प्रीव्यू अपलोड हो रहा है...', 'status.publishing': 'प्रकाशित हो रहा है...', 'status.publishingToNostr': 'Nostr पर प्रकाशित हो रहा है...', 'status.publishingVideoToNostr': 'Nostr पर वीडियो प्रकाशित हो रहा है...', 'status.generatingPoW': 'प्रूफ ऑफ वर्क बनाया जा रहा है...', 'status.posting': 'पोस्ट हो रहा है...', 'status.processingVideoAndThumbnail': 'वीडियो और थंबनेल प्रोसेस हो रहे हैं...', 'status.uploadFailed': 'अपलोड विफल - फिर से प्रयास करें', 'status.selectVideoToUpload': 'अपलोड करने के लिए वीडियो चुनें', 'status.waitingForVideoUpload': 'वीडियो अपलोड की प्रतीक्षा...', 'status.selectVideoAndThumbnail': 'प्रकाशित करने के लिए वीडियो और थंबनेल चुनें', 'status.ready': 'तैयार ✓', 'status.failed': 'विफल ✗', 'status.fromDraft': 'ड्राफ्ट से', 'status.startingNow': 'अभी शुरू हो रहा है!', 'status.ended': 'समाप्त', 'status.thumbnailReady': 'तैयार', 'status.thumbnailFailed': 'विफल', 'status.uploadFailedRetry': 'अपलोड विफल। फिर से प्रयास करें।',
        'publish.video': 'वीडियो प्रकाशित करें', 'publish.autoThumbnail': 'वीडियो प्रकाशित करें (ऑटो थंबनेल)',
        'report.titleComment': 'टिप्पणी की रिपोर्ट करें', 'report.titleUser': 'उपयोगकर्ता की रिपोर्ट करें', 'report.titleVideo': 'वीडियो की रिपोर्ट करें', 'report.descComment': 'इस टिप्पणी की रिपोर्ट करने का कारण चुनें:', 'report.descUser': 'इस उपयोगकर्ता की रिपोर्ट करने का कारण चुनें:', 'report.descVideo': 'इस सामग्री की रिपोर्ट करने का कारण चुनें:',
        'empty.noMutedUsers': 'कोई म्यूट किए गए उपयोगकर्ता नहीं।', 'empty.noVideosToMonitor': 'मॉनिटर करने के लिए कोई वीडियो नहीं।', 'empty.noRecentActivity': 'कोई हाल की गतिविधि नहीं।', 'empty.failedLoadNotifications': 'सूचनाएं लोड करने में विफल', 'empty.loginToViewLiked': 'पसंद किए गए वीडियो देखने के लिए कृपया <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">लॉग इन करें</a>।', 'empty.loginToViewFollowing': 'फॉलोइंग देखने के लिए कृपया <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">लॉग इन करें</a>।', 'empty.loginToViewVideos': 'अपने वीडियो देखने के लिए कृपया <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">लॉग इन करें</a>।', 'empty.loginToViewAnalytics': 'आंकड़े देखने के लिए कृपया <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">लॉग इन करें</a>।', 'empty.noLikedVideosYet': 'आपने अभी तक कोई वीडियो पसंद नहीं किया।', 'empty.noLikedVideosFound': 'पसंद किए गए वीडियो नहीं मिले।', 'empty.noFullLengthLikedVideos': 'पसंद किए गए लंबे वीडियो नहीं मिले।', 'empty.noWatchHistory': 'कोई देखने का इतिहास नहीं। वीडियो देखना शुरू करें।', 'empty.noVideosInHistory': 'इतिहास में कोई वीडियो नहीं।', 'empty.noFullLengthHistory': 'इतिहास में लंबे वीडियो नहीं।', 'empty.noMatchingVideos': 'मिलते-जुलते वीडियो नहीं मिले।', 'empty.noFullLengthVideos': 'लंबे वीडियो नहीं मिले।', 'empty.failedLoadTrending': 'ट्रेंडिंग लोड करने में विफल।', 'empty.noTrendingVideos': 'ट्रेंडिंग वीडियो नहीं मिले।', 'empty.noMatchingUsers': 'मिलते-जुलते उपयोगकर्ता नहीं मिले।', 'empty.unableLoadProfiles': 'प्रोफाइल लोड करने में असमर्थ।', 'empty.noFollowingVideos': 'फॉलो किए गए लोगों के वीडियो अभी नहीं।', 'empty.noFullLengthFollowing': 'फॉलो किए गए लोगों के लंबे वीडियो नहीं।', 'empty.failedLoadFollowing': 'लोड करने में विफल। फिर से प्रयास करें।', 'empty.noVideosUploadFirst': 'कोई वीडियो नहीं। पहला वीडियो अपलोड करें!', 'empty.noFullLengthUploaded': 'लंबे वीडियो नहीं मिले।', 'empty.noMatchingLiveStreams': 'मिलती-जुलती लाइव स्ट्रीम नहीं मिली।', 'empty.noMatchingShorts': 'मिलते-जुलते शॉर्ट्स नहीं मिले।', 'empty.noVideosForTag': 'इस टैग के लिए कोई वीडियो नहीं।', 'empty.noFullLengthForTag': 'इस टैग के लिए लंबे वीडियो नहीं।', 'empty.noUploadedVideos': 'अभी तक कोई वीडियो अपलोड नहीं।', 'empty.noVideosFound': 'कोई वीडियो नहीं मिला।', 'empty.failedLoadProfile': 'प्रोफाइल लोड करने में विफल। फिर से प्रयास करें।', 'empty.noComments': 'अभी कोई टिप्पणी नहीं। पहले टिप्पणी करें!', 'empty.failedLoadComments': 'टिप्पणियां लोड करने में विफल', 'empty.noLiveNow': 'अभी कोई लाइव नहीं। पहले बनें!',
        'error.videoNotFound': 'वीडियो नहीं मिला।', 'error.contentNotAvailable': 'यह सामग्री उपलब्ध नहीं है।', 'error.invalidVideoData': 'अमान्य वीडियो डेटा।', 'error.videoNotAvailable': 'वीडियो उपलब्ध नहीं। फाइल हटाई जा सकती है।', 'error.failedLoadVideo': 'वीडियो लोड करने में विफल। फिर से प्रयास करें।', 'error.failedLoadVideoShort': 'लोड करने में विफल। फाइल हटाई जा सकती है।', 'error.liveStreamNotFound': 'लाइव स्ट्रीम नहीं मिली।', 'error.invalidLiveStreamData': 'अमान्य लाइव स्ट्रीम डेटा।', 'error.failedLoadLiveStream': 'लाइव स्ट्रीम लोड करने में विफल।',
        // New Button & Action Labels
        'button.follow': 'फॉलो करें', 'button.unfollow': 'अनफॉलो करें', 'button.mute': 'म्यूट करें', 'button.unmute': 'अनम्यूट करें', 'button.muteUser': 'उपयोगकर्ता को म्यूट करें', 'button.unmuteUser': 'उपयोगकर्ता को अनम्यूट करें', 'button.confirm': 'पुष्टि करें', 'button.cancel': 'रद्द करें', 'button.close': 'बंद करें', 'button.boost': 'बूस्ट', 'button.zap': 'Zap', 'button.viewMore': 'और देखें', 'button.viewAnalytics': 'विश्लेषण देखें', 'button.backToMyVideos': 'मेरे वीडियो पर वापस जाएं', 'button.editDraft': 'ड्राफ्ट संपादित करें', 'button.deleteDraft': 'ड्राफ्ट हटाएं', 'button.editVideo': 'वीडियो संपादित करें', 'button.deleteVideo': 'वीडियो हटाएं', 'button.editShort': 'शॉर्ट संपादित करें', 'button.deleteShort': 'शॉर्ट हटाएं', 'button.editStream': 'स्ट्रीम संपादित करें', 'button.endStream': 'स्ट्रीम समाप्त करें', 'button.reset': 'रीसेट करें', 'button.download': 'डाउनलोड करें', 'button.watchRecording': 'रिकॉर्डिंग देखें', 'button.show': 'दिखाएं', 'button.login': 'लॉगिन करें', 'button.toggleChat': 'चैट टॉगल करें', 'button.blockVideo': 'वीडियो ब्लॉक करें', 'button.blockUser': 'उपयोगकर्ता ब्लॉक करें', 'button.unblock': 'अनब्लॉक करें', 'button.removeFromHistory': 'इतिहास से हटाएं',
        // New Stats & Counts
        'stat.views': 'बार देखा गया', 'stat.viewsCount': '{count} बार देखा गया', 'stat.videos': 'वीडियो', 'stat.video': 'वीडियो', 'stat.followers': 'फॉलोअर्स', 'stat.follower': 'फॉलोअर', 'stat.following': 'फॉलो कर रहे हैं', 'stat.subscribers': 'सब्सक्राइबर्स', 'stat.comments': 'टिप्पणियां', 'stat.liveCount': '{count} लाइव', 'stat.percentOfGoal': 'लक्ष्य का {percent}%', 'stat.netGrowth': 'शुद्ध वृद्धि', 'stat.newFollowers': 'नए फॉलोअर्स', 'stat.unfollowed': 'अनफॉलो', 'stat.lastUpdated': 'अंतिम अपडेट: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'लाइव', 'badge.ended': 'समाप्त', 'badge.scheduled': 'निर्धारित', 'badge.warning': 'चेतावनी', 'badge.communityWarning': 'समुदाय चेतावनी', 'badge.verifiedNip05': 'NIP-05 सत्यापित', 'badge.streamer': 'स्ट्रीमर', 'badge.clickToView': 'देखने के लिए क्लिक करें',
        // New Actions
        'action.report': 'रिपोर्ट करें', 'action.reportComment': 'टिप्पणी की रिपोर्ट करें', 'action.reportVideo': 'इस वीडियो की रिपोर्ट करें', 'action.reportStream': 'इस स्ट्रीम की रिपोर्ट करें', 'action.like': 'पसंद', 'action.dislike': 'नापसंद', 'action.reply': 'जवाब दें',
        // New Placeholders
        'placeholder.searchHistory': 'इतिहास खोजें...', 'placeholder.searchUsers': 'उपयोगकर्ता खोजें...', 'placeholder.searchMyVideos': 'मेरे वीडियो खोजें...', 'placeholder.eventId': 'इवेंट ID दर्ज करें (hex या nevent/note)', 'placeholder.pubkey': 'pubkey दर्ज करें (hex या npub)', 'placeholder.customAmount': 'कस्टम राशि', 'placeholder.chatEnded': 'चैट बंद - स्ट्रीम समाप्त', 'placeholder.addComment': 'टिप्पणी जोड़ें...', 'placeholder.setNewGoal': 'नया लक्ष्य सेट करें (sats)',
        // New Video & Content
        'video.untitledVideo': 'शीर्षकहीन वीडियो', 'video.untitledShort': 'शीर्षकहीन शॉर्ट', 'video.upNext': 'अगला', 'video.noVideosYet': 'अभी तक कोई वीडियो नहीं', 'video.noShortsYet': 'अभी तक कोई शॉर्ट्स नहीं', 'video.noLiveStreamsYet': 'अभी तक कोई लाइव स्ट्रीम नहीं', 'video.noBlockedVideos': 'कोई ब्लॉक वीडियो नहीं', 'video.noBlockedUsers': 'कोई ब्लॉक उपयोगकर्ता नहीं',
        // New Stream Messages
        'stream.ended': 'यह स्ट्रीम समाप्त हो गई है। चैट अब बंद है।', 'stream.welcomeChat': 'लाइव चैट में आपका स्वागत है!', 'stream.goalReached': 'लक्ष्य प्राप्त!', 'stream.zapGoalReached': 'Zap लक्ष्य प्राप्त! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'म्यूट उपयोगकर्ता का संदेश', 'muted.commentFromMutedUserHidden': 'म्यूट उपयोगकर्ता की टिप्पणी छिपी', 'muted.commentHidden': 'टिप्पणी छिपी ({packs})', 'muted.messageHidden': 'संदेश छिपा ({packs})', 'muted.commentReportedByFollows': 'आप जिन्हें फॉलो करते हैं उनने रिपोर्ट की गई टिप्पणी', 'muted.messageReportedByFollows': 'आप जिन्हें फॉलो करते हैं उनने रिपोर्ट किया संदेश', 'muted.commentHeavilyDownvoted': 'समुदाय द्वारा भारी डाउनवोट टिप्पणी', 'muted.messageHeavilyDownvoted': 'भारी डाउनवोट संदेश',
        // New Admin & Lists
        'list.blockedVideos': 'ब्लॉक वीडियो', 'list.blockedUsers': 'ब्लॉक उपयोगकर्ता',
        // New Alerts
        'alert.cameraNotSupported': 'इस ब्राउज़र में कैमरा एक्सेस समर्थित नहीं है। कृपया Chrome, Firefox, या Safari जैसा आधुनिक ब्राउज़र उपयोग करें।', 'alert.noCameraFound': 'कोई कैमरा नहीं मिला। कृपया कैमरा कनेक्ट करें या फ़ाइल अपलोड विकल्प का उपयोग करें।', 'alert.cameraAccessDenied': 'कैमरा एक्सेस अस्वीकृत। कृपया ब्राउज़र सेटिंग्स में कैमरा अनुमति दें।', 'alert.cameraInUse': 'कैमरा किसी अन्य एप्लिकेशन द्वारा उपयोग में है। कृपया अन्य ऐप्स बंद करें।', 'alert.cameraUnableAccess': 'कैमरा एक्सेस नहीं हो पा रहा। कृपया अपलोड विकल्प का उपयोग करें।', 'alert.cameraUnableAccessWithError': 'कैमरा एक्सेस नहीं हो पा रहा: {error}\n\nकृपया अपलोड विकल्प का उपयोग करें।', 'alert.fillRequiredFields': 'कृपया सभी आवश्यक फ़ील्ड भरें', 'alert.uploadThumbnail': 'कृपया अपनी स्ट्रीम के लिए थंबनेल अपलोड करें', 'alert.failedCreateStream': 'लाइव स्ट्रीम बनाने में विफल। कृपया पुनः प्रयास करें।', 'alert.failedUpdateStream': 'अपडेट विफल। कृपया पुनः प्रयास करें।', 'alert.streamNotFound': 'स्ट्रीम नहीं मिली', 'alert.canOnlyEditOwnStreams': 'आप केवल अपनी स्ट्रीम्स संपादित कर सकते हैं', 'alert.invalidStreamData': 'अमान्य स्ट्रीम डेटा', 'alert.enterValidGoalAmount': 'कृपया वैध लक्ष्य राशि दर्ज करें', 'alert.canOnlyResetOwnGoals': 'आप केवल अपने लक्ष्य रीसेट कर सकते हैं', 'alert.streamEventNotFound': 'स्ट्रीम इवेंट नहीं मिला', 'alert.failedResetZapGoal': 'Zap लक्ष्य रीसेट करने में विफल। कृपया पुनः प्रयास करें।', 'alert.cannotBlockAdmin': 'एडमिन अकाउंट ब्लॉक नहीं किया जा सकता', 'alert.analyticsLoadFailed': 'विश्लेषण लोड करने में विफल। कृपया पुनः प्रयास करें।', 'alert.cannotReplaceShortWithVideo': 'शॉर्ट को सामान्य वीडियो से नहीं बदल सकते। कृपया वर्टिकल वीडियो (60 सेकंड या कम) अपलोड करें।', 'alert.cannotReplaceVideoWithShort': 'सामान्य वीडियो को शॉर्ट से नहीं बदल सकते। कृपया हॉरिज़ॉन्टल वीडियो अपलोड करें।', 'alert.shortsRequireVertical': 'यह वीडियो हॉरिज़ॉन्टल लगता है। शॉर्ट्स वर्टिकल वीडियो होने चाहिए। हॉरिज़ॉन्टल वीडियो के लिए "वीडियो अपलोड करें" का उपयोग करें।',
        // New Zap Messages
        'zap.cannotZapYourself': 'आप खुद को Zap नहीं कर सकते', 'zap.cannotZapOwnContent': 'आप अपनी सामग्री को Zap नहीं कर सकते', 'zap.cannotZapOwnComment': 'आप अपनी टिप्पणी को Zap नहीं कर सकते', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'वीडियो लोड हो रहा है...', 'status.loading': 'लोड हो रहा है...', 'status.compressingProgress': 'कंप्रेस हो रहा है... {progress}%', 'status.uploadingProgress': 'अपलोड हो रहा है... {progress}%', 'status.uploadingServers': 'अपलोड हो रहा है... ({completed}/{total} सर्वर)', 'status.publishedSuccess': '{type} सफलतापूर्वक प्रकाशित!',
        // New Warnings
        'warning.webmFormat': 'नोट: आपका ब्राउज़र WebM फॉर्मेट आउटपुट करेगा (iOS पर काम नहीं कर सकता)। iOS-संगत MP4 के लिए Windows/Mac पर Chrome का उपयोग करें।',
        // New Footer
        'footer.lastUpdated': 'अंतिम अपडेट: दिसंबर 2024',
    },
    it: {
        // Navigation & Header
        'nav.home': 'Home', 'nav.following': 'Seguiti', 'nav.myVideos': 'I Miei Video', 'nav.liked': 'Piaciuti', 'nav.history': 'Cronologia', 'nav.topics': 'ARGOMENTI', 'nav.live': 'In Diretta', 'nav.bitcoin': 'Bitcoin', 'nav.nostr': 'Nostr', 'nav.technology': 'Tecnologia', 'nav.gaming': 'Gaming', 'nav.tutorials': 'Tutorial', 'nav.podcasts': 'Podcast', 'nav.music': 'Musica', 'nav.nsfw': 'NSFW', 'nav.about': 'Info', 'nav.contact': 'Contatti', 'nav.terms': 'Termini', 'nav.privacy': 'Privacy', 'nav.faq': 'FAQ', 'nav.dmca': 'DMCA', 'nav.liveStreams': 'Live Stream', 'nav.github': 'GitHub',
        'header.search': 'Cerca video...', 'header.notifications': 'Notifiche', 'header.settings': 'Impostazioni', 'header.create': 'Crea', 'header.viewProfile': 'Vedi Profilo', 'header.logout': 'Esci',
        // Login Modal
        'login.title': 'Accedi con Nostr', 'login.extensionButton': 'Accedi con Estensione Nostr', 'login.extensionDesc': 'Usa estensione di firma (Alby, nos2x, ecc.)', 'login.orDivider': 'OPPURE', 'login.nsecLabel': 'Accedi con Chiave Privata (nsec)', 'login.nsecPlaceholder': 'Inserisci il tuo nsec...', 'login.nsecButton': 'Accedi con nsec', 'login.nsecWarning': 'Attenzione: Inserire nsec direttamente è meno sicuro rispetto all\'uso di un\'estensione. Considera un\'estensione NIP-07 per maggiore sicurezza.', 'login.newToNostr': 'Nuovo su Nostr?', 'login.createAccount': 'Crea Account', 'login.learnMore': 'Scopri di più su Nostr',
        // Connect Modal
        'connect.title': 'Connetti a Nostr', 'connect.or': 'OPPURE', 'connect.extensionButton': 'Connetti Estensione Nostr', 'connect.extensionDesc': 'Usa estensione (Alby, nos2x, ecc.)', 'connect.nsecLabel': 'Accedi con Chiave Privata', 'connect.nsecPlaceholder': 'nsec1...', 'connect.nsecButton': 'Connetti con nsec', 'connect.nsecWarning': 'Attenzione: Inserire nsec direttamente è meno sicuro. Usa un\'estensione NIP-07 per maggiore sicurezza.', 'connect.newToNostr': 'Nuovo su Nostr?', 'connect.createAccount': 'Crea Account',
        // Private Key Modal
        'privateKey.title': 'La Tua Chiave Privata', 'privateKey.warning': 'IMPORTANTE: Salva questo in un posto sicuro. Se perdi questa chiave, perderai l\'accesso al tuo account. Non condividerla mai con nessuno!', 'privateKey.show': 'Mostra Chiave Privata', 'privateKey.hide': 'Nascondi Chiave Privata', 'privateKey.copy': 'Copia', 'privateKey.saved': 'Ho salvato la mia chiave', 'privateKey.yourPublicKey': 'La tua Chiave Pubblica (npub):', 'privateKey.yourPrivateKey': 'La tua Chiave Privata (nsec):',
        // Signup Modal
        'signup.title': 'Crea Account Nostr', 'signup.whatIsNostr': 'Cos\'è Nostr?', 'signup.nostrDescription': 'Nostr è un protocollo decentralizzato che ti dà il controllo sulla tua identità e i tuoi dati. Nessun server centrale - il tuo account è una coppia di chiavi crittografiche.', 'signup.whyNostr': 'Perché Nostr?', 'signup.benefit1': 'Possiedi la tua identità', 'signup.benefit2': 'Nessuna censura', 'signup.benefit3': 'Portabilità tra piattaforme', 'signup.createNew': 'Crea Nuovo Account', 'signup.haveAccount': 'Hai già un account?', 'signup.login': 'Accedi', 'signup.createButton': 'Crea Account', 'signup.generating': 'Generazione chiavi...', 'signup.displayName': 'Nome Visualizzato', 'signup.displayNamePlaceholder': 'Inserisci nome visualizzato', 'signup.username': 'Nome Utente', 'signup.usernamePlaceholder': 'Inserisci nome utente',
        // Notifications
        'notifications.title': 'Notifiche', 'notifications.empty': 'Nessuna notifica', 'notifications.viewAll': 'Vedi tutte le notifiche', 'notifications.markAllRead': 'Segna tutto come letto', 'notifications.settings': 'Impostazioni notifiche', 'notifications.loading': 'Caricamento notifiche...', 'notifications.zap': 'ti ha inviato uno zap', 'notifications.like': 'ha apprezzato il tuo contenuto', 'notifications.comment': 'ha commentato', 'notifications.follow': 'ti ha seguito', 'notifications.repost': 'ha ripostato', 'notifications.mention': 'ti ha menzionato',
        // Settings Modal
        'settings.title': 'Impostazioni', 'settings.language': 'Lingua', 'settings.languageDesc': 'Scegli la lingua', 'settings.saveToNostr': 'Salva su Nostr', 'settings.darkMode': 'Modalità Scura', 'settings.darkModeDesc': 'Attiva/disattiva tema scuro', 'settings.autoplay': 'Riproduzione Auto', 'settings.autoplayDesc': 'Riproduci video automaticamente', 'settings.saveSettings': 'Salva Impostazioni', 'settings.resetDefaults': 'Ripristina', 'settings.notifications': 'Notifiche', 'settings.notificationsDesc': 'Ricevi notifiche push', 'settings.quality': 'Qualità Predefinita', 'settings.qualityDesc': 'Qualità riproduzione video',
        // Upload Modal
        'upload.title': 'Carica Video', 'upload.dragDrop': 'Trascina e rilascia il file video qui', 'upload.or': 'oppure', 'upload.browse': 'Sfoglia File', 'upload.supportedFormats': 'Formati supportati: MP4, WebM, MOV', 'upload.maxSize': 'Dimensione massima: 2GB', 'upload.videoTitle': 'Titolo', 'upload.titlePlaceholder': 'Inserisci titolo video', 'upload.description': 'Descrizione', 'upload.descriptionPlaceholder': 'Descrivi il tuo video...', 'upload.tags': 'Tag', 'upload.tagsPlaceholder': 'Aggiungi tag separati da virgola', 'upload.visibility': 'Visibilità', 'upload.public': 'Pubblico', 'upload.unlisted': 'Non elencato', 'upload.uploadButton': 'Carica Video', 'upload.uploading': 'Caricamento...', 'upload.processing': 'Elaborazione...', 'upload.complete': 'Completato!', 'upload.error': 'Caricamento fallito', 'upload.nsfw': 'Contenuto NSFW', 'upload.nsfwDesc': 'Contrassegna come contenuto per adulti', 'upload.thumbnail': 'Miniatura', 'upload.thumbnailDesc': 'Carica miniatura video', 'upload.preparing': 'Preparazione...', 'upload.cancel': 'Annulla', 'upload.progress': 'Progresso caricamento', 'upload.transcoding': 'Transcodifica', 'upload.status.preparing': 'Preparazione caricamento...', 'upload.status.uploading': 'Caricamento video...', 'upload.status.transcoding': 'Transcodifica video...', 'upload.status.complete': 'Caricamento completato!', 'upload.qualityHigh': 'Alta', 'upload.qualityMedium': 'Media', 'upload.qualityLow': 'Bassa',
        // Create Modal
        'create.title': 'Crea', 'create.uploadVideo': 'Carica Video', 'create.uploadDesc': 'Condividi un video', 'create.goLive': 'Vai in Diretta', 'create.goLiveDesc': 'Avvia streaming live', 'create.createPost': 'Crea Post', 'create.createPostDesc': 'Condividi un post testuale',
        // Go Live Modal
        'goLive.title': 'Vai in Diretta', 'goLive.streamTitle': 'Titolo Stream', 'goLive.streamTitlePlaceholder': 'Inserisci titolo stream', 'goLive.description': 'Descrizione', 'goLive.descriptionPlaceholder': 'Descrivi il tuo stream...', 'goLive.category': 'Categoria', 'goLive.selectCategory': 'Seleziona categoria', 'goLive.tags': 'Tag', 'goLive.tagsPlaceholder': 'Aggiungi tag separati da virgola', 'goLive.startStream': 'Avvia Stream', 'goLive.streamKey': 'Chiave Stream', 'goLive.streamUrl': 'URL Stream', 'goLive.copy': 'Copia', 'goLive.hideKey': 'Nascondi Chiave', 'goLive.showKey': 'Mostra Chiave', 'goLive.connecting': 'Connessione...', 'goLive.live': 'IN DIRETTA', 'goLive.offline': 'Offline', 'goLive.viewers': 'spettatori', 'goLive.endStream': 'Termina Stream', 'goLive.nsfw': 'Contenuto NSFW', 'goLive.nsfwDesc': 'Contrassegna come contenuto per adulti', 'goLive.thumbnail': 'Miniatura Stream', 'goLive.thumbnailDesc': 'Carica miniatura',
        // Edit Stream Modal
        'editStream.title': 'Modifica Stream', 'editStream.save': 'Salva Modifiche',
        // NSFW Warning Modal
        'nsfw.title': 'Avviso Contenuto Adulti', 'nsfw.warning': 'Questo contenuto è contrassegnato come NSFW (Non Sicuro per il Lavoro) e potrebbe contenere materiale per adulti.', 'nsfw.confirm': 'Conferma la tua età', 'nsfw.confirmAge': 'Ho 18 anni o più', 'nsfw.cancel': 'Torna Indietro', 'nsfw.continue': 'Continua', 'nsfw.dontShowAgain': 'Non mostrare più questo avviso',
        // Community Warning Modal
        'community.title': 'Linee Guida Community', 'community.warning': 'Rivedi le nostre linee guida della community prima di continuare.', 'community.guidelines': 'Sii rispettoso e segui gli standard della community.', 'community.accept': 'Accetto', 'community.decline': 'Rifiuto',
        // Report Modal
        'report.title': 'Segnala Contenuto', 'report.reason': 'Motivo della Segnalazione', 'report.selectReason': 'Seleziona motivo', 'report.spam': 'Spam o fuorviante', 'report.inappropriate': 'Contenuto inappropriato', 'report.violence': 'Contenuto violento o pericoloso', 'report.copyright': 'Violazione copyright', 'report.other': 'Altro', 'report.details': 'Dettagli', 'report.detailsPlaceholder': 'Fornisci maggiori dettagli...', 'report.submit': 'Invia Segnalazione', 'report.cancel': 'Annulla',
        // Share Modal
        'share.title': 'Condividi', 'share.copyLink': 'Copia Link', 'share.embed': 'Codice Embed', 'share.copyEmbed': 'Copia Codice Embed', 'share.social': 'Condividi sui Social', 'share.twitter': 'Twitter', 'share.facebook': 'Facebook', 'share.reddit': 'Reddit', 'share.telegram': 'Telegram', 'share.whatsapp': 'WhatsApp', 'share.email': 'Email', 'share.copied': 'Copiato!', 'share.nostr': 'Condividi su Nostr', 'share.generateImage': 'Genera Immagine', 'share.downloadImage': 'Scarica', 'share.shareImage': 'Condividi', 'share.size1280x720': '1280 × 720 (HD)', 'share.size1080x1080': '1080 × 1080 (quadrato)', 'share.size1080x1920': '1080 × 1920 (storia)',
        // Edit Video Modal
        'editVideo.title': 'Modifica Video', 'editVideo.videoTitle': 'Titolo', 'editVideo.description': 'Descrizione', 'editVideo.tags': 'Tag', 'editVideo.thumbnail': 'Miniatura', 'editVideo.changeThumbnail': 'Cambia Miniatura', 'editVideo.visibility': 'Visibilità', 'editVideo.nsfw': 'Contenuto NSFW', 'editVideo.save': 'Salva Modifiche', 'editVideo.delete': 'Elimina Video', 'editVideo.confirmDelete': 'Sei sicuro di voler eliminare questo video?',
        // Edit Profile Modal
        'editProfile.title': 'Modifica Profilo', 'editProfile.displayName': 'Nome Visualizzato', 'editProfile.displayNamePlaceholder': 'Inserisci nome visualizzato', 'editProfile.username': 'Nome Utente', 'editProfile.usernamePlaceholder': 'Inserisci nome utente', 'editProfile.about': 'Bio', 'editProfile.aboutPlaceholder': 'Raccontaci di te...', 'editProfile.website': 'Sito Web', 'editProfile.websitePlaceholder': 'https://tuosito.com', 'editProfile.lightning': 'Indirizzo Lightning', 'editProfile.lightningPlaceholder': 'tu@getalby.com', 'editProfile.nip05': 'Verifica NIP-05', 'editProfile.nip05Placeholder': 'tu@dominio.com', 'editProfile.avatar': 'Avatar', 'editProfile.changeAvatar': 'Cambia Avatar', 'editProfile.banner': 'Banner', 'editProfile.changeBanner': 'Cambia Banner', 'editProfile.save': 'Salva Profilo',
        // Confirmation Modal
        'confirm.title': 'Conferma Azione', 'confirm.message': 'Sei sicuro di voler continuare?', 'confirm.confirm': 'Conferma', 'confirm.cancel': 'Annulla',
        // Video Page
        'video.views': 'visualizzazioni', 'video.like': 'Mi Piace', 'video.dislike': 'Non Mi Piace', 'video.share': 'Condividi', 'video.save': 'Salva', 'video.report': 'Segnala', 'video.follow': 'Segui', 'video.unfollow': 'Non Seguire', 'video.subscribe': 'Iscriviti', 'video.subscribed': 'Iscritto', 'video.comments': 'Commenti', 'video.addComment': 'Aggiungi commento...', 'video.reply': 'Rispondi', 'video.replies': 'risposte', 'video.loadMore': 'Carica Altri', 'video.noComments': 'Nessun commento. Sii il primo!', 'video.zap': 'Zap', 'video.zapAmount': 'Importo Zap (sats)', 'video.sendZap': 'Invia Zap', 'video.boost': 'Boost', 'video.description': 'Descrizione', 'video.showMore': 'Mostra di più', 'video.showLess': 'Mostra meno', 'video.publishedOn': 'Pubblicato il',
        // Toast Messages
        'toast.loggedIn': 'Accesso effettuato!', 'toast.loggedOut': 'Disconnesso', 'toast.settingsSaved': 'Impostazioni salvate!', 'toast.settingsReset': 'Impostazioni ripristinate', 'toast.videoUploaded': 'Video caricato!', 'toast.videoDeleted': 'Video eliminato', 'toast.profileUpdated': 'Profilo aggiornato!', 'toast.linkCopied': 'Link copiato!', 'toast.embedCopied': 'Codice embed copiato!', 'toast.zapSent': 'Zap inviato!', 'toast.followed': 'Seguito!', 'toast.unfollowed': 'Non più seguito', 'toast.reported': 'Segnalazione inviata', 'toast.saved': 'Salvato!', 'toast.error': 'Si è verificato un errore', 'toast.networkError': 'Errore di rete. Riprova.', 'toast.uploadError': 'Caricamento fallito. Riprova.', 'toast.languageChanged': 'Lingua cambiata', 'toast.commentPosted': 'Commento pubblicato', 'toast.keyCopied': 'Chiave copiata!',
        // Time
        'time.now': 'adesso', 'time.minutesAgo': '{count} minuti fa', 'time.hoursAgo': '{count} ore fa', 'time.daysAgo': '{count} giorni fa', 'time.weeksAgo': '{count} settimane fa', 'time.monthsAgo': '{count} mesi fa', 'time.yearsAgo': '{count} anni fa',
        // Empty States
        'empty.noVideos': 'Nessun video trovato', 'empty.noVideosDesc': 'Prova una ricerca diversa', 'empty.noFollowing': 'Non segui ancora nessuno', 'empty.noFollowingDesc': 'Segui i creator per vedere i loro video', 'empty.noHistory': 'Nessuna cronologia', 'empty.noHistoryDesc': 'I video che guardi appariranno qui', 'empty.noLiked': 'Nessun video piaciuto', 'empty.noLikedDesc': 'I video che ti piacciono appariranno qui', 'empty.noResults': 'Nessun risultato trovato', 'empty.noResultsDesc': 'Prova parole chiave diverse',
        // Misc
        'misc.loading': 'Caricamento...', 'misc.loadingMore': 'Caricamento altri...', 'misc.refresh': 'Aggiorna', 'misc.retry': 'Riprova', 'misc.close': 'Chiudi', 'misc.back': 'Indietro', 'misc.next': 'Avanti', 'misc.previous': 'Precedente', 'misc.search': 'Cerca', 'misc.filter': 'Filtra', 'misc.sort': 'Ordina', 'misc.newest': 'Più Recenti', 'misc.oldest': 'Più Vecchi', 'misc.popular': 'Popolari', 'misc.trending': 'Di Tendenza', 'misc.sats': 'sats', 'misc.all': 'Tutti', 'misc.copiedToClipboard': 'Copiato negli appunti!',
        // Common
        'common.submit': 'Invia', 'common.cancel': 'Annulla', 'common.save': 'Salva', 'common.delete': 'Elimina', 'common.edit': 'Modifica', 'common.close': 'Chiudi', 'common.confirm': 'Conferma', 'common.yes': 'Sì', 'common.no': 'No', 'common.ok': 'OK', 'common.loading': 'Caricamento...', 'common.uploading': 'Caricamento...', 'common.error': 'Errore', 'common.success': 'Successo',
        // Aria Labels
        'aria.toggleMenu': 'Attiva/disattiva menu', 'aria.mainNavigation': 'Navigazione principale', 'aria.videoContent': 'Contenuto video', 'aria.loadingContent': 'Caricamento contenuto', 'aria.closeModal': 'Chiudi modale', 'aria.playVideo': 'Riproduci video', 'aria.pauseVideo': 'Pausa video', 'aria.muteVideo': 'Disattiva audio', 'aria.unmuteVideo': 'Attiva audio', 'aria.fullscreen': 'Schermo intero', 'aria.exitFullscreen': 'Esci da schermo intero', 'aria.settings': 'Impostazioni', 'aria.notifications': 'Notifiche', 'aria.userMenu': 'Menu utente', 'aria.searchInput': 'Cerca video', 'aria.videoPlayer': 'Lettore video',
        // Dynamic JavaScript text
        'button.hideQR': 'Nascondi QR Code', 'button.showQR': 'Mostra QR Code', 'button.copied': 'Copiato!', 'button.showLess': 'Mostra Meno', 'button.showMore': 'Mostra Altro', 'button.creatingAccount': 'Creazione account...', 'button.submitting': 'Invio in corso...', 'button.scheduleStream': 'Programma Streaming', 'button.goLive': 'Vai in Diretta', 'button.creatingStream': 'Creazione streaming...', 'button.continueCustomAmount': 'Continua con Importo Personalizzato', 'button.recordFromCamera': 'Registra dalla Fotocamera', 'button.requestingCamera': 'Richiesta fotocamera...', 'button.recording': 'Registrazione...',
        'status.saving': 'Salvataggio...', 'status.saved': 'Salvato!', 'status.uploading': 'Caricamento...', 'status.uploadComplete': 'Caricamento completato!', 'status.uploadingToNostrBuild': 'Caricamento su nostr.build...', 'status.publishingChanges': 'Pubblicazione modifiche...', 'status.removingOldVersion': 'Rimozione vecchia versione...', 'status.validatingThumbnail': 'Validazione miniatura...', 'status.uploadingThumbnail': 'Caricamento miniatura...', 'status.thumbnailUploaded': 'Miniatura caricata!', 'status.processingVideo': 'Elaborazione video...', 'status.compressingVideo': 'Compressione video...', 'status.uploadingVideo': 'Caricamento video...', 'status.videoUploaded': 'Video caricato con successo!', 'status.processing': 'Elaborazione...', 'status.generatingThumbnail': 'Generazione miniatura...', 'status.generatingPreview': 'Generazione anteprima...', 'status.uploadingPreview': 'Caricamento anteprima...', 'status.publishing': 'Pubblicazione...', 'status.publishingToNostr': 'Pubblicazione su Nostr...', 'status.publishingVideoToNostr': 'Pubblicazione video su Nostr...', 'status.generatingPoW': 'Generazione proof of work...', 'status.posting': 'Pubblicazione...', 'status.processingVideoAndThumbnail': 'Elaborazione video e miniatura...', 'status.uploadFailed': 'Caricamento fallito - riprova', 'status.selectVideoToUpload': 'Seleziona video da caricare', 'status.waitingForVideoUpload': 'In attesa del caricamento video...', 'status.selectVideoAndThumbnail': 'Seleziona video e miniatura per pubblicare', 'status.ready': 'Pronto ✓', 'status.failed': 'Fallito ✗', 'status.fromDraft': 'Da bozza', 'status.startingNow': 'Inizia ora!', 'status.ended': 'TERMINATO', 'status.thumbnailReady': 'Pronto', 'status.thumbnailFailed': 'Fallito', 'status.uploadFailedRetry': 'Caricamento fallito. Riprova.',
        'publish.video': 'Pubblica Video', 'publish.autoThumbnail': 'Pubblica Video (miniatura auto)',
        'report.titleComment': 'Segnala Commento', 'report.titleUser': 'Segnala Utente', 'report.titleVideo': 'Segnala Video', 'report.descComment': 'Seleziona un motivo per segnalare questo commento:', 'report.descUser': 'Seleziona un motivo per segnalare questo utente:', 'report.descVideo': 'Seleziona un motivo per segnalare questo contenuto:',
        'empty.noMutedUsers': 'Nessun utente silenziato.', 'empty.noVideosToMonitor': 'Nessun video da monitorare.', 'empty.noRecentActivity': 'Nessuna attività recente.', 'empty.failedLoadNotifications': 'Impossibile caricare le notifiche', 'empty.loginToViewLiked': 'Per favore <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">accedi</a> per vedere i video che ti piacciono.', 'empty.loginToViewFollowing': 'Per favore <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">accedi</a> per vedere chi segui.', 'empty.loginToViewVideos': 'Per favore <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">accedi</a> per vedere i tuoi video.', 'empty.loginToViewAnalytics': 'Per favore <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">accedi</a> per vedere le tue statistiche.', 'empty.noLikedVideosYet': 'Non hai ancora messo mi piace a nessun video.', 'empty.noLikedVideosFound': 'Nessun video piaciuto trovato.', 'empty.noFullLengthLikedVideos': 'Nessun video lungo piaciuto trovato.', 'empty.noWatchHistory': 'Nessuna cronologia. Inizia a guardare video.', 'empty.noVideosInHistory': 'Nessun video nella cronologia.', 'empty.noFullLengthHistory': 'Nessun video lungo nella cronologia.', 'empty.noMatchingVideos': 'Nessun video corrispondente trovato.', 'empty.noFullLengthVideos': 'Nessun video lungo trovato.', 'empty.failedLoadTrending': 'Impossibile caricare le tendenze.', 'empty.noTrendingVideos': 'Nessun video di tendenza trovato.', 'empty.noMatchingUsers': 'Nessun utente corrispondente trovato.', 'empty.unableLoadProfiles': 'Impossibile caricare i profili.', 'empty.noFollowingVideos': 'Nessun video dagli utenti che segui.', 'empty.noFullLengthFollowing': 'Nessun video lungo dagli utenti che segui.', 'empty.failedLoadFollowing': 'Caricamento fallito. Riprova.', 'empty.noVideosUploadFirst': 'Nessun video. Carica il tuo primo video!', 'empty.noFullLengthUploaded': 'Nessun video lungo trovato.', 'empty.noMatchingLiveStreams': 'Nessun live stream corrispondente trovato.', 'empty.noMatchingShorts': 'Nessun short corrispondente trovato.', 'empty.noVideosForTag': 'Nessun video per questo tag.', 'empty.noFullLengthForTag': 'Nessun video lungo per questo tag.', 'empty.noUploadedVideos': 'Nessun video caricato ancora.', 'empty.noVideosFound': 'Nessun video trovato.', 'empty.failedLoadProfile': 'Impossibile caricare il profilo. Riprova.', 'empty.noComments': 'Nessun commento ancora. Sii il primo!', 'empty.failedLoadComments': 'Impossibile caricare i commenti', 'empty.noLiveNow': 'Nessuno in diretta ora. Sii il primo!',
        'error.videoNotFound': 'Video non trovato.', 'error.contentNotAvailable': 'Questo contenuto non è disponibile.', 'error.invalidVideoData': 'Dati video non validi.', 'error.videoNotAvailable': 'Video non disponibile. Il file potrebbe essere stato rimosso.', 'error.failedLoadVideo': 'Impossibile caricare il video. Riprova.', 'error.failedLoadVideoShort': 'Caricamento fallito. File potrebbe essere rimosso.', 'error.liveStreamNotFound': 'Live stream non trovato.', 'error.invalidLiveStreamData': 'Dati live stream non validi.', 'error.failedLoadLiveStream': 'Impossibile caricare il live stream.',
        // New Button & Action Labels
        'button.follow': 'Segui', 'button.unfollow': 'Non seguire', 'button.mute': 'Silenzia', 'button.unmute': 'Riattiva audio', 'button.muteUser': 'Silenzia utente', 'button.unmuteUser': 'Riattiva utente', 'button.confirm': 'Conferma', 'button.cancel': 'Annulla', 'button.close': 'Chiudi', 'button.boost': 'Potenzia', 'button.zap': 'Zap', 'button.viewMore': 'Mostra altro', 'button.viewAnalytics': 'Visualizza statistiche', 'button.backToMyVideos': 'Torna ai Miei Video', 'button.editDraft': 'Modifica bozza', 'button.deleteDraft': 'Elimina bozza', 'button.editVideo': 'Modifica video', 'button.deleteVideo': 'Elimina video', 'button.editShort': 'Modifica short', 'button.deleteShort': 'Elimina short', 'button.editStream': 'Modifica diretta', 'button.endStream': 'Termina diretta', 'button.reset': 'Reimposta', 'button.download': 'Scarica', 'button.watchRecording': 'Guarda registrazione', 'button.show': 'Mostra', 'button.login': 'Accedi', 'button.toggleChat': 'Attiva/disattiva chat', 'button.blockVideo': 'Blocca video', 'button.blockUser': 'Blocca utente', 'button.unblock': 'Sblocca', 'button.removeFromHistory': 'Rimuovi dalla cronologia',
        // New Stats & Counts
        'stat.views': 'visualizzazioni', 'stat.viewsCount': '{count} visualizzazioni', 'stat.videos': 'video', 'stat.video': 'video', 'stat.followers': 'follower', 'stat.follower': 'follower', 'stat.following': 'Seguiti', 'stat.subscribers': 'iscritti', 'stat.comments': 'Commenti', 'stat.liveCount': '{count} in diretta', 'stat.percentOfGoal': '{percent}% dell\'obiettivo', 'stat.netGrowth': 'Crescita netta', 'stat.newFollowers': 'Nuovi follower', 'stat.unfollowed': 'Non seguono più', 'stat.lastUpdated': 'Ultimo aggiornamento: {date}',
        // New Content Badges
        'badge.nsfw': 'NSFW', 'badge.live': 'IN DIRETTA', 'badge.ended': 'TERMINATA', 'badge.scheduled': 'PROGRAMMATA', 'badge.warning': 'AVVISO', 'badge.communityWarning': 'AVVISO DELLA COMUNITÀ', 'badge.verifiedNip05': 'NIP-05 verificato', 'badge.streamer': 'Streamer', 'badge.clickToView': 'Clicca per vedere',
        // New Actions
        'action.report': 'Segnala', 'action.reportComment': 'Segnala commento', 'action.reportVideo': 'Segnala questo video', 'action.reportStream': 'Segnala questa diretta', 'action.like': 'Mi piace', 'action.dislike': 'Non mi piace', 'action.reply': 'Rispondi',
        // New Placeholders
        'placeholder.searchHistory': 'Cerca nella cronologia...', 'placeholder.searchUsers': 'Cerca utenti...', 'placeholder.searchMyVideos': 'Cerca nei miei video...', 'placeholder.eventId': 'Inserisci ID evento (hex o nevent/note)', 'placeholder.pubkey': 'Inserisci pubkey (hex o npub)', 'placeholder.customAmount': 'Importo personalizzato', 'placeholder.chatEnded': 'Chat chiusa - diretta terminata', 'placeholder.addComment': 'Aggiungi un commento...', 'placeholder.setNewGoal': 'Imposta nuovo obiettivo (sats)',
        // New Video & Content
        'video.untitledVideo': 'Video senza titolo', 'video.untitledShort': 'Short senza titolo', 'video.upNext': 'Prossimo', 'video.noVideosYet': 'Ancora nessun video', 'video.noShortsYet': 'Ancora nessun short', 'video.noLiveStreamsYet': 'Ancora nessuna diretta', 'video.noBlockedVideos': 'Nessun video bloccato', 'video.noBlockedUsers': 'Nessun utente bloccato',
        // New Stream Messages
        'stream.ended': 'Questa diretta è terminata. La chat è ora chiusa.', 'stream.welcomeChat': 'Benvenuto nella chat dal vivo!', 'stream.goalReached': 'Obiettivo raggiunto!', 'stream.zapGoalReached': 'Obiettivo Zap raggiunto! {amount} sats!',
        // New Muted/Hidden Content
        'muted.messageFromMutedUser': 'Messaggio da utente silenziato', 'muted.commentFromMutedUserHidden': 'Commento da utente silenziato nascosto', 'muted.commentHidden': 'Commento nascosto ({packs})', 'muted.messageHidden': 'Messaggio nascosto ({packs})', 'muted.commentReportedByFollows': 'Commento segnalato da persone che segui', 'muted.messageReportedByFollows': 'Messaggio segnalato da persone che segui', 'muted.commentHeavilyDownvoted': 'Commento molto criticato dalla comunità', 'muted.messageHeavilyDownvoted': 'Messaggio molto criticato',
        // New Admin & Lists
        'list.blockedVideos': 'Video bloccati', 'list.blockedUsers': 'Utenti bloccati',
        // New Alerts
        'alert.cameraNotSupported': 'L\'accesso alla fotocamera non è supportato in questo browser. Utilizza un browser moderno come Chrome, Firefox o Safari.', 'alert.noCameraFound': 'Nessuna fotocamera trovata. Collega una fotocamera o usa l\'opzione di caricamento file.', 'alert.cameraAccessDenied': 'Accesso alla fotocamera negato. Consenti i permessi della fotocamera nelle impostazioni del browser.', 'alert.cameraInUse': 'La fotocamera è in uso da un\'altra applicazione. Chiudi le altre app.', 'alert.cameraUnableAccess': 'Impossibile accedere alla fotocamera. Prova l\'opzione di caricamento.', 'alert.cameraUnableAccessWithError': 'Impossibile accedere alla fotocamera: {error}\n\nUsa l\'opzione di caricamento.', 'alert.fillRequiredFields': 'Compila tutti i campi obbligatori', 'alert.uploadThumbnail': 'Carica una miniatura per la tua diretta', 'alert.failedCreateStream': 'Impossibile creare la diretta. Riprova.', 'alert.failedUpdateStream': 'Aggiornamento fallito. Riprova.', 'alert.streamNotFound': 'Diretta non trovata', 'alert.canOnlyEditOwnStreams': 'Puoi modificare solo le tue dirette', 'alert.invalidStreamData': 'Dati diretta non validi', 'alert.enterValidGoalAmount': 'Inserisci un importo obiettivo valido', 'alert.canOnlyResetOwnGoals': 'Puoi reimpostare solo i tuoi obiettivi', 'alert.streamEventNotFound': 'Evento diretta non trovato', 'alert.failedResetZapGoal': 'Impossibile reimpostare l\'obiettivo Zap. Riprova.', 'alert.cannotBlockAdmin': 'Non è possibile bloccare l\'account admin', 'alert.analyticsLoadFailed': 'Impossibile caricare le statistiche. Riprova.', 'alert.cannotReplaceShortWithVideo': 'Non è possibile sostituire uno Short con un video normale. Carica un video verticale (60 secondi o meno).', 'alert.cannotReplaceVideoWithShort': 'Non è possibile sostituire un video normale con uno Short. Carica un video orizzontale.', 'alert.shortsRequireVertical': 'Questo video sembra essere orizzontale. Gli Short devono essere video verticali. Usa "Carica Video" per i video orizzontali.',
        // New Zap Messages
        'zap.cannotZapYourself': 'Non puoi inviare Zap a te stesso', 'zap.cannotZapOwnContent': 'Non puoi inviare Zap al tuo contenuto', 'zap.cannotZapOwnComment': 'Non puoi inviare Zap al tuo commento', 'zap.zapAmount': 'Zap {value} sats',
        // New Status Messages
        'status.loadingVideo': 'Caricamento video...', 'status.loading': 'Caricamento...', 'status.compressingProgress': 'Compressione... {progress}%', 'status.uploadingProgress': 'Caricamento... {progress}%', 'status.uploadingServers': 'Caricamento... ({completed}/{total} server)', 'status.publishedSuccess': '{type} pubblicato con successo!',
        // New Warnings
        'warning.webmFormat': 'Nota: Il tuo browser produrrà formato WebM (potrebbe non funzionare su iOS). Per MP4 compatibile con iOS, usa Chrome su Windows/Mac.',
        // New Footer
        'footer.lastUpdated': 'Ultimo aggiornamento: Dicembre 2024',
    }
};

// Get translation for a key
function t(key, params = {}) {
    let text = translations[currentLanguage]?.[key] || translations.en[key] || key;
    Object.keys(params).forEach(param => {
        text = text.replace(new RegExp(`\\{${param}\\}`, 'g'), params[param]);
    });
    return text;
}

// Detect browser language and return best match
function detectBrowserLanguage() {
    const browserLang = navigator.language || navigator.userLanguage || 'en';
    const langCode = browserLang.split('-')[0].toLowerCase();
    return SUPPORTED_LANGUAGES[langCode] ? langCode : 'en';
}

// Initialize language from storage or browser
function initializeLanguage() {
    const savedLang = localStorage.getItem('plebsLanguage');
    if (savedLang && SUPPORTED_LANGUAGES[savedLang]) {
        currentLanguage = savedLang;
    } else {
        currentLanguage = detectBrowserLanguage();
        localStorage.setItem('plebsLanguage', currentLanguage);
    }
    document.documentElement.setAttribute('lang', currentLanguage);
    document.documentElement.setAttribute('dir', currentLanguage === 'ar' ? 'rtl' : 'ltr');
}

// Change language and update UI
function changeLanguage(langCode) {
    if (!SUPPORTED_LANGUAGES[langCode]) return;
    currentLanguage = langCode;
    localStorage.setItem('plebsLanguage', langCode);
    document.documentElement.setAttribute('lang', langCode);
    document.documentElement.setAttribute('dir', langCode === 'ar' ? 'rtl' : 'ltr');
    if (typeof userSettings !== 'undefined') {
        userSettings.language = langCode;
    }
    applyTranslations();
    const langSelect = document.getElementById('languageSelect');
    if (langSelect) langSelect.value = langCode;
}

// Apply translations to all elements with data-i18n attribute
function applyTranslations() {
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        el.textContent = t(key);
    });
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        el.placeholder = t(key);
    });
    document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const key = el.getAttribute('data-i18n-title');
        el.title = t(key);
    });
    document.querySelectorAll('[data-i18n-html]').forEach(el => {
        const key = el.getAttribute('data-i18n-html');
        el.innerHTML = t(key);
    });
    document.querySelectorAll('[data-i18n-aria-label]').forEach(el => {
        const key = el.getAttribute('data-i18n-aria-label');
        el.setAttribute('aria-label', t(key));
    });
}

// Generate language selector HTML options
function generateLanguageSelector() {
    let options = '';
    Object.entries(SUPPORTED_LANGUAGES).forEach(([code, name]) => {
        options += `<option value="${code}" ${code === currentLanguage ? 'selected' : ''}>${name}</option>`;
    });
    return options;
}

// ===== END i18n SYSTEM =====

// Global state
let currentUser = null;
let relayConnections = {};
let currentView = 'home';
let uploadedVideoHash = null;

// Upload state tracking for immediate uploads
const uploadState = {
    video: {
        file: null,
        status: 'pending', // pending, compressing, uploading, complete, error
        progress: 0,
        url: null,
        hash: null,
        error: null,
        size: 0,
        type: null,
        duration: null,
        dimensions: null,
        mirrors: [] // All successful blossom upload URLs for NIP-71 fallbacks
    },
    thumbnail: {
        file: null,
        status: 'pending', // pending, uploading, complete, error
        progress: 0,
        url: null,
        error: null
    },
    preview: {
        file: null,
        status: 'pending', // pending, generating, uploading, complete, error
        progress: 0,
        url: null,
        error: null
    },
    draftId: null // Track if this is an existing draft being edited
};

// Next video auto-play state
let nextVideoData = null;
let autoPlayCountdownTimer = null;
const AUTO_PLAY_COUNTDOWN_SECONDS = 5;

let allEvents = new Map();
let profileCache = new Map();
let reactionsCache = new Map();
let nip05ValidationCache = new Map();
let imageValidationCache = new Map();
// Cache profile validation results per pubkey: { isSuspicious: boolean, avatarValid: boolean, nip05Valid: boolean }
let profileValidationCache = new Map();
let pendingNSFWAction = null;
let pendingRatioedAction = null;
let sessionNSFWAllowed = false;
let sessionRatioedAllowed = new Set();
let currentTrendingPeriod = 'week';
let isInitializingSettings = false;
let boostsCache = new Map();

// Mute list cache (NIP-51 kind 10000)
let mutedUsersCache = new Set();
let muteListLoaded = false;
// Session-based "temporarily show" for muted user content
let sessionUnhiddenMutedUsers = new Set();

// User's follows cache (kind 3) - Set of pubkeys user follows
let userFollowsCache = new Set();
let userFollowsLoaded = false;

// Reports cache (NIP-56 kind 1984) - Maps event/pubkey to Set of reporter pubkeys
// Structure: { eventReports: Map<eventId, Set<reporterPubkey>>, pubkeyReports: Map<pubkey, Set<reporterPubkey>> }
let reportsCache = {
    eventReports: new Map(),
    pubkeyReports: new Map(),
    loadedEvents: new Set(),
    loadedPubkeys: new Set()
};

// Admin configuration
const ADMIN_PUBKEY = 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df';
const ADMIN_BLOCKLIST_KIND = 30000; // NIP-51 parameterized replaceable list
const ADMIN_BLOCKLIST_D_TAG = 'plebs-blocklist';

// Admin blocklist cache (fetched from Nostr, cached in localStorage)
let adminBlocklist = {
    events: new Set(),    // Blocked event IDs (videos)
    pubkeys: new Set()    // Blocked user pubkeys
};
const ADMIN_BLOCKLIST_CACHE_KEY = 'plebsAdminBlocklistCache';
let adminBlocklistLoaded = false;

// Check if current user is admin
function isAdmin() {
    return currentUser && currentUser.pubkey === ADMIN_PUBKEY;
}

// Load admin blocklist - first from cache, then fetch from Nostr
function loadAdminBlocklist() {
    // Load from localStorage cache first for immediate availability
    try {
        const cached = localStorage.getItem(ADMIN_BLOCKLIST_CACHE_KEY);
        if (cached) {
            const data = JSON.parse(cached);
            adminBlocklist.events = new Set(data.events || []);
            adminBlocklist.pubkeys = new Set(data.pubkeys || []);
        }
    } catch (e) {
        console.error('Failed to load blocklist cache:', e);
    }

    // Then fetch latest from Nostr (non-blocking)
    fetchAdminBlocklistFromNostr();
}

// Fetch admin blocklist from Nostr relays
async function fetchAdminBlocklistFromNostr() {
    try {
        const filter = {
            kinds: [ADMIN_BLOCKLIST_KIND],
            authors: [ADMIN_PUBKEY],
            '#d': [ADMIN_BLOCKLIST_D_TAG],
            limit: 1
        };

        let blocklistEvent = null;
        await requestEventsStream(
            filter,
            event => {
                // Keep the most recent event
                if (!blocklistEvent || event.created_at > blocklistEvent.created_at) {
                    blocklistEvent = event;
                }
            },
            { timeout: 10000 }
        );

        if (blocklistEvent) {
            // Parse blocked events and pubkeys from tags
            const blockedEvents = new Set();
            const blockedPubkeys = new Set();

            for (const tag of blocklistEvent.tags) {
                if (tag[0] === 'e' && tag[1]) {
                    blockedEvents.add(tag[1].toLowerCase());
                } else if (tag[0] === 'p' && tag[1]) {
                    blockedPubkeys.add(tag[1].toLowerCase());
                }
            }

            adminBlocklist.events = blockedEvents;
            adminBlocklist.pubkeys = blockedPubkeys;

            // Update localStorage cache
            saveAdminBlocklistCache();
        }

        adminBlocklistLoaded = true;
    } catch (e) {
        console.error('Failed to fetch admin blocklist from Nostr:', e);
        adminBlocklistLoaded = true; // Mark as loaded even on error to not block app
    }
}

// Save blocklist to localStorage cache (for faster startup)
function saveAdminBlocklistCache() {
    try {
        const data = {
            events: Array.from(adminBlocklist.events),
            pubkeys: Array.from(adminBlocklist.pubkeys)
        };
        localStorage.setItem(ADMIN_BLOCKLIST_CACHE_KEY, JSON.stringify(data));
    } catch (e) {
        console.error('Failed to save blocklist cache:', e);
    }
}

// Publish admin blocklist to Nostr (admin only)
async function publishAdminBlocklist() {
    if (!isAdmin()) {
        console.error('Only admin can publish blocklist');
        return false;
    }

    try {
        // Build tags array
        const tags = [
            ['d', ADMIN_BLOCKLIST_D_TAG]
        ];

        // Add blocked events
        for (const eventId of adminBlocklist.events) {
            tags.push(['e', eventId]);
        }

        // Add blocked pubkeys
        for (const pubkey of adminBlocklist.pubkeys) {
            tags.push(['p', pubkey]);
        }

        // Create the event
        const event = {
            kind: ADMIN_BLOCKLIST_KIND,
            created_at: Math.floor(Date.now() / 1000),
            tags: tags,
            content: '' // Content is empty, data is in tags
        };

        // Sign the event
        const signedEvent = await signEvent(event);
        if (!signedEvent) {
            throw new Error('Failed to sign blocklist event');
        }

        // Publish to relays
        const published = await publishEvent(signedEvent);
        if (!published) {
            throw new Error('Failed to publish to any relay');
        }

        // Update local cache
        saveAdminBlocklistCache();

        return true;
    } catch (e) {
        console.error('Failed to publish admin blocklist:', e);
        return false;
    }
}

// Check if content is blocked by admin
function isBlockedByAdmin(eventId, pubkey) {
    return adminBlocklist.events.has(eventId) || adminBlocklist.pubkeys.has(pubkey);
}

// Check if a pubkey is blocked (for action restrictions)
function isPubkeyBlocked(pubkey) {
    return adminBlocklist.pubkeys.has(pubkey);
}

// Comments state for sorting
let currentCommentsState = {
    comments: [],
    eventIds: [],
    reactions: new Map(),
    zaps: new Map(),
    sortBy: 'newest'
};

// Track pubkeys currently being loaded to avoid duplicate requests
const pendingProfileLoads = new Set();

// Author stats cache (video count, follower count) with expiry
const authorStatsCache = new Map();
const AUTHOR_STATS_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

// NIP-46 connection state
let nip46Connection = null;
let nip46Secret = null;

// Local storage keys
const STORAGE_KEYS = {
    privateKey: 'plebsPrivateKey',
    publicKey: 'plebsPublicKey',
    profile: 'plebsProfile',
    loginMethod: 'plebsLoginMethod',
    relays: 'plebsRelays',
    bunkerURL: 'plebsBunkerURL',
    nip46Secret: 'plebsNip46Secret',
    lastNotificationView: 'plebsLastNotificationView'
};

// Blossom servers
const BLOSSOM_SERVERS = [
    'https://blossom.primal.net',
    'https://blossom.band',
    'https://nostr.media'
];

// Premium Blossom server
const PREMIUM_BLOSSOM_SERVER = 'https://nostrmedia.com';

// Default relay URLs
const RELAY_URLS = [
    'wss://relay.damus.io',
    'wss://relay.nostr.band',
    'wss://nos.lol',
    'wss://relay.primal.net'
];

// WoT relay URLs
const WOT_RELAY_URLS = [
    'wss://wot.utxo.one',
    'wss://nostrelites.org',
    'wss://wot.nostr.party',
    'wss://wot.nostr.net'
];

// Additional relay for publishing only
const PUBLISH_ONLY_RELAYS = [
    'wss://sendit.nosflare.com'
];

// NIP-71 Video Event Kinds (Addressable/Parameterized Replaceable)
// Using kinds 34235/34236 for addressable events that can be updated
const NIP71_VIDEO_KIND = 34235;   // Addressable normal/horizontal videos
const NIP71_SHORT_KIND = 34236;   // Addressable vertical/short videos (like Reels/Shorts)

// Legacy NIP-71 kinds (regular events, for backwards compatibility)
const NIP71_VIDEO_KIND_LEGACY = 21;
const NIP71_SHORT_KIND_LEGACY = 22;

// All video kinds for querying (includes legacy kind 1, legacy NIP-71, and addressable NIP-71)
const ALL_VIDEO_KINDS = [1, NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY];

// NIP-53 Live Activities
const NIP53_LIVE_EVENT_KIND = 30311;  // Live activity (streaming)
const NIP53_LIVE_CHAT_KIND = 1311;    // Live chat messages

// All content kinds including live
const ALL_CONTENT_KINDS = [...ALL_VIDEO_KINDS, NIP53_LIVE_EVENT_KIND];

// Live stream state
let currentLiveChat = {
    streamId: null,        // Current stream ID being viewed
    messages: [],          // Chat messages
    subscriptionId: null,  // Relay subscription ID for chat
    lastMessageTime: 0,    // For deduplication
    viewers: new Set(),    // Track unique viewers
    chatParticipants: new Map(), // Track chat participants: pubkey -> lastActivityTime
    viewerCount: 0,        // Current viewer count from live event
    eventId: null          // Current live event ID
};

// Live stream thumbnail upload state
const liveStreamState = {
    thumbnailUrl: null,
    thumbnailFile: null,
    isScheduled: false,
    scheduledTime: null
};

// Draft storage key
const DRAFTS_STORAGE_KEY = 'plebsVideoDrafts';

// Map to link kind 1 events to their NIP-71 counterparts
let videoEventLinks = new Map(); // Maps kind 1 event ID to kind 21/22 event ID and vice versa

// ===== NIP-13 Proof of Work =====
// Minimum PoW difficulty for reactions and comments to count in trending
const MIN_POW_DIFFICULTY = 16; // Require 16 leading zero bits (about 65k hash attempts average)

// ===== NIP-78 View Tracking =====
// Kind 30078 for aggregated view counts (replaceable by d-tag)
const VIEW_TRACKING_APP_ID = 'plebs/video-views';
const LIVE_VIEWER_TRACKING_APP_ID = 'plebs/live-viewers';
const VIEW_EVENT_KIND = 30078;
const LIVE_VIEWER_TIMEOUT = 5 * 60; // 5 minutes in seconds - viewers must update within this window
const LIVE_VIEWER_UPDATE_INTERVAL = 4 * 60 * 1000; // 4 minutes in ms - send updates before timeout

// Cache for video view counts with TTL
const videoViewsCache = new Map(); // eventId -> { count, timestamp }
const VIEW_CACHE_TTL = 5 * 60 * 1000; // 5 minute TTL for view counts
const pendingViewRequests = new Map(); // eventId -> Promise (track in-flight requests)

// Helper to get cached view count (respects TTL)
function getCachedViewCount(eventId) {
    const cached = videoViewsCache.get(eventId);
    if (!cached) return null;
    if (Date.now() - cached.timestamp > VIEW_CACHE_TTL) {
        videoViewsCache.delete(eventId);
        return null;
    }
    return cached.count;
}

// Helper to set cached view count with timestamp
function setCachedViewCount(eventId, count) {
    videoViewsCache.set(eventId, { count, timestamp: Date.now() });
}

// Settings management
let userSettings = {
    useWotRelays: false,
    usePremiumBlossom: false,
    customBlossomServers: [],
    saveToNostr: true,
    showNSFWWarnings: true,
    showCommunityWarnings: true,
    showFollowsReportWarnings: true,
    enabledFilterPacks: [],
    customKeywordFilter: [],
    // Notification settings
    notifications: {
        reactions: true,
        replies: true,
        zaps: true,
        chatMentions: true,
        newFollowers: true
    }
};

// ===== CONTENT FILTER PACKS =====
// Each pack contains keywords that will hide content matching them
// Icons are SVG strings for consistent rendering
const FILTER_PACK_ICONS = {
    // No/prohibited symbol - hate not allowed
    racism: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z"/></svg>',
    // Eye with slash - hidden/adult content
    sexualExplicit: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>',
    // Warning triangle - danger/violence
    violence: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>',
    // Pill/capsule - drugs
    drugs: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M19 8H5c-2.21 0-4 1.79-4 4s1.79 4 4 4h14c2.21 0 4-1.79 4-4s-1.79-4-4-4zM5 14c-1.1 0-2-.9-2-2s.9-2 2-2h6v4H5z"/></svg>',
    // Email warning - spam
    spam: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>',
    // Capitol/government building - politics
    politics: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L3 8v2h2v8H3v2h18v-2h-2v-8h2V8l-9-6zM7 18v-8h2v8H7zm4 0v-8h2v8h-2zm4 0v-8h2v8h-2z"/></svg>',
    // Chat bubble with asterisks - profanity/censored
    profanity: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-9 11H9V7h2v6zm4 0h-2V7h2v6z"/></svg>',
    // Coin with C symbol (like Bitcoin ₿ but C) - cryptocurrency
    crypto: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/><path d="M15 9.5c-.8-1.1-2-1.5-3-1.5-2.2 0-4 1.8-4 4s1.8 4 4 4c1 0 2.2-.4 3-1.5"/><line x1="12" y1="5" x2="12" y2="8"/><line x1="12" y1="16" x2="12" y2="19"/></svg>'
};

const FILTER_PACKS = {
    racism: {
        name: 'Racism & Hate Speech',
        description: 'Filters racial slurs, ethnic hate speech, and discriminatory content',
        icon: FILTER_PACK_ICONS.racism,
        keywords: [
            'nigger', 'nigga', 'n1gger', 'n1gga', 'nigg3r', 'nig nog', 'spic', 'sp1c', 'wetback', 'beaner',
            'chink', 'ch1nk', 'gook', 'g00k', 'zipperhead', 'slant eye', 'kike', 'k1ke', 'kyke', 'heeb',
            'raghead', 'towelhead', 'sand nigger', 'camel jockey', 'paki', 'curry muncher', 'dot head',
            'cracker', 'honky', 'white trash', 'redneck trash', 'coon', 'c00n', 'darkie', 'jungle bunny',
            'porch monkey', 'moon cricket', 'tar baby', 'negro', 'colored people', 'redskin', 'injun',
            'prairie nigger', 'wagon burner', 'squaw', 'wop', 'dago', 'guinea', 'greaseball', 'polack',
            'mick', 'paddy', 'white power', 'heil hitler', '1488', 'gas the', 'race war', 'ethnic cleansing',
            'white genocide', 'great replacement', 'jew world order', 'zog', 'dindu', 'we wuz', 'jogger',
            'despite being 13', 'crime statistics'
        ]
    },
    sexualExplicit: {
        name: 'Sexually Explicit',
        description: 'Filters pornographic terms and sexually explicit content',
        icon: FILTER_PACK_ICONS.sexualExplicit,
        keywords: [
            'porn', 'p0rn', 'pron', 'xxx', 'xxxx', 'hardcore sex', 'anal sex', 'blowjob', 'blow job',
            'handjob', 'hand job', 'cumshot', 'cum shot', 'facial cumshot', 'creampie', 'cream pie',
            'gangbang', 'gang bang', 'bukkake', 'deepthroat', 'deep throat', 'milf', 'm1lf', 'dilf',
            'pussy', 'p*ssy', 'cock', 'c0ck', 'dick pic', 'd1ck', 'tits', 't1ts',
            'boobs', 'b00bs', 'naked', 'nude', 'nudes', 'onlyfans', 'only fans', 'fansly', 'chaturbate',
            'pornhub', 'xvideos', 'xhamster', 'brazzers', 'bangbros', 'realitykings', 'naughtyamerica',
            'hentai', 'h3ntai', 'rule34', 'rule 34', 'r34', 'ecchi', 'ahegao', 'futanari', 'futa',
            'masturbat', 'masterbat', 'jerk off', 'jack off', 'fap', 'orgasm', '0rgasm', 'ejaculat',
            'squirt', 'fetish', 'bondage', 'bdsm', 'dominatrix', 'femdom', 'pegging', 'cuckold',
            'swinger', 'threesome', 'foursome', 'orgy', '0rgy', 'sex tape', 'sextape', 'leaked nudes',
            'nip slip', 'upskirt', 'downblouse', 'camgirl', 'cam girl', 'stripper', 'escort',
            'prostitut', 'hooker', 'whore', 'wh0re', 'slut', 'sl*t', 'lolita', 'loli', 'cuck', 'cuckold', 'cucking'
        ]
    },
    violence: {
        name: 'Violence & Gore',
        description: 'Filters graphic violence, gore, and violent threats',
        icon: FILTER_PACK_ICONS.violence,
        keywords: [
            'gore', 'g0re', 'gory', 'beheading', 'decapitat', 'dismember', 'mutilat', 'disembowel',
            'execution video', 'snuff', 'snuff film', 'real death', 'actual death', 'watch him die',
            'watch her die', 'brutal murder', 'torture video', 't0rture', 'cartel video', 'cartel execution',
            'isis execution', 'terrorist execution', 'mass shooting', 'school shooting', 'shoot up',
            'bomb threat', 'kill everyone', 'murder everyone', 'massacre', 'bloodbath', 'blood bath',
            'self harm', 'self-harm', 'cutting myself', 'slit wrist', 'suicide video', 'kms', 'kys',
            'kill myself', 'kill yourself', 'neck rope', 'an hero', 'livestream shooting',
            'manifesto', 'going postal', 'rampage'
        ]
    },
    drugs: {
        name: 'Drugs & Substances',
        description: 'Filters drug-related content and substance abuse',
        icon: FILTER_PACK_ICONS.drugs,
        keywords: [
            'cocaine', 'c0caine', 'coke dealer', 'crack cocaine', 'heroin', 'her0in', 'h3roin',
            'fentanyl', 'fent', 'meth', 'm3th', 'methamphetamine', 'crystal meth', 'ice drug',
            'mdma', 'ecstasy', 'molly drug', 'lsd', 'acid trip', 'shrooms', 'magic mushrooms',
            'psilocybin', 'dmt', 'ayahuasca', 'ketamine', 'k hole', 'pcp', 'angel dust',
            'xanax', 'xans', 'bars drug', 'percocet', 'percs', 'oxy', 'oxycontin', 'oxycodone',
            'vicodin', 'codeine', 'lean drug', 'purple drank', 'sizzurp', 'drug dealer',
            'plug drug', 'trap house', 'cook meth', 'drug cartel', 'smuggling drugs',
            'inject heroin', 'shooting up', 'overdose', '0verdose', 'od\'d', 'nodding off'
        ]
    },
    spam: {
        name: 'Spam & Scams',
        description: 'Filters common spam, scam, and promotional content',
        icon: FILTER_PACK_ICONS.spam,
        keywords: [
            'free bitcoin', 'free btc', 'free crypto', 'double your bitcoin', 'double your btc',
            'send btc get', '2x return', '10x return', 'guaranteed profit', 'guaranteed returns',
            'investment opportunity', 'get rich quick', 'make money fast', 'passive income secret',
            'work from home scam', 'mlm opportunity', 'pyramid scheme', 'ponzi', 'rug pull',
            'pump and dump', 'to the moon', '100x gains', '1000x', 'next bitcoin', 'next ethereum',
            'presale token', 'airdrop claim', 'claim your tokens', 'connect wallet', 'mint now',
            'limited spots', 'act now', 'dm for details', 'dm me for', 'link in bio', 'check bio',
            'follow for follow', 'f4f', 'sub4sub', 'like4like', 'giveaway winner', 'you won',
            'congratulations you', 'claim your prize', 'click here now', 'sign up now',
            'telegram group', 'join our discord', 'whatsapp group', 'hot singles', 'date tonight',
            'viagra', 'v1agra', 'cialis', 'c1alis', 'weight loss', 'diet pill', 'enhancement pill'
        ]
    },
    crypto: {
        name: 'Cryptocurrency',
        description: 'Filters cryptocurrency promotion, trading signals, and token shilling',
        icon: FILTER_PACK_ICONS.crypto,
        keywords: [
            'bitcoin', 'btc', 'ethereum', 'eth', 'crypto', 'cryptocurrency', 'altcoin', 'altcoins',
            'blockchain', 'defi', 'nft', 'nfts', 'web3', 'hodl', 'hodling', 'fomo', 'fud',
            'bullish', 'bearish', 'mooning', 'lambo', 'wen lambo', 'wagmi', 'ngmi',
            'diamond hands', 'paper hands', 'whale', 'whales', 'pump', 'dump', 'dyor',
            'shill', 'shilling', 'shitcoin', 'memecoin', 'meme coin', 'dogecoin', 'doge',
            'shiba', 'shib', 'pepe coin', 'solana', 'sol', 'cardano', 'ada', 'xrp', 'ripple',
            'binance', 'bnb', 'coinbase', 'kraken', 'kucoin', 'ftx', 'dex', 'cex',
            'staking', 'yield farming', 'liquidity pool', 'airdrop', 'ico', 'ido', 'ieo',
            'token sale', 'presale', 'whitelist', 'mint', 'minting', 'gas fee', 'gas fees',
            'metamask', 'wallet connect', 'seed phrase', 'private key', 'cold wallet', 'hot wallet',
            'ledger', 'trezor', 'uniswap', 'pancakeswap', 'opensea', 'rarible',
            'trading signal', 'buy signal', 'sell signal', 'technical analysis', 'ta',
            'market cap', 'mcap', 'volume', 'candle', 'candlestick', 'resistance', 'support',
            'breakout', 'breakdown', 'rsi', 'macd', 'fibonacci', 'elliot wave'
        ]
    },
    politics: {
        name: 'Political Content',
        description: 'Filters partisan political content and divisive rhetoric',
        icon: FILTER_PACK_ICONS.politics,
        keywords: [
            'maga', 'make america great', 'trump', 'biden', 'lets go brandon', 'fjb',
            'trump supporter', 'biden supporter', 'libtard', 'l1btard', 'conservatard', 'republicunt',
            'demonrat', 'demoncrat', 'republikkkan', 'snowflake lib', 'triggered lib', 'own the libs',
            'woke mob', 'cancel culture', 'sjw', 'social justice warrior', 'antifa', 'ant1fa',
            'proud boys', 'proud boy', 'qanon', 'q anon', 'deep state', 'globalist', 'nwo',
            'new world order', 'great reset', 'build back better', 'stolen election', 'stop the steal',
            'election fraud', 'voter fraud', 'dominion machines', 'rigged election', 'plandemic',
            'scamdemic', 'covid hoax', 'vaccine injury', 'vaxxed', 'antivaxx', 'anti-vaxx',
            'big pharma', 'bill gates microchip', 'george soros', 'koch brothers', 'mainstream media',
            'fake news media', 'lamestream', 'sheeple', 'wake up sheeple'
        ]
    },
    profanity: {
        name: 'Strong Profanity',
        description: 'Filters strong profanity and vulgar language',
        icon: FILTER_PACK_ICONS.profanity,
        keywords: [
            'fuck', 'f*ck', 'fuk', 'fck', 'f u c k', 'fucking', 'fuckin', 'fucker', 'motherfuck',
            'motherfucker', 'mf', 'mfer', 'shit', 'sh1t', 'sh*t', 'bullshit', 'bullsh1t', 'horseshit',
            'shithead', 'shitface', 'asshole', 'assh0le', 'a**hole', 'ass hole', 'arsehole', 'arse',
            'bitch', 'b1tch', 'b*tch', 'bitches', 'son of a bitch', 'bastard', 'b4stard', 'dumbass',
            'dumb ass', 'jackass', 'jack ass', 'dipshit', 'dip shit', 'douchebag', 'douche bag',
            'douche', 'd-bag', 'scumbag', 'scum bag', 'piss off', 'pissed off', 'damn', 'goddamn',
            'god damn', 'bloody hell', 'bollocks', 'wanker', 'twat', 'bellend', 'cunt'
        ]
    }
};

// Enabled filter packs (stored in localStorage)
let enabledFilterPacks = new Set();
// Session-allowed filtered content (user clicked "show anyway")
let sessionFilteredAllowed = new Set();

// Initialize filter packs from localStorage
function initFilterPacks() {
    const stored = localStorage.getItem('plebsFilterPacks');
    if (stored) {
        try {
            const parsed = JSON.parse(stored);
            enabledFilterPacks = new Set(parsed);
        } catch (e) {
            console.error('Failed to parse filter packs:', e);
            enabledFilterPacks = new Set();
        }
    }
    // Update sidebar visibility based on saved filter packs
    updateSidebarFilterVisibility();
}

// Save filter packs to localStorage
function saveFilterPacks() {
    localStorage.setItem('plebsFilterPacks', JSON.stringify([...enabledFilterPacks]));
}

// Toggle a filter pack
function toggleFilterPack(packId) {
    if (enabledFilterPacks.has(packId)) {
        enabledFilterPacks.delete(packId);
    } else {
        enabledFilterPacks.add(packId);
    }
    saveFilterPacks();

    // Update UI checkbox
    const checkbox = document.getElementById(`filterPack_${packId}`);
    if (checkbox) {
        checkbox.checked = enabledFilterPacks.has(packId);
    }

    // Update sidebar visibility based on filter packs
    updateSidebarFilterVisibility();
}

// Update sidebar menu visibility based on enabled filter packs
function updateSidebarFilterVisibility() {
    // Hide NSFW link if Sexually Explicit filter is enabled
    const nsfwLink = document.getElementById('sidebar-nsfw-link');
    if (nsfwLink) {
        nsfwLink.style.display = enabledFilterPacks.has('sexualExplicit') ? 'none' : '';
    }

    // Hide Bitcoin link if Cryptocurrency filter is enabled
    const bitcoinLink = document.getElementById('sidebar-bitcoin-link');
    if (bitcoinLink) {
        bitcoinLink.style.display = enabledFilterPacks.has('crypto') ? 'none' : '';
    }

    // Hide Bitcoin featured topic section if on homepage and Crypto filter is enabled
    const bitcoinFeaturedSection = document.getElementById('featuredTopic3Section');
    if (bitcoinFeaturedSection) {
        bitcoinFeaturedSection.style.display = enabledFilterPacks.has('crypto') ? 'none' : '';
    }
}

// Check if text matches any enabled filter pack keywords or custom keywords
function matchesFilterPacks(text) {
    const hasFilterPacks = enabledFilterPacks.size > 0;
    const hasCustomKeywords = userSettings.customKeywordFilter && userSettings.customKeywordFilter.length > 0;

    if (!text || (!hasFilterPacks && !hasCustomKeywords)) return { matches: false, packs: [] };

    const lowerText = text.toLowerCase();
    const matchedPacks = [];

    // Check filter packs
    for (const packId of enabledFilterPacks) {
        const pack = FILTER_PACKS[packId];
        if (!pack) continue;

        for (const keyword of pack.keywords) {
            // Use word boundary matching to avoid false positives
            // But also check for intentional obfuscation patterns
            const escaped = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(^|[^a-z0-9])${escaped}([^a-z0-9]|$)`, 'i');

            if (regex.test(lowerText)) {
                matchedPacks.push({ packId, packName: pack.name, keyword });
                break; // One match per pack is enough
            }
        }
    }

    // Check custom keywords
    if (hasCustomKeywords) {
        for (const keyword of userSettings.customKeywordFilter) {
            const escaped = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const regex = new RegExp(`(^|[^a-z0-9])${escaped}([^a-z0-9]|$)`, 'i');

            if (regex.test(lowerText)) {
                matchedPacks.push({ packId: 'custom', packName: 'Custom Filter', keyword });
                break; // One match is enough for custom keywords
            }
        }
    }

    return {
        matches: matchedPacks.length > 0,
        packs: matchedPacks
    };
}

// Check if video content should be filtered
function shouldFilterVideoContent(event, videoData) {
    const hasFilters = enabledFilterPacks.size > 0 ||
        (userSettings.customKeywordFilter && userSettings.customKeywordFilter.length > 0);
    if (!hasFilters) return { filtered: false };

    // Check if user already allowed this content this session
    if (sessionFilteredAllowed.has(event.id)) {
        return { filtered: false };
    }

    // Filter NSFW videos when Sexually Explicit filter is enabled
    if (enabledFilterPacks.has('sexualExplicit')) {
        // Check for NSFW content-warning tag
        if (isVideoNSFW(event)) {
            return {
                filtered: true,
                packs: [{ packId: 'sexualExplicit', packName: 'Sexually Explicit' }],
                reason: 'Sexually Explicit'
            };
        }
        // Check for nsfw tag
        const tags = event.tags || [];
        if (tags.some(t => t[0] === 't' && t[1]?.toLowerCase() === 'nsfw')) {
            return {
                filtered: true,
                packs: [{ packId: 'sexualExplicit', packName: 'Sexually Explicit' }],
                reason: 'Sexually Explicit'
            };
        }
    }

    // Combine all text content to check
    const textToCheck = [
        videoData?.title || '',
        videoData?.description || '',
        ...(videoData?.tags || [])
    ].join(' ');

    const result = matchesFilterPacks(textToCheck);

    if (result.matches) {
        return {
            filtered: true,
            packs: result.packs,
            reason: result.packs.map(p => p.packName).join(', ')
        };
    }

    return { filtered: false };
}

// Check if comment should be filtered
function shouldFilterComment(commentText) {
    const hasFilters = enabledFilterPacks.size > 0 ||
        (userSettings.customKeywordFilter && userSettings.customKeywordFilter.length > 0);
    if (!hasFilters) return { filtered: false };

    const result = matchesFilterPacks(commentText);

    if (result.matches) {
        return {
            filtered: true,
            packs: result.packs,
            reason: result.packs.map(p => p.packName).join(', ')
        };
    }

    return { filtered: false };
}

// Allow filtered content for this session
function allowFilteredContent(eventId) {
    sessionFilteredAllowed.add(eventId);
}

// Create filtered content placeholder for videos
function createFilteredContentPlaceholder(event, filterResult, type = 'video') {
    const packNames = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.name || p.packName).join(', ');
    const packIcons = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.icon || '🚫').join(' ');

    if (type === 'video') {
        return `
            <div class="video-card filtered-content-placeholder" data-event-id="${event.id}">
                <div class="filtered-placeholder-content">
                    <div class="filtered-icon">${packIcons}</div>
                    <p>Content hidden by filter</p>
                    <p class="filtered-reason">${escapeHtml(packNames)}</p>
                    <button class="unhide-filtered-btn" onclick="handleUnhideFilteredContent('${event.id}')">
                        Show anyway
                    </button>
                </div>
            </div>
        `;
    } else if (type === 'comment') {
        return `
            <div class="comment filtered-comment-placeholder" data-event-id="${event.id}">
                <div class="filtered-placeholder-content filtered-comment">
                    <span class="filtered-icon-small">${packIcons}</span>
                    <span>Comment hidden (${escapeHtml(packNames)})</span>
                    <button class="unhide-filtered-btn-small" onclick="handleUnhideFilteredContent('${event.id}')">
                        Show
                    </button>
                </div>
            </div>
        `;
    }
    return '';
}

// Handle unhide filtered content
function handleUnhideFilteredContent(eventId) {
    allowFilteredContent(eventId);
    showToast('Showing filtered content', 'info');

    // Find and replace the placeholder
    const placeholder = document.querySelector(`.filtered-content-placeholder[data-event-id="${eventId}"], .filtered-comment-placeholder[data-event-id="${eventId}"]`);
    if (placeholder) {
        // Trigger a re-render by refreshing the current view
        const event = allEvents.get(eventId);
        if (event) {
            if (placeholder.classList.contains('video-card')) {
                // Re-render video card
                const profile = profileCache.get(event.pubkey);
                const reactions = reactionsCache.get(eventId);
                const isShort = isNip71ShortKind(event.kind);
                const newCard = isShort
                    ? createShortCard(event, profile, reactions)
                    : createVideoCard(event, profile, reactions);
                placeholder.outerHTML = newCard;
            } else {
                // For comments, re-render just this comment without reloading all
                const comment = currentCommentsState.comments.find(c => c.id === eventId);
                if (comment) {
                    // Get depth from placeholder data attribute
                    const depth = parseInt(placeholder.dataset.depth || '0', 10);
                    const commentWithDepth = { ...comment, depth, children: [] };

                    // Create the comment element
                    const commentElement = createCommentElement(
                        commentWithDepth,
                        profileCache,
                        currentCommentsState.reactions,
                        currentCommentsState.zaps
                    );

                    // Replace placeholder with the actual comment
                    placeholder.replaceWith(commentElement);
                }
            }
        }
    }
}

// ===== PERFORMANCE OPTIMIZATIONS =====

// Relay latency tracking
const relayLatency = new Map();

// LRU Cache implementation for memory management
class LRUCache {
    constructor(maxSize = 500) {
        this.maxSize = maxSize;
        this.cache = new Map();
    }

    get(key) {
        if (!this.cache.has(key)) return undefined;
        const value = this.cache.get(key);
        // Move to end (most recently used)
        this.cache.delete(key);
        this.cache.set(key, value);
        return value;
    }

    set(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.maxSize) {
            // Delete oldest (first) entry
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }

    has(key) {
        return this.cache.has(key);
    }

    delete(key) {
        return this.cache.delete(key);
    }

    clear() {
        this.cache.clear();
    }

    get size() {
        return this.cache.size;
    }
}

// Replace standard Maps with LRU caches for better memory management
const profileCacheLRU = new LRUCache(1000);
const reactionsCacheLRU = new LRUCache(2000);

// Debounce utility function
function debounce(func, wait, immediate = false) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            timeout = null;
            if (!immediate) func.apply(this, args);
        };
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(this, args);
    };
}

// Throttle utility function
function throttle(func, limit) {
    let inThrottle;
    return function executedFunction(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// ===== NIP-71 VIDEO EVENT HELPERS =====

// Generate a unique d-tag identifier for parameterized replaceable events
function generateVideoDTag() {
    // Create a unique identifier using timestamp and random string
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 10);
    return `video-${timestamp}-${random}`;
}

// Get image dimensions from a file
function getImageDimensions(file) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = () => {
            URL.revokeObjectURL(url);
            resolve({ width: img.naturalWidth, height: img.naturalHeight });
        };

        img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to load image'));
        };

        img.src = url;
    });
}

// Check if an image orientation matches the video type (vertical for Shorts, horizontal for regular)
function isThumbnailOrientationValid(thumbnailWidth, thumbnailHeight, isShortVideo) {
    const thumbnailIsVertical = thumbnailHeight > thumbnailWidth;
    // For Shorts, thumbnail should be vertical; for regular videos, thumbnail should be horizontal
    return isShortVideo === thumbnailIsVertical;
}

// Capture a frame from a video URL at a specific time and return as a File object
function captureVideoFrame(videoUrl, captureTimeSeconds = 2) {
    return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        video.muted = true;
        video.preload = 'auto';
        video.crossOrigin = 'anonymous';

        video.onloadedmetadata = () => {
            // Ensure capture time is within video duration (default to 2s or 10% into video)
            const duration = video.duration;
            const seekTime = Math.min(captureTimeSeconds, duration * 0.1, duration - 0.5);
            video.currentTime = Math.max(0, seekTime);
        };

        video.onseeked = () => {
            try {
                // Set canvas to video dimensions
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                // Draw the video frame to canvas
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                // Convert canvas to blob
                canvas.toBlob((blob) => {
                    if (blob) {
                        // Create a File object from the blob
                        const file = new File([blob], 'auto-thumbnail.jpg', { type: 'image/jpeg' });
                        resolve({
                            file: file,
                            width: canvas.width,
                            height: canvas.height
                        });
                    } else {
                        reject(new Error('Failed to create thumbnail blob'));
                    }
                }, 'image/jpeg', 0.85);
            } catch (error) {
                reject(error);
            }
        };

        video.onerror = () => {
            reject(new Error('Failed to load video for thumbnail capture'));
        };

        video.src = videoUrl;
    });
}

// GIF Encoder - Creates animated GIFs from canvas frames
// Based on NeuQuant algorithm and LZW compression
const GIFEncoder = {
    // LZW encoding
    encode: function(width, height, frames, delay = 100) {
        const stream = [];

        // GIF Header
        this.writeString(stream, 'GIF89a');

        // Logical Screen Descriptor
        this.writeShort(stream, width);
        this.writeShort(stream, height);
        stream.push(0xF7); // Global Color Table Flag + Color Resolution + Sort Flag + Size (256 colors)
        stream.push(0x00); // Background Color Index
        stream.push(0x00); // Pixel Aspect Ratio

        // Global Color Table (256 colors)
        const colorTable = this.buildColorTable(frames);
        for (let i = 0; i < 256; i++) {
            stream.push(colorTable[i * 3] || 0);
            stream.push(colorTable[i * 3 + 1] || 0);
            stream.push(colorTable[i * 3 + 2] || 0);
        }

        // Netscape Application Extension (for looping)
        stream.push(0x21, 0xFF, 0x0B);
        this.writeString(stream, 'NETSCAPE2.0');
        stream.push(0x03, 0x01);
        this.writeShort(stream, 0); // Loop forever
        stream.push(0x00);

        // Process each frame
        for (const frameData of frames) {
            // Graphics Control Extension
            stream.push(0x21, 0xF9, 0x04);
            stream.push(0x04); // Disposal method: restore to background
            this.writeShort(stream, Math.round(delay / 10)); // Delay in 1/100ths of a second
            stream.push(0x00); // Transparent color index (none)
            stream.push(0x00);

            // Image Descriptor
            stream.push(0x2C);
            this.writeShort(stream, 0); // Left
            this.writeShort(stream, 0); // Top
            this.writeShort(stream, width);
            this.writeShort(stream, height);
            stream.push(0x00); // No local color table

            // Image Data
            const indexedPixels = this.quantizeFrame(frameData, colorTable, width, height);
            this.writeLZW(stream, indexedPixels, 8);
        }

        // GIF Trailer
        stream.push(0x3B);

        return new Uint8Array(stream);
    },

    writeString: function(stream, str) {
        for (let i = 0; i < str.length; i++) {
            stream.push(str.charCodeAt(i));
        }
    },

    writeShort: function(stream, val) {
        stream.push(val & 0xFF);
        stream.push((val >> 8) & 0xFF);
    },

    buildColorTable: function(frames) {
        // Simple color quantization - sample colors from all frames
        const colorCounts = new Map();

        for (const frame of frames) {
            for (let i = 0; i < frame.length; i += 4) {
                // Quantize to 5-bit color for grouping
                const r = frame[i] & 0xF8;
                const g = frame[i + 1] & 0xF8;
                const b = frame[i + 2] & 0xF8;
                const key = (r << 16) | (g << 8) | b;
                colorCounts.set(key, (colorCounts.get(key) || 0) + 1);
            }
        }

        // Sort by frequency and take top 256
        const sortedColors = [...colorCounts.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, 256);

        const table = new Uint8Array(768);
        for (let i = 0; i < sortedColors.length; i++) {
            const color = sortedColors[i][0];
            table[i * 3] = (color >> 16) & 0xFF;
            table[i * 3 + 1] = (color >> 8) & 0xFF;
            table[i * 3 + 2] = color & 0xFF;
        }

        return table;
    },

    quantizeFrame: function(frameData, colorTable, width, height) {
        const pixels = new Uint8Array(width * height);

        for (let i = 0; i < width * height; i++) {
            const r = frameData[i * 4];
            const g = frameData[i * 4 + 1];
            const b = frameData[i * 4 + 2];

            // Find closest color in palette
            let minDist = Infinity;
            let bestIndex = 0;

            for (let j = 0; j < 256; j++) {
                const dr = r - colorTable[j * 3];
                const dg = g - colorTable[j * 3 + 1];
                const db = b - colorTable[j * 3 + 2];
                const dist = dr * dr + dg * dg + db * db;

                if (dist < minDist) {
                    minDist = dist;
                    bestIndex = j;
                    if (dist === 0) break;
                }
            }

            pixels[i] = bestIndex;
        }

        return pixels;
    },

    writeLZW: function(stream, pixels, minCodeSize) {
        stream.push(minCodeSize);

        const clearCode = 1 << minCodeSize;
        const eoiCode = clearCode + 1;

        let codeSize = minCodeSize + 1;
        let nextCode = eoiCode + 1;
        const codeTable = new Map();

        // Initialize code table
        for (let i = 0; i < clearCode; i++) {
            codeTable.set(String.fromCharCode(i), i);
        }

        let buffer = 0;
        let bufferSize = 0;
        const subBlock = [];

        const writeCode = (code) => {
            buffer |= code << bufferSize;
            bufferSize += codeSize;

            while (bufferSize >= 8) {
                subBlock.push(buffer & 0xFF);
                buffer >>= 8;
                bufferSize -= 8;

                if (subBlock.length === 255) {
                    stream.push(255);
                    for (const b of subBlock) stream.push(b);
                    subBlock.length = 0;
                }
            }
        };

        writeCode(clearCode);

        let indexBuffer = String.fromCharCode(pixels[0]);

        for (let i = 1; i < pixels.length; i++) {
            const k = String.fromCharCode(pixels[i]);
            const combined = indexBuffer + k;

            if (codeTable.has(combined)) {
                indexBuffer = combined;
            } else {
                writeCode(codeTable.get(indexBuffer));

                if (nextCode < 4096) {
                    codeTable.set(combined, nextCode++);
                    if (nextCode > (1 << codeSize) && codeSize < 12) {
                        codeSize++;
                    }
                }

                indexBuffer = k;
            }
        }

        writeCode(codeTable.get(indexBuffer));
        writeCode(eoiCode);

        // Flush remaining bits
        if (bufferSize > 0) {
            subBlock.push(buffer & 0xFF);
        }

        // Write remaining sub-block
        if (subBlock.length > 0) {
            stream.push(subBlock.length);
            for (const b of subBlock) stream.push(b);
        }

        stream.push(0x00); // Block terminator
    }
};

// Detect iOS/Safari for optimized handling
function isIOSOrSafari() {
    const ua = navigator.userAgent;
    const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
    return isIOS || isSafari;
}

// Generate an animated GIF preview from a video URL
// Captures frames from the first few seconds and creates a looping GIF
// Optimized for cross-browser compatibility including iOS/Safari
function generatePreviewGif(videoUrl, options = {}) {
    // Use fewer frames on iOS/Safari for faster processing
    const isMobileOrSafari = isIOSOrSafari();
    const defaultFrameCount = isMobileOrSafari ? 5 : 8;

    const {
        frameCount = defaultFrameCount,
        startTime = 0.5,
        duration = 3,
        maxWidth = isMobileOrSafari ? 240 : 320,  // Smaller on mobile for speed
        frameDelay = 150,
        seekTimeout = isMobileOrSafari ? 3000 : 2000  // Timeout per seek operation
    } = options;

    return new Promise((resolve, reject) => {
        // Use parallel video loading for faster frame capture on all browsers
        const captureFrameAtTime = (url, time, width, height) => {
            return new Promise((resolveFrame, rejectFrame) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                video.muted = true;
                video.playsInline = true;  // Required for iOS
                video.preload = 'metadata';
                video.crossOrigin = 'anonymous';

                // Timeout for this frame capture
                const timeout = setTimeout(() => {
                    video.src = '';
                    rejectFrame(new Error('Frame capture timeout'));
                }, seekTimeout);

                video.onloadedmetadata = () => {
                    canvas.width = width;
                    canvas.height = height;
                    video.currentTime = Math.min(time, video.duration - 0.1);
                };

                video.onseeked = () => {
                    clearTimeout(timeout);
                    try {
                        ctx.drawImage(video, 0, 0, width, height);
                        const imageData = ctx.getImageData(0, 0, width, height);
                        video.src = '';  // Clean up
                        resolveFrame(new Uint8Array(imageData.data));
                    } catch (error) {
                        video.src = '';
                        rejectFrame(error);
                    }
                };

                video.onerror = () => {
                    clearTimeout(timeout);
                    video.src = '';
                    rejectFrame(new Error('Failed to load video frame'));
                };

                video.src = url;
            });
        };

        // First, get video metadata to calculate dimensions and timing
        const metaVideo = document.createElement('video');
        metaVideo.muted = true;
        metaVideo.playsInline = true;
        metaVideo.preload = 'metadata';
        metaVideo.crossOrigin = 'anonymous';

        const metaTimeout = setTimeout(() => {
            metaVideo.src = '';
            reject(new Error('Video metadata load timeout'));
        }, 10000);

        metaVideo.onloadedmetadata = async () => {
            clearTimeout(metaTimeout);

            try {
                // Calculate scaled dimensions
                const aspectRatio = metaVideo.videoWidth / metaVideo.videoHeight;
                let width = Math.min(maxWidth, metaVideo.videoWidth);
                let height = Math.round(width / aspectRatio);

                // Ensure even dimensions
                width = width - (width % 2);
                height = height - (height % 2);

                // Calculate frame times
                const videoDuration = metaVideo.duration;
                const actualDuration = Math.min(duration, videoDuration - startTime);
                const frameInterval = actualDuration / (frameCount - 1);

                const frameTimes = [];
                for (let i = 0; i < frameCount; i++) {
                    frameTimes.push(Math.min(startTime + (i * frameInterval), videoDuration - 0.1));
                }

                metaVideo.src = '';  // Clean up metadata video

                // Capture frames in parallel (up to 3 concurrent for balance)
                const frames = [];
                const batchSize = isMobileOrSafari ? 2 : 3;  // Smaller batches on mobile

                for (let i = 0; i < frameTimes.length; i += batchSize) {
                    const batch = frameTimes.slice(i, i + batchSize);
                    const batchPromises = batch.map(time =>
                        captureFrameAtTime(videoUrl, time, width, height)
                            .catch(() => null)  // Don't fail entire process for one frame
                    );

                    const batchResults = await Promise.all(batchPromises);
                    for (const result of batchResults) {
                        if (result) frames.push(result);
                    }
                }

                // Need at least 2 frames for a GIF
                if (frames.length < 2) {
                    reject(new Error('Could not capture enough frames'));
                    return;
                }

                // Generate GIF
                const gifData = GIFEncoder.encode(width, height, frames, frameDelay);
                const blob = new Blob([gifData], { type: 'image/gif' });
                const file = new File([blob], 'preview.gif', { type: 'image/gif' });

                resolve({
                    file: file,
                    width: width,
                    height: height,
                    frameCount: frames.length
                });
            } catch (error) {
                reject(new Error('Failed to generate GIF: ' + error.message));
            }
        };

        metaVideo.onerror = () => {
            clearTimeout(metaTimeout);
            metaVideo.src = '';
            reject(new Error('Failed to load video for preview generation'));
        };

        metaVideo.src = videoUrl;
    });
}

// Determine if a video should be a "short" (kind 22) based on dimensions and duration
function isVideoShort(width, height, duration = null) {
    if (!width || !height) return false;

    // Video is considered a "short" if it's vertical (height > width)
    const aspectRatio = width / height;
    const isVertical = aspectRatio < 1; // Portrait orientation

    // If duration is provided, also check if it's under 60 seconds
    // A short must be vertical AND (if duration is known) under 60 seconds
    if (duration !== null && duration > 0) {
        return isVertical && duration <= 60;
    }

    // If no duration, just check orientation
    return isVertical;
}

// Validate that a video file is vertical (for Create Short modal validation)
function validateVideoIsVertical(file) {
    return new Promise((resolve) => {
        const video = document.createElement('video');
        video.preload = 'metadata';

        video.onloadedmetadata = function() {
            URL.revokeObjectURL(video.src);
            const isVertical = video.videoHeight > video.videoWidth;
            resolve(isVertical);
        };

        video.onerror = function() {
            URL.revokeObjectURL(video.src);
            // On error, allow upload (let the normal processing handle it)
            resolve(true);
        };

        video.src = URL.createObjectURL(file);
    });
}

// Create NIP-71 imeta tag from video data
function createImetaTag(videoData) {
    const parts = [];

    // Primary URL
    if (videoData.url) {
        parts.push(`url ${videoData.url}`);
    }

    // Fallback URLs from successful blossom uploads
    if (videoData.mirrors && videoData.mirrors.length > 0) {
        videoData.mirrors.forEach(mirror => {
            if (mirror.url && mirror.url !== videoData.url) {
                parts.push(`fallback ${mirror.url}`);
            }
        });
    }

    // File hash
    if (videoData.hash) {
        parts.push(`x ${videoData.hash}`);
    }

    // MIME type
    if (videoData.type) {
        parts.push(`m ${videoData.type}`);
    }

    // File size
    if (videoData.size) {
        parts.push(`size ${videoData.size}`);
    }

    // Dimensions
    if (videoData.width && videoData.height) {
        parts.push(`dim ${videoData.width}x${videoData.height}`);
    }

    // Duration (in seconds)
    if (videoData.duration) {
        parts.push(`duration ${Math.floor(videoData.duration)}`);
    }

    // Thumbnail/preview image
    if (videoData.thumbnail) {
        parts.push(`image ${videoData.thumbnail}`);
    }

    // Animated preview GIF for hover effect
    if (videoData.preview) {
        parts.push(`preview ${videoData.preview}`);
    }

    return ['imeta', ...parts];
}

// Create a NIP-71 video event (kind 21 or 22)
function createNip71VideoEvent(videoData) {
    // When editing, preserve the original kind to ensure proper replacement
    // Otherwise, calculate kind based on dimensions
    let kind;
    if (videoData.originalKind === NIP71_VIDEO_KIND || videoData.originalKind === NIP71_SHORT_KIND) {
        kind = videoData.originalKind;
    } else {
        const isShort = isVideoShort(videoData.width, videoData.height, videoData.duration);
        kind = isShort ? NIP71_SHORT_KIND : NIP71_VIDEO_KIND;
    }

    // Generate or use existing d-tag for parameterized replaceable event
    const dTag = videoData.dTag || generateVideoDTag();

    const tags = [
        ['d', dTag],
        ['title', videoData.title],
        createImetaTag(videoData),
        ['t', 'pv69420'], // Keep our app identifier for easy filtering
        ...videoData.tags.map(tag => ['t', tag]),
        ['client', 'Plebs']
    ];

    // Add published_at if this is an edit (use original publish time)
    if (videoData.publishedAt) {
        tags.push(['published_at', videoData.publishedAt.toString()]);
    }

    // Add content warning if NSFW
    if (videoData.isNSFW) {
        tags.push(['content-warning', 'nsfw']);
    }

    // Add thumbnail as separate tag for backwards compatibility
    if (videoData.thumbnail) {
        tags.push(['thumb', videoData.thumbnail]);
    }

    // Add preview GIF as separate tag for hover previews
    if (videoData.preview) {
        tags.push(['preview', videoData.preview]);
    }

    // Add legacy tags for broader compatibility
    tags.push(['x', videoData.hash]);
    tags.push(['url', videoData.url]);
    tags.push(['m', videoData.type || 'video/mp4']);
    tags.push(['size', (videoData.size || 0).toString()]);
    tags.push(['duration', Math.floor(videoData.duration || 0).toString()]);

    return {
        kind: kind,
        tags: tags,
        content: videoData.description || '',
        created_at: Math.floor(Date.now() / 1000)
    };
}

// Create a kind 1 video event (for backwards compatibility)
function createKind1VideoEvent(videoData) {
    const tags = [
        ['title', videoData.title],
        ['t', 'pv69420'],
        ...videoData.tags.map(tag => ['t', tag]),
        ['x', videoData.hash],
        ['url', videoData.url],
        ['m', videoData.type || 'video/mp4'],
        ['size', (videoData.size || 0).toString()],
        ['duration', Math.floor(videoData.duration || 0).toString()],
        ['thumb', videoData.thumbnail],
        ['client', 'Plebs']
    ];

    if (videoData.isNSFW) {
        tags.push(['content-warning', 'nsfw']);
    }

    // Link to NIP-71 event if we have a d-tag
    if (videoData.dTag) {
        tags.push(['nip71-d', videoData.dTag]);
    }

    return {
        kind: 1,
        tags: tags,
        content: `${escapeHtml(videoData.title)}\n\n${escapeHtml(videoData.description)}\n\n${videoData.url}`,
        created_at: Math.floor(Date.now() / 1000)
    };
}

// Create a legacy NIP-71 video event (kind 21/22 - for maximum reach on other clients)
function createLegacyNip71VideoEvent(videoData) {
    const isShort = isVideoShort(videoData.width, videoData.height, videoData.duration);
    const kind = isShort ? NIP71_SHORT_KIND_LEGACY : NIP71_VIDEO_KIND_LEGACY;

    const tags = [
        ['d', videoData.dTag || generateVideoDTag()],
        ['title', videoData.title],
        createImetaTag(videoData),
        ['t', 'pv69420'],
        ...videoData.tags.map(tag => ['t', tag]),
        ['client', 'Plebs']
    ];

    // Add published_at if this is an edit
    if (videoData.publishedAt) {
        tags.push(['published_at', videoData.publishedAt.toString()]);
    }

    // Add content warning if NSFW
    if (videoData.isNSFW) {
        tags.push(['content-warning', 'nsfw']);
    }

    // Add thumbnail as separate tag for backwards compatibility
    if (videoData.thumbnail) {
        tags.push(['thumb', videoData.thumbnail]);
    }

    // Add preview GIF as separate tag for hover previews
    if (videoData.preview) {
        tags.push(['preview', videoData.preview]);
    }

    // Add legacy tags for broader compatibility
    tags.push(['x', videoData.hash]);
    tags.push(['url', videoData.url]);
    tags.push(['m', videoData.type || 'video/mp4']);
    tags.push(['size', (videoData.size || 0).toString()]);
    tags.push(['duration', Math.floor(videoData.duration || 0).toString()]);

    return {
        kind: kind,
        tags: tags,
        content: videoData.description || '',
        created_at: Math.floor(Date.now() / 1000)
    };
}

// Helper to check if event kind is a NIP-71 video (normal) kind
function isNip71VideoKind(kind) {
    return kind === NIP71_VIDEO_KIND || kind === NIP71_VIDEO_KIND_LEGACY;
}

// Helper to check if event kind is a NIP-71 short kind
function isNip71ShortKind(kind) {
    return kind === NIP71_SHORT_KIND || kind === NIP71_SHORT_KIND_LEGACY;
}

// Helper to check if event kind is any NIP-71 kind
function isNip71Kind(kind) {
    return isNip71VideoKind(kind) || isNip71ShortKind(kind);
}

// Helper to check if a video event is a short (based on kind)
function isShortVideoEvent(event) {
    if (!event) return false;
    // NIP-71 short kinds (34236, 22) are shorts
    return isNip71ShortKind(event.kind);
}

// Helper to get video kinds for filtering (shorts vs normal)
function getVideoKindsForType(preferShorts) {
    if (preferShorts) {
        // Short kinds first
        return [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY, NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1];
    } else {
        // Normal video kinds first
        return [NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1, NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY];
    }
}

// Parse NIP-71 video event (kind 34235/34236 or legacy 21/22)
function parseNip71VideoEvent(event) {
    if (!isNip71Kind(event.kind)) {
        return null;
    }

    const tags = event.tags || [];

    // Check for our app identifier
    if (!tags.some(tag => tag[0] === 't' && tag[1] === 'pv69420')) {
        return null;
    }

    const videoData = {
        title: '',
        description: event.content || '',
        hash: '',
        url: '',
        fallbackUrls: [],
        thumbnail: '',
        preview: '',
        duration: 0,
        size: 0,
        type: 'video/mp4',
        width: 0,
        height: 0,
        tags: [],
        author: event.pubkey,
        dTag: '',
        publishedAt: event.created_at,
        isShort: isNip71ShortKind(event.kind),
        kind: event.kind
    };

    for (const tag of tags) {
        switch (tag[0]) {
            case 'd':
                videoData.dTag = tag[1];
                break;
            case 'title':
                videoData.title = tag[1];
                break;
            case 'imeta':
                // Parse imeta tag (NIP-92 format)
                for (let i = 1; i < tag.length; i++) {
                    const part = tag[i];
                    const spaceIndex = part.indexOf(' ');
                    if (spaceIndex === -1) continue;

                    const key = part.substring(0, spaceIndex);
                    const value = part.substring(spaceIndex + 1);

                    switch (key) {
                        case 'url':
                            if (!videoData.url) {
                                videoData.url = value;
                            } else {
                                videoData.fallbackUrls.push(value);
                            }
                            break;
                        case 'fallback':
                            videoData.fallbackUrls.push(value);
                            break;
                        case 'x':
                            videoData.hash = value;
                            break;
                        case 'm':
                            videoData.type = value;
                            break;
                        case 'size':
                            videoData.size = parseInt(value) || 0;
                            break;
                        case 'dim':
                            const dims = value.split('x');
                            if (dims.length === 2) {
                                videoData.width = parseInt(dims[0]) || 0;
                                videoData.height = parseInt(dims[1]) || 0;
                            }
                            break;
                        case 'duration':
                            videoData.duration = parseInt(value) || 0;
                            break;
                        case 'image':
                            if (!videoData.thumbnail) {
                                videoData.thumbnail = value;
                            }
                            break;
                        case 'preview':
                            if (!videoData.preview) {
                                videoData.preview = value;
                            }
                            break;
                    }
                }
                break;
            case 'thumb':
                if (!videoData.thumbnail) {
                    videoData.thumbnail = tag[1];
                }
                break;
            case 'preview':
                if (!videoData.preview) {
                    videoData.preview = tag[1];
                }
                break;
            case 'x':
                if (!videoData.hash) {
                    videoData.hash = tag[1];
                }
                break;
            case 'url':
                if (!videoData.url) {
                    videoData.url = tag[1];
                }
                break;
            case 'm':
                if (videoData.type === 'video/mp4') {
                    videoData.type = tag[1];
                }
                break;
            case 'size':
                if (!videoData.size) {
                    videoData.size = parseInt(tag[1]) || 0;
                }
                break;
            case 'duration':
                if (!videoData.duration) {
                    videoData.duration = parseInt(tag[1]) || 0;
                }
                break;
            case 'published_at':
                videoData.publishedAt = parseInt(tag[1]) || event.created_at;
                break;
            case 't':
                if (tag[1] && tag[1] !== 'pv69420') {
                    videoData.tags.push(tag[1]);
                }
                break;
            case 'content-warning':
                videoData.isNSFW = tag[1] === 'nsfw';
                break;
        }
    }

    return videoData.title ? videoData : null;
}

// Parse any video event (supports both kind 1 and NIP-71)
function parseAnyVideoEvent(event) {
    if (isNip71Kind(event.kind)) {
        return parseNip71VideoEvent(event);
    } else if (event.kind === 1) {
        return parseVideoEvent(event);
    }
    return null;
}

// Check if an event is a video event (kind 1 with pv69420, or NIP-71 kinds)
function isVideoEvent(event) {
    if (isNip71Kind(event.kind)) {
        return event.tags?.some(tag => tag[0] === 't' && tag[1] === 'pv69420');
    }
    if (event.kind === 1) {
        return event.tags?.some(tag => tag[0] === 't' && tag[1] === 'pv69420');
    }
    return false;
}

// Find linked events (kind 1 <-> NIP-71) by d-tag
async function findLinkedVideoEvents(event) {
    const linkedIds = [];
    const dTag = event.tags?.find(t => t[0] === 'd')?.[1] ||
                 event.tags?.find(t => t[0] === 'nip71-d')?.[1];

    if (!dTag) return linkedIds;

    // If this is a kind 1 event, look for NIP-71 events with matching d-tag
    if (event.kind === 1) {
        const filter = {
            kinds: [NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY],
            authors: [event.pubkey],
            '#d': [dTag]
        };

        return new Promise(resolve => {
            requestEventsStream(filter, (linkedEvent) => {
                linkedIds.push(linkedEvent.id);
                allEvents.set(linkedEvent.id, linkedEvent);
                videoEventLinks.set(event.id, linkedEvent.id);
                videoEventLinks.set(linkedEvent.id, event.id);
            }, () => resolve(linkedIds));
        });
    }

    // If this is an addressable NIP-71 event (34235/34236), look for kind 1, legacy kind 21/22, AND historical versions
    if (event.kind === NIP71_VIDEO_KIND || event.kind === NIP71_SHORT_KIND) {
        return new Promise(resolve => {
            // Query ALL video events from this author with pv69420 tag, then filter locally by d-tag
            // This is more reliable than using #d or #nip71-d filters which some relays don't support
            const filter = {
                kinds: [1, NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY],
                authors: [event.pubkey],
                '#t': ['pv69420']
            };

            requestEventsStream(filter, (linkedEvent) => {
                // Skip self
                if (linkedEvent.id === event.id) return;
                if (linkedIds.includes(linkedEvent.id)) return;

                // Check if this event has matching d-tag or nip71-d tag
                const linkedDTag = linkedEvent.tags?.find(t => t[0] === 'd')?.[1];
                const linkedNip71DTag = linkedEvent.tags?.find(t => t[0] === 'nip71-d')?.[1];

                if (linkedDTag === dTag || linkedNip71DTag === dTag) {
                    linkedIds.push(linkedEvent.id);
                    allEvents.set(linkedEvent.id, linkedEvent);
                    videoEventLinks.set(event.id, linkedEvent.id);
                    videoEventLinks.set(linkedEvent.id, event.id);
                }
            }, () => resolve(linkedIds));
        });
    }

    // If this is a legacy NIP-71 event (21/22), look for kind 1 with matching nip71-d tag
    if (event.kind === NIP71_VIDEO_KIND_LEGACY || event.kind === NIP71_SHORT_KIND_LEGACY) {
        const filter = {
            kinds: [1],
            authors: [event.pubkey],
            '#nip71-d': [dTag],
            '#t': ['pv69420']
        };

        return new Promise(resolve => {
            requestEventsStream(filter, (linkedEvent) => {
                linkedIds.push(linkedEvent.id);
                allEvents.set(linkedEvent.id, linkedEvent);
                videoEventLinks.set(event.id, linkedEvent.id);
                videoEventLinks.set(linkedEvent.id, event.id);
            }, () => resolve(linkedIds));
        });
    }

    return linkedIds;
}

// Check if a legacy event (kind 1 or kind 21/22) should be skipped
// We only show addressable events (kind 34235/34236) as the primary source
// This prevents showing duplicate videos when multiple event types exist
function shouldSkipLegacyEvent(event) {
    // Addressable events (34235/34236) are always shown
    if (event.kind === NIP71_VIDEO_KIND || event.kind === NIP71_SHORT_KIND) {
        return false;
    }

    // For kind 1 events: skip if they have a nip71-d tag (means NIP-71 version exists)
    if (event.kind === 1) {
        const nip71DTag = event.tags?.find(t => t[0] === 'nip71-d')?.[1];
        if (nip71DTag) {
            return true;
        }
    }

    // For legacy NIP-71 events (21/22): skip only if we find the addressable counterpart in cache
    if (event.kind === NIP71_VIDEO_KIND_LEGACY || event.kind === NIP71_SHORT_KIND_LEGACY) {
        const dTag = event.tags?.find(t => t[0] === 'd')?.[1];
        if (dTag) {
            // Check if we have an addressable counterpart with the same d-tag
            for (const [id, cachedEvent] of allEvents) {
                if ((cachedEvent.kind === NIP71_VIDEO_KIND || cachedEvent.kind === NIP71_SHORT_KIND) &&
                    cachedEvent.pubkey === event.pubkey) {
                    const cachedDTag = cachedEvent.tags?.find(t => t[0] === 'd')?.[1];
                    if (cachedDTag === dTag) {
                        return true;
                    }
                }
            }
            // Don't skip if addressable counterpart not found - show the legacy event
        }
    }

    // Check via videoEventLinks for events linked to addressable events
    const linkedId = videoEventLinks.get(event.id);
    if (linkedId) {
        const linkedEvent = allEvents.get(linkedId);
        if (linkedEvent && (linkedEvent.kind === NIP71_VIDEO_KIND || linkedEvent.kind === NIP71_SHORT_KIND)) {
            return true;
        }
    }

    return false;
}

// Get all event IDs to query for reactions/zaps (includes linked events)
// This allows merging reactions from addressable, legacy NIP-71, and kind 1 events
function getAllLinkedEventIds(eventId) {
    const ids = new Set([eventId]);
    const toProcess = [eventId];

    // Traverse all linked events (BFS)
    while (toProcess.length > 0) {
        const currentId = toProcess.shift();

        // Check for linked events in videoEventLinks
        for (const [id, linkedId] of videoEventLinks) {
            if (id === currentId && !ids.has(linkedId)) {
                ids.add(linkedId);
                toProcess.push(linkedId);
            }
            if (linkedId === currentId && !ids.has(id)) {
                ids.add(id);
                toProcess.push(id);
            }
        }
    }

    // Also check allEvents for videos with matching d-tag or nip71-d tag
    const event = allEvents.get(eventId);
    if (event) {
        const dTag = event.tags?.find(t => t[0] === 'd')?.[1] ||
                     event.tags?.find(t => t[0] === 'nip71-d')?.[1];
        if (dTag) {
            for (const [id, cachedEvent] of allEvents) {
                if (ids.has(id)) continue;
                if (cachedEvent.pubkey !== event.pubkey) continue;

                // Check if this event has matching d-tag or nip71-d tag
                const cachedDTag = cachedEvent.tags?.find(t => t[0] === 'd')?.[1];
                const cachedNip71DTag = cachedEvent.tags?.find(t => t[0] === 'nip71-d')?.[1];

                if (cachedDTag === dTag || cachedNip71DTag === dTag) {
                    ids.add(id);
                    // Also add to videoEventLinks for future lookups
                    videoEventLinks.set(eventId, id);
                    videoEventLinks.set(id, eventId);
                }
            }
        }
    }

    return Array.from(ids);
}

// ===== NIP-13 Proof of Work Validation =====
// Count leading zero bits in a hex string (event ID)
function countLeadingZeroBits(hexString) {
    let count = 0;
    for (let i = 0; i < hexString.length; i++) {
        const nibble = parseInt(hexString[i], 16);
        if (nibble === 0) {
            count += 4;
        } else {
            // Count leading zeros in this nibble
            if (nibble < 2) count += 3;
            else if (nibble < 4) count += 2;
            else if (nibble < 8) count += 1;
            break;
        }
    }
    return count;
}

// Validate that an event has sufficient proof of work (NIP-13)
function validateEventPoW(event, minDifficulty = MIN_POW_DIFFICULTY) {
    if (!event || !event.id) return false;

    // Check for nonce tag (NIP-13 compliance)
    const nonceTag = event.tags?.find(t => t[0] === 'nonce');
    if (!nonceTag) return false;

    // The nonce tag should have: ['nonce', '<random>', '<target_difficulty>']
    const targetDifficulty = parseInt(nonceTag[2], 10);
    if (isNaN(targetDifficulty) || targetDifficulty < minDifficulty) return false;

    // Count actual leading zero bits in the event ID
    const actualDifficulty = countLeadingZeroBits(event.id);

    return actualDifficulty >= minDifficulty;
}

// Generate proof of work for an event (NIP-13)
// This is computationally intensive - runs in a loop until target difficulty is met
async function generatePoW(eventTemplate, targetDifficulty = MIN_POW_DIFFICULTY) {
    let nonce = 0;
    const maxIterations = 10000000; // Safety limit

    // Add nonce tag placeholder
    const nonceTagIndex = eventTemplate.tags.findIndex(t => t[0] === 'nonce');
    if (nonceTagIndex >= 0) {
        eventTemplate.tags.splice(nonceTagIndex, 1);
    }

    while (nonce < maxIterations) {
        // Update nonce tag
        const tagsWithNonce = [...eventTemplate.tags, ['nonce', nonce.toString(), targetDifficulty.toString()]];

        // Create event for hashing
        const eventForHash = {
            pubkey: eventTemplate.pubkey,
            created_at: eventTemplate.created_at,
            kind: eventTemplate.kind,
            tags: tagsWithNonce,
            content: eventTemplate.content
        };

        // Serialize and hash (NIP-01 format)
        const serialized = JSON.stringify([
            0,
            eventForHash.pubkey,
            eventForHash.created_at,
            eventForHash.kind,
            eventForHash.tags,
            eventForHash.content
        ]);

        // Hash using Web Crypto API
        const encoder = new TextEncoder();
        const data = encoder.encode(serialized);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

        // Check difficulty
        const difficulty = countLeadingZeroBits(hashHex);
        if (difficulty >= targetDifficulty) {
            eventTemplate.tags = tagsWithNonce;
            return eventTemplate;
        }

        nonce++;

        // Yield to UI every 10000 iterations
        if (nonce % 10000 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    throw new Error('Failed to generate proof of work within iteration limit');
}

// Get the editable event ID for a video
// Returns the NIP-71 event ID if available, null otherwise
// Only addressable kinds (34235/34236) support true replacement editing
// Legacy kinds (21/22) use delete + republish flow
function getEditableEventId(eventId) {
    const event = allEvents.get(eventId);
    if (!event) return null;

    // If this is an addressable NIP-71 event (34235/34236), it's directly editable
    if (event.kind === NIP71_VIDEO_KIND || event.kind === NIP71_SHORT_KIND) {
        return eventId;
    }

    // Legacy NIP-71 kinds (21/22) also support editing via delete + republish
    if (event.kind === NIP71_VIDEO_KIND_LEGACY || event.kind === NIP71_SHORT_KIND_LEGACY) {
        return eventId;
    }

    // If this is a kind 1 event, check for a linked NIP-71 event
    if (event.kind === 1) {
        const linkedId = videoEventLinks.get(eventId);
        if (linkedId) {
            const linkedEvent = allEvents.get(linkedId);
            if (linkedEvent && isNip71Kind(linkedEvent.kind)) {
                return linkedId;
            }
        }
    }

    // No editable event found (legacy kind 1 without NIP-71 counterpart)
    return null;
}

// Merge reactions from multiple event IDs into a single result
// Used when we have both kind 1 and kind 21/22 events for the same video
function mergeReactionsForLinkedEvents(primaryEventId, reactionsByEventId) {
    const mergedUserReactions = new Map();

    // Get all linked event IDs
    const allIds = getAllLinkedEventIds(primaryEventId);

    // Merge reactions from all linked events
    for (const eventId of allIds) {
        const reactions = reactionsByEventId.get(eventId);
        if (reactions) {
            for (const [userPubkey, reactionData] of reactions) {
                const existing = mergedUserReactions.get(userPubkey);
                // Keep the most recent reaction from each user
                if (!existing || existing.timestamp < reactionData.timestamp) {
                    mergedUserReactions.set(userPubkey, reactionData);
                }
            }
        }
    }

    return mergedUserReactions;
}

// Calculate merged reaction counts for a video
function getMergedReactionCounts(primaryEventId, reactionsByEventId) {
    const mergedReactions = mergeReactionsForLinkedEvents(primaryEventId, reactionsByEventId);

    let likes = 0;
    let dislikes = 0;
    let userReaction = null;

    for (const [userPubkey, reactionData] of mergedReactions) {
        if (reactionData.reaction === '👍') {
            likes++;
        } else if (reactionData.reaction === '👎') {
            dislikes++;
        }

        // Track current user's reaction
        if (currentUser && userPubkey === currentUser.pubkey) {
            userReaction = reactionData.reaction === '👍' ? 'like' : reactionData.reaction === '👎' ? 'dislike' : null;
        }
    }

    return { likes, dislikes, userReaction };
}

// ===== DRAFT MANAGEMENT (NIP-78 kind 30078) =====

// NIP-78 Application Data kind for storing drafts
const NIP78_APP_DATA_KIND = 30078;
const DRAFT_APP_IDENTIFIER = 'plebs/video-draft';

// Save video draft to localStorage and optionally to Nostr (NIP-78)
async function saveDraft(draftData, saveToNostr = false) {
    const drafts = getDrafts();
    const draftId = draftData.id || `draft-${Date.now()}`;

    const draft = {
        ...draftData,
        id: draftId,
        updatedAt: Date.now()
    };

    drafts[draftId] = draft;
    localStorage.setItem(DRAFTS_STORAGE_KEY, JSON.stringify(drafts));

    // Save to Nostr if user is logged in and saveToNostr is enabled
    if (saveToNostr && currentUser) {
        try {
            await saveDraftToNostr(draft);
        } catch (e) {
            console.error('Failed to save draft to Nostr:', e);
            // Don't fail - local save succeeded
        }
    }

    return draftId;
}

// Save draft to Nostr using NIP-78 (kind 30078)
async function saveDraftToNostr(draftData) {
    if (!currentUser) {
        throw new Error('Not logged in');
    }

    const dTag = `${DRAFT_APP_IDENTIFIER}/${draftData.id}`;

    const event = {
        kind: NIP78_APP_DATA_KIND,
        tags: [
            ['d', dTag],
            ['t', 'video-draft'],
            ['client', 'Plebs']
        ],
        content: JSON.stringify(draftData),
        created_at: Math.floor(Date.now() / 1000)
    };

    const signedEvent = await signEvent(event);
    const published = await publishEvent(signedEvent);

    if (!published) {
        throw new Error('Failed to publish draft to relays');
    }

    return signedEvent.id;
}

// Get all drafts from localStorage
function getDrafts() {
    try {
        const draftsJson = localStorage.getItem(DRAFTS_STORAGE_KEY);
        return draftsJson ? JSON.parse(draftsJson) : {};
    } catch (e) {
        console.error('Failed to load drafts:', e);
        return {};
    }
}

// Load drafts from Nostr (NIP-78) and merge with localStorage
async function loadDraftsFromNostr() {
    if (!currentUser) return {};

    const filter = {
        kinds: [NIP78_APP_DATA_KIND],
        authors: [currentUser.pubkey],
        '#t': ['video-draft']
    };

    const nostrDrafts = {};

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            try {
                const draftData = JSON.parse(event.content);
                const dTag = event.tags.find(t => t[0] === 'd')?.[1] || '';
                const draftId = dTag.replace(`${DRAFT_APP_IDENTIFIER}/`, '');

                if (draftId && draftData) {
                    // Use event timestamp for ordering
                    draftData.updatedAt = event.created_at * 1000;
                    draftData.nostrEventId = event.id;
                    nostrDrafts[draftId] = draftData;
                }
            } catch (e) {
                console.error('Failed to parse draft from Nostr:', e);
            }
        }, () => {
            // Merge with localStorage drafts
            const localDrafts = getDrafts();
            const mergedDrafts = { ...localDrafts };

            for (const [draftId, nostrDraft] of Object.entries(nostrDrafts)) {
                const localDraft = localDrafts[draftId];
                // Use the more recent version
                if (!localDraft || (nostrDraft.updatedAt > localDraft.updatedAt)) {
                    mergedDrafts[draftId] = nostrDraft;
                }
            }

            // Save merged drafts to localStorage
            localStorage.setItem(DRAFTS_STORAGE_KEY, JSON.stringify(mergedDrafts));

            resolve(mergedDrafts);
        });
    });
}

// Get a single draft by ID
function getDraft(draftId) {
    const drafts = getDrafts();
    return drafts[draftId] || null;
}

// Delete a draft from localStorage and optionally from Nostr
async function deleteDraft(draftId, deleteFromNostr = false) {
    const drafts = getDrafts();
    const draft = drafts[draftId];

    delete drafts[draftId];
    localStorage.setItem(DRAFTS_STORAGE_KEY, JSON.stringify(drafts));

    // Delete from Nostr by publishing a deletion event
    if (deleteFromNostr && currentUser && draft?.nostrEventId) {
        try {
            await deleteDraftFromNostr(draftId, draft.nostrEventId);
        } catch (e) {
            console.error('Failed to delete draft from Nostr:', e);
            // Don't fail - local delete succeeded
        }
    }
}

// Delete draft from Nostr using NIP-09 deletion
async function deleteDraftFromNostr(draftId, nostrEventId) {
    if (!currentUser) return;

    const dTag = `${DRAFT_APP_IDENTIFIER}/${draftId}`;

    const deleteEvent = {
        kind: 5,
        tags: [
            ['e', nostrEventId],
            ['a', `${NIP78_APP_DATA_KIND}:${currentUser.pubkey}:${dTag}`]
        ],
        content: 'Draft deleted',
        created_at: Math.floor(Date.now() / 1000)
    };

    const signedEvent = await signEvent(deleteEvent);
    await publishEvent(signedEvent);
}

// ===== VIEW TRACKING (NIP-78 kind 30078) =====
// Track video views using NIP-78 application-specific data
// Views are aggregated per video, stored as replaceable events by each viewer
// Supports both logged-in users and anonymous viewers (using ephemeral keys)

// Get canonical d-tag for a video event
function getVideoCanonicalDTag(videoEventId) {
    const event = allEvents.get(videoEventId);
    if (!event) return null;

    // Get all linked event IDs for this video
    const allLinkedIds = getAllLinkedEventIds(videoEventId);

    // Get the canonical d-tag for this video (prefer from addressable event)
    let canonicalDTag = null;
    for (const id of allLinkedIds) {
        const linkedEvent = allEvents.get(id);
        if (linkedEvent && (linkedEvent.kind === NIP71_VIDEO_KIND || linkedEvent.kind === NIP71_SHORT_KIND)) {
            canonicalDTag = linkedEvent.tags?.find(t => t[0] === 'd')?.[1];
            if (canonicalDTag) break;
        }
    }

    // Fall back to nip71-d tag or event id
    if (!canonicalDTag) {
        canonicalDTag = event.tags?.find(t => t[0] === 'nip71-d')?.[1] ||
                       event.tags?.find(t => t[0] === 'd')?.[1] ||
                       videoEventId;
    }

    return canonicalDTag;
}

// Record a view for a video (works for both logged-in and anonymous users)
async function recordVideoView(videoEventId) {
    const event = allEvents.get(videoEventId);
    if (!event) return;

    const canonicalDTag = getVideoCanonicalDTag(videoEventId);
    if (!canonicalDTag) return;

    const now = Date.now();
    const isLoggedIn = currentUser;

    // Create view key for deduplication (different for logged-in vs anonymous)
    const viewKey = isLoggedIn
        ? `view_${canonicalDTag}_${currentUser.pubkey}`
        : `anon_view_${canonicalDTag}`;

    // Check if already viewed recently (within 24 hours)
    const lastView = localStorage.getItem(viewKey);
    if (lastView && (now - parseInt(lastView)) < 24 * 60 * 60 * 1000) {
        return; // Already viewed recently
    }

    // Record view locally to prevent duplicate publishing
    localStorage.setItem(viewKey, now.toString());

    // Build view event
    const viewEvent = {
        kind: VIEW_EVENT_KIND,
        tags: [
            ['d', `${VIEW_TRACKING_APP_ID}/${canonicalDTag}`],
            ['t', 'video-view'],
            ['e', videoEventId],
            ['p', event.pubkey],
            ['client', 'Plebs']
        ],
        content: JSON.stringify({
            viewedAt: Math.floor(now / 1000),
            videoId: videoEventId,
            videoDTag: canonicalDTag
        }),
        created_at: Math.floor(now / 1000)
    };

    try {
        if (isLoggedIn) {
            // Logged-in user: sign with their key
            const signedEvent = await signEvent(viewEvent);
            await publishEvent(signedEvent);
        } else {
            // Anonymous user: generate ephemeral keypair and sign
            const sk = window.NostrTools.generateSecretKey();
            const signedViewEvent = window.NostrTools.finalizeEvent(viewEvent, sk);

            await publishEvent(signedViewEvent);
        }
    } catch (e) {
        console.error('Failed to record view:', e);
    }
}

// Record video share when share modal is opened
async function recordVideoShare(videoEventId) {
    const event = allEvents.get(videoEventId);
    if (!event) return;

    const canonicalDTag = getVideoCanonicalDTag(videoEventId);
    if (!canonicalDTag) return;

    // Only record shares for logged-in users
    if (!currentUser) return;

    const now = Date.now();

    // Create share key for deduplication (once per 24 hours per video per user)
    const shareKey = `share_${canonicalDTag}_${currentUser.pubkey}`;

    // Check if already shared recently (within 24 hours)
    const lastShare = localStorage.getItem(shareKey);
    if (lastShare && (now - parseInt(lastShare)) < 24 * 60 * 60 * 1000) {
        return; // Already shared recently
    }

    // Record share locally to prevent duplicate publishing
    localStorage.setItem(shareKey, now.toString());

    // Build share event
    const shareEvent = {
        kind: VIEW_EVENT_KIND,
        tags: [
            ['d', `${VIEW_TRACKING_APP_ID}/share/${canonicalDTag}`],
            ['t', 'video-share'],
            ['e', videoEventId],
            ['p', event.pubkey],
            ['client', 'Plebs']
        ],
        content: JSON.stringify({
            sharedAt: Math.floor(now / 1000),
            videoId: videoEventId,
            videoDTag: canonicalDTag
        }),
        created_at: Math.floor(now / 1000)
    };

    try {
        const signedEvent = await signEvent(shareEvent);
        await publishEvent(signedEvent);
    } catch (e) {
        console.error('Failed to record share:', e);
    }
}

// Record channel follow event for analytics tracking
async function recordChannelFollow(channelPubkey) {
    if (!currentUser) return;

    const now = Date.now();

    // Create unique follow event (one per channel per user, can be replaced)
    const followEvent = {
        kind: VIEW_EVENT_KIND,
        tags: [
            ['d', `${VIEW_TRACKING_APP_ID}/follow/${channelPubkey}`],
            ['t', 'channel-follow'],
            ['p', channelPubkey],
            ['client', 'Plebs']
        ],
        content: JSON.stringify({
            action: 'follow',
            followedAt: Math.floor(now / 1000),
            channelPubkey: channelPubkey
        }),
        created_at: Math.floor(now / 1000)
    };

    try {
        const signedEvent = await signEvent(followEvent);
        await publishEvent(signedEvent);
    } catch (e) {
        console.error('Failed to record follow:', e);
    }
}

// Record channel unfollow event for analytics tracking
async function recordChannelUnfollow(channelPubkey) {
    if (!currentUser) return;

    const now = Date.now();

    // Create unfollow event (separate from follow to track history)
    const unfollowEvent = {
        kind: VIEW_EVENT_KIND,
        tags: [
            ['d', `${VIEW_TRACKING_APP_ID}/unfollow/${channelPubkey}/${Math.floor(now / 1000)}`],
            ['t', 'channel-unfollow'],
            ['p', channelPubkey],
            ['client', 'Plebs']
        ],
        content: JSON.stringify({
            action: 'unfollow',
            unfollowedAt: Math.floor(now / 1000),
            channelPubkey: channelPubkey
        }),
        created_at: Math.floor(now / 1000)
    };

    try {
        const signedEvent = await signEvent(unfollowEvent);
        await publishEvent(signedEvent);
    } catch (e) {
        console.error('Failed to record unfollow:', e);
    }
}

// Load aggregated view count for a video with pagination support
// Handles relay limits by paginating through older events
async function loadVideoViews(videoEventId) {
    // Check TTL cache first
    const cached = getCachedViewCount(videoEventId);
    if (cached !== null) {
        return cached;
    }

    // Check if there's already an in-flight request for this video
    if (pendingViewRequests.has(videoEventId)) {
        return pendingViewRequests.get(videoEventId);
    }

    // Create the actual fetch promise
    const fetchPromise = (async () => {
        try {
            // Get all linked event IDs
            const allLinkedIds = getAllLinkedEventIds(videoEventId);
            const viewers = new Set(); // Track unique viewers from Nostr

            // Pagination settings
            const PAGE_SIZE = 500; // Request up to 500 at a time
            const MAX_PAGES = 10; // Safety limit to prevent infinite loops
            let until = undefined; // Start from most recent
            let page = 0;
            let hasMore = true;

            while (hasMore && page < MAX_PAGES) {
                const filter = {
                    kinds: [VIEW_EVENT_KIND],
                    '#e': allLinkedIds,
                    '#t': ['video-view'],
                    limit: PAGE_SIZE
                };

                if (until !== undefined) {
                    filter.until = until;
                }

                const pageEvents = await new Promise((resolve) => {
                    const events = [];
                    requestEventsStream(filter, (event) => {
                        events.push(event);
                        viewers.add(event.pubkey);
                    }, () => {
                        resolve(events);
                    });
                });

                // Check if we got a full page (might be more)
                if (pageEvents.length >= PAGE_SIZE) {
                    // Find oldest timestamp for next page
                    const oldestTimestamp = Math.min(...pageEvents.map(e => e.created_at));
                    until = oldestTimestamp - 1;
                    page++;
                } else {
                    // Got less than a full page, we're done
                    hasMore = false;
                }
            }

            const viewCount = viewers.size;
            // Cache for all linked IDs with TTL
            allLinkedIds.forEach(id => setCachedViewCount(id, viewCount));
            return viewCount;
        } finally {
            // Clean up pending request
            pendingViewRequests.delete(videoEventId);
        }
    })();

    // Store the pending request
    pendingViewRequests.set(videoEventId, fetchPromise);
    return fetchPromise;
}

// Batch load views for multiple videos and update UI
// Uses pagination to handle relay limits
async function loadViewsForVideos(videoIds, updateUI = false) {
    const viewCounts = new Map();

    // Check cache and pending requests first
    const uncachedIds = [];
    const pendingPromises = [];

    videoIds.forEach(id => {
        const cached = getCachedViewCount(id);
        if (cached !== null) {
            viewCounts.set(id, cached);
        } else if (pendingViewRequests.has(id)) {
            // Wait for existing in-flight request
            pendingPromises.push(
                pendingViewRequests.get(id).then(count => {
                    viewCounts.set(id, count);
                })
            );
        } else {
            uncachedIds.push(id);
        }
    });

    // Wait for any pending requests to complete first
    if (pendingPromises.length > 0) {
        await Promise.all(pendingPromises);
    }

    if (uncachedIds.length === 0) {
        if (updateUI) updateViewCountsInUI(viewCounts);
        return viewCounts;
    }

    // Expand uncached video IDs to include linked events
    const primaryToLinked = new Map();
    const linkedToPrimary = new Map();
    const allLinkedIds = new Set();

    // Create a shared promise that will resolve with all view counts
    // This allows individual loadVideoViews calls to await this batch operation
    let resolveBatchPromise;
    const batchPromise = new Promise(resolve => {
        resolveBatchPromise = resolve;
    });

    uncachedIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        primaryToLinked.set(id, linkedIds);
        linkedIds.forEach(linkedId => {
            linkedToPrimary.set(linkedId, id);
            allLinkedIds.add(linkedId);
        });
        viewCounts.set(id, 0);
        // Register pending request so individual calls wait for this batch
        pendingViewRequests.set(id, batchPromise.then(() => getCachedViewCount(id) || 0));
    });

    const allIdsArray = Array.from(allLinkedIds);

    // Batch fetch views with pagination support
    const BATCH_SIZE = 50; // Video IDs per batch
    const PAGE_SIZE = 500; // Events per page
    const MAX_PAGES = 5; // Max pages per batch
    const batches = [];
    for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
        batches.push(allIdsArray.slice(i, i + BATCH_SIZE));
    }

    const viewersByVideo = new Map();

    try {
        await Promise.all(batches.map(async (batch) => {
            let until = undefined;
            let page = 0;
            let hasMore = true;

            while (hasMore && page < MAX_PAGES) {
                const filter = {
                    kinds: [VIEW_EVENT_KIND],
                    '#e': batch,
                    '#t': ['video-view'],
                    limit: PAGE_SIZE
                };

                if (until !== undefined) {
                    filter.until = until;
                }

                const pageEvents = await new Promise((resolve) => {
                    const events = [];
                    requestEventsStream(filter, (event) => {
                        events.push(event);
                        const videoId = event.tags.find(t => t[0] === 'e')?.[1];
                        if (videoId && allLinkedIds.has(videoId)) {
                            const primaryId = linkedToPrimary.get(videoId);
                            if (primaryId) {
                                if (!viewersByVideo.has(primaryId)) {
                                    viewersByVideo.set(primaryId, new Set());
                                }
                                viewersByVideo.get(primaryId).add(event.pubkey);
                            }
                        }
                    }, () => resolve(events));
                });

                if (pageEvents.length >= PAGE_SIZE) {
                    const oldestTimestamp = Math.min(...pageEvents.map(e => e.created_at));
                    until = oldestTimestamp - 1;
                    page++;
                } else {
                    hasMore = false;
                }
            }
        }));

        // Convert sets to counts and cache
        uncachedIds.forEach(id => {
            const viewers = viewersByVideo.get(id);
            const count = viewers ? viewers.size : 0;

            viewCounts.set(id, count);
            setCachedViewCount(id, count);

            // Also cache for all linked IDs
            const linkedIds = primaryToLinked.get(id) || [id];
            linkedIds.forEach(linkedId => setCachedViewCount(linkedId, count));
        });
    } catch (error) {
        console.error('Error loading batch views:', error);
        // Cache 0 views on error to prevent retries flooding
        uncachedIds.forEach(id => {
            viewCounts.set(id, 0);
            setCachedViewCount(id, 0);
        });
    } finally {
        // Always resolve batch promise and clean up pending requests
        resolveBatchPromise();
        uncachedIds.forEach(id => pendingViewRequests.delete(id));
    }

    if (updateUI) updateViewCountsInUI(viewCounts);
    return viewCounts;
}

// Update view counts in the UI for rendered video cards
function updateViewCountsInUI(viewCounts) {
    viewCounts.forEach((count, eventId) => {
        // Update video cards - always show view count, even if 0
        document.querySelectorAll(`.video-views[data-event-id="${eventId}"]`).forEach(el => {
            el.textContent = ` • ${formatNumber(count)} ${t('stat.views')}`;
        });
        // Update video page view count
        const pageViewEl = document.getElementById(`video-views-${eventId}`);
        if (pageViewEl) {
            pageViewEl.textContent = `${formatNumber(count)} ${t('stat.views')}`;
        }
    });
}

// Toast notification system
const toastQueue = [];
let toastContainer = null;

function showToast(message, type = 'info', duration = 3000) {
    if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.className = 'toast-container';
        document.body.appendChild(toastContainer);
    }

    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.innerHTML = `
        <span>${message}</span>
    `;
    toastContainer.appendChild(toast);

    setTimeout(() => {
        toast.style.animation = 'toastOut 0.3s ease forwards';
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

// Confirmation modal system
let confirmModalCallback = null;

function showConfirmModal(title, message, onConfirm, options = {}) {
    const modal = document.getElementById('confirmModal');
    const titleEl = document.getElementById('confirmModalTitle');
    const messageEl = document.getElementById('confirmModalMessage');
    const confirmBtn = document.getElementById('confirmModalBtn');

    titleEl.textContent = title;
    messageEl.textContent = message;
    confirmBtn.textContent = options.confirmText || 'Confirm';

    // Add danger class for destructive actions
    if (options.danger) {
        confirmBtn.classList.add('danger');
    } else {
        confirmBtn.classList.remove('danger');
    }

    confirmModalCallback = onConfirm;
    confirmBtn.onclick = () => {
        // Save callback reference before hiding (which clears it)
        const callback = confirmModalCallback;
        hideConfirmModal();
        if (callback) {
            callback();
        }
    };

    modal.classList.add('active');
}

function hideConfirmModal() {
    const modal = document.getElementById('confirmModal');
    modal.classList.remove('active');
    confirmModalCallback = null;
}

function cancelConfirmModal() {
    hideConfirmModal();
}

// Skeleton loader generator
function createSkeletonCard() {
    return `
        <div class="video-card skeleton-card">
            <div class="skeleton skeleton-thumbnail"></div>
            <div class="video-info">
                <div class="skeleton-info">
                    <div class="skeleton skeleton-avatar"></div>
                    <div class="skeleton-details">
                        <div class="skeleton skeleton-text title"></div>
                        <div class="skeleton skeleton-text subtitle"></div>
                        <div class="skeleton skeleton-text small"></div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

// Skeleton loader for short cards (vertical 9:16 aspect ratio)
function createShortSkeletonCard() {
    return `
        <div class="video-card short-card skeleton-card skeleton-short-card">
            <div class="skeleton skeleton-thumbnail"></div>
            <div class="video-info">
                <div class="skeleton-info">
                    <div class="skeleton skeleton-avatar"></div>
                    <div class="skeleton-details">
                        <div class="skeleton skeleton-text title"></div>
                        <div class="skeleton skeleton-text subtitle"></div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function showSkeletonGrid(container, count = 8) {
    let skeletons = '';
    for (let i = 0; i < count; i++) {
        skeletons += createSkeletonCard();
    }
    container.innerHTML = `<div class="video-grid">${skeletons}</div>`;
}

// Skeleton card for following page user cards (vertical layout with centered avatar)
function createSkeletonFollowingUserCard() {
    return `
        <div class="following-user-card skeleton-user-card">
            <div class="skeleton skeleton-user-avatar-large"></div>
            <div class="skeleton skeleton-text skeleton-user-name"></div>
            <div class="skeleton skeleton-text skeleton-user-nip05"></div>
        </div>
    `;
}

// Skeleton card for search page user cards (horizontal layout)
function createSkeletonUserSearchCard() {
    return `
        <div class="user-search-card skeleton-user-card">
            <div class="skeleton skeleton-user-avatar-medium"></div>
            <div class="skeleton-user-info">
                <div class="skeleton skeleton-text skeleton-user-name-wide"></div>
                <div class="skeleton skeleton-text skeleton-user-nip05"></div>
                <div class="skeleton skeleton-text skeleton-user-about"></div>
            </div>
        </div>
    `;
}

// Show skeleton grid for user cards (following page)
function showSkeletonFollowingUsersGrid(container, count = 6) {
    let skeletons = '';
    for (let i = 0; i < count; i++) {
        skeletons += createSkeletonFollowingUserCard();
    }
    container.innerHTML = skeletons;
}

// Show skeleton grid for user cards (search page)
function showSkeletonUserSearchGrid(container, count = 3) {
    let skeletons = '';
    for (let i = 0; i < count; i++) {
        skeletons += createSkeletonUserSearchCard();
    }
    container.innerHTML = skeletons;
}

// Skeleton card for live stream cards
function createLiveStreamSkeletonCard() {
    return `
        <div class="video-card skeleton-card skeleton-live-card">
            <div class="skeleton skeleton-thumbnail">
                <div class="skeleton-live-badge"></div>
                <div class="skeleton-live-viewers"></div>
            </div>
            <div class="video-info">
                <div class="skeleton-info">
                    <div class="skeleton skeleton-avatar"></div>
                    <div class="skeleton-details">
                        <div class="skeleton skeleton-text title"></div>
                        <div class="skeleton skeleton-text subtitle"></div>
                    </div>
                </div>
                <div class="skeleton skeleton-text skeleton-title-large"></div>
                <div class="skeleton skeleton-text small"></div>
            </div>
        </div>
    `;
}

// Show skeleton grid for live stream cards
function showLiveStreamSkeletonGrid(container, count = 4) {
    let skeletons = '';
    for (let i = 0; i < count; i++) {
        skeletons += createLiveStreamSkeletonCard();
    }
    container.innerHTML = skeletons;
}

// Lazy loading with Intersection Observer
let lazyLoadObserver = null;

function initLazyLoading() {
    if (!('IntersectionObserver' in window)) {
        // Fallback: load all images immediately
        return;
    }

    lazyLoadObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const card = entry.target;
                loadLazyCard(card);
            }
        });
    }, {
        rootMargin: '300px',  // Increased for earlier loading
        threshold: 0.01       // Lower threshold to trigger sooner
    });

    // Fallback: periodically check for visible unloaded cards
    setInterval(checkVisibleLazyCards, 1000);
}

// Load a lazy card's media
function loadLazyCard(card) {
    if (card.dataset.loaded === 'true') return;

    const img = card.querySelector('img[data-src]');
    const video = card.querySelector('video[data-src]');

    if (img && img.dataset.src) {
        img.src = img.dataset.src;
        img.removeAttribute('data-src');
        img.onload = () => img.classList.add('loaded');
    }

    if (video && video.dataset.src) {
        video.src = video.dataset.src;
        video.removeAttribute('data-src');
    }

    card.dataset.loaded = 'true';
    if (lazyLoadObserver) {
        lazyLoadObserver.unobserve(card);
    }
}

// Fallback check for cards that might have been missed by IntersectionObserver
function checkVisibleLazyCards() {
    const cards = document.querySelectorAll('.video-card[data-lazy="true"]:not([data-loaded="true"])');
    cards.forEach(card => {
        const rect = card.getBoundingClientRect();
        const isVisible = (
            rect.top < window.innerHeight + 300 &&
            rect.bottom > -300 &&
            rect.left < window.innerWidth + 300 &&
            rect.right > -300
        );
        if (isVisible) {
            loadLazyCard(card);
        }
    });
}

function observeLazyCards() {
    if (!lazyLoadObserver) return;

    document.querySelectorAll('.video-card[data-lazy="true"]:not([data-loaded="true"])').forEach(card => {
        lazyLoadObserver.observe(card);
    });
}

// Relay status indicator UI
let relayStatusDropdownVisible = false;

function createRelayStatusIndicator() {
    // Remove existing indicator if any
    const existing = document.querySelector('.relay-status-indicator');
    if (existing) existing.remove();

    const existingDropdown = document.querySelector('.relay-status-dropdown');
    if (existingDropdown) existingDropdown.remove();

    const indicator = document.createElement('div');
    indicator.className = 'relay-status-indicator';
    indicator.setAttribute('role', 'status');
    indicator.setAttribute('aria-live', 'polite');
    indicator.onclick = toggleRelayStatusDropdown;

    const dropdown = document.createElement('div');
    dropdown.className = 'relay-status-dropdown';
    dropdown.id = 'relayStatusDropdown';

    document.body.appendChild(indicator);
    document.body.appendChild(dropdown);

    updateRelayStatusIndicator();
}

function updateRelayStatusIndicator() {
    const indicator = document.querySelector('.relay-status-indicator');
    if (!indicator) return;

    // Only show read relays in the status indicator (not publish-only relays like sendit)
    const displayRelays = RELAY_URLS;
    let connectedCount = 0;
    let totalLatency = 0;
    let latencyCount = 0;

    displayRelays.forEach(url => {
        const ws = relayConnections[url];
        if (ws && ws.readyState === WebSocket.OPEN) {
            connectedCount++;
            const latency = relayLatency.get(url);
            if (latency) {
                totalLatency += latency;
                latencyCount++;
            }
        }
    });

    const avgLatency = latencyCount > 0 ? Math.round(totalLatency / latencyCount) : null;
    const status = connectedCount === 0 ? 'disconnected' :
                   connectedCount < displayRelays.length / 2 ? 'connecting' : 'connected';

    indicator.innerHTML = `
        <span class="status-dot ${status}"></span>
        <span class="relay-count">${connectedCount}/${displayRelays.length}</span>
        ${avgLatency ? `<span class="latency">${avgLatency}ms</span>` : ''}
    `;
    indicator.title = `${connectedCount} of ${displayRelays.length} relays connected`;

    // Update dropdown if visible
    if (relayStatusDropdownVisible) {
        updateRelayStatusDropdown();
    }
}

function toggleRelayStatusDropdown() {
    const dropdown = document.getElementById('relayStatusDropdown');
    if (!dropdown) return;

    relayStatusDropdownVisible = !relayStatusDropdownVisible;
    dropdown.classList.toggle('active', relayStatusDropdownVisible);

    if (relayStatusDropdownVisible) {
        updateRelayStatusDropdown();
    }
}

function updateRelayStatusDropdown() {
    const dropdown = document.getElementById('relayStatusDropdown');
    if (!dropdown) return;

    // Only show read relays in the dropdown (not publish-only relays like sendit)
    const displayRelays = RELAY_URLS;

    let html = '<h4>Relay Connections</h4>';

    displayRelays.forEach(url => {
        const ws = relayConnections[url];
        const isConnected = ws && ws.readyState === WebSocket.OPEN;
        const latency = relayLatency.get(url);
        const latencyClass = latency ? (latency < 200 ? 'fast' : latency < 500 ? 'medium' : 'slow') : '';

        html += `
            <div class="relay-item">
                <span class="relay-url">${url.replace('wss://', '')}</span>
                <div class="relay-info">
                    ${latency ? `<span class="relay-latency ${latencyClass}">${latency}ms</span>` : ''}
                    <span class="status-dot ${isConnected ? 'connected' : 'disconnected'}"></span>
                </div>
            </div>
        `;
    });

    dropdown.innerHTML = html;
}

// Close dropdown when clicking outside
document.addEventListener('click', (e) => {
    if (relayStatusDropdownVisible &&
        !e.target.closest('.relay-status-indicator') &&
        !e.target.closest('.relay-status-dropdown')) {
        relayStatusDropdownVisible = false;
        const dropdown = document.getElementById('relayStatusDropdown');
        if (dropdown) dropdown.classList.remove('active');
    }
});

// Search debouncing
let searchDebounceTimeout = null;
const debouncedSearch = debounce((query) => {
    if (query.length >= 2) {
        // Update URL without adding to history (replaceState instead of pushState)
        const newHash = `#/search/${encodeURIComponent(query)}`;
        if (window.location.hash !== newHash) {
            history.replaceState(null, '', newHash);
        }
        performSearch(query);
    }
}, 300);

function initSearchEnhancements() {
    const searchInput = document.getElementById('searchInput');
    if (!searchInput) return;

    // Add input event for real-time search
    searchInput.addEventListener('input', (e) => {
        const query = e.target.value.trim();
        if (query.length >= 2) {
            debouncedSearch(query);
        }
    });

    // Handle Enter key
    searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            searchVideos();
        }
    });
}

// Touch gesture support for carousel
let touchStartX = 0;
let touchEndX = 0;
let carouselElement = null;

function initCarouselTouchSupport() {
    const container = document.querySelector('.trending-carousel-container');
    if (!container) return;

    container.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        carouselElement = container;
    }, { passive: true });

    container.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        handleCarouselSwipe();
    }, { passive: true });
}

function handleCarouselSwipe() {
    const swipeThreshold = 50;
    const diff = touchStartX - touchEndX;

    if (Math.abs(diff) > swipeThreshold) {
        if (diff > 0) {
            // Swipe left - next slide
            const nextBtn = document.querySelector('.carousel-btn.next');
            if (nextBtn && !nextBtn.disabled) nextBtn.click();
        } else {
            // Swipe right - previous slide
            const prevBtn = document.querySelector('.carousel-btn.prev');
            if (prevBtn && !prevBtn.disabled) prevBtn.click();
        }
    }
}

// Keyboard navigation for video grid
function initKeyboardNavigation() {
    document.addEventListener('keydown', (e) => {
        // Only if not in an input field
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        const focusedCard = document.activeElement.closest('.video-card');
        if (!focusedCard) return;

        const cards = Array.from(document.querySelectorAll('.video-card'));
        const currentIndex = cards.indexOf(focusedCard);

        let newIndex = -1;
        const gridCols = Math.floor(document.querySelector('.video-grid')?.offsetWidth / 280) || 4;

        switch (e.key) {
            case 'ArrowRight':
                newIndex = Math.min(currentIndex + 1, cards.length - 1);
                break;
            case 'ArrowLeft':
                newIndex = Math.max(currentIndex - 1, 0);
                break;
            case 'ArrowDown':
                newIndex = Math.min(currentIndex + gridCols, cards.length - 1);
                break;
            case 'ArrowUp':
                newIndex = Math.max(currentIndex - gridCols, 0);
                break;
            case 'Enter':
                const thumbnail = focusedCard.querySelector('.video-thumbnail');
                if (thumbnail) thumbnail.click();
                return;
        }

        if (newIndex >= 0 && newIndex !== currentIndex) {
            e.preventDefault();
            cards[newIndex].focus();
        }
    });
}

// Add tabindex to video cards for keyboard navigation
function makeCardsKeyboardAccessible() {
    document.querySelectorAll('.video-card:not([tabindex])').forEach((card, index) => {
        card.setAttribute('tabindex', '0');
        card.setAttribute('role', 'article');
        card.setAttribute('aria-label', card.querySelector('.video-title')?.textContent || `Video ${index + 1}`);
    });
}

// Connection retry with exponential backoff
const connectionRetryState = new Map();

async function connectWithRetry(url, maxRetries = 4) {
    let retryCount = connectionRetryState.get(url) || 0;

    if (retryCount >= maxRetries) {
        console.log(`Max retries reached for ${url}, will try again later`);
        connectionRetryState.set(url, 0);
        return null;
    }

    const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s, 8s

    if (retryCount > 0) {
        console.log(`Retry ${retryCount}/${maxRetries} for ${url} after ${delay}ms`);
        await new Promise(resolve => setTimeout(resolve, delay));
    }

    try {
        const ws = await connectToRelay(url);
        connectionRetryState.set(url, 0);
        return ws;
    } catch (error) {
        connectionRetryState.set(url, retryCount + 1);
        return connectWithRetry(url, maxRetries);
    }
}

// Measure relay latency
async function measureRelayLatency(url) {
    const ws = relayConnections[url];
    if (!ws || ws.readyState !== WebSocket.OPEN) return;

    const start = performance.now();
    const testSubId = `latency_${Date.now()}`;

    return new Promise((resolve) => {
        const timeout = setTimeout(() => {
            relayLatency.set(url, 999);
            resolve(999);
        }, 5000);

        const handler = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data[0] === 'EOSE' && data[1] === testSubId) {
                    clearTimeout(timeout);
                    const latency = Math.round(performance.now() - start);
                    relayLatency.set(url, latency);
                    ws.removeEventListener('message', handler);
                    ws.send(JSON.stringify(['CLOSE', testSubId]));
                    resolve(latency);
                }
            } catch (e) {}
        };

        ws.addEventListener('message', handler);
        ws.send(JSON.stringify(['REQ', testSubId, { kinds: [0], limit: 1 }]));
    });
}

// Periodically measure relay latency
function startLatencyMonitoring() {
    // Initial measurement after connections are established
    setTimeout(async () => {
        for (const url of RELAY_URLS) {
            await measureRelayLatency(url);
        }
        updateRelayStatusIndicator();
    }, 5000);

    // Update every 60 seconds
    setInterval(async () => {
        for (const url of RELAY_URLS) {
            await measureRelayLatency(url);
        }
        updateRelayStatusIndicator();
    }, 60000);
}

// Batch DOM updates for better performance
const pendingDOMUpdates = [];
let rafScheduled = false;

function scheduleDOMUpdate(updateFn) {
    pendingDOMUpdates.push(updateFn);

    if (!rafScheduled) {
        rafScheduled = true;
        requestAnimationFrame(() => {
            const updates = [...pendingDOMUpdates];
            pendingDOMUpdates.length = 0;
            rafScheduled = false;

            updates.forEach(fn => fn());
        });
    }
}

// Initialize all performance optimizations
function initPerformanceOptimizations() {
    initLazyLoading();
    initSearchEnhancements();
    initKeyboardNavigation();
    createRelayStatusIndicator();
    startLatencyMonitoring();

    // Initialize touch support after DOM is ready
    setTimeout(() => {
        initCarouselTouchSupport();
        makeCardsKeyboardAccessible();
    }, 1000);
}

// ===== END PERFORMANCE OPTIMIZATIONS =====

// Theme management
function initTheme() {
    const savedTheme = localStorage.getItem('theme');
    let theme;
    if (savedTheme) {
        theme = savedTheme;
    } else {
        // Use system preference if no saved theme
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        theme = prefersDark ? 'dark' : 'light';
    }
    document.documentElement.setAttribute('data-theme', theme);
}

// Handle dark mode toggle from settings modal
function handleDarkModeToggle() {
    const isDark = document.getElementById('darkModeToggle').checked;
    const newTheme = isDark ? 'dark' : 'light';
    setTheme(newTheme);
}

// Set theme and sync to Nostr
function setTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);

    // Sync theme to Nostr if logged in
    if (currentUser && userSettings) {
        userSettings.theme = theme;
        localStorage.setItem('plebsSettings', JSON.stringify(userSettings));
        if (userSettings.saveToNostr) {
            saveSettingsToNostr().catch(err => console.error('Failed to sync theme to Nostr:', err));
        }
    }
}

// Legacy function for backwards compatibility
function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    setTheme(newTheme);
}

// Initialize all relay connections
async function initializeRelayConnections() {
    console.log('Initializing relay connections...');
    const connectionPromises = RELAY_URLS.map(url =>
        connectToRelay(url).catch(err =>
            console.error(`Failed to initialize connection to ${url}:`, err)
        )
    );

    await Promise.allSettled(connectionPromises);
    console.log('Relay initialization complete');
}

// Track relay connection status for UI feedback
let relayStatus = new Map();

// Monitor relay connection health (reduced frequency - event-based reconnection handles immediate cases)
function monitorRelayConnections() {
    // Initial status update
    updateRelayStatus();

    // Less frequent background check since ws.onclose already triggers reconnection
    // Only monitor read relays - publish-only relays (sendit) connect on-demand when needed
    setInterval(() => {
        const relaysToCheck = RELAY_URLS;
        let reconnectAttempts = 0;

        relaysToCheck.forEach(url => {
            const ws = relayConnections[url];
            const isConnected = ws && ws.readyState === WebSocket.OPEN;
            relayStatus.set(url, isConnected ? 'connected' : 'disconnected');

            if (!isConnected && reconnectAttempts < 2) {
                // Limit concurrent reconnection attempts to avoid hammering relays
                reconnectAttempts++;
                console.log(`Connection to ${url} lost, attempting to reconnect...`);
                connectToRelay(url).catch(err =>
                    console.error(`Failed to reconnect to ${url}:`, err)
                );
            }
        });

        updateRelayStatus();
    }, 30000); // Check every 30 seconds (event-based reconnection handles immediate cases)
}

// Update relay status for potential UI display
function updateRelayStatus() {
    const connected = [...relayStatus.values()].filter(s => s === 'connected').length;
    const total = RELAY_URLS.length;
    if (connected < total) {
        console.log(`Relay status: ${connected}/${total} connected`);
    }
}

// Video compression
const VideoCompressor = {
    isAvailable: true,
    compressionInProgress: false,
    calibrationData: null,
    currentMimeType: null,

    async compressVideo(file, options = {}) {
        const { maxSizeMB = 100, onProgress = () => { } } = options;

        if (this.compressionInProgress) {
            throw new Error('Compression already in progress');
        }

        const fileSizeMB = file.size / (1024 * 1024);

        // If file is already small enough, return it
        if (fileSizeMB <= maxSizeMB) {
            console.log('File already meets size requirements');
            return file;
        }

        this.compressionInProgress = true;
        this.calibrationData = null;

        try {
            onProgress({ stage: 'analyzing', progress: 5 });

            // Get video metadata first
            const metadata = await this.getVideoMetadata(file);
            if (!metadata) {
                throw new Error('Could not read video metadata');
            }

            // Analyze video complexity for better compression predictions
            const complexity = await this.analyzeVideoComplexity(file, metadata);
            metadata.complexity = complexity;

            // Select optimal codec based on browser support and efficiency
            const codecInfo = this.selectOptimalCodec();
            console.log(`Selected codec: ${codecInfo.name} (${codecInfo.mimeType})`);

            // Calculate initial compression settings
            let compressionSettings = this.calculateCompressionSettings(
                fileSizeMB,
                maxSizeMB,
                metadata,
                codecInfo
            );

            onProgress({
                stage: 'preparing',
                progress: 10,
                originalSize: file.size,
                quality: compressionSettings.quality
            });

            // For large files (>500MB), do a calibration pass first
            const needsCalibration = fileSizeMB > 500;
            if (needsCalibration) {
                onProgress({
                    stage: 'calibrating',
                    progress: 12,
                    message: 'Calibrating compression settings...'
                });

                const calibrationResult = await this.runCalibrationPass(
                    file,
                    compressionSettings,
                    metadata,
                    codecInfo
                );

                if (calibrationResult.adjustmentFactor !== 1.0) {
                    console.log(`Calibration adjustment: ${calibrationResult.adjustmentFactor.toFixed(3)}x`);
                    compressionSettings = this.applyCalibration(
                        compressionSettings,
                        calibrationResult,
                        maxSizeMB,
                        metadata
                    );
                }
            }

            // Perform main compression with adaptive bitrate monitoring
            const compressedBlob = await this.performAdaptiveCompression(
                file,
                compressionSettings,
                metadata,
                codecInfo,
                maxSizeMB,
                onProgress
            );

            let compressedSizeMB = compressedBlob.size / (1024 * 1024);
            console.log(`Compressed blob size: ${compressedBlob.size} bytes (${compressedSizeMB.toFixed(2)} MB)`);

            // If still too large, use intelligent retry with adjusted parameters
            if (compressedSizeMB > maxSizeMB) {
                const retryResult = await this.intelligentRetry(
                    file,
                    compressedSizeMB,
                    maxSizeMB,
                    metadata,
                    codecInfo,
                    compressionSettings,
                    onProgress
                );

                if (retryResult) {
                    return retryResult;
                }

                throw new Error(
                    `Unable to compress video to under ${maxSizeMB}MB. ` +
                    `Final size: ${compressedSizeMB.toFixed(1)}MB. ` +
                    `Consider using a shorter video or lower resolution.`
                );
            }

            const mimeType = this.currentMimeType || codecInfo.mimeType.split(';')[0];
            const extension = mimeType.includes('mp4') ? '.mp4' : '.webm';

            const compressedFile = new File(
                [compressedBlob],
                file.name.replace(/\.[^/.]+$/, extension),
                { type: mimeType }
            );

            onProgress({
                stage: 'complete',
                progress: 100,
                originalSize: file.size,
                compressedSize: compressedFile.size,
                compressionRatio: compressedFile.size / file.size,
                quality: compressionSettings.quality,
                outputFormat: mimeType
            });

            return compressedFile;

        } catch (error) {
            console.error('Video compression failed:', error);
            throw error;
        } finally {
            this.compressionInProgress = false;
            this.currentMimeType = null;
            this.calibrationData = null;
            window.userSelectedQuality = null;
        }
    },

    // Analyze video complexity by sampling frames
    async analyzeVideoComplexity(file, metadata) {
        return new Promise((resolve) => {
            const video = document.createElement('video');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            video.muted = true;
            video.preload = 'auto';

            const videoUrl = URL.createObjectURL(file);
            let complexityScores = [];
            let samplesCollected = 0;
            const targetSamples = Math.min(10, Math.max(3, Math.floor(metadata.duration / 30)));
            const sampleInterval = metadata.duration / (targetSamples + 1);

            video.onloadeddata = async () => {
                canvas.width = Math.min(320, video.videoWidth);
                canvas.height = Math.round(canvas.width * (video.videoHeight / video.videoWidth));

                const collectSample = () => {
                    return new Promise((res) => {
                        if (samplesCollected >= targetSamples) {
                            res();
                            return;
                        }

                        const seekTime = sampleInterval * (samplesCollected + 1);
                        video.currentTime = Math.min(seekTime, metadata.duration - 0.5);

                        video.onseeked = () => {
                            try {
                                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                                const complexity = this.calculateFrameComplexity(imageData);
                                complexityScores.push(complexity);
                            } catch (e) {
                                console.warn('Frame analysis error:', e);
                            }
                            samplesCollected++;
                            res();
                        };
                    });
                };

                // Collect samples sequentially
                for (let i = 0; i < targetSamples; i++) {
                    await collectSample();
                }

                URL.revokeObjectURL(videoUrl);
                video.remove();

                if (complexityScores.length === 0) {
                    resolve({ score: 0.5, type: 'unknown' });
                    return;
                }

                // Calculate average complexity
                const avgComplexity = complexityScores.reduce((a, b) => a + b, 0) / complexityScores.length;
                const variance = complexityScores.reduce((sum, c) => sum + Math.pow(c - avgComplexity, 2), 0) / complexityScores.length;

                // Classify video type
                let type = 'mixed';
                if (avgComplexity < 0.2 && variance < 0.01) {
                    type = 'static'; // Screencast, presentation
                } else if (avgComplexity > 0.6 || variance > 0.05) {
                    type = 'dynamic'; // Action, sports, fast motion
                } else if (avgComplexity < 0.4) {
                    type = 'talking-head'; // Vlogs, interviews
                }

                console.log(`Video complexity: ${avgComplexity.toFixed(3)} (${type}), variance: ${variance.toFixed(4)}`);

                resolve({
                    score: avgComplexity,
                    variance: variance,
                    type: type,
                    samples: complexityScores.length
                });
            };

            video.onerror = () => {
                URL.revokeObjectURL(videoUrl);
                resolve({ score: 0.5, type: 'unknown' });
            };

            // Timeout after 15 seconds
            setTimeout(() => {
                if (complexityScores.length > 0) {
                    URL.revokeObjectURL(videoUrl);
                    const avgComplexity = complexityScores.reduce((a, b) => a + b, 0) / complexityScores.length;
                    resolve({ score: avgComplexity, type: 'unknown', samples: complexityScores.length });
                } else {
                    resolve({ score: 0.5, type: 'unknown' });
                }
            }, 15000);

            video.src = videoUrl;
        });
    },

    // Calculate complexity of a single frame using edge detection approximation
    calculateFrameComplexity(imageData) {
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;
        let totalDiff = 0;
        let samples = 0;

        // Sample pixels and calculate local variance (edge detection approximation)
        const step = 4; // Sample every 4th pixel for speed
        for (let y = 1; y < height - 1; y += step) {
            for (let x = 1; x < width - 1; x += step) {
                const idx = (y * width + x) * 4;
                const idxRight = (y * width + x + 1) * 4;
                const idxDown = ((y + 1) * width + x) * 4;

                // Calculate luminance differences
                const lum = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;
                const lumRight = data[idxRight] * 0.299 + data[idxRight + 1] * 0.587 + data[idxRight + 2] * 0.114;
                const lumDown = data[idxDown] * 0.299 + data[idxDown + 1] * 0.587 + data[idxDown + 2] * 0.114;

                totalDiff += Math.abs(lum - lumRight) + Math.abs(lum - lumDown);
                samples++;
            }
        }

        // Normalize to 0-1 range (255 * 2 is max possible diff per sample)
        return Math.min(1, (totalDiff / samples) / 100);
    },

    // Check if browser supports iOS-compatible encoding (H.264/MP4)
    checkiOSCompatibility() {
        const h264Types = [
            'video/mp4;codecs="avc1.64001F"',
            'video/mp4;codecs="avc1.640028"',
            'video/mp4;codecs="avc1.4D401F"',
            'video/mp4;codecs="avc1.4D4028"',
            'video/mp4;codecs="avc1.42E01E"',
            'video/mp4;codecs="avc1.42001E"',
            'video/mp4;codecs=avc1',
            'video/mp4'
        ];

        for (const type of h264Types) {
            if (MediaRecorder.isTypeSupported(type)) {
                return { supported: true, codec: type };
            }
        }

        return { supported: false, codec: null };
    },

    // Select optimal codec based on browser support and compatibility
    // Prioritizes H.264/MP4 for universal playback (iOS, Android, web)
    selectOptimalCodec() {
        const codecs = [
            // H.264 High Profile - best quality H.264, widely supported
            { name: 'H.264 High', mimeType: 'video/mp4;codecs="avc1.64001F"', efficiency: 1.2, iosCompatible: true },
            { name: 'H.264 High', mimeType: 'video/mp4;codecs="avc1.640028"', efficiency: 1.2, iosCompatible: true },
            // H.264 Main Profile
            { name: 'H.264 Main', mimeType: 'video/mp4;codecs="avc1.4D401F"', efficiency: 1.1, iosCompatible: true },
            { name: 'H.264 Main', mimeType: 'video/mp4;codecs="avc1.4D4028"', efficiency: 1.1, iosCompatible: true },
            // H.264 Baseline - most compatible across all devices
            { name: 'H.264 Baseline', mimeType: 'video/mp4;codecs="avc1.42E01E"', efficiency: 1.0, iosCompatible: true },
            { name: 'H.264 Baseline', mimeType: 'video/mp4;codecs="avc1.42001E"', efficiency: 1.0, iosCompatible: true },
            { name: 'H.264', mimeType: 'video/mp4;codecs=avc1', efficiency: 1.0, iosCompatible: true },
            { name: 'H.264', mimeType: 'video/mp4', efficiency: 1.0, iosCompatible: true },
            // WebM/VP9 fallback only if H.264 not available (won't play on iOS)
            { name: 'VP9', mimeType: 'video/webm;codecs=vp9', efficiency: 1.4, iosCompatible: false },
            { name: 'VP8', mimeType: 'video/webm;codecs=vp8', efficiency: 0.9, iosCompatible: false },
            { name: 'WebM', mimeType: 'video/webm', efficiency: 0.85, iosCompatible: false }
        ];

        for (const codec of codecs) {
            if (MediaRecorder.isTypeSupported(codec.mimeType)) {
                const isIosCompatible = codec.iosCompatible !== false;
                console.log(`Selected codec: ${codec.name} (${codec.mimeType})`);
                console.log(`iOS compatible: ${isIosCompatible}`);

                // Store iOS compatibility flag for UI warnings
                this.lastCodecIosCompatible = isIosCompatible;

                if (!isIosCompatible) {
                    console.warn('WARNING: This browser does not support H.264 encoding.');
                    console.warn('Compressed videos will be in WebM format which may not play on iOS devices.');
                    console.warn('For iOS-compatible uploads, use Chrome on Windows or macOS.');
                }

                return codec;
            }
        }

        // Ultimate fallback - warn about compatibility
        console.warn('No H.264 codec available, falling back to WebM (will not play on iOS)');
        this.lastCodecIosCompatible = false;
        return { name: 'Default', mimeType: 'video/webm', efficiency: 0.8, iosCompatible: false };
    },

    calculateCompressionSettings(fileSizeMB, maxSizeMB, metadata, codecInfo) {
        const duration = metadata.duration;
        const complexity = metadata.complexity || { score: 0.5, type: 'mixed' };

        let settings = {
            quality: 'high',
            scale: 1,
            fps: 30,
            bitrate: 2000000
        };

        // Always use high quality - UI no longer allows selection
        const userQuality = window.userSelectedQuality || window.suggestedCompressionQuality || 'high';

        // Codec efficiency adjustment
        const codecEfficiency = codecInfo.efficiency || 1.0;

        // Calculate required compression ratio
        const compressionRatio = fileSizeMB / maxSizeMB;

        // Improved quality tiers with better scaling for large files
        const getQualitySettings = (quality, sizeMB, complexity) => {
            // Base quality parameters - improved for large files
            const qualityBase = {
                'ultra-low': {
                    scaleMin: 0.20, scaleMax: 0.45,
                    fpsMin: 15, fpsMax: 24,
                    bitrateMultiplier: 0.5
                },
                'low': {
                    scaleMin: 0.28, scaleMax: 0.55,
                    fpsMin: 20, fpsMax: 30,
                    bitrateMultiplier: 0.65
                },
                'medium': {
                    scaleMin: 0.35, scaleMax: 0.70,
                    fpsMin: 24, fpsMax: 30,
                    bitrateMultiplier: 0.8
                },
                'high': {
                    scaleMin: 0.45, scaleMax: 0.90,
                    fpsMin: 24, fpsMax: 30,
                    bitrateMultiplier: 1.0
                }
            };

            const params = qualityBase[quality] || qualityBase['medium'];

            // Scale based on file size - use logarithmic scaling for very large files
            // This prevents overly aggressive reduction for huge files
            const sizeFactorLog = Math.log10(Math.max(100, sizeMB)) / Math.log10(2000);
            const sizeFactor = Math.max(0, Math.min(1, 1 - sizeFactorLog));

            // Adjust for video complexity
            let complexityAdjust = 1.0;
            if (complexity.type === 'static') {
                complexityAdjust = 1.15; // Can use higher scale for static content
            } else if (complexity.type === 'dynamic') {
                complexityAdjust = 0.9; // Need more headroom for motion
            }

            const scale = params.scaleMin + (params.scaleMax - params.scaleMin) * sizeFactor * complexityAdjust;

            // FPS: prioritize keeping FPS high, reduce resolution instead
            let fps = params.fpsMax;
            if (sizeMB > 2000) {
                fps = Math.max(params.fpsMin, params.fpsMax - 6);
            } else if (sizeMB > 1000) {
                fps = Math.max(params.fpsMin, params.fpsMax - 3);
            }

            // Snap FPS to standard values
            if (fps >= 28) fps = 30;
            else if (fps >= 22) fps = 24;
            else if (fps >= 18) fps = 20;
            else fps = Math.max(15, Math.round(fps));

            return {
                scale: Math.max(params.scaleMin, Math.min(params.scaleMax, scale)),
                fps: fps,
                bitrateMultiplier: params.bitrateMultiplier
            };
        };

        // Calculate target size with safety margin
        const getTargetSize = (quality, sizeMB, duration) => {
            // Base targets adjusted for codec efficiency
            const baseTargets = {
                'ultra-low': 75 * codecEfficiency,
                'low': 82 * codecEfficiency,
                'medium': 88 * codecEfficiency,
                'high': 94 * codecEfficiency
            };

            let targetSize = baseTargets[quality] || 85;

            // Safety margin based on file size (larger files need more margin)
            const safetyMargin = Math.max(0.90, 0.98 - (sizeMB / 20000));
            targetSize *= safetyMargin;

            // Duration-based adjustment
            if (duration > 7200) { // > 2 hours
                targetSize *= 0.92;
            } else if (duration > 3600) { // > 1 hour
                targetSize *= 0.95;
            } else if (duration > 1800) { // > 30 min
                targetSize *= 0.97;
            }

            return Math.min(maxSizeMB * 0.98, Math.floor(targetSize));
        };

        // Improved bitrate calculation
        const calculateOptimalBitrate = (targetSizeMB, duration, scale, complexity) => {
            const audioBitrate = 64000; // 64 kbps
            const audioSizeMB = (audioBitrate * duration) / (8 * 1024 * 1024);
            const videoTargetSizeMB = Math.max(targetSizeMB - audioSizeMB, targetSizeMB * 0.85);

            // Base bitrate calculation
            const baseBitrate = (videoTargetSizeMB * 8 * 1024 * 1024) / duration;

            // MediaRecorder compensation - learned from actual behavior
            // VP9 is more predictable, H.264 varies more
            let compensation;
            if (codecInfo.name.includes('VP9')) {
                compensation = 1.3 + (0.4 * (1 - codecEfficiency));
            } else if (codecInfo.name.includes('H.264')) {
                // H.264 in MediaRecorder often overshoots by 1.5-2.5x
                compensation = 1.8 + (fileSizeMB / 3000);
            } else {
                compensation = 2.2 + (fileSizeMB / 2500);
            }

            // Apply calibration data if available
            if (this.calibrationData && this.calibrationData.adjustmentFactor) {
                compensation *= this.calibrationData.adjustmentFactor;
            }

            // Complexity adjustment
            let complexityMultiplier = 1.0;
            if (complexity.type === 'static') {
                complexityMultiplier = 0.7; // Static content compresses better
            } else if (complexity.type === 'dynamic') {
                complexityMultiplier = 1.2; // Dynamic content needs more bits
            } else if (complexity.type === 'talking-head') {
                complexityMultiplier = 0.85;
            }

            const compensatedBitrate = baseBitrate * compensation * complexityMultiplier;

            // Resolution-based bounds
            const pixels = Math.pow(scale, 2); // Approximate pixel ratio
            const minBitrate = pixels * 300000; // Minimum quality floor
            const maxBitrate = pixels * 8000000; // Reasonable maximum

            return Math.max(minBitrate, Math.min(maxBitrate, compensatedBitrate));
        };

        // Apply calculations
        const qualitySettings = getQualitySettings(userQuality, fileSizeMB, complexity);
        const targetSizeMB = getTargetSize(userQuality, fileSizeMB, duration);

        settings.quality = userQuality;
        settings.scale = qualitySettings.scale;
        settings.fps = qualitySettings.fps;
        settings.bitrate = calculateOptimalBitrate(
            targetSizeMB,
            duration,
            settings.scale,
            complexity
        );

        // Apply extreme compression ratio adjustments (but less aggressive than before)
        if (compressionRatio > 30) {
            settings.scale *= 0.88;
            settings.bitrate *= 0.7;
            console.log('Applied extreme compression adjustment (>30x ratio)');
        } else if (compressionRatio > 20) {
            settings.scale *= 0.92;
            settings.bitrate *= 0.8;
        } else if (compressionRatio > 10) {
            settings.scale *= 0.96;
            settings.bitrate *= 0.9;
        }

        // Ensure minimum quality thresholds
        const minScale = userQuality === 'ultra-low' ? 0.18 : 0.25;
        settings.scale = Math.max(minScale, settings.scale);

        // CRITICAL: Verify expected output size is under target and adjust if needed
        const audioBitrate = 64000; // 64 kbps audio
        const audioSizeMB = (audioBitrate * duration) / (8 * 1024 * 1024);

        const calculateExpectedSize = (bitrate) => {
            const videoBitrateMbps = bitrate / 1000000;
            const videoSizeMB = (videoBitrateMbps * duration * 1000000) / (8 * 1024 * 1024);
            return videoSizeMB + audioSizeMB;
        };

        let expectedSizeMB = calculateExpectedSize(settings.bitrate);
        const hardLimit = maxSizeMB * 0.95; // 95MB for 100MB target - leave safety margin
        let adjustmentIterations = 0;

        // If expected size exceeds target, reduce bitrate iteratively
        while (expectedSizeMB > hardLimit && adjustmentIterations < 10) {
            const reduction = hardLimit / expectedSizeMB;
            settings.bitrate = Math.round(settings.bitrate * reduction * 0.92); // Extra 8% safety
            expectedSizeMB = calculateExpectedSize(settings.bitrate);
            adjustmentIterations++;
            console.log(`Bitrate adjustment ${adjustmentIterations}: ${(settings.bitrate / 1000000).toFixed(2)} Mbps → expected ${expectedSizeMB.toFixed(1)}MB`);
        }

        // If still over after iterations, also reduce scale
        if (expectedSizeMB > hardLimit) {
            settings.scale *= 0.85;
            settings.scale = Math.max(minScale, settings.scale);
            settings.bitrate = Math.round(settings.bitrate * 0.8);
            expectedSizeMB = calculateExpectedSize(settings.bitrate);
            console.log(`Applied additional scale reduction: ${(settings.scale * 100).toFixed(0)}%`);
        }

        // Final safety check - set absolute maximum bitrate based on duration
        const absoluteMaxBitrate = ((hardLimit - audioSizeMB) * 8 * 1024 * 1024) / duration;
        if (settings.bitrate > absoluteMaxBitrate) {
            settings.bitrate = Math.round(absoluteMaxBitrate * 0.9);
            expectedSizeMB = calculateExpectedSize(settings.bitrate);
            console.log(`Applied absolute max bitrate cap: ${(settings.bitrate / 1000000).toFixed(2)} Mbps`);
        }

        console.log(`=== Compression Settings ===`);
        console.log(`Input: ${fileSizeMB.toFixed(1)}MB (${formatDuration(Math.floor(duration))})`);
        console.log(`Target: ${targetSizeMB}MB (hard limit: ${hardLimit.toFixed(0)}MB) | Compression ratio: ${compressionRatio.toFixed(1)}x`);
        console.log(`Quality: ${userQuality} | Scale: ${(settings.scale * 100).toFixed(0)}% | FPS: ${settings.fps}`);
        console.log(`Codec: ${codecInfo.name} (efficiency: ${codecInfo.efficiency}x)`);
        console.log(`Complexity: ${complexity.score.toFixed(2)} (${complexity.type})`);
        console.log(`Bitrate: ${(settings.bitrate / 1000000).toFixed(2)} Mbps`);
        console.log(`Expected output: ~${expectedSizeMB.toFixed(1)}MB (${adjustmentIterations > 0 ? adjustmentIterations + ' adjustments made' : 'no adjustments needed'})`);

        settings.metrics = {
            inputSize: fileSizeMB,
            targetSize: targetSizeMB,
            compressionRatio,
            codecEfficiency,
            complexity: complexity,
            expectedSize: expectedSizeMB
        };

        return settings;
    },

    // Run a short calibration pass to measure actual encoder behavior
    async runCalibrationPass(file, settings, metadata, codecInfo) {
        return new Promise((resolve) => {
            const video = document.createElement('video');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { alpha: false });

            video.muted = true;
            video.playsInline = true;

            const videoUrl = URL.createObjectURL(file);
            const calibrationDuration = Math.min(10, metadata.duration * 0.05); // 5% of video or 10 seconds max
            let totalBytes = 0;
            let elapsedTime = 0;

            video.onloadedmetadata = async () => {
                const targetWidth = Math.round(video.videoWidth * settings.scale);
                const targetHeight = Math.round(video.videoHeight * settings.scale);
                canvas.width = targetWidth % 2 === 0 ? targetWidth : targetWidth - 1;
                canvas.height = targetHeight % 2 === 0 ? targetHeight : targetHeight - 1;

                const stream = canvas.captureStream(settings.fps);

                try {
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: codecInfo.mimeType,
                        videoBitsPerSecond: settings.bitrate
                    });

                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data && e.data.size > 0) {
                            totalBytes += e.data.size;
                        }
                    };

                    mediaRecorder.start(500); // Collect data every 500ms

                    // Seek to middle of video for representative sample
                    video.currentTime = Math.max(0, (metadata.duration / 2) - (calibrationDuration / 2));

                    await video.play();

                    const startTime = Date.now();
                    const frameInterval = 1000 / settings.fps;
                    let lastFrameTime = 0;

                    const drawLoop = (timestamp) => {
                        elapsedTime = (Date.now() - startTime) / 1000;

                        if (elapsedTime >= calibrationDuration || video.ended) {
                            video.pause();
                            mediaRecorder.stop();

                            setTimeout(() => {
                                URL.revokeObjectURL(videoUrl);

                                // Calculate actual vs expected bitrate
                                const actualBitrate = (totalBytes * 8) / elapsedTime;
                                const expectedBitrate = settings.bitrate;
                                const adjustmentFactor = actualBitrate / expectedBitrate;

                                console.log(`Calibration: ${elapsedTime.toFixed(1)}s sampled`);
                                console.log(`Expected bitrate: ${(expectedBitrate / 1000000).toFixed(2)} Mbps`);
                                console.log(`Actual bitrate: ${(actualBitrate / 1000000).toFixed(2)} Mbps`);
                                console.log(`Adjustment factor: ${adjustmentFactor.toFixed(3)}x`);

                                this.calibrationData = {
                                    adjustmentFactor: adjustmentFactor,
                                    sampleDuration: elapsedTime,
                                    actualBitrate: actualBitrate
                                };

                                resolve(this.calibrationData);
                            }, 200);
                            return;
                        }

                        if (timestamp - lastFrameTime >= frameInterval) {
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            lastFrameTime = timestamp;
                        }

                        requestAnimationFrame(drawLoop);
                    };

                    requestAnimationFrame(drawLoop);

                } catch (e) {
                    console.warn('Calibration failed:', e);
                    URL.revokeObjectURL(videoUrl);
                    resolve({ adjustmentFactor: 1.0 });
                }
            };

            video.onerror = () => {
                URL.revokeObjectURL(videoUrl);
                resolve({ adjustmentFactor: 1.0 });
            };

            // Timeout
            setTimeout(() => {
                if (!this.calibrationData) {
                    URL.revokeObjectURL(videoUrl);
                    resolve({ adjustmentFactor: 1.0 });
                }
            }, 20000);

            video.src = videoUrl;
        });
    },

    // Apply calibration results to adjust settings
    applyCalibration(settings, calibration, maxSizeMB, metadata) {
        if (!calibration || calibration.adjustmentFactor === 1.0) {
            return settings;
        }

        const newSettings = { ...settings };

        // If actual output is higher than expected, reduce bitrate
        if (calibration.adjustmentFactor > 1.1) {
            const reduction = 1 / calibration.adjustmentFactor;
            newSettings.bitrate = Math.round(settings.bitrate * reduction * 0.95); // Extra 5% safety
            console.log(`Calibration: Reducing bitrate by ${((1 - reduction) * 100).toFixed(1)}%`);
        }
        // If actual output is lower, we can increase quality slightly
        else if (calibration.adjustmentFactor < 0.85) {
            const increase = Math.min(1.2, 1 / calibration.adjustmentFactor);
            newSettings.bitrate = Math.round(settings.bitrate * increase * 0.9);
            console.log(`Calibration: Encoder is efficient, adjusting bitrate up by ${((increase - 1) * 100).toFixed(1)}%`);
        }

        return newSettings;
    },

    // Main compression with adaptive monitoring
    async performAdaptiveCompression(file, settings, metadata, codecInfo, maxSizeMB, onProgress) {
        return new Promise((resolve, reject) => {
            const video = document.createElement('video');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', {
                alpha: false,
                desynchronized: true,
                willReadFrequently: false,
                imageSmoothingEnabled: true,
                imageSmoothingQuality: 'high'
            });

            video.muted = true;
            video.playsInline = true;
            video.crossOrigin = 'anonymous';

            let videoUrl;
            try {
                videoUrl = URL.createObjectURL(file);
            } catch (error) {
                console.error('Failed to create blob URL:', error);
                reject(new Error('Failed to create video URL'));
                return;
            }

            video.onloadedmetadata = async () => {
                try {
                    const targetWidth = Math.round(video.videoWidth * settings.scale);
                    const targetHeight = Math.round(video.videoHeight * settings.scale);

                    // Ensure even dimensions for codec compatibility
                    canvas.width = targetWidth % 2 === 0 ? targetWidth : targetWidth - 1;
                    canvas.height = targetHeight % 2 === 0 ? targetHeight : targetHeight - 1;

                    // Enforce minimum resolution
                    if (canvas.width < 320) {
                        const ratio = 320 / canvas.width;
                        canvas.width = 320;
                        canvas.height = Math.round(canvas.height * ratio);
                        canvas.height = canvas.height % 2 === 0 ? canvas.height : canvas.height - 1;
                    }

                    console.log(`Compressing: ${video.videoWidth}x${video.videoHeight} -> ${canvas.width}x${canvas.height}`);
                    console.log(`Bitrate: ${(settings.bitrate / 1000000).toFixed(2)} Mbps, FPS: ${settings.fps}`);

                    const stream = canvas.captureStream(settings.fps);

                    // Extract and add audio track
                    let hasAudio = false;
                    if (video.mozCaptureStream || video.captureStream) {
                        try {
                            const videoStream = video.mozCaptureStream ? video.mozCaptureStream() : video.captureStream();
                            const audioTracks = videoStream.getAudioTracks();

                            if (audioTracks.length > 0) {
                                audioTracks.forEach(track => {
                                    stream.addTrack(track);
                                    hasAudio = true;
                                });
                                console.log('Audio track added successfully');
                            }
                        } catch (e) {
                            console.warn('Audio extraction failed:', e);
                        }
                    }

                    const recorderOptions = {
                        mimeType: codecInfo.mimeType,
                        videoBitsPerSecond: settings.bitrate
                    };

                    if (hasAudio) {
                        recorderOptions.audioBitsPerSecond = 64000;
                    }

                    const mediaRecorder = new MediaRecorder(stream, recorderOptions);

                    this.currentMimeType = mediaRecorder.mimeType ?
                        mediaRecorder.mimeType.split(';')[0] :
                        codecInfo.mimeType.split(';')[0];

                    const chunks = [];
                    let lastProgressUpdate = 0;
                    let frameCount = 0;
                    let rafId = null;
                    let totalBytesRecorded = 0;
                    let lastBitrateCheck = 0;
                    let bitrateWarningIssued = false;

                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data && e.data.size > 0) {
                            chunks.push(e.data);
                            totalBytesRecorded += e.data.size;

                            // Adaptive bitrate monitoring (check every 5 seconds of video)
                            const now = Date.now();
                            if (now - lastBitrateCheck > 5000 && video.currentTime > 5) {
                                lastBitrateCheck = now;
                                const currentSizeMB = totalBytesRecorded / (1024 * 1024);
                                const progress = video.currentTime / metadata.duration;
                                const projectedSizeMB = currentSizeMB / progress;

                                if (projectedSizeMB > maxSizeMB * 1.15 && !bitrateWarningIssued) {
                                    console.warn(`Projected size ${projectedSizeMB.toFixed(1)}MB exceeds target. May need retry.`);
                                    bitrateWarningIssued = true;
                                }
                            }
                        }
                    };

                    mediaRecorder.onstop = () => {
                        console.log(`Encoding complete: ${chunks.length} chunks, ${frameCount} frames`);

                        const blob = new Blob(chunks, {
                            type: this.currentMimeType.includes('mp4') ? 'video/mp4' : this.currentMimeType
                        });

                        const sizeMB = blob.size / (1024 * 1024);
                        const originalSizeMB = file.size / (1024 * 1024);
                        const reduction = ((originalSizeMB - sizeMB) / originalSizeMB * 100).toFixed(1);

                        console.log(`Result: ${originalSizeMB.toFixed(1)}MB -> ${sizeMB.toFixed(1)}MB (${reduction}% reduction)`);

                        video.pause();
                        URL.revokeObjectURL(videoUrl);

                        // Clean up canvas
                        canvas.width = 0;
                        canvas.height = 0;

                        resolve(blob);
                    };

                    mediaRecorder.onerror = (e) => {
                        console.error('MediaRecorder error:', e);
                        URL.revokeObjectURL(videoUrl);
                        reject(new Error('MediaRecorder error: ' + (e.error || 'Unknown error')));
                    };

                    // Use larger chunks for efficiency (1 second)
                    mediaRecorder.start(1000);
                    console.log('MediaRecorder started');

                    video.currentTime = 0;

                    const targetDuration = metadata.duration;
                    let lastDrawTime = 0;
                    const frameInterval = 1000 / settings.fps;

                    const drawFrame = (timestamp) => {
                        if (!video.paused && !video.ended && mediaRecorder.state === 'recording') {
                            // Draw frame at correct interval
                            if (timestamp - lastDrawTime >= frameInterval) {
                                try {
                                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                    frameCount++;
                                    lastDrawTime = timestamp;
                                } catch (e) {
                                    console.warn('Frame draw error:', e);
                                }
                            }

                            // Progress update
                            const now = Date.now();
                            if (now - lastProgressUpdate > 500) {
                                const videoTime = video.currentTime;
                                const progress = Math.min(95, 20 + (videoTime / targetDuration) * 75);
                                const currentSizeMB = totalBytesRecorded / (1024 * 1024);

                                onProgress({
                                    stage: 'compressing',
                                    progress: Math.round(progress),
                                    quality: settings.quality,
                                    currentTime: videoTime.toFixed(1),
                                    duration: targetDuration.toFixed(1),
                                    currentSize: currentSizeMB.toFixed(1)
                                });
                                lastProgressUpdate = now;
                            }

                            rafId = requestAnimationFrame(drawFrame);
                        }
                    };

                    video.addEventListener('ended', () => {
                        console.log('Video playback ended');
                        if (rafId) {
                            cancelAnimationFrame(rafId);
                        }
                        // Small delay to ensure all frames are recorded
                        setTimeout(() => {
                            if (mediaRecorder.state === 'recording') {
                                mediaRecorder.stop();
                            }
                        }, 300);
                    });

                    video.muted = true;
                    video.volume = 0;
                    video.playbackRate = 1.0;

                    // Start playback
                    setTimeout(async () => {
                        try {
                            await video.play();
                            console.log('Video playback started');
                            rafId = requestAnimationFrame(drawFrame);
                        } catch (err) {
                            console.error('Failed to start video playback:', err);
                            reject(err);
                        }
                    }, 100);

                } catch (error) {
                    console.error('Compression setup error:', error);
                    URL.revokeObjectURL(videoUrl);
                    reject(error);
                }
            };

            video.onerror = (e) => {
                console.error('Video loading error:', e);
                URL.revokeObjectURL(videoUrl);
                reject(new Error('Video loading error: ' + (e.message || 'Unknown error')));
            };

            video.src = videoUrl;
            video.load();
        });
    },

    // Intelligent retry with learned parameters
    async intelligentRetry(file, currentSizeMB, maxSizeMB, metadata, codecInfo, previousSettings, onProgress) {
        const overageRatio = currentSizeMB / maxSizeMB;
        console.log(`Retry needed: ${currentSizeMB.toFixed(1)}MB (${((overageRatio - 1) * 100).toFixed(1)}% over target)`);

        // Calculate required reduction
        const requiredReduction = maxSizeMB / currentSizeMB;

        // Determine retry strategy based on how far over we are
        let retryStrategy;
        if (overageRatio <= 1.15) {
            // Close to target - just reduce bitrate
            retryStrategy = 'bitrate-only';
        } else if (overageRatio <= 1.4) {
            // Moderate overage - reduce bitrate and slightly lower quality
            retryStrategy = 'bitrate-and-quality';
        } else {
            // Significant overage - need aggressive reduction
            retryStrategy = 'aggressive';
        }

        console.log(`Retry strategy: ${retryStrategy}`);

        // Determine quality levels for retry
        const qualityLevels = ['high', 'medium', 'low', 'ultra-low'];
        const currentQualityIndex = qualityLevels.indexOf(previousSettings.quality);

        let attempts = 0;
        const maxAttempts = 3;

        while (attempts < maxAttempts) {
            attempts++;

            let newSettings = { ...previousSettings };

            if (retryStrategy === 'bitrate-only' || attempts === 1) {
                // First attempt: reduce bitrate by the overage amount + safety margin
                newSettings.bitrate = Math.round(previousSettings.bitrate * requiredReduction * 0.88);
            } else if (retryStrategy === 'bitrate-and-quality' || attempts === 2) {
                // Second attempt: also drop quality level
                const nextQualityIndex = Math.min(currentQualityIndex + 1, qualityLevels.length - 1);
                window.userSelectedQuality = qualityLevels[nextQualityIndex];
                newSettings = this.calculateCompressionSettings(
                    file.size / (1024 * 1024),
                    maxSizeMB,
                    metadata,
                    codecInfo
                );
                // Apply additional bitrate reduction based on overage
                newSettings.bitrate = Math.round(newSettings.bitrate * requiredReduction * 0.85);
            } else {
                // Third attempt: ultra-low quality with aggressive bitrate
                window.userSelectedQuality = 'ultra-low';
                newSettings = this.calculateCompressionSettings(
                    file.size / (1024 * 1024),
                    maxSizeMB,
                    metadata,
                    codecInfo
                );
                newSettings.bitrate = Math.round(newSettings.bitrate * 0.7);
                newSettings.scale = Math.max(0.2, newSettings.scale * 0.85);
            }

            onProgress({
                stage: 'retrying',
                message: `Attempt ${attempts}: Adjusting compression (target reduction: ${((1 - requiredReduction) * 100).toFixed(0)}%)`,
                quality: newSettings.quality
            });

            console.log(`Retry attempt ${attempts}: bitrate=${(newSettings.bitrate / 1000000).toFixed(2)} Mbps, scale=${(newSettings.scale * 100).toFixed(0)}%`);

            const retryBlob = await this.performAdaptiveCompression(
                file,
                newSettings,
                metadata,
                codecInfo,
                maxSizeMB,
                onProgress
            );

            const retrySizeMB = retryBlob.size / (1024 * 1024);
            console.log(`Retry attempt ${attempts} result: ${retrySizeMB.toFixed(1)}MB`);

            if (retrySizeMB <= maxSizeMB) {
                const mimeType = this.currentMimeType || codecInfo.mimeType.split(';')[0];
                const extension = mimeType.includes('mp4') ? '.mp4' : '.webm';

                const compressedFile = new File(
                    [retryBlob],
                    file.name.replace(/\.[^/.]+$/, extension),
                    { type: mimeType }
                );

                onProgress({
                    stage: 'complete',
                    progress: 100,
                    originalSize: file.size,
                    compressedSize: compressedFile.size,
                    compressionRatio: compressedFile.size / file.size,
                    quality: newSettings.quality,
                    outputFormat: mimeType
                });

                return compressedFile;
            }

            // Update for next iteration
            currentSizeMB = retrySizeMB;
        }

        return null; // All retries failed
    },

    // Legacy method for compatibility
    getSupportedMimeType() {
        const codecInfo = this.selectOptimalCodec();
        console.log('Using mime type:', codecInfo.mimeType);
        return codecInfo.mimeType;
    },

    async getVideoMetadata(file) {
        return new Promise((resolve, reject) => {
            const video = document.createElement('video');
            video.preload = 'metadata';
            video.muted = true;

            const timeout = setTimeout(() => {
                URL.revokeObjectURL(video.src);
                reject(new Error('Video metadata loading timeout'));
            }, 30000);

            video.onloadedmetadata = () => {
                clearTimeout(timeout);
                URL.revokeObjectURL(video.src);

                // Validate metadata
                if (!video.duration || video.duration === Infinity) {
                    reject(new Error('Invalid video duration'));
                    return;
                }

                resolve({
                    duration: video.duration,
                    width: video.videoWidth,
                    height: video.videoHeight,
                    aspectRatio: video.videoWidth / video.videoHeight
                });
            };

            video.onerror = () => {
                clearTimeout(timeout);
                URL.revokeObjectURL(video.src);
                reject(new Error('Failed to load video metadata'));
            };

            video.src = URL.createObjectURL(file);
        });
    }
};

// Initialize app without checking for login
async function initializeApp() {
    initTheme();

    // Initialize filter packs from localStorage
    initFilterPacks();

    // Load admin blocklist from localStorage
    loadAdminBlocklist();

    // Start relay connections in the background (non-blocking)
    // This allows the UI to render immediately while connections establish
    initializeRelayConnections();

    // Check for stored login (fast, local storage based)
    // Don't await - let it run in parallel with route handling
    const loginPromise = checkStoredLogin();

    // Handle route immediately - content will render progressively as relays connect
    handleRoute();

    // Ensure login completes (for UI state updates)
    await loginPromise;
}

// Check for stored login
async function checkStoredLogin() {
    return new Promise((resolve) => {
        const storedMethod = localStorage.getItem(STORAGE_KEYS.loginMethod);
        const storedPubkey = localStorage.getItem(STORAGE_KEYS.publicKey);

        if (storedMethod && storedPubkey) {
            if (storedMethod === 'extension') {
                // Try to reconnect with extension
                if (window.nostr) {
                    window.nostr.getPublicKey().then(pubkey => {
                        if (pubkey === storedPubkey) {
                            currentUser = { pubkey };
                            onUserLoggedIn().then(resolve);
                        } else {
                            resolve();
                        }
                    }).catch(() => {
                        console.log('Extension login failed, clearing stored login');
                        clearStoredLogin();
                        resolve();
                    });
                } else {
                    resolve();
                }
            } else if (storedMethod === 'privateKey') {
                const storedKey = localStorage.getItem(STORAGE_KEYS.privateKey);
                if (storedKey) {
                    const pubkey = getPublicKeyFromPrivate(storedKey);
                    currentUser = { pubkey, privateKey: storedKey };
                    onUserLoggedIn().then(resolve);
                } else {
                    resolve();
                }
            } else if (storedMethod === 'connect') {
                const bunkerURL = localStorage.getItem(STORAGE_KEYS.bunkerURL);
                const secret = localStorage.getItem(STORAGE_KEYS.nip46Secret);
                if (bunkerURL && secret) {
                    reconnectNip46(bunkerURL, secret).then(resolve);
                } else {
                    resolve();
                }
            }
        } else {
            resolve();
        }
    });
}

// Clear stored login
function clearStoredLogin() {
    Object.values(STORAGE_KEYS).forEach(key => {
        localStorage.removeItem(key);
    });
    currentUser = null;
    // Clear mute list cache
    mutedUsersCache.clear();
    muteListLoaded = false;
    sessionUnhiddenMutedUsers.clear();
    updateUserInterface();
}

// User logged in handler
async function onUserLoggedIn(freshLogin = false) {
    updateUserInterface();
    await initializeSettings();
    // Load user's mute list in background
    fetchMuteList().catch(err => console.error('Failed to load mute list:', err));
    // Load user's follows for report warnings in background
    fetchUserFollows().catch(err => console.error('Failed to load follows:', err));
    // Check for new notifications in background
    checkNotificationsInBackground().catch(err => console.error('Failed to check notifications:', err));
    // Load watch history from Nostr and merge with local
    loadWatchHistoryFromNostr().catch(err => console.error('Failed to load watch history from Nostr:', err));

    // Unlock login-gated features without page reload
    if (freshLogin) {
        unlockLoginGatedFeatures();
    }
}

// Unlock login-gated features after fresh login (AJAX style, no page reload)
function unlockLoginGatedFeatures() {
    // Reload content for login-gated pages based on current view
    if (currentView === 'liked') {
        // Reload liked videos page
        loadLikedVideos();
        showToast('Logged in successfully!', 'success');
        return;
    }

    if (currentView === 'following') {
        // Reload following page
        loadFollowing();
        showToast('Logged in successfully!', 'success');
        return;
    }

    if (currentView === 'my-videos') {
        // Reload my videos page
        loadMyVideos();
        showToast('Logged in successfully!', 'success');
        return;
    }

    // Unlock comment form on video pages
    const commentContainer = document.getElementById('main-comment-input');
    if (commentContainer) {
        const textarea = commentContainer.querySelector('.comment-textarea');
        const submitBtn = commentContainer.querySelector('.comment-submit-btn');
        const loginPrompt = commentContainer.querySelector('.comment-login-prompt');

        if (textarea) {
            textarea.disabled = false;
            textarea.placeholder = 'Write a comment...';
        }
        if (submitBtn) {
            submitBtn.disabled = false;
        }
        if (loginPrompt) {
            loginPrompt.remove();
        }
    }

    // Unlock any reply input forms that might be open
    document.querySelectorAll('[id^="reply-input-"]').forEach(replyContainer => {
        const textarea = replyContainer.querySelector('.comment-textarea');
        const submitBtn = replyContainer.querySelector('.comment-submit-btn');
        const loginPrompt = replyContainer.querySelector('.comment-login-prompt');

        if (textarea) textarea.disabled = false;
        if (submitBtn) submitBtn.disabled = false;
        if (loginPrompt) loginPrompt.remove();
    });

    // Unlock comment action buttons (like, dislike, reply, zap)
    document.querySelectorAll('.comment').forEach(comment => {
        const commentPubkey = comment.querySelector('.comment-author')?.getAttribute('href')?.split('/').pop();

        // Enable like, dislike, reply, zap buttons
        comment.querySelectorAll('.comment-like-btn, .comment-dislike-btn, .comment-reply-btn, .comment-zap-btn').forEach(btn => {
            btn.disabled = false;
        });

        // Add mute/report buttons if they don't exist and it's not the user's own comment
        if (commentPubkey && commentPubkey !== currentUser?.pubkey) {
            const actionsContainer = comment.querySelector('.comment-actions');
            if (actionsContainer && !actionsContainer.querySelector('.comment-mute-btn')) {
                const commentId = comment.querySelector('[data-comment-id]')?.dataset.commentId;
                const isMuted = isUserMuted(commentPubkey);

                // Add mute button
                const muteBtn = document.createElement('button');
                muteBtn.className = `comment-action-btn comment-mute-btn ${isMuted ? 'muted' : ''}`;
                muteBtn.onclick = () => handleMute(commentPubkey, isMuted);
                muteBtn.title = isMuted ? 'Unmute user' : 'Mute user';
                muteBtn.innerHTML = `${getMuteIconSVG(14)}<span>${isMuted ? t('button.unmute') : t('button.mute')}</span>`;
                actionsContainer.appendChild(muteBtn);

                // Add report button
                const reportBtn = document.createElement('button');
                reportBtn.className = 'comment-action-btn comment-report-btn';
                reportBtn.onclick = () => showReportModal(commentId, commentPubkey, 'comment');
                reportBtn.title = 'Report comment';
                reportBtn.innerHTML = `
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"/>
                    </svg>
                    <span>Report</span>
                `;
                actionsContainer.appendChild(reportBtn);
            }
        }
    });

    // Update follow/mute buttons on profile pages
    if (currentView.startsWith('profile-')) {
        const profilePubkey = currentView.replace('profile-', '');
        if (profilePubkey && profilePubkey !== currentUser?.pubkey) {
            // Update follow button
            const followBtn = document.querySelector('.follow-btn');
            if (followBtn) {
                const isFollowing = userFollows.has(profilePubkey);
                followBtn.textContent = isFollowing ? t('button.unfollow') : t('button.follow');
                followBtn.classList.toggle('following', isFollowing);
                followBtn.onclick = () => toggleFollow(profilePubkey);
            }

            // Update mute button
            const muteBtn = document.querySelector('.mute-btn');
            if (muteBtn) {
                const isMuted = mutedUsersCache.has(profilePubkey);
                muteBtn.textContent = isMuted ? t('button.unmute') : t('button.mute');
                muteBtn.classList.toggle('muted', isMuted);
                muteBtn.onclick = () => toggleMute(profilePubkey);
            }
        }
    }

    // Update any "login to X" links/buttons throughout the page
    document.querySelectorAll('a[onclick*="showLoginModal"]').forEach(link => {
        // Check if parent contains login prompt text
        const parent = link.closest('p');
        if (parent && parent.textContent.includes('login')) {
            // This is likely a login prompt that should be removed/updated
            // The page content should reload based on context
        }
    });

    // Show toast to confirm login success
    showToast('Logged in successfully!', 'success');
}

// Update user interface
function updateUserInterface() {
    const userIcon = document.getElementById('userIcon');
    const userAvatar = document.getElementById('userAvatar');
    const userDropdown = document.getElementById('userDropdown');
    const adminMenuBtn = document.getElementById('adminMenuBtn');

    if (currentUser) {
        // Show/hide admin button based on admin status
        if (adminMenuBtn) {
            adminMenuBtn.style.display = isAdmin() ? 'flex' : 'none';
        }

        // Try to get profile from cache or storage
        const storedProfile = localStorage.getItem(STORAGE_KEYS.profile);
        if (storedProfile) {
            try {
                const profile = JSON.parse(storedProfile);
                if (profile.picture) {
                    userAvatar.src = profile.picture;
                    userAvatar.style.display = 'block';
                    userIcon.style.display = 'none';
                }
            } catch (e) {
                console.error('Failed to parse stored profile');
            }
        }

        // Fetch latest profile
        fetchUserProfile(currentUser.pubkey).then(profile => {
            if (profile && profile.picture) {
                userAvatar.src = profile.picture;
                userAvatar.style.display = 'block';
                userIcon.style.display = 'none';
                localStorage.setItem(STORAGE_KEYS.profile, JSON.stringify(profile));
            }
        });
    } else {
        userAvatar.style.display = 'none';
        userIcon.style.display = 'block';
        // Hide admin button when logged out
        if (adminMenuBtn) {
            adminMenuBtn.style.display = 'none';
        }
    }
}

// User menu functions
function toggleUserMenu() {
    if (!currentUser) {
        showLoginModal();
    } else {
        const dropdown = document.getElementById('userDropdown');
        dropdown.classList.toggle('active');

        // Close dropdown when clicking outside
        if (dropdown.classList.contains('active')) {
            document.addEventListener('click', closeUserMenuOnClickOutside);
        }
    }
}

function closeUserMenuOnClickOutside(e) {
    const userMenu = document.getElementById('userMenu');
    if (!userMenu.contains(e.target)) {
        document.getElementById('userDropdown').classList.remove('active');
        document.removeEventListener('click', closeUserMenuOnClickOutside);
    }
}

// Login modal functions
function showLoginModal() {
    document.getElementById('loginModal').classList.add('active');
}

function hideLoginModal() {
    document.getElementById('loginModal').classList.remove('active');
}

// Login with extension
async function loginWithExtension() {
    if (!window.nostr) {
        showToast('Please install a Nostr browser extension like Alby or nos2x', 'warning');
        return;
    }

    try {
        const pubkey = await window.nostr.getPublicKey();

        currentUser = { pubkey };

        // Store login method
        localStorage.setItem(STORAGE_KEYS.loginMethod, 'extension');
        localStorage.setItem(STORAGE_KEYS.publicKey, pubkey);

        hideLoginModal();
        await onUserLoggedIn(true);

    } catch (error) {
        console.error('Extension login failed:', error);
        showToast('Failed to login with extension. Please try again.', 'error');
    }
}

// NIP-46 Connect functions
function showConnectModal() {
    hideLoginModal();
    const modal = document.getElementById('connectModal');
    modal.classList.add('active');

    // Generate the connection URI and prepare for listening
    const uri = generateNostrConnectURI();
    document.getElementById('nostrConnectURI').value = uri;
}

function hideConnectModal() {
    document.getElementById('connectModal').classList.remove('active');
    window.pendingNostrConnect = null;
    window.isListeningForConnect = false;
}

// Generate nostrconnect:// URI for the user
function generateNostrConnectURI() {
    // Generate a new ephemeral key pair for this connection
    const ephemeralPrivKey = window.NostrTools.generateSecretKey();
    const ephemeralPubKey = window.NostrTools.getPublicKey(ephemeralPrivKey);

    // Store for later use
    window.pendingNostrConnect = {
        ephemeralPrivKey: bytesToHex(ephemeralPrivKey),
        ephemeralPubKey
    };

    // Create the metadata
    const metadata = {
        name: "Plebs",
        url: window.location.origin,
        description: "Decentralized video platform"
    };

    // Use multiple relays for better compatibility
    const relays = [
        'wss://relay.nsec.app',
        'wss://relay.damus.io',
        'wss://nos.lol',
        'wss://relay.nostr.band'
    ];

    // Some apps want base64, others want URL-encoded JSON
    const params = new URLSearchParams();

    // Add primary relay
    params.append('relay', relays[0]);

    // Add additional relays
    relays.slice(1).forEach(relay => {
        params.append('relay', relay);
    });

    // Add metadata
    params.append('metadata', JSON.stringify(metadata));

    return `nostrconnect://${ephemeralPubKey}?${params.toString()}`;
}

// Show QR code for mobile scanning
function showNostrConnectQR() {
    const uri = document.getElementById('nostrConnectURI').value;

    // Generate QR code
    const qrContainer = document.getElementById('nostrConnectQR');
    qrContainer.innerHTML = ''; // Clear existing QR

    if (window.QRCode) {
        new QRCode(qrContainer, {
            text: uri,
            width: 256,
            height: 256,
            colorDark: "#000000",
            colorLight: "#FFFFFF",
            correctLevel: QRCode.CorrectLevel.L
        });
    }

    // Show listening status for QR code
    document.getElementById('qrConnectionStatus').style.display = 'block';

    // Start listening for connection only if not already listening
    if (!window.isListeningForConnect) {
        window.isListeningForConnect = true;
        listenForNostrConnect();
    }
}

function toggleQRDisplay() {
    const qrSection = document.getElementById('qrCodeSection');
    const btn = event.target;

    if (qrSection.style.display === 'none') {
        qrSection.style.display = 'block';
        btn.textContent = t('button.hideQR');
        showNostrConnectQR(); // Use existing function
    } else {
        qrSection.style.display = 'none';
        btn.textContent = t('button.showQR');
    }
}

// Listen for incoming connection from the app
async function listenForNostrConnect() {
    if (!window.pendingNostrConnect) return;

    const { ephemeralPrivKey, ephemeralPubKey } = window.pendingNostrConnect;

    showConnectionStatus('Waiting for app connection...');

    const relays = ['wss://relay.nsec.app', 'wss://relay.damus.io', 'wss://nos.lol', 'wss://relay.nostr.band'];
    const connections = [];

    for (const relay of relays) {
        try {
            const ws = await connectToRelay(relay);
            connections.push({ relay, ws });

            const subId = generateRandomId();
            const subscription = JSON.stringify([
                'REQ',
                subId,
                {
                    kinds: [24133],
                    '#p': [ephemeralPubKey],
                    since: Math.floor(Date.now() / 1000) - 60
                }
            ]);
            ws.send(subscription);
        } catch (error) {
            console.error(`Failed to connect to ${relay}:`, error);
        }
    }

    if (connections.length === 0) {
        showConnectionStatus('Failed to connect to any relay');
        setTimeout(hideConnectionStatus, 3000);
        window.pendingNostrConnect = null;
        return;
    }

    const timeout = setTimeout(() => {
        showConnectionStatus('Connection timeout. Please try again.');
        setTimeout(hideConnectionStatus, 3000);
        window.pendingNostrConnect = null;
    }, 120000);

    let isConnected = false;
    let remotePubkey = null;
    let connectedRelay = null;

    const checkForConnection = async () => {
        if (isConnected) return;

        try {
            for (const { relay, ws } of connections) {
                if (ws.readyState !== WebSocket.OPEN) continue;

                const handler = (event) => {
                    try {
                        const message = JSON.parse(event.data);

                        if (message[0] === 'EVENT') {
                            const responseEvent = message.length === 2 ? message[1] : message[2];

                            if (responseEvent && responseEvent.kind === 24133) {
                                const pTag = responseEvent.tags.find(t => t[0] === 'p');

                                if (pTag && pTag[1] === ephemeralPubKey) {
                                    remotePubkey = responseEvent.pubkey;

                                    let decryptedContent;
                                    try {
                                        if (responseEvent.content.includes('?iv=')) {
                                            decryptedContent = window.NostrTools.nip04.decrypt(
                                                ephemeralPrivKey,
                                                remotePubkey,
                                                responseEvent.content
                                            );
                                        } else {
                                            const conversationKey = window.NostrTools.nip44.v2.utils.getConversationKey(
                                                hexToBytes(ephemeralPrivKey),
                                                remotePubkey
                                            );

                                            decryptedContent = window.NostrTools.nip44.v2.decrypt(
                                                responseEvent.content,
                                                conversationKey
                                            );
                                        }

                                        const response = JSON.parse(decryptedContent);

                                        if (response.result === 'ack') {
                                            isConnected = true;
                                            connectedRelay = relay;
                                            clearTimeout(timeout);

                                            showConnectionStatus('Connected! Getting public key...');

                                            handleNostrConnectSuccess(ws, ephemeralPrivKey, ephemeralPubKey, remotePubkey, relay);
                                        }
                                    } catch (decryptError) {
                                        console.error('Failed to decrypt response:', decryptError);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error processing message:', e);
                    }
                };

                ws.addEventListener('message', handler);

                setTimeout(() => {
                    ws.removeEventListener('message', handler);
                }, 1000);
            }

            if (!isConnected) {
                setTimeout(checkForConnection, 2000);
            }

        } catch (e) {
            console.error('Connection check error:', e);
            setTimeout(checkForConnection, 2000);
        }
    };

    checkForConnection();
}

// Handle successful nostrconnect connection
async function handleNostrConnectSuccess(ws, ephemeralPrivKey, ephemeralPubKey, remotePubkey, relay) {
    try {
        // Now request the public key
        const getPubkeyRequest = {
            id: generateRandomId(),
            method: 'get_public_key',
            params: []
        };

        let encryptedContent;
        try {
            encryptedContent = await encryptNip44(ephemeralPrivKey, remotePubkey, JSON.stringify(getPubkeyRequest));
        } catch (e) {
            encryptedContent = await window.NostrTools.nip04.encrypt(
                ephemeralPrivKey,
                remotePubkey,
                JSON.stringify(getPubkeyRequest)
            );
        }

        const requestEvent = {
            kind: 24133,
            pubkey: ephemeralPubKey,
            content: encryptedContent,
            tags: [['p', remotePubkey]],
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedRequestEvent = window.NostrTools.finalizeEvent(requestEvent, hexToBytes(ephemeralPrivKey));

        ws.send(JSON.stringify(['EVENT', signedRequestEvent]));

        const pubkeyResponse = await waitForNip46Response(ws, getPubkeyRequest.id, ephemeralPrivKey, remotePubkey);

        if (pubkeyResponse.result) {
            const userPubkey = pubkeyResponse.result;

            currentUser = { pubkey: userPubkey, nip46: true };
            nip46Connection = {
                relay: relay,
                remotePubkey,
                ephemeralPrivKey,
                ephemeralPubKey,
                secret: null
            };

            // Store connection info
            localStorage.setItem(STORAGE_KEYS.loginMethod, 'connect');
            localStorage.setItem(STORAGE_KEYS.publicKey, userPubkey);
            localStorage.setItem(STORAGE_KEYS.bunkerURL, `nostrconnect://${remotePubkey}`);
            localStorage.setItem(STORAGE_KEYS.nip46Secret, JSON.stringify({
                ephemeralPrivKey,
                remotePubkey,
                relay: relay
            }));

            hideConnectionStatus();
            hideConnectModal();
            window.pendingNostrConnect = null;
            await onUserLoggedIn(true);

            showConnectionStatus('Successfully connected!');
            setTimeout(hideConnectionStatus, 3000);

        } else {
            throw new Error('Failed to get public key from app');
        }
    } catch (error) {
        console.error('Failed to complete connection:', error);
        showConnectionStatus('Connection failed: ' + error.message);
        setTimeout(hideConnectionStatus, 5000);
        window.pendingNostrConnect = null;
    }
}

// Copy nostrconnect URI
function copyNostrConnectURI() {
    const textarea = document.getElementById('nostrConnectURI');
    const uri = textarea.value;

    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(uri).then(() => {
            handleCopySuccess();
        }).catch(err => {
            console.error('Clipboard API failed:', err);
            fallbackCopy();
        });
    } else {
        fallbackCopy();
    }

    function fallbackCopy() {
        try {
            textarea.select();
            textarea.setSelectionRange(0, 99999);
            document.execCommand('copy');
            handleCopySuccess();
        } catch (err) {
            console.error('Fallback copy failed:', err);
            showToast('Failed to copy. Please manually select and copy the text.', 'error');
        }
    }

    function handleCopySuccess() {
        const btn = document.querySelector('.copy-btn');
        const originalText = btn.textContent;
        btn.textContent = t('button.copied');
        btn.style.background = 'var(--accent)';

        // Show listening status
        document.getElementById('connectStringStatus').style.display = 'block';

        // Start listening for connections only if not already listening
        if (!window.isListeningForConnect) {
            window.isListeningForConnect = true;
            listenForNostrConnect();
        }

        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
        }, 2000);
    }
}

function showConnectTab(tab) {
    const bunkerTab = document.getElementById('bunkerTab');
    const qrTab = document.getElementById('qrTab');
    const tabBtns = document.querySelectorAll('.tab-btn');

    tabBtns.forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');

    if (tab === 'bunker') {
        bunkerTab.style.display = 'block';
        qrTab.style.display = 'none';
    } else {
        bunkerTab.style.display = 'none';
        qrTab.style.display = 'block';
        showNostrConnectQR();
    }
}

function selectBunker(provider) {
    // Update UI to show selected bunker
    document.querySelectorAll('.bunker-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');

    // Pre-fill bunker URL based on provider
    const bunkerUrlInput = document.getElementById('bunkerUrl');
    if (provider === 'nsec.app') {
        bunkerUrlInput.placeholder = 'bunker://...@relay.nsec.app';
    } else if (provider === 'highlighter.com') {
        bunkerUrlInput.placeholder = 'bunker://...@relay.highlighter.com';
    }
}

// Helper to wait for NIP-46
async function waitForNip46Response(ws, requestId, ephemeralPrivKey, remotePubkey) {
    return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
            reject(new Error('NIP-46 response timeout'));
        }, 30000);

        const privKeyHex = typeof ephemeralPrivKey === 'string' ?
            ephemeralPrivKey : bytesToHex(ephemeralPrivKey);
        const privKeyBytes = typeof ephemeralPrivKey === 'string' ?
            hexToBytes(ephemeralPrivKey) : ephemeralPrivKey;

        const ephemeralPubKey = window.NostrTools.getPublicKey(privKeyBytes);

        const handler = async (event) => {
            try {
                const message = JSON.parse(event.data);

                if (message[0] === 'EVENT') {
                    const responseEvent = message.length === 2 ? message[1] : message[2];

                    if (responseEvent && responseEvent.kind === 24133) {
                        if (responseEvent.pubkey === remotePubkey) {
                            const pTag = responseEvent.tags.find(t => t[0] === 'p');

                            if (pTag && pTag[1] === ephemeralPubKey) {
                                try {
                                    let decryptedContent;

                                    if (responseEvent.content.includes('?iv=')) {
                                        decryptedContent = await window.NostrTools.nip04.decrypt(
                                            privKeyHex,
                                            remotePubkey,
                                            responseEvent.content
                                        );
                                    } else {
                                        const conversationKey = window.NostrTools.nip44.v2.utils.getConversationKey(
                                            privKeyBytes,
                                            remotePubkey
                                        );

                                        decryptedContent = window.NostrTools.nip44.v2.decrypt(
                                            responseEvent.content,
                                            conversationKey
                                        );
                                    }

                                    const response = JSON.parse(decryptedContent);

                                    if (response.id === requestId) {
                                        clearTimeout(timeout);
                                        ws.removeEventListener('message', handler);
                                        resolve(response);
                                    }
                                } catch (decryptError) {
                                    console.error('Failed to decrypt NIP-46 response:', decryptError);
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                console.error('Error processing message:', e);
            }
        };

        ws.addEventListener('message', handler);
    });
}

// Connect using a bunker string
async function connectWithBunker() {
    const bunkerUrl = document.getElementById('bunkerUrl').value.trim();

    if (!bunkerUrl || !bunkerUrl.startsWith('bunker://')) {
        showToast('Please enter a valid bunker URL', 'warning');
        return;
    }

    try {
        const urlParts = bunkerUrl.slice(9).split('?');
        const remotePubkey = urlParts[0];

        if (!remotePubkey) {
            throw new Error('Invalid bunker URL format - missing pubkey');
        }

        const params = new URLSearchParams(urlParts[1] || '');
        const relay = params.get('relay');
        let secret = params.get('secret');

        if (!relay) {
            throw new Error('Invalid bunker URL format - missing relay parameter');
        }

        const ephemeralPrivKey = window.NostrTools.generateSecretKey();
        const ephemeralPubKey = window.NostrTools.getPublicKey(ephemeralPrivKey);
        const ephemeralPrivKeyHex = bytesToHex(ephemeralPrivKey);

        nip46Secret = secret || remotePubkey;

        const ws = await connectToRelay(relay);

        const subId = generateRandomId();
        const subscription = JSON.stringify([
            'REQ',
            subId,
            {
                kinds: [24133],
                '#p': [ephemeralPubKey],
                since: Math.floor(Date.now() / 1000) - 60
            }
        ]);
        ws.send(subscription);

        showConnectionStatus('Connecting to bunker...');

        const connectRequest = {
            id: generateRandomId(),
            method: 'connect',
            params: [ephemeralPubKey, secret || '']
        };

        let encryptedContent;
        try {
            encryptedContent = await encryptNip44(ephemeralPrivKeyHex, remotePubkey, JSON.stringify(connectRequest));
        } catch (encryptError) {
            encryptedContent = await window.NostrTools.nip04.encrypt(
                ephemeralPrivKeyHex,
                remotePubkey,
                JSON.stringify(connectRequest)
            );
        }

        const requestEvent = {
            kind: 24133,
            pubkey: ephemeralPubKey,
            content: encryptedContent,
            tags: [['p', remotePubkey]],
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedRequestEvent = window.NostrTools.finalizeEvent(requestEvent, ephemeralPrivKey);

        ws.send(JSON.stringify(['EVENT', signedRequestEvent]));

        const connectResponse = await waitForNip46Response(ws, connectRequest.id, ephemeralPrivKeyHex, remotePubkey);

        if (connectResponse.result === 'auth_url' && connectResponse.error) {
            showConnectionStatus('Authorization required. Opening approval page...');

            const authUrl = connectResponse.error;
            const authWindow = window.open(authUrl, 'nostr-auth', 'width=600,height=800');

            showConnectionStatus('Waiting for approval...');

            let approved = false;
            let attempts = 0;
            const maxAttempts = 60;

            while (!approved && attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 1000));

                if (authWindow && authWindow.closed) {
                    const getPubkeyRequest = {
                        id: generateRandomId(),
                        method: 'get_public_key',
                        params: []
                    };

                    let pubkeyEncrypted;
                    try {
                        pubkeyEncrypted = await encryptNip44(ephemeralPrivKeyHex, remotePubkey, JSON.stringify(getPubkeyRequest));
                    } catch (e) {
                        pubkeyEncrypted = await window.NostrTools.nip04.encrypt(
                            ephemeralPrivKeyHex,
                            remotePubkey,
                            JSON.stringify(getPubkeyRequest)
                        );
                    }

                    const pubkeyRequestEvent = {
                        kind: 24133,
                        pubkey: ephemeralPubKey,
                        content: pubkeyEncrypted,
                        tags: [['p', remotePubkey]],
                        created_at: Math.floor(Date.now() / 1000)
                    };

                    const signedPubkeyRequestEvent = window.NostrTools.finalizeEvent(pubkeyRequestEvent, ephemeralPrivKey);

                    ws.send(JSON.stringify(['EVENT', signedPubkeyRequestEvent]));

                    try {
                        const pubkeyResponse = await waitForNip46Response(ws, getPubkeyRequest.id, ephemeralPrivKeyHex, remotePubkey);

                        if (pubkeyResponse.result) {
                            approved = true;
                            const userPubkey = pubkeyResponse.result;

                            currentUser = { pubkey: userPubkey, nip46: true };
                            nip46Connection = {
                                relay,
                                remotePubkey,
                                ephemeralPrivKey: ephemeralPrivKeyHex,
                                ephemeralPubKey,
                                secret: nip46Secret
                            };

                            localStorage.setItem(STORAGE_KEYS.loginMethod, 'connect');
                            localStorage.setItem(STORAGE_KEYS.publicKey, userPubkey);
                            localStorage.setItem(STORAGE_KEYS.bunkerURL, bunkerUrl);
                            localStorage.setItem(STORAGE_KEYS.nip46Secret, JSON.stringify({
                                ephemeralPrivKey: ephemeralPrivKeyHex,
                                remotePubkey,
                                relay
                            }));

                            hideConnectionStatus();
                            hideConnectModal();
                            await onUserLoggedIn(true);
                        }
                    } catch (e) {
                        // Not approved yet, continue waiting
                    }
                }

                attempts++;
            }

            if (!approved) {
                throw new Error('Connection approval timeout');
            }

        } else if (connectResponse.result === 'ack') {
            showConnectionStatus('Connected! Getting public key...');

            const getPubkeyRequest = {
                id: generateRandomId(),
                method: 'get_public_key',
                params: []
            };

            let pubkeyEncrypted;
            try {
                pubkeyEncrypted = await encryptNip44(ephemeralPrivKeyHex, remotePubkey, JSON.stringify(getPubkeyRequest));
            } catch (e) {
                pubkeyEncrypted = await window.NostrTools.nip04.encrypt(
                    ephemeralPrivKeyHex,
                    remotePubkey,
                    JSON.stringify(getPubkeyRequest)
                );
            }

            const pubkeyRequestEvent = {
                kind: 24133,
                pubkey: ephemeralPubKey,
                content: pubkeyEncrypted,
                tags: [['p', remotePubkey]],
                created_at: Math.floor(Date.now() / 1000)
            };

            const signedPubkeyRequestEvent = window.NostrTools.finalizeEvent(pubkeyRequestEvent, ephemeralPrivKey);

            ws.send(JSON.stringify(['EVENT', signedPubkeyRequestEvent]));

            const pubkeyResponse = await waitForNip46Response(ws, getPubkeyRequest.id, ephemeralPrivKeyHex, remotePubkey);

            if (pubkeyResponse.result) {
                const userPubkey = pubkeyResponse.result;

                currentUser = { pubkey: userPubkey, nip46: true };
                nip46Connection = {
                    relay,
                    remotePubkey,
                    ephemeralPrivKey: ephemeralPrivKeyHex,
                    ephemeralPubKey,
                    secret: nip46Secret
                };

                localStorage.setItem(STORAGE_KEYS.loginMethod, 'connect');
                localStorage.setItem(STORAGE_KEYS.publicKey, userPubkey);
                localStorage.setItem(STORAGE_KEYS.bunkerURL, bunkerUrl);
                localStorage.setItem(STORAGE_KEYS.nip46Secret, JSON.stringify({
                    ephemeralPrivKey: ephemeralPrivKeyHex,
                    remotePubkey,
                    relay
                }));

                hideConnectionStatus();
                hideConnectModal();
                await onUserLoggedIn(true);
            } else {
                throw new Error('Failed to get public key from bunker');
            }
        } else {
            throw new Error(connectResponse.error || 'Connection rejected by bunker');
        }

    } catch (error) {
        console.error('NIP-46 connection failed:', error);
        hideConnectionStatus();
        showToast('Failed to connect: ' + error.message, 'error');
    }
}

// Show connection status
function showConnectionStatus(message) {
    // Update all possible status displays
    const stringStatus = document.getElementById('connectStringStatus');
    const qrStatus = document.getElementById('qrConnectionStatus');

    if (stringStatus && stringStatus.style.display !== 'none') {
        stringStatus.querySelector('span').textContent = message;
    }

    if (qrStatus && qrStatus.style.display !== 'none') {
        qrStatus.querySelector('span').textContent = message;
    }
}

function hideConnectionStatus() {
    const stringStatus = document.getElementById('connectStringStatus');
    const qrStatus = document.getElementById('qrConnectionStatus');

    if (stringStatus) stringStatus.style.display = 'none';
    if (qrStatus) qrStatus.style.display = 'none';
}

// Private key login functions
function showPrivateKeyModal() {
    hideLoginModal();
    document.getElementById('privateKeyModal').classList.add('active');
}

function hidePrivateKeyModal() {
    document.getElementById('privateKeyModal').classList.remove('active');
}

function toggleKeyVisibility() {
    const input = document.getElementById('privateKeyInput');
    const checkbox = document.getElementById('showKey');
    input.type = checkbox.checked ? 'text' : 'password';
}

async function loginWithPrivateKey() {
    const keyInput = document.getElementById('privateKeyInput').value.trim();

    if (!keyInput) {
        showToast('Please enter your private key', 'warning');
        return;
    }

    try {
        let privateKey;
        let publicKey;

        if (keyInput.startsWith('nsec1')) {
            // Decode nsec
            const decoded = window.NostrTools.nip19.decode(keyInput);
            if (decoded.type !== 'nsec') {
                throw new Error('Invalid nsec key');
            }
            privateKey = decoded.data;
            publicKey = window.NostrTools.getPublicKey(privateKey);
        } else if (/^[0-9a-fA-F]{64}$/.test(keyInput)) {
            // Hex private key - convert to Uint8Array for nostr-tools
            privateKey = hexToBytes(keyInput);
            publicKey = window.NostrTools.getPublicKey(privateKey);
        } else {
            throw new Error('Invalid private key format');
        }

        currentUser = { pubkey: publicKey, privateKey: bytesToHex(privateKey) };

        // Store login info
        localStorage.setItem(STORAGE_KEYS.loginMethod, 'privateKey');
        localStorage.setItem(STORAGE_KEYS.publicKey, publicKey);
        localStorage.setItem(STORAGE_KEYS.privateKey, bytesToHex(privateKey));

        hidePrivateKeyModal();
        await onUserLoggedIn(true);

    } catch (error) {
        console.error('Private key login failed:', error);
        showToast('Invalid private key. Please check and try again.', 'error');
    }
}

// Signup functions
let signupAvatarUrl = null;
let preGeneratedKeys = null; // Pre-generated keys for signup avatar upload

function showSignupModal() {
    hideLoginModal();
    // Reset the modal to initial state
    document.getElementById('nostrExplainer').style.display = 'block';
    document.getElementById('signupFormSection').style.display = 'none';
    document.getElementById('signupSuccess').style.display = 'none';
    signupAvatarUrl = null;
    preGeneratedKeys = null;

    // Reset form fields
    const usernameInput = document.getElementById('signupUsername');
    const aboutInput = document.getElementById('signupAbout');
    const lnInput = document.getElementById('signupLightningAddress');
    if (usernameInput) usernameInput.value = '';
    if (aboutInput) aboutInput.value = '';
    if (lnInput) lnInput.value = '';

    // Reset avatar preview
    resetAvatarUpload();

    document.getElementById('signupModal').classList.add('active');
}

function showSignupForm() {
    // Pre-generate keys so we can use them for avatar upload
    const privateKey = window.NostrTools.generateSecretKey();
    const publicKey = window.NostrTools.getPublicKey(privateKey);
    preGeneratedKeys = { privateKey, publicKey };

    document.getElementById('nostrExplainer').style.display = 'none';
    document.getElementById('signupFormSection').style.display = 'block';
    updateSignupPreview();

    // Add input listeners for preview updates
    const usernameInput = document.getElementById('signupUsername');
    const aboutInput = document.getElementById('signupAbout');

    if (usernameInput) {
        usernameInput.addEventListener('input', updateSignupPreview);
    }
    if (aboutInput) {
        aboutInput.addEventListener('input', updateSignupPreview);
    }
}

function hideSignupModal() {
    document.getElementById('signupModal').classList.remove('active');
}

function updateSignupPreview() {
    const username = document.getElementById('signupUsername')?.value || 'Your Username';
    const about = document.getElementById('signupAbout')?.value || 'Your bio will appear here';

    const previewName = document.getElementById('previewName');
    const previewAbout = document.getElementById('previewAbout');
    const previewAvatarInitial = document.getElementById('previewAvatarInitial');
    const previewAvatarImage = document.getElementById('previewAvatarImage');
    const avatarInitial = document.getElementById('avatarInitial');

    if (previewName) previewName.textContent = username;
    if (previewAbout) previewAbout.textContent = about;

    // Update avatar preview
    if (signupAvatarUrl) {
        if (previewAvatarImage) {
            previewAvatarImage.src = signupAvatarUrl;
            previewAvatarImage.style.display = 'block';
        }
        if (previewAvatarInitial) previewAvatarInitial.style.display = 'none';
    } else {
        if (previewAvatarImage) previewAvatarImage.style.display = 'none';
        if (previewAvatarInitial) {
            previewAvatarInitial.style.display = 'block';
            previewAvatarInitial.textContent = username.charAt(0).toUpperCase() || '?';
        }
    }

    // Update the avatar placeholder initial
    if (avatarInitial && !signupAvatarUrl) {
        avatarInitial.textContent = username.charAt(0).toUpperCase() || '?';
    }
}

// Avatar upload for signup using Blossom (requires pre-generated keys)
async function handleAvatarSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    // Validate file
    if (!file.type.startsWith('image/')) {
        showToast('Please select an image file', 'error');
        return;
    }

    if (file.size > 5 * 1024 * 1024) {
        showToast('Image must be less than 5MB', 'error');
        return;
    }

    if (!preGeneratedKeys) {
        showToast('Please try again', 'error');
        return;
    }

    // Show local preview immediately
    const reader = new FileReader();
    reader.onload = (e) => {
        const avatarPreviewImage = document.getElementById('avatarPreviewImage');
        const avatarPlaceholder = document.getElementById('avatarPlaceholder');
        const avatarRemoveBtn = document.getElementById('avatarRemoveBtn');

        if (avatarPreviewImage) {
            avatarPreviewImage.src = e.target.result;
            avatarPreviewImage.style.display = 'block';
        }
        if (avatarPlaceholder) avatarPlaceholder.style.display = 'none';
        if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'block';
    };
    reader.readAsDataURL(file);

    // Show upload progress
    const progressDiv = document.getElementById('avatarUploadProgress');
    const progressFill = document.getElementById('avatarProgressFill');
    const statusSpan = document.getElementById('avatarUploadStatus');

    if (progressDiv) progressDiv.style.display = 'block';
    if (progressFill) progressFill.style.width = '20%';
    if (statusSpan) statusSpan.textContent = t('status.uploading');

    try {
        // Upload using Blossom with pre-generated keys
        const uploadedUrl = await uploadAvatarWithKeys(file, preGeneratedKeys.privateKey, preGeneratedKeys.publicKey);

        if (uploadedUrl) {
            signupAvatarUrl = uploadedUrl;
            if (progressFill) progressFill.style.width = '100%';
            if (statusSpan) statusSpan.textContent = t('status.uploadComplete');

            setTimeout(() => {
                if (progressDiv) progressDiv.style.display = 'none';
            }, 1500);

            updateSignupPreview();
            showToast('Avatar uploaded successfully!', 'success');
        } else {
            throw new Error('Upload failed');
        }
    } catch (error) {
        console.error('Avatar upload failed:', error);
        if (progressDiv) progressDiv.style.display = 'none';
        showToast('Failed to upload avatar. Please try again.', 'error');
        removeAvatarUpload();
    }
}

// Upload avatar to Blossom with specific keys (for signup flow)
async function uploadAvatarWithKeys(file, privateKey, publicKey) {
    const hash = await calculateSHA256(file);

    // Try each Blossom server
    for (const server of BLOSSOM_SERVERS) {
        try {
            // Create auth event for Blossom
            const expiration = Math.floor(Date.now() / 1000) + 300; // 5 minutes
            const authEvent = {
                kind: 24242,
                pubkey: publicKey,
                created_at: Math.floor(Date.now() / 1000),
                tags: [
                    ['t', 'upload'],
                    ['x', hash],
                    ['expiration', expiration.toString()]
                ],
                content: `Upload ${hash}`
            };

            // Sign with the provided keys
            const signedAuthEvent = window.NostrTools.finalizeEvent(authEvent, privateKey);
            const authHeader = btoa(JSON.stringify(signedAuthEvent));

            const response = await fetch(`${server}/upload`, {
                method: 'PUT',
                body: file,
                headers: {
                    'Content-Type': file.type,
                    'Authorization': `Nostr ${authHeader}`
                }
            });

            if (response.ok) {
                const result = await response.json();
                console.log(`Avatar uploaded successfully to ${server}`);
                return result.url || `${server}/${hash}`;
            }
        } catch (error) {
            console.error(`Failed to upload avatar to ${server}:`, error);
        }
    }

    throw new Error('Failed to upload to all servers');
}

function removeAvatarUpload() {
    signupAvatarUrl = null;

    const avatarPreviewImage = document.getElementById('avatarPreviewImage');
    const avatarPlaceholder = document.getElementById('avatarPlaceholder');
    const avatarRemoveBtn = document.getElementById('avatarRemoveBtn');
    const avatarFileInput = document.getElementById('avatarFileInput');

    if (avatarPreviewImage) avatarPreviewImage.style.display = 'none';
    if (avatarPlaceholder) avatarPlaceholder.style.display = 'flex';
    if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'none';
    if (avatarFileInput) avatarFileInput.value = '';

    updateSignupPreview();
}

function resetAvatarUpload() {
    signupAvatarUrl = null;

    const avatarPreviewImage = document.getElementById('avatarPreviewImage');
    const avatarPlaceholder = document.getElementById('avatarPlaceholder');
    const avatarRemoveBtn = document.getElementById('avatarRemoveBtn');
    const avatarFileInput = document.getElementById('avatarFileInput');
    const previewAvatarImage = document.getElementById('previewAvatarImage');
    const previewAvatarInitial = document.getElementById('previewAvatarInitial');

    if (avatarPreviewImage) avatarPreviewImage.style.display = 'none';
    if (avatarPlaceholder) {
        avatarPlaceholder.style.display = 'flex';
        const initial = avatarPlaceholder.querySelector('#avatarInitial');
        if (initial) initial.textContent = '?';
    }
    if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'none';
    if (avatarFileInput) avatarFileInput.value = '';
    if (previewAvatarImage) previewAvatarImage.style.display = 'none';
    if (previewAvatarInitial) {
        previewAvatarInitial.style.display = 'block';
        previewAvatarInitial.textContent = '?';
    }
}

async function signEvent(event) {
    if (!currentUser) {
        throw new Error('No user logged in');
    }

    // Ensure pubkey is set
    if (!event.pubkey) {
        event.pubkey = currentUser.pubkey;
    }

    if (window.nostr && !currentUser.privateKey && !currentUser.nip46) {
        // NIP-07 extension signing
        return await window.nostr.signEvent(event);
    } else if (currentUser.nip46) {
        // NIP-46 remote signing
        return await signEventWithNip46(event);
    } else if (currentUser.privateKey) {
        // Local key signing using nostr-tools
        const privKey = typeof currentUser.privateKey === 'string' ?
            hexToBytes(currentUser.privateKey) : currentUser.privateKey;

        // finalizeEvent returns the complete signed event
        const signedEvent = window.NostrTools.finalizeEvent(event, privKey);

        return signedEvent;
    } else {
        throw new Error('No signing method available');
    }
}

// Store generated keys for later use in finishAccountCreation
let generatedKeys = null;

async function createAccount() {
    const username = document.getElementById('signupUsername').value.trim();
    const about = document.getElementById('signupAbout').value.trim();
    const lightningAddress = document.getElementById('signupLightningAddress')?.value.trim() || '';

    if (!username) {
        showToast('Please enter a username', 'error');
        return;
    }

    // Use pre-generated keys (created when entering signup form for avatar upload)
    if (!preGeneratedKeys) {
        showToast('Error: Keys not generated. Please try again.', 'error');
        return;
    }

    const createBtn = document.getElementById('createAccountBtn');
    if (createBtn) {
        createBtn.disabled = true;
        createBtn.textContent = t('button.creatingAccount');
    }

    try {
        // Use the pre-generated keys
        const privateKey = preGeneratedKeys.privateKey;
        const publicKey = preGeneratedKeys.publicKey;

        // Build profile content
        const profileContent = {
            name: username,
            about: about,
            picture: signupAvatarUrl || `https://robohash.org/${publicKey}.png`
        };

        // Add lightning address if provided
        if (lightningAddress) {
            profileContent.lud16 = lightningAddress;
        }

        // Create profile event
        const profileEvent = {
            kind: 0,
            pubkey: publicKey,
            created_at: Math.floor(Date.now() / 1000),
            tags: [],
            content: JSON.stringify(profileContent)
        };

        // Use finalizeEvent to sign
        const signedProfileEvent = window.NostrTools.finalizeEvent(profileEvent, privateKey);

        // Publish profile
        await publishEvent(signedProfileEvent);

        // Create contact list
        const contactListEvent = {
            kind: 3,
            pubkey: publicKey,
            created_at: Math.floor(Date.now() / 1000),
            tags: [],
            content: ''
        };

        const signedContactListEvent = window.NostrTools.finalizeEvent(contactListEvent, privateKey);
        await publishEvent(signedContactListEvent);

        // Store keys for later use in finishAccountCreation
        generatedKeys = {
            privateKey: privateKey,
            publicKey: publicKey,
            nsec: window.NostrTools.nip19.nsecEncode(privateKey)
        };

        // Hide the form section and show success section
        document.getElementById('signupFormSection').style.display = 'none';
        document.getElementById('signupSuccess').style.display = 'block';
        document.getElementById('generatedNsec').textContent = generatedKeys.nsec;

    } catch (error) {
        console.error('Account creation failed:', error);
        showToast('Failed to create account. Please try again.', 'error');
    } finally {
        if (createBtn) {
            createBtn.disabled = false;
            createBtn.textContent = t('login.createAccount');
        }
    }
}

function copyGeneratedKey() {
    const nsec = document.getElementById('generatedNsec').textContent;
    navigator.clipboard.writeText(nsec).then(() => {
        // Update button to show copied
        const copyBtn = document.getElementById('copyNsecBtn');
        if (copyBtn) {
            copyBtn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
                </svg>
                Copied!
            `;
            copyBtn.style.background = 'var(--success-color)';
        }

        // Show the instructions section
        const keyInstructions = document.getElementById('keyInstructions');
        if (keyInstructions) {
            keyInstructions.style.display = 'block';
        }

        showToast('Private key copied to clipboard!', 'success');
    }).catch(() => {
        showToast('Failed to copy. Please copy manually.', 'error');
    });
}

function finishAccountCreation() {
    if (!generatedKeys) {
        showToast('Error: Keys not found. Please try again.', 'error');
        return;
    }

    // Log the user in
    currentUser = {
        pubkey: generatedKeys.publicKey,
        privateKey: bytesToHex(generatedKeys.privateKey)
    };

    localStorage.setItem(STORAGE_KEYS.loginMethod, 'privateKey');
    localStorage.setItem(STORAGE_KEYS.publicKey, generatedKeys.publicKey);
    localStorage.setItem(STORAGE_KEYS.privateKey, bytesToHex(generatedKeys.privateKey));

    // Clear the stored keys
    generatedKeys = null;
    signupAvatarUrl = null;
    preGeneratedKeys = null;

    hideSignupModal();
    onUserLoggedIn(true);

    showToast('Welcome to Plebs! You are now logged in.', 'success');
}

// View own profile function
function viewOwnProfile() {
    if (!currentUser) {
        showLoginModal();
        return;
    }

    // Close the dropdown
    document.getElementById('userDropdown').classList.remove('active');

    // Navigate to profile
    const npub = window.NostrTools.nip19.npubEncode(currentUser.pubkey);
    navigateTo(`/profile/${npub}`);
}

// ===== Edit Profile Modal Functions =====

let editAvatarUrl = null;
let currentEditProfile = null;

async function showEditProfileModal() {
    if (!currentUser) {
        showLoginModal();
        return;
    }

    // Fetch current profile
    const profile = await fetchUserProfile(currentUser.pubkey);
    currentEditProfile = profile || {};

    // Populate form fields
    document.getElementById('editProfileName').value = profile?.name || profile?.display_name || '';
    document.getElementById('editProfileAbout').value = profile?.about || '';
    document.getElementById('editProfilePicture').value = profile?.picture || '';
    document.getElementById('editProfileLud16').value = profile?.lud16 || '';
    document.getElementById('editProfileNip05').value = profile?.nip05 || '';
    document.getElementById('editProfileWebsite').value = profile?.website || '';

    // Set avatar preview
    editAvatarUrl = profile?.picture || null;
    updateEditAvatarPreview();

    // Load muted users list
    loadMutedUsersList();

    // Show modal
    document.getElementById('editProfileModal').classList.add('active');
}

// Load and display muted users list in the profile edit modal
async function loadMutedUsersList(containerId = 'mutedUsersList', hideModalFn = 'hideEditProfileModal') {
    const container = document.getElementById(containerId);
    if (!container) return;

    container.innerHTML = '<div class="spinner" style="margin: 1rem auto;"></div>';

    // Ensure mute list is loaded
    if (!muteListLoaded) {
        await fetchMuteList();
    }

    if (mutedUsersCache.size === 0) {
        container.innerHTML = `<p class="no-muted-users">${t('empty.noMutedUsers')}</p>`;
        return;
    }

    // Fetch profiles for muted users
    const mutedPubkeys = Array.from(mutedUsersCache);
    const profiles = new Map();

    // Fetch profiles in batches
    const batchSize = 20;
    for (let i = 0; i < mutedPubkeys.length; i += batchSize) {
        const batch = mutedPubkeys.slice(i, i + batchSize);
        await Promise.all(batch.map(async (pubkey) => {
            const profile = await fetchUserProfile(pubkey);
            if (profile) profiles.set(pubkey, profile);
        }));
    }

    container.innerHTML = '';

    mutedPubkeys.forEach(pubkey => {
        const profile = profiles.get(pubkey) || {};
        const displayName = profile.name || profile.display_name || `User ${pubkey.slice(0, 8)}`;
        const avatarUrl = profile.picture || profile.avatar || '';

        const userItem = document.createElement('div');
        userItem.className = 'muted-user-item';
        userItem.dataset.pubkey = pubkey;
        userItem.innerHTML = `
            <a href="#/profile/${pubkey}" class="muted-user-info" onclick="${hideModalFn}()">
                <div class="muted-user-avatar">
                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${escapeHtml(displayName)}">` : `<span>${displayName.charAt(0).toUpperCase()}</span>`}
                </div>
                <span class="muted-user-name">${escapeHtml(displayName)}</span>
            </a>
            <button class="unmute-btn" onclick="handleUnmuteFromModal('${pubkey}')" title="${t('button.unmuteUser')}">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                </svg>
            </button>
        `;
        container.appendChild(userItem);
    });
}

// Handle unmute from any modal (profile edit or settings)
async function handleUnmuteFromModal(pubkey) {
    // Get all matching items from both modals
    const userItems = document.querySelectorAll(`.muted-user-item[data-pubkey="${pubkey}"]`);
    userItems.forEach(item => item.classList.add('removing'));

    const success = await unmuteUser(pubkey);

    if (success) {
        userItems.forEach(item => item.remove());
        // Check both containers for empty state
        const containers = ['mutedUsersList', 'settingsMutedUsersList'];
        containers.forEach(containerId => {
            const container = document.getElementById(containerId);
            if (container && container.children.length === 0) {
                container.innerHTML = `<p class="no-muted-users">${t('empty.noMutedUsers')}</p>`;
            }
        });
        showToast('User unmuted', 'success');
    } else {
        userItems.forEach(item => item.classList.remove('removing'));
        showToast('Failed to unmute user', 'error');
    }
}

function hideEditProfileModal() {
    document.getElementById('editProfileModal').classList.remove('active');
    editAvatarUrl = null;
    currentEditProfile = null;
}

function updateEditAvatarPreview() {
    const avatarPreviewImage = document.getElementById('editAvatarPreviewImage');
    const avatarPlaceholder = document.getElementById('editAvatarPlaceholder');
    const avatarRemoveBtn = document.getElementById('editAvatarRemoveBtn');
    const name = document.getElementById('editProfileName')?.value || '';

    if (editAvatarUrl) {
        if (avatarPreviewImage) {
            avatarPreviewImage.src = editAvatarUrl;
            avatarPreviewImage.style.display = 'block';
        }
        if (avatarPlaceholder) avatarPlaceholder.style.display = 'none';
        if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'block';
    } else {
        if (avatarPreviewImage) avatarPreviewImage.style.display = 'none';
        if (avatarPlaceholder) {
            avatarPlaceholder.style.display = 'flex';
            const initial = document.getElementById('editAvatarInitial');
            if (initial) initial.textContent = name.charAt(0).toUpperCase() || '?';
        }
        if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'none';
    }
}

async function handleEditAvatarSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    // Validate file
    if (!file.type.startsWith('image/')) {
        showToast('Please select an image file', 'error');
        return;
    }

    if (file.size > 5 * 1024 * 1024) {
        showToast('Image must be less than 5MB', 'error');
        return;
    }

    // Show local preview immediately
    const reader = new FileReader();
    reader.onload = (e) => {
        const avatarPreviewImage = document.getElementById('editAvatarPreviewImage');
        const avatarPlaceholder = document.getElementById('editAvatarPlaceholder');
        const avatarRemoveBtn = document.getElementById('editAvatarRemoveBtn');

        if (avatarPreviewImage) {
            avatarPreviewImage.src = e.target.result;
            avatarPreviewImage.style.display = 'block';
        }
        if (avatarPlaceholder) avatarPlaceholder.style.display = 'none';
        if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'block';
    };
    reader.readAsDataURL(file);

    // Show upload progress
    const progressDiv = document.getElementById('editAvatarUploadProgress');
    const progressFill = document.getElementById('editAvatarProgressFill');
    const statusSpan = document.getElementById('editAvatarUploadStatus');

    if (progressDiv) progressDiv.style.display = 'block';
    if (progressFill) progressFill.style.width = '20%';
    if (statusSpan) statusSpan.textContent = t('status.uploadingToNostrBuild');

    try {
        // Upload to nostr.build
        const uploadedUrl = await uploadToNostrBuild(file);

        if (uploadedUrl) {
            editAvatarUrl = uploadedUrl;
            document.getElementById('editProfilePicture').value = uploadedUrl;

            if (progressFill) progressFill.style.width = '100%';
            if (statusSpan) statusSpan.textContent = t('status.uploadComplete');

            setTimeout(() => {
                if (progressDiv) progressDiv.style.display = 'none';
            }, 1500);

            showToast('Avatar uploaded successfully!', 'success');
        } else {
            throw new Error('Upload failed');
        }
    } catch (error) {
        console.error('Avatar upload failed:', error);
        if (progressDiv) progressDiv.style.display = 'none';
        showToast('Failed to upload avatar. Please try again.', 'error');
    }
}

function removeEditAvatarUpload() {
    editAvatarUrl = null;
    document.getElementById('editProfilePicture').value = '';

    const avatarPreviewImage = document.getElementById('editAvatarPreviewImage');
    const avatarPlaceholder = document.getElementById('editAvatarPlaceholder');
    const avatarRemoveBtn = document.getElementById('editAvatarRemoveBtn');
    const avatarFileInput = document.getElementById('editAvatarFileInput');

    if (avatarPreviewImage) avatarPreviewImage.style.display = 'none';
    if (avatarPlaceholder) avatarPlaceholder.style.display = 'flex';
    if (avatarRemoveBtn) avatarRemoveBtn.style.display = 'none';
    if (avatarFileInput) avatarFileInput.value = '';
}

async function saveProfile() {
    if (!currentUser) {
        showToast('You must be logged in to edit your profile', 'error');
        return;
    }

    const name = document.getElementById('editProfileName').value.trim();
    const about = document.getElementById('editProfileAbout').value.trim();
    const picture = document.getElementById('editProfilePicture').value.trim() || editAvatarUrl || '';
    const lud16 = document.getElementById('editProfileLud16').value.trim();
    const nip05 = document.getElementById('editProfileNip05').value.trim();
    const website = document.getElementById('editProfileWebsite').value.trim();

    if (!name) {
        showToast('Please enter a display name', 'error');
        return;
    }

    const saveBtn = document.getElementById('saveProfileBtn');
    if (saveBtn) {
        saveBtn.disabled = true;
        saveBtn.textContent = t('status.saving');
    }

    try {
        // Build profile content, preserving any existing fields
        const profileContent = {
            ...currentEditProfile,
            name: name
        };

        // Only include fields if they have values
        if (about) profileContent.about = about;
        else delete profileContent.about;

        if (picture) profileContent.picture = picture;
        else delete profileContent.picture;

        if (lud16) profileContent.lud16 = lud16;
        else delete profileContent.lud16;

        if (nip05) profileContent.nip05 = nip05;
        else delete profileContent.nip05;

        if (website) profileContent.website = website;
        else delete profileContent.website;

        // Create kind 0 event
        const profileEvent = {
            kind: 0,
            created_at: Math.floor(Date.now() / 1000),
            tags: [],
            content: JSON.stringify(profileContent)
        };

        // Sign and publish
        const signedEvent = await signEvent(profileEvent);
        const published = await publishEvent(signedEvent);

        if (published) {
            // Update local cache
            profileCache.set(currentUser.pubkey, profileContent);
            localStorage.setItem(STORAGE_KEYS.profile, JSON.stringify(profileContent));

            // Update user avatar in header
            updateUserInterface();

            showToast('Profile updated successfully!', 'success');
            hideEditProfileModal();

            // Reload the profile page if we're on it
            if (currentView.startsWith('profile-')) {
                loadProfile(currentUser.pubkey);
            }
        } else {
            throw new Error('Failed to publish profile update');
        }
    } catch (error) {
        console.error('Failed to save profile:', error);
        showToast('Failed to save profile. Please try again.', 'error');
    } finally {
        if (saveBtn) {
            saveBtn.disabled = false;
            saveBtn.textContent = t('common.saveChanges');
        }
    }
}

// Logout function
async function handleLogout() {
    showConfirmModal(
        'Logout',
        'Are you sure you want to logout?',
        () => {
            // Close any NIP-46 connections
            if (nip46Connection) {
                // Send disconnect message
                nip46Connection = null;
            }

            clearStoredLogin();

            // Close dropdown
            document.getElementById('userDropdown').classList.remove('active');

            // Refresh current view
            handleRoute();
        },
        { confirmText: 'Logout' }
    );
}

// Helper functions
function getPublicKeyFromPrivate(privateKey) {
    // Convert hex to Uint8Array if needed
    if (typeof privateKey === 'string') {
        return window.NostrTools.getPublicKey(hexToBytes(privateKey));
    }
    return window.NostrTools.getPublicKey(privateKey);
}

function generateRandomId() {
    // Use crypto.getRandomValues for browser compatibility
    const bytes = new Uint8Array(32);
    crypto.getRandomValues(bytes);
    return bytesToHex(bytes);
}

function generateRandomHex(length) {
    const bytes = new Uint8Array(length / 2);
    crypto.getRandomValues(bytes);
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

// Sign event based on current auth method
async function signEventForBundle(event, privateKey) {
    // The browser bundle uses finalizeEvent which both calculates id and signs
    const signedEvent = window.NostrTools.finalizeEvent(event, privateKey);
    return signedEvent.sig;
}

async function encryptNip44(privateKey, publicKey, content) {
    const privKeyBytes = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;
    const pubKeyHex = typeof publicKey === 'string' ? publicKey : bytesToHex(publicKey);

    try {
        if (window.NostrTools.nip44.encrypt) {
            return await window.NostrTools.nip44.encrypt(
                privateKey,
                publicKey,
                content
            );
        }
    } catch (e) {
        // Silently fall back to NIP-04
    }

    try {
        const conversationKey = window.NostrTools.nip44.getConversationKey(
            privKeyBytes,
            pubKeyHex
        );

        if (window.NostrTools.nip44.v2 && window.NostrTools.nip44.v2.encrypt) {
            return window.NostrTools.nip44.v2.encrypt(
                content,
                conversationKey
            );
        }
    } catch (e) {
        // Silently fall back to NIP-04
    }

    throw new Error('Failed to encrypt with NIP-44');
}

// NIP-46 signing
async function signEventWithNip46(event) {
    if (!nip46Connection) {
        throw new Error('No NIP-46 connection');
    }

    const request = {
        id: generateRandomId(),
        method: 'sign_event',
        params: [JSON.stringify(event)]
    };

    const ws = await connectToRelay(nip46Connection.relay);

    const ephemeralPrivKeyHex = nip46Connection.ephemeralPrivKey;

    let encryptedContent;
    try {
        encryptedContent = await encryptNip44(
            ephemeralPrivKeyHex,
            nip46Connection.remotePubkey,
            JSON.stringify(request)
        );
    } catch (e) {
        encryptedContent = await window.NostrTools.nip04.encrypt(
            ephemeralPrivKeyHex,
            nip46Connection.remotePubkey,
            JSON.stringify(request)
        );
    }

    const requestEvent = {
        kind: 24133,
        pubkey: nip46Connection.ephemeralPubKey,
        content: encryptedContent,
        tags: [['p', nip46Connection.remotePubkey]],
        created_at: Math.floor(Date.now() / 1000)
    };

    const signedRequestEvent = window.NostrTools.finalizeEvent(requestEvent, hexToBytes(ephemeralPrivKeyHex));

    ws.send(JSON.stringify(['EVENT', signedRequestEvent]));

    const response = await waitForNip46Response(
        ws,
        request.id,
        ephemeralPrivKeyHex,
        nip46Connection.remotePubkey
    );

    if (response.error) {
        throw new Error(response.error);
    }

    return JSON.parse(response.result);
}

// Compute shared secret for NIP-04 encryption
async function computeSharedSecret(privateKey, publicKey) {
    // Convert keys to proper format if needed
    const privKeyBytes = typeof privateKey === 'string' ? hexToBytes(privateKey) : privateKey;
    const pubKeyBytes = typeof publicKey === 'string' ? hexToBytes(publicKey) : publicKey;

    // Use secp256k1 to compute shared secret
    const sharedPoint = window.NostrTools.secp256k1.getSharedSecret(privKeyBytes, '02' + bytesToHex(pubKeyBytes));
    return sharedPoint.slice(1); // Remove the prefix byte
}

// Encrypt message using NIP-04
async function encryptMessage(message, sharedSecret) {
    const iv = crypto.getRandomValues(new Uint8Array(16));
    const key = await crypto.subtle.importKey(
        'raw',
        sharedSecret.slice(0, 32),
        { name: 'AES-CBC' },
        false,
        ['encrypt']
    );

    const encoded = new TextEncoder().encode(message);
    const padded = addPKCS7Padding(encoded);

    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-CBC', iv },
        key,
        padded
    );

    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encrypted), iv.length);

    return bytesToBase64(combined);
}

// Decrypt message using NIP-04
async function decryptMessage(encryptedBase64, sharedSecret) {
    const combined = base64ToBytes(encryptedBase64);
    const iv = combined.slice(0, 16);
    const ciphertext = combined.slice(16);

    const key = await crypto.subtle.importKey(
        'raw',
        sharedSecret.slice(0, 32),
        { name: 'AES-CBC' },
        false,
        ['decrypt']
    );

    const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-CBC', iv },
        key,
        ciphertext
    );

    const decoded = removePKCS7Padding(new Uint8Array(decrypted));
    return new TextDecoder().decode(decoded);
}

// Helper functions for encryption
function hexToBytes(hex) {
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
    }
    return bytes;
}

function bytesToHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

function bytesToBase64(bytes) {
    return btoa(String.fromCharCode.apply(null, bytes));
}

function base64ToBytes(base64) {
    return new Uint8Array(atob(base64).split('').map(c => c.charCodeAt(0)));
}

function addPKCS7Padding(data) {
    const blockSize = 16;
    const padding = blockSize - (data.length % blockSize);
    const padded = new Uint8Array(data.length + padding);
    padded.set(data);
    padded.fill(padding, data.length);
    return padded;
}

function removePKCS7Padding(data) {
    const padding = data[data.length - 1];
    return data.slice(0, data.length - padding);
}

async function signEventWithConnection(event) {
    // Sign with local ephemeral key for NIP-46 connection
    const ephemeralKey = generateRandomHex(32);
    event.pubkey = window.NostrTools.getPublicKey(ephemeralKey);
    event.id = window.NostrTools.getEventHash(event);
    event.sig = window.NostrTools.signEvent(event, ephemeralKey);
    return event;
}

async function reconnectNip46(bunkerUrl, secretData) {
    try {
        const data = JSON.parse(secretData);
        const { ephemeralPrivKey, remotePubkey, relay } = data;

        // Convert hex private key back to Uint8Array if needed
        const privKeyBytes = typeof ephemeralPrivKey === 'string' ?
            hexToBytes(ephemeralPrivKey) : ephemeralPrivKey;
        const ephemeralPrivKeyHex = typeof ephemeralPrivKey === 'string' ?
            ephemeralPrivKey : bytesToHex(ephemeralPrivKey);

        const ephemeralPubKey = window.NostrTools.getPublicKey(privKeyBytes);

        // Reconnect and verify
        const ws = await connectToRelay(relay);

        // Subscribe to responses
        const subId = generateRandomId();
        const subscription = JSON.stringify([
            'REQ',
            subId,
            {
                kinds: [24133],
                '#p': [ephemeralPubKey],
                since: Math.floor(Date.now() / 1000) - 60
            }
        ]);
        ws.send(subscription);

        // Test connection with get_public_key
        const getPubkeyRequest = {
            id: generateRandomId(),
            method: 'get_public_key',
            params: []
        };

        let encryptedContent;
        try {
            encryptedContent = await encryptNip44(ephemeralPrivKeyHex, remotePubkey, JSON.stringify(getPubkeyRequest));
        } catch (e) {
            encryptedContent = await window.NostrTools.nip04.encrypt(
                ephemeralPrivKeyHex,
                remotePubkey,
                JSON.stringify(getPubkeyRequest)
            );
        }

        const requestEvent = {
            kind: 24133,
            pubkey: ephemeralPubKey,
            content: encryptedContent,
            tags: [['p', remotePubkey]],
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedRequestEvent = window.NostrTools.finalizeEvent(requestEvent, privKeyBytes);

        ws.send(JSON.stringify(['EVENT', signedRequestEvent]));

        const response = await waitForNip46Response(ws, getPubkeyRequest.id, ephemeralPrivKeyHex, remotePubkey);

        if (response.result) {
            currentUser = { pubkey: response.result, nip46: true };
            nip46Connection = {
                relay,
                remotePubkey,
                ephemeralPrivKey: ephemeralPrivKeyHex,
                ephemeralPubKey,
                secret: remotePubkey
            };
            await onUserLoggedIn();
        } else {
            throw new Error('Failed to reconnect');
        }
    } catch (error) {
        console.error('NIP-46 reconnection failed:', error);
        clearStoredLogin();
    }
}

// Ensure user is logged in
async function ensureLoggedIn() {
    if (currentUser) {
        return true;
    }

    showLoginModal();
    return false;
}

// Default settings for merging
const defaultSettings = {
    useWotRelays: false,
    usePremiumBlossom: false,
    customBlossomServers: [],
    saveToNostr: true,
    showNSFWWarnings: true,
    showCommunityWarnings: true,
    showFollowsReportWarnings: true,
    enabledFilterPacks: [],
    customKeywordFilter: [],
    theme: null, // null means use system preference
    lastNotificationView: 0, // Timestamp of last notification view
    notifications: {
        reactions: true,
        replies: true,
        zaps: true,
        chatMentions: true,
        newFollowers: true
    }
};

// Initialize settings after login
async function initializeSettings() {
    if (isInitializingSettings) return;
    isInitializingSettings = true;

    try {
        // Try to load from Nostr if user is logged in
        if (currentUser) {
            const nostrSettings = await loadSettingsFromNostr();
            if (nostrSettings) {
                // Deep merge with defaults to ensure all fields exist (especially nested notifications)
                userSettings = {
                    ...defaultSettings,
                    ...nostrSettings,
                    notifications: { ...defaultSettings.notifications, ...(nostrSettings.notifications || {}) }
                };
                applySettings();
                return;
            }
        }

        // Fall back to localStorage
        const savedSettings = localStorage.getItem('plebsSettings');
        if (savedSettings) {
            try {
                const parsed = JSON.parse(savedSettings);
                // Deep merge with defaults to ensure all fields exist (especially nested notifications)
                userSettings = {
                    ...defaultSettings,
                    ...parsed,
                    notifications: { ...defaultSettings.notifications, ...(parsed.notifications || {}) }
                };
                applySettings();
            } catch (e) {
                console.error('Failed to parse saved settings:', e);
            }
        }
    } finally {
        isInitializingSettings = false;
    }
}

// Load settings from Nostr
async function loadSettingsFromNostr() {
    if (!currentUser) return null;

    try {
        const filter = {
            kinds: [30078],
            authors: [currentUser.pubkey],
            '#d': ['plebs-settings'],
            limit: 1
        };

        let settings = null;
        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                try {
                    settings = JSON.parse(event.content);
                } catch (e) {
                    console.error('Failed to parse Nostr settings:', e);
                }
            }, resolve);
        });

        return settings;
    } catch (error) {
        console.error('Failed to load settings from Nostr:', error);
        return null;
    }
}

// Save settings to Nostr
async function saveSettingsToNostr() {
    if (!currentUser) return false;

    try {
        const settingsEvent = {
            kind: 30078,
            tags: [
                ['d', 'plebs-settings'],
                ['title', 'Plebs App Settings'],
                ['client', 'Plebs']
            ],
            content: JSON.stringify(userSettings),
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(settingsEvent);
        return await publishEvent(signedEvent);
    } catch (error) {
        console.error('Failed to save settings to Nostr:', error);
        return false;
    }
}

// Apply settings to the app
function applySettings() {
    const previousRelayUrls = [...RELAY_URLS];

    // Update relay URLs based on settings
    if (userSettings.useWotRelays) {
        RELAY_URLS.length = 0;
        RELAY_URLS.push(...WOT_RELAY_URLS);
    } else {
        RELAY_URLS.length = 0;
        RELAY_URLS.push(
            'wss://relay.damus.io',
            'wss://relay.nostr.band',
            'wss://nos.lol',
            'wss://relay.primal.net'
        );
    }

    // Only disconnect if relay URLs actually changed
    const relaysChanged = previousRelayUrls.length !== RELAY_URLS.length ||
        previousRelayUrls.some((url, index) => url !== RELAY_URLS[index]);

    if (relaysChanged) {
        // Close connections to ALL existing relays first
        Object.entries(relayConnections).forEach(([url, ws]) => {
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                ws.close();
            }
            delete relayConnections[url];
        });

        // Clear any existing subscription handlers to prevent memory leaks
        if (window.subscriptionHandlers) {
            window.subscriptionHandlers = {};
        }

        // Initialize connections to new relays
        initializeRelayConnections().then(() => {
            console.log('Relay connections updated after settings change');
        });
    }

    // Update Blossom servers based on settings
    BLOSSOM_SERVERS.length = 0;

    BLOSSOM_SERVERS.push(
        'https://blossom.primal.net',
        'https://blossom.band',
        'https://nostr.media'
    );

    if (userSettings.usePremiumBlossom) {
        BLOSSOM_SERVERS.unshift(PREMIUM_BLOSSOM_SERVER);
    }

    if (userSettings.customBlossomServers.length > 0) {
        BLOSSOM_SERVERS.push(...userSettings.customBlossomServers);
    }

    // Apply warning preferences
    if (userSettings.showNSFWWarnings) {
        localStorage.removeItem('allowNSFW');
        sessionNSFWAllowed = false;
    } else {
        localStorage.setItem('allowNSFW', 'true');
        sessionNSFWAllowed = true;
    }

    if (userSettings.showCommunityWarnings) {
        localStorage.removeItem('allowCommunityWarning');
    } else {
        localStorage.setItem('allowCommunityWarning', 'true');
    }

    // Apply filter packs
    if (userSettings.enabledFilterPacks && userSettings.enabledFilterPacks.length > 0) {
        enabledFilterPacks = new Set(userSettings.enabledFilterPacks);
        saveFilterPacks();
    }

    // Apply theme from settings if set
    if (userSettings.theme) {
        document.documentElement.setAttribute('data-theme', userSettings.theme);
        localStorage.setItem('theme', userSettings.theme);
    }
}

// Show settings modal
function showSettingsModal() {
    if (!currentUser) {
        ensureLoggedIn().then(loggedIn => {
            if (!loggedIn) {
                return;
            }
            // If user logs in successfully, show the settings modal
            showSettingsModalContent();
        });
        return;
    }

    showSettingsModalContent();
}

// Helper function to show settings modal content
function showSettingsModalContent() {
    document.getElementById('useWotRelays').checked = userSettings.useWotRelays;
    document.getElementById('usePremiumBlossom').checked = userSettings.usePremiumBlossom;
    document.getElementById('customBlossomServers').value = userSettings.customBlossomServers.join(', ');
    document.getElementById('saveToNostr').checked = userSettings.saveToNostr;

    // Set dark mode toggle state
    const currentTheme = document.documentElement.getAttribute('data-theme');
    document.getElementById('darkModeToggle').checked = currentTheme === 'dark';

    // Set language selector value
    const langSelect = document.getElementById('languageSelect');
    if (langSelect) {
        langSelect.value = currentLanguage;
    }

    // Load warning preferences from userSettings
    document.getElementById('showNSFWWarnings').checked = userSettings.showNSFWWarnings;
    document.getElementById('showCommunityWarnings').checked = userSettings.showCommunityWarnings;
    document.getElementById('showFollowsReportWarnings').checked = userSettings.showFollowsReportWarnings;

    // Load custom keyword filter
    document.getElementById('customKeywordFilter').value = userSettings.customKeywordFilter.join(', ');

    // Sync enabledFilterPacks Set with userSettings
    if (userSettings.enabledFilterPacks && userSettings.enabledFilterPacks.length > 0) {
        enabledFilterPacks = new Set(userSettings.enabledFilterPacks);
    }

    // Populate filter packs list
    populateFilterPacksList();

    // Load muted users list
    loadMutedUsersList('settingsMutedUsersList', 'hideSettingsModal');

    document.getElementById('settingsModal').classList.add('active');
}

// Populate filter packs list in settings
function populateFilterPacksList() {
    const container = document.getElementById('filterPacksList');
    if (!container) return;

    let html = '';
    for (const [packId, pack] of Object.entries(FILTER_PACKS)) {
        const isEnabled = enabledFilterPacks.has(packId);
        html += `
            <div class="filter-pack-item">
                <div class="filter-pack-header">
                    <div class="checkbox-group">
                        <input type="checkbox" id="filterPack_${packId}"
                               ${isEnabled ? 'checked' : ''}
                               onchange="toggleFilterPack('${packId}')">
                        <label for="filterPack_${packId}">
                            <span class="filter-pack-icon">${pack.icon}</span>
                            ${pack.name}
                        </label>
                    </div>
                </div>
                <p class="filter-pack-description">${pack.description}</p>
            </div>
        `;
    }
    container.innerHTML = html;
}

// Hide settings modal
function hideSettingsModal() {
    document.getElementById('settingsModal').classList.remove('active');
}

// Toggle WoT relays
function toggleWotRelays() {
    const checkbox = document.getElementById('useWotRelays');
    userSettings.useWotRelays = checkbox.checked;
}

// Toggle premium Blossom
function togglePremiumBlossom() {
    const checkbox = document.getElementById('usePremiumBlossom');
    userSettings.usePremiumBlossom = checkbox.checked;
}

// Save settings
async function saveSettings() {
    const customServersInput = document.getElementById('customBlossomServers').value;
    userSettings.customBlossomServers = customServersInput
        .split(',')
        .map(url => url.trim())
        .filter(url => url.startsWith('http'));

    userSettings.saveToNostr = document.getElementById('saveToNostr').checked;

    // Save warning preferences
    userSettings.showNSFWWarnings = document.getElementById('showNSFWWarnings').checked;
    userSettings.showCommunityWarnings = document.getElementById('showCommunityWarnings').checked;
    userSettings.showFollowsReportWarnings = document.getElementById('showFollowsReportWarnings').checked;

    // Save custom keyword filter
    const customKeywordsInput = document.getElementById('customKeywordFilter').value;
    userSettings.customKeywordFilter = customKeywordsInput
        .split(',')
        .map(kw => kw.trim().toLowerCase())
        .filter(kw => kw.length > 0);

    // Save enabled filter packs
    userSettings.enabledFilterPacks = [...enabledFilterPacks];

    // Update legacy localStorage for backwards compatibility
    if (userSettings.showNSFWWarnings) {
        localStorage.removeItem('allowNSFW');
        sessionNSFWAllowed = false;
    } else {
        localStorage.setItem('allowNSFW', 'true');
        sessionNSFWAllowed = true;
    }

    if (userSettings.showCommunityWarnings) {
        localStorage.removeItem('allowCommunityWarning');
    } else {
        localStorage.setItem('allowCommunityWarning', 'true');
    }

    localStorage.setItem('plebsSettings', JSON.stringify(userSettings));

    if (userSettings.saveToNostr && currentUser) {
        const saved = await saveSettingsToNostr();
        if (saved) {
            showToast('Settings saved successfully!', 'success');
        } else {
            showToast('Settings saved locally. Could not save to Nostr.', 'warning');
        }
    } else {
        showToast('Settings saved locally!', 'success');
    }

    applySettings();
    hideSettingsModal();
    handleRoute();
}

// Reset settings to defaults
function resetSettings() {
    showConfirmModal(
        'Reset Settings',
        'Are you sure you want to reset all settings to defaults?',
        () => {
            userSettings = {
                useWotRelays: false,
                usePremiumBlossom: false,
                customBlossomServers: [],
                saveToNostr: true,
                showNSFWWarnings: true,
                showCommunityWarnings: true,
                showFollowsReportWarnings: true,
                enabledFilterPacks: [],
                customKeywordFilter: []
            };

            // Clear filter packs
            enabledFilterPacks.clear();
            localStorage.removeItem('plebsFilterPacks');

            localStorage.removeItem('plebsSettings');

            // Reset warning preferences to show warnings (remove allow flags)
            localStorage.removeItem('allowNSFW');
            localStorage.removeItem('allowCommunityWarning');
            sessionNSFWAllowed = false;

            applySettings();
            showSettingsModal();

            showToast('Settings reset to defaults!', 'success');
        },
        { confirmText: 'Reset', danger: true }
    );
}

// Sidebar management
function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.querySelector('.sidebar-overlay');

    sidebar.classList.toggle('expanded');
    overlay.classList.toggle('active');
}

function closeSidebarOnNavigate() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.querySelector('.sidebar-overlay');
    if (sidebar.classList.contains('expanded')) {
        sidebar.classList.remove('expanded');
        overlay.classList.remove('active');
    }
}

// Close sidebar when clicking on any link inside it (using event delegation)
document.getElementById('sidebar').addEventListener('click', (e) => {
    const link = e.target.closest('a');
    if (link) {
        closeSidebarOnNavigate();
    }
});

// Swipe gesture support for opening/closing sidebar
(function initSidebarSwipe() {
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const swipeThreshold = 50;
    const edgeThreshold = 30; // How close to edge to start swipe

    document.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    }, { passive: true });

    document.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        handleSwipe();
    }, { passive: true });

    function handleSwipe() {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const sidebar = document.getElementById('sidebar');
        const overlay = document.querySelector('.sidebar-overlay');

        // Only handle horizontal swipes (ignore if vertical movement is greater)
        if (Math.abs(deltaY) > Math.abs(deltaX)) {
            return;
        }

        // Swipe right from left edge to open sidebar
        if (deltaX > swipeThreshold && touchStartX < edgeThreshold) {
            if (!sidebar.classList.contains('expanded')) {
                sidebar.classList.add('expanded');
                overlay.classList.add('active');
            }
        }

        // Swipe left to close sidebar (when sidebar is open)
        if (deltaX < -swipeThreshold && sidebar.classList.contains('expanded')) {
            sidebar.classList.remove('expanded');
            overlay.classList.remove('active');
        }
    }
})();

// URL Routing with hash
function navigateTo(path) {
    window.location.hash = path;
}

// Routes based on page type
async function handleRoute() {
    hideNotificationsModal();

    // Clean up live chat subscriptions when navigating away
    if (currentView === 'live') {
        cleanupLiveChatSubscriptions();
    }

    const hash = window.location.hash.slice(1) || '/';
    const pathParts = hash.split('/').filter(p => p);

    // Update meta tags with structured data
    const updateMetaTags = (title, description, image = null, type = 'website') => {
        const ogImage = image || './images/plebs-og.png';

        document.title = title;

        const setMetaTag = (selector, attribute, value) => {
            let tag = document.querySelector(selector);
            if (!tag && selector.includes('property')) {
                tag = document.createElement('meta');
                tag.setAttribute('property', selector.match(/property="([^"]+)"/)[1]);
                document.head.appendChild(tag);
            } else if (!tag && selector.includes('name')) {
                tag = document.createElement('meta');
                tag.setAttribute('name', selector.match(/name="([^"]+)"/)[1]);
                document.head.appendChild(tag);
            }
            if (tag) tag.setAttribute('content', value);
        };

        setMetaTag('meta[name="description"]', 'content', description);
        setMetaTag('meta[property="og:title"]', 'content', title);
        setMetaTag('meta[property="og:description"]', 'content', description);
        setMetaTag('meta[property="og:type"]', 'content', type);
        setMetaTag('meta[property="og:site_name"]', 'content', 'Plebs');
        setMetaTag('meta[property="og:image"]', 'content', ogImage);

        // Include the full URL with hash
        const fullUrl = window.location.href;
        setMetaTag('meta[property="og:url"]', 'content', fullUrl);

        setMetaTag('meta[name="twitter:card"]', 'content', image ? 'summary_large_image' : 'summary');
        setMetaTag('meta[name="twitter:title"]', 'content', title);
        setMetaTag('meta[name="twitter:description"]', 'content', description);
        setMetaTag('meta[name="twitter:image"]', 'content', ogImage);

        let canonical = document.querySelector('link[rel="canonical"]');
        if (!canonical) {
            canonical = document.createElement('link');
            canonical.setAttribute('rel', 'canonical');
            document.head.appendChild(canonical);
        }
        canonical.setAttribute('href', fullUrl);
    };

    // Add JSON-LD structured data
    const setStructuredData = (data) => {
        let script = document.querySelector('script[type="application/ld+json"]');
        if (!script) {
            script = document.createElement('script');
            script.type = 'application/ld+json';
            document.head.appendChild(script);
        }
        script.textContent = JSON.stringify(data);
    };

    updateMetaTags(
        'Plebs - Decentralized Video Platform',
        'Plebs is a censorship-resistant, decentralized video platform powered by the Nostr social protocol'
    );

    setStructuredData({
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "Plebs",
        "description": "Censorship-resistant, decentralized video platform powered by Nostr",
        "url": window.location.href
    });

    if (pathParts.length === 0) {
        loadHomeFeed();
    } else if (pathParts[0] === 'video' && pathParts[1]) {
        const eventId = pathParts[1];

        document.getElementById('mainContent').innerHTML = '<div class="spinner"></div>';

        // Fetch video metadata for SEO
        try {
            const event = await fetchVideoEvent(eventId);
            if (event) {
                const videoData = parseVideoEvent(event);
                const profile = await fetchUserProfile(event.pubkey);

                if (videoData) {
                    const authorName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;

                    updateMetaTags(
                        `${videoData.title} - Plebs`,
                        videoData.description ? videoData.description.slice(0, 155) : `Watch "${videoData.title}" by ${authorName} on Plebs`,
                        videoData.thumbnail,
                        'video.other'
                    );

                    setStructuredData({
                        "@context": "https://schema.org",
                        "@type": "VideoObject",
                        "name": videoData.title,
                        "description": videoData.description || `Watch "${videoData.title}" on Plebs`,
                        "thumbnailUrl": videoData.thumbnail || undefined,
                        "uploadDate": new Date(event.created_at * 1000).toISOString(),
                        "duration": videoData.duration ? `PT${Math.floor(videoData.duration / 60)}M${videoData.duration % 60}S` : undefined,
                        "author": {
                            "@type": "Person",
                            "name": authorName,
                            "url": `${window.location.origin}${window.location.pathname}#/profile/${event.pubkey}`
                        },
                        "url": window.location.href  // Use full URL including hash
                    });
                }
            }
        } catch (error) {
            console.error('Failed to fetch video metadata:', error);
        }

        playVideo(eventId);
    } else if (pathParts[0] === 'profile' && pathParts[1]) {
        let pubkey = pathParts[1];

        // Decode npub to hex pubkey if needed
        if (pubkey.startsWith('npub1')) {
            try {
                const decoded = window.NostrTools.nip19.decode(pubkey);
                if (decoded.type === 'npub') {
                    pubkey = decoded.data;
                }
            } catch (e) {
                console.error('Failed to decode npub:', e);
            }
        }

        try {
            const profile = await fetchUserProfile(pubkey);
            if (profile) {
                const displayName = profile?.name || profile?.display_name || `User ${pubkey.slice(0, 8)}`;
                const about = profile?.about || '';
                const avatarUrl = profile?.picture || profile?.avatar || '';

                updateMetaTags(
                    `${displayName} - Plebs`,
                    about ? about.slice(0, 155) : `Watch videos from ${displayName} on Plebs`,
                    avatarUrl,
                    'profile'
                );

                setStructuredData({
                    "@context": "https://schema.org",
                    "@type": "Person",
                    "name": displayName,
                    "description": about,
                    "image": avatarUrl || undefined,
                    "url": window.location.href  // Use full URL including hash
                });
            }
        } catch (error) {
            console.error('Failed to fetch profile metadata:', error);
        }

        loadProfile(pubkey);
    } else if (pathParts[0] === 'tag' && pathParts[1]) {
        const originalTag = pathParts[1];
        const normalizedTag = originalTag.toLowerCase();

        if (originalTag !== normalizedTag) {
            navigateTo(`/tag/${normalizedTag}`);
            return;
        }

        updateMetaTags(
            `${normalizedTag.charAt(0).toUpperCase() + normalizedTag.slice(1)} Videos - Plebs`,
            `Watch ${normalizedTag} videos on Plebs, the censorship-resistant decentralized video platform`
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": `${normalizedTag.charAt(0).toUpperCase() + normalizedTag.slice(1)} Videos`,
            "description": `Watch ${normalizedTag} videos on Plebs`,
            "url": window.location.href
        });

        loadTag(normalizedTag);
    } else if (pathParts[0] === 'search' && pathParts[1]) {
        const query = decodeURIComponent(pathParts[1]);
        updateMetaTags(
            `Search: ${query} - Plebs`,
            `Search results for "${query}" on Plebs`
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "SearchResultsPage",
            "name": `Search: ${query}`,
            "description": `Search results for "${query}" on Plebs`,
            "url": window.location.href
        });

        document.getElementById('searchInput').value = query;
        performSearch(pathParts[1]);
    } else if (pathParts[0] === 'following') {
        updateMetaTags(
            'Following - Plebs',
            'Watch videos from creators you follow on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": "Following",
            "description": "Watch videos from creators you follow on Plebs",
            "url": window.location.href
        });

        loadFollowing();
    } else if (pathParts[0] === 'my-videos') {
        updateMetaTags(
            'My Videos - Plebs',
            'Manage your videos on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": "My Videos",
            "description": "Manage your videos on Plebs",
            "url": window.location.href
        });

        loadMyVideos();
    } else if (pathParts[0] === 'analytics') {
        updateMetaTags(
            'Analytics - Plebs',
            'View your channel analytics and video performance on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "Analytics",
            "description": "View your channel analytics and video performance on Plebs",
            "url": window.location.href
        });

        loadAnalytics();
    } else if (pathParts[0] === 'liked') {
        updateMetaTags(
            'Liked Videos - Plebs',
            'Watch your liked videos on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": "Liked Videos",
            "description": "Watch your liked videos on Plebs",
            "url": window.location.href
        });

        loadLikedVideos();
    } else if (pathParts[0] === 'history') {
        updateMetaTags(
            'Watched History - Plebs',
            'View your recently watched videos on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": "Watched History",
            "description": "View your recently watched videos on Plebs",
            "url": window.location.href
        });

        loadWatchHistory();
    } else if (pathParts[0] === 'about') {
        updateMetaTags(
            'About - Plebs',
            'Learn about Plebs, a censorship-resistant decentralized video platform powered by Nostr'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "AboutPage",
            "name": "About Plebs",
            "description": "Learn about Plebs, a censorship-resistant decentralized video platform powered by Nostr",
            "url": window.location.href
        });

        loadAboutPage();
    } else if (pathParts[0] === 'contact') {
        updateMetaTags(
            'Contact - Plebs',
            'Get in touch with the Plebs team'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "ContactPage",
            "name": "Contact Plebs",
            "description": "Get in touch with the Plebs team",
            "url": window.location.href
        });

        loadContactPage();
    } else if (pathParts[0] === 'terms') {
        updateMetaTags(
            'Terms of Service - Plebs',
            'Terms of Service for using the Plebs platform'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "Terms of Service",
            "description": "Terms of Service for using the Plebs platform",
            "url": window.location.href
        });

        loadTermsPage();
    } else if (pathParts[0] === 'privacy') {
        updateMetaTags(
            'Privacy Policy - Plebs',
            'Privacy Policy for the Plebs platform'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "Privacy Policy",
            "description": "Privacy Policy for the Plebs platform",
            "url": window.location.href
        });

        loadPrivacyPage();
    } else if (pathParts[0] === 'faq') {
        updateMetaTags(
            'FAQ - Plebs',
            'Frequently asked questions about Plebs, Nostr, and decentralized video'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "FAQPage",
            "name": "Frequently Asked Questions",
            "description": "Frequently asked questions about Plebs, Nostr, and decentralized video",
            "url": window.location.href
        });

        loadFaqPage();
    } else if (pathParts[0] === 'dmca') {
        updateMetaTags(
            'DMCA & Content Policy - Plebs',
            'DMCA and content policy information for Plebs decentralized video platform'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "DMCA & Content Policy",
            "description": "DMCA and content policy information for Plebs decentralized video platform",
            "url": window.location.href
        });

        loadDmcaPage();
    } else if (pathParts[0] === 'admin') {
        updateMetaTags(
            'Admin Dashboard - Plebs',
            'Admin dashboard for Plebs platform management'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "Admin Dashboard",
            "description": "Admin dashboard for Plebs platform management",
            "url": window.location.href
        });

        loadAdminPage();
    } else if (pathParts[0] === 'live' && pathParts[1]) {
        // Individual live stream page
        const eventId = pathParts[1];

        updateMetaTags(
            'Live Stream - Plebs',
            'Watch this live stream on Plebs'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "BroadcastEvent",
            "name": "Live Stream",
            "description": "Watch this live stream on Plebs",
            "url": window.location.href
        });

        playLiveStream(eventId);
    } else if (pathParts[0] === 'live') {
        // Live feed page
        updateMetaTags(
            'Live Streams - Plebs',
            'Watch live streams on Plebs, the decentralized video platform'
        );

        setStructuredData({
            "@context": "https://schema.org",
            "@type": "CollectionPage",
            "name": "Live Streams",
            "description": "Watch live streams on Plebs",
            "url": window.location.href
        });

        loadLiveFeed();
    } else {
        loadHomeFeed();
    }

    updateSidebarActive();
}

// Show notifications modal and fetch notifications
async function loadNotifications() {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            return;
        }
    }

    const modal = document.getElementById("notificationsModal");
    const list = document.getElementById("notificationsList");
    list.innerHTML = '<div class="spinner"></div>';
    modal.classList.add("active");

    // Mark notifications as viewed when modal is opened
    markNotificationsViewed();

    try {
        const userVideosFilter = {
            kinds: ALL_VIDEO_KINDS,
            authors: [currentUser.pubkey],
            '#t': ['pv69420']
        };

        const userVideos = await fetchEvents(userVideosFilter);
        const videoIds = userVideos.map(e => e.id);

        if (videoIds.length === 0) {
            list.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.noVideosToMonitor')}</p>`;
            return;
        }

        // Fetch reactions
        const reactions = [];
        const reactionFilter = {
            kinds: [7],
            '#e': videoIds
        };

        const reactionAuthors = new Set();

        await new Promise((resolve) => {
            requestEventsStream(reactionFilter, (reactionEvent) => {
                const videoId = reactionEvent.tags.find(t => t[0] === 'e')?.[1];
                if (
                    videoId &&
                    videoIds.includes(videoId) &&
                    reactionEvent.pubkey !== currentUser.pubkey
                ) {
                    reactions.push(reactionEvent);
                    // Collect reaction authors for validation
                    reactionAuthors.add(reactionEvent.pubkey);
                }
            }, resolve);
        });

        // Validate reaction authors
        const validatedAuthors = new Set();

        if (reactionAuthors.size > 0) {
            const profileFilter = {
                kinds: [0],
                authors: Array.from(reactionAuthors)
            };

            await new Promise((resolve) => {
                requestEventsStream(profileFilter, async (profileEvent) => {
                    try {
                        const profile = JSON.parse(profileEvent.content);
                        profileCache.set(profileEvent.pubkey, profile);

                        if (profile.nip05) {
                            const isValid = await validateNip05(profile.nip05, profileEvent.pubkey);
                            if (isValid) {
                                validatedAuthors.add(profileEvent.pubkey);
                            }
                        }
                    } catch (e) {
                        console.error('Failed to parse profile:', e);
                    }
                }, resolve);
            });
        }

        // Filter reactions to only include validated authors
        const validReactions = reactions.filter(r => validatedAuthors.has(r.pubkey));

        // Fetch replies
        const replies = [];
        const repliesFilter = {
            kinds: [1],
            '#e': videoIds
        };

        await new Promise((resolve) => {
            requestEventsStream(repliesFilter, (event) => {
                const videoId = event.tags.find(t => t[0] === 'e')?.[1];
                if (
                    videoId &&
                    videoIds.includes(videoId) &&
                    event.pubkey !== currentUser.pubkey
                ) {
                    replies.push(event);
                }
            }, resolve);
        });

        // Fetch zaps
        const zaps = [];
        const zapsFilter = {
            kinds: [9735], // Zap receipts
            '#e': videoIds
        };

        await new Promise((resolve) => {
            requestEventsStream(zapsFilter, (zapEvent) => {
                const videoId = zapEvent.tags.find(t => t[0] === 'e')?.[1];
                if (videoId && videoIds.includes(videoId)) {
                    // Extract zapper pubkey from the 'P' tag (uppercase P for zap receipts)
                    const zapperTag = zapEvent.tags.find(t => t[0] === 'P');
                    if (zapperTag && zapperTag[1] !== currentUser.pubkey) {
                        zaps.push(zapEvent);
                    }
                }
            }, resolve);
        });

        // Fetch live chat mentions (kind 1311 messages that mention the current user)
        const chatMentions = [];
        const myProfile = profileCache.get(currentUser.pubkey);
        const myName = myProfile?.name || myProfile?.display_name || '';

        // First, fetch user's live streams to build 'a' tags
        const userStreamsFilter = {
            kinds: [NIP53_LIVE_EVENT_KIND],
            authors: [currentUser.pubkey],
            '#t': ['pv69420']
        };
        const userStreams = await fetchEvents(userStreamsFilter);

        // Build 'a' tags for user's streams and map them to event IDs
        const streamATags = [];
        const aTagToEventId = new Map();
        for (const stream of userStreams) {
            const liveData = parseLiveEvent(stream);
            if (liveData && liveData.dTag) {
                const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${stream.pubkey}:${liveData.dTag}`;
                streamATags.push(aTagValue);
                aTagToEventId.set(aTagValue, stream.id);
                allEvents.set(stream.id, stream);
            }
        }

        if (myName && streamATags.length > 0) {
            const chatMentionFilter = {
                kinds: [NIP53_LIVE_CHAT_KIND],
                '#a': streamATags,
                limit: 200,
                since: Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60) // Last 30 days
            };

            await new Promise((resolve) => {
                requestEventsStream(chatMentionFilter, (chatEvent) => {
                    // Check if the message mentions the current user
                    if (chatEvent.pubkey !== currentUser.pubkey) {
                        const mentionPattern = new RegExp(`@${myName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                        if (mentionPattern.test(chatEvent.content)) {
                            // Attach the stream event ID for easy lookup later
                            const aTag = chatEvent.tags?.find(t => t[0] === 'a')?.[1];
                            if (aTag) {
                                chatEvent._streamEventId = aTagToEventId.get(aTag);
                            }
                            chatMentions.push(chatEvent);
                        }
                    }
                }, resolve);
            });
        }

        // Combine and sort all notifications (using filtered reactions)
        const notifications = [...validReactions, ...replies, ...zaps, ...chatMentions].sort((a, b) => b.created_at - a.created_at);

        if (notifications.length === 0) {
            list.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.noRecentActivity')}</p>`;
            return;
        }

        // Fetch profiles for all notification authors (already have profiles for reactions)
        const uniquePubkeys = [...new Set([
            ...notifications.filter(n => n.kind === 1).map(n => n.pubkey), // replies
            ...notifications.filter(n => n.kind === NIP53_LIVE_CHAT_KIND).map(n => n.pubkey), // chat mentions
            ...notifications.filter(n => n.kind === 9735).map(n => {
                const zapperTag = n.tags.find(t => t[0] === 'P');
                return zapperTag ? zapperTag[1] : null;
            }).filter(Boolean)
        ])];

        const profilePromises = uniquePubkeys.map(pubkey => fetchUserProfile(pubkey));
        await Promise.all(profilePromises);

        list.innerHTML = '';

        // Get notification settings
        const notifSettings = userSettings.notifications || {};

        notifications.forEach(event => {
            const isReaction = event.kind === 7;
            const isReply = event.kind === 1;
            const isZap = event.kind === 9735;
            const isChatMention = event.kind === NIP53_LIVE_CHAT_KIND;

            // Skip based on notification settings
            if (isReaction && notifSettings.reactions === false) return;
            if (isReply && notifSettings.replies === false) return;
            if (isZap && notifSettings.zaps === false) return;
            if (isChatMention && notifSettings.chatMentions === false) return;

            // Get the pubkey of the person who triggered the notification
            let notificationPubkey;
            if (isZap) {
                const zapperTag = event.tags.find(t => t[0] === 'P');
                notificationPubkey = zapperTag ? zapperTag[1] : '';
            } else {
                notificationPubkey = event.pubkey;
            }

            // Skip notifications from muted users
            if (isUserMuted(notificationPubkey)) return;

            // For chat mentions, get the stream info from the attached event ID
            let videoId, videoTitle, streamEventId;
            if (isChatMention) {
                // Use the stream event ID we attached during fetch
                streamEventId = event._streamEventId;
                // Try to get the stream title
                const streamEvent = streamEventId ? allEvents.get(streamEventId) : null;
                if (streamEvent) {
                    const liveData = parseLiveEvent(streamEvent);
                    videoTitle = liveData?.title || 'Live Stream';
                } else {
                    videoTitle = 'Live Stream';
                }
            } else {
                const originalVideoId = event.tags.find(t => t[0] === 'e')?.[1];
                const video = userVideos.find(v => v.id === originalVideoId);
                const parsedVideo = video ? parseVideoEvent(video) : null;
                videoTitle = parsedVideo?.title || 'Unknown Video';

                // For legacy kinds (1, 21, 22), find the NIP-71 addressable counterpart
                videoId = originalVideoId;
                if (video && (video.kind === 1 || video.kind === NIP71_VIDEO_KIND_LEGACY || video.kind === NIP71_SHORT_KIND_LEGACY)) {
                    const dTag = video.tags?.find(t => t[0] === 'd')?.[1] ||
                                 video.tags?.find(t => t[0] === 'nip71-d')?.[1];
                    if (dTag) {
                        // Find the NIP-71 addressable counterpart with the same d-tag
                        const nip71Video = userVideos.find(v =>
                            (v.kind === NIP71_VIDEO_KIND || v.kind === NIP71_SHORT_KIND) &&
                            v.tags?.find(t => t[0] === 'd')?.[1] === dTag
                        );
                        if (nip71Video) {
                            videoId = nip71Video.id;
                        }
                    }
                }
            }

            const profile = profileCache.get(notificationPubkey) || {};
            const displayName = profile.name || profile.display_name || `User ${notificationPubkey.slice(0, 8)}`;
            const avatarUrl = profile.picture || profile.avatar || '';
            const nip05 = profile.nip05 || '';

            let content;
            if (isZap) {
                // Extract amount from bolt11 tag
                const bolt11Tag = event.tags.find(t => t[0] === 'bolt11');
                const amount = bolt11Tag ? extractAmountFromBolt11(bolt11Tag[1]) : 0;
                content = `Zapped: ${formatSats(amount)} sats ⚡`;
            } else if (isChatMention) {
                content = `Mentioned you: "${event.content.slice(0, 40)}${event.content.length > 40 ? '...' : ''}"`;
            } else {
                content = isReaction
                    ? `Reacted: ${event.content}`
                    : `Replied: "${event.content.slice(0, 40)}${event.content.length > 40 ? '...' : ''}"`;
            }

            const timestamp = formatTimestamp(event.created_at);

            // Determine the link based on notification type
            const linkHref = isChatMention && streamEventId
                ? `#/live/${streamEventId}`
                : `#/video/${videoId}`;

            const item = document.createElement('div');
            item.className = 'notification-item';
            item.innerHTML = `
                <div class="notification-content">
                    <div class="notification-author">
                        ${avatarUrl ? `
                            <div class="notification-avatar">
                                <img src="${avatarUrl}" alt="${displayName}">
                            </div>
                        ` : ''}
                        <div>
                            <div style="font-weight: 500;">${displayName}</div>
                            ${nip05 ? `<div style="font-size: 0.75rem; color: var(--text-secondary);">${nip05}</div>` : ''}
                            <div style="font-size: 0.875rem; color: var(--text-secondary);">${timestamp}</div>
                        </div>
                    </div>
                    <div style="margin-top: 0.25rem; ${isZap ? 'color: #f7931a; font-weight: 500;' : ''}">${content}</div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">on "${videoTitle || 'Live Stream'}"</div>
                </div>
                <a href="${linkHref}" onclick="hideNotificationsModal();" class="notification-link">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                    </svg>
                </a>
            `;
            list.appendChild(item);
        });

    } catch (error) {
        console.error("Failed to load notifications:", error);
        list.innerHTML = `<div class="error-message">${t('empty.failedLoadNotifications')}</div>`;
    }
}

// Fetch events via stream
function fetchEvents(filter) {
    return new Promise((resolve, reject) => {
        const results = [];
        requestEventsStream(filter, (event) => {
            results.push(event);
        }, () => resolve(results));
    });
}

// Close modal
function hideNotificationsModal() {
    document.getElementById("notificationsModal").classList.remove("active");
    // Reset to notifications view when closing
    const settingsPanel = document.getElementById('notificationSettingsPanel');
    const notificationsList = document.getElementById('notificationsList');
    const settingsBtn = document.querySelector('.notification-settings-btn');
    const title = document.getElementById('notificationsModalTitle');
    if (settingsPanel) settingsPanel.style.display = 'none';
    if (notificationsList) notificationsList.style.display = 'flex';
    if (settingsBtn) settingsBtn.classList.remove('active');
    if (title) title.textContent = t('header.notifications');
}

// Toggle notification settings panel
function toggleNotificationSettings() {
    const settingsPanel = document.getElementById('notificationSettingsPanel');
    const notificationsList = document.getElementById('notificationsList');
    const settingsBtn = document.querySelector('.notification-settings-btn');
    const title = document.getElementById('notificationsModalTitle');

    const showingSettings = settingsPanel.style.display === 'none';

    if (showingSettings) {
        // Show settings
        settingsPanel.style.display = 'block';
        notificationsList.style.display = 'none';
        settingsBtn.classList.add('active');
        title.textContent = t('settings.notificationSettings') || 'Notification Settings';
        // Sync checkboxes with current settings
        syncNotificationSettingsUI();
    } else {
        // Show notifications
        settingsPanel.style.display = 'none';
        notificationsList.style.display = 'flex';
        settingsBtn.classList.remove('active');
        title.textContent = t('header.notifications');
    }
}

// Sync notification settings UI with current userSettings
function syncNotificationSettingsUI() {
    const settings = userSettings.notifications || {};
    document.getElementById('notifReactions').checked = settings.reactions !== false;
    document.getElementById('notifReplies').checked = settings.replies !== false;
    document.getElementById('notifZaps').checked = settings.zaps !== false;
    document.getElementById('notifChatMentions').checked = settings.chatMentions !== false;
    document.getElementById('notifNewFollowers').checked = settings.newFollowers !== false;
}

// Update a notification setting
async function updateNotificationSetting(setting, enabled) {
    // Ensure notifications object exists
    if (!userSettings.notifications) {
        userSettings.notifications = {
            reactions: true,
            replies: true,
            zaps: true,
            chatMentions: true,
            newFollowers: true
        };
    }

    userSettings.notifications[setting] = enabled;

    // Save to localStorage immediately
    localStorage.setItem('plebs_settings', JSON.stringify(userSettings));

    // Save to Nostr in background
    if (currentUser) {
        saveSettingsToNostr().catch(err => console.error('Failed to sync notification settings to Nostr:', err));
    }
}

// Check for new notifications in background and update badge
async function checkNotificationsInBackground() {
    if (!currentUser) return;

    try {
        const userVideosFilter = {
            kinds: ALL_VIDEO_KINDS,
            authors: [currentUser.pubkey],
            '#t': ['pv69420']
        };

        const userVideos = await fetchEvents(userVideosFilter);
        const videoIds = userVideos.map(e => e.id);

        if (videoIds.length === 0) {
            updateNotificationBadge(0);
            return;
        }

        // Get last viewed time from userSettings (synced via Nostr) or fall back to localStorage
        const lastViewedTime = userSettings?.lastNotificationView || parseInt(localStorage.getItem(STORAGE_KEYS.lastNotificationView) || '0', 10);

        // Get notification settings
        const notifSettings = userSettings.notifications || {};

        // Fetch notification types based on settings
        const fetchPromises = [];
        if (notifSettings.reactions !== false) {
            fetchPromises.push(fetchNotificationEvents({ kinds: [7], '#e': videoIds }, videoIds));
        }
        if (notifSettings.replies !== false) {
            fetchPromises.push(fetchNotificationEvents({ kinds: [1], '#e': videoIds }, videoIds));
        }
        if (notifSettings.zaps !== false) {
            fetchPromises.push(fetchNotificationEvents({ kinds: [9735], '#e': videoIds }, videoIds, true));
        }

        const results = await Promise.all(fetchPromises);

        // Count notifications newer than last viewed time
        const allNotifications = results.flat();
        const unreadCount = allNotifications.filter(n => n.created_at > lastViewedTime).length;

        updateNotificationBadge(unreadCount);
    } catch (error) {
        console.error('Failed to check notifications in background:', error);
    }
}

// Helper to fetch notification events
async function fetchNotificationEvents(filter, videoIds, isZap = false) {
    const events = [];
    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            const videoId = event.tags.find(t => t[0] === 'e')?.[1];
            if (videoId && videoIds.includes(videoId)) {
                if (isZap) {
                    const zapperTag = event.tags.find(t => t[0] === 'P');
                    if (zapperTag && zapperTag[1] !== currentUser.pubkey) {
                        events.push(event);
                    }
                } else if (event.pubkey !== currentUser.pubkey) {
                    events.push(event);
                }
            }
        }, resolve);
    });
    return events;
}

// Update notification badge
function updateNotificationBadge(count) {
    const badge = document.getElementById('notificationBadge');
    if (!badge) return;

    if (count > 0) {
        badge.textContent = count > 99 ? '99+' : count.toString();
        badge.style.display = 'flex';
    } else {
        badge.style.display = 'none';
    }
}

// Mark notifications as viewed
function markNotificationsViewed() {
    const timestamp = Math.floor(Date.now() / 1000);
    localStorage.setItem(STORAGE_KEYS.lastNotificationView, timestamp.toString());
    updateNotificationBadge(0);

    // Sync to Nostr if logged in
    if (currentUser && userSettings) {
        userSettings.lastNotificationView = timestamp;
        localStorage.setItem('plebsSettings', JSON.stringify(userSettings));
        if (userSettings.saveToNostr) {
            saveSettingsToNostr().catch(err => console.error('Failed to sync notification view to Nostr:', err));
        }
    }
}

// Function to load liked videos
async function loadLikedVideos() {
    if (!currentUser) {
        await checkStoredLogin(); // Wait for login check
        if (!currentUser) {
            document.getElementById('mainContent').innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.loginToViewLiked')}</p>`;
            return;
        }
    }

    currentView = 'liked';

    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const skeletonCount = cardsPerRow * 10; // 10 rows of skeletons
    const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');

    mainContent.innerHTML = `
        <h2 style="margin-bottom: 1.5rem;">Liked Videos</h2>
        <!-- Live Streams Section -->
        <div id="likedLiveSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <circle cx="12" cy="12" r="4" fill="#f44336"/>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                </svg>
                Live Streams
            </h3>
            <div class="video-grid" id="likedLiveGrid"></div>
        </div>
        <!-- Shorts Section -->
        <div id="likedShortsSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M10 8l6 4-6 4V8z"/>
                </svg>
                Shorts
            </h3>
            <div class="shorts-grid" id="likedShortsGrid"></div>
            <div class="view-more-container" id="likedShortsViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('likedShorts')">View More</button>
            </div>
        </div>
        <!-- Videos Section -->
        <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                </svg>
                Videos
            </h3>
        <div class="video-grid" id="videoGrid">
            ${skeletons}
        </div>
    `;

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('likedShortsGrid');
    const shortsSection = document.getElementById('likedShortsSection');
    const shortsViewMore = document.getElementById('likedShortsViewMore');
    const liveGrid = document.getElementById('likedLiveGrid');
    const liveSection = document.getElementById('likedLiveSection');
    const maxInitialShorts = getShortsCardsPerRow();
    const likedVideoIds = new Set();
    const likedLiveATags = new Set(); // Track #a tags for live streams

    // Reset cached liked shorts
    cachedLikedShorts = [];
    sectionExpanded.likedShorts = false;

    const reactionFilter = {
        kinds: [7],
        authors: [currentUser.pubkey],
        '#t': ['pv69420']
    };

    // Also fetch live stream reactions that may not have the #t tag (backwards compatibility)
    const liveReactionFilter = {
        kinds: [7],
        authors: [currentUser.pubkey]
    };

    await Promise.all([
        new Promise((resolve) => {
            requestEventsStream(reactionFilter, (event) => {
                if (event.content === '👍' || event.content === '+') {
                    const videoIdTag = event.tags.find(tag => tag[0] === 'e');
                    if (videoIdTag) {
                        likedVideoIds.add(videoIdTag[1]);
                    }
                    // Also check for #a tags (live streams use these)
                    const aTag = event.tags.find(tag => tag[0] === 'a' && tag[1]?.startsWith('30311:'));
                    if (aTag) {
                        likedLiveATags.add(aTag[1]);
                    }
                }
            }, resolve);
        }),
        new Promise((resolve) => {
            requestEventsStream(liveReactionFilter, (event) => {
                // Only process live stream reactions (those with #a tag starting with 30311:)
                if (event.content === '👍' || event.content === '+') {
                    const aTag = event.tags.find(tag => tag[0] === 'a' && tag[1]?.startsWith('30311:'));
                    if (aTag) {
                        likedLiveATags.add(aTag[1]);
                    }
                }
            }, resolve);
        })
    ]);

    if (likedVideoIds.size === 0 && likedLiveATags.size === 0) {
        videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noLikedVideosYet')}</p>`;
        return;
    }

    // Batch the IDs to handle relay limits
    const BATCH_SIZE = 50;
    const likedIds = Array.from(likedVideoIds);
    const idBatches = [];
    for (let i = 0; i < likedIds.length; i += BATCH_SIZE) {
        idBatches.push(likedIds.slice(i, i + BATCH_SIZE));
    }

    // Fetch all videos first, then separate shorts from videos
    const allVideos = [];
    const seenIds = new Set();

    await Promise.all(idBatches.map(async (batch) => {
        const videoFilter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            ids: batch
        };

        await new Promise((resolve) => {
            requestEventsStream(videoFilter, (event) => {
                if (!seenIds.has(event.id)) {
                    seenIds.add(event.id);
                    allVideos.push(event);
                    allEvents.set(event.id, event);
                }
            }, resolve);
        });
    }));

    // Fetch liked live streams by #a tags
    const likedLiveStreams = [];
    if (likedLiveATags.size > 0) {
        const aTagsArray = Array.from(likedLiveATags);
        for (const aTagValue of aTagsArray) {
            // Parse the #a tag: "30311:pubkey:dTag"
            const parts = aTagValue.split(':');
            if (parts.length >= 3) {
                const pubkey = parts[1];
                const dTag = parts.slice(2).join(':'); // Handle dTags with colons

                await new Promise((resolve) => {
                    requestEventsStream({
                        kinds: [NIP53_LIVE_EVENT_KIND],
                        authors: [pubkey],
                        '#d': [dTag]
                    }, (event) => {
                        if (!seenIds.has(event.id)) {
                            seenIds.add(event.id);
                            likedLiveStreams.push(event);
                            allEvents.set(event.id, event);
                        }
                    }, resolve);
                });
            }
        }
    }

    videoGrid.innerHTML = '';

    if (allVideos.length === 0 && likedLiveStreams.length === 0) {
        videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noLikedVideosFound')}</p>`;
        return;
    }

    // Separate shorts from videos and filter kind 1 duplicates
    const shorts = [];
    const videos = [];
    for (const event of allVideos) {
        if (shouldSkipLegacyEvent(event)) continue;
        if (isNip71ShortKind(event.kind)) {
            shorts.push(event);
        } else {
            videos.push(event);
        }
    }

    // Sort both by created_at descending
    shorts.sort((a, b) => b.created_at - a.created_at);
    videos.sort((a, b) => b.created_at - a.created_at);

    // Cache shorts for View More
    cachedLikedShorts = shorts;

    // Display live streams
    if (likedLiveStreams.length > 0) {
        // Sort by most recent
        likedLiveStreams.sort((a, b) => b.created_at - a.created_at);
        liveSection.style.display = 'block';
        const liveEventIds = [];

        for (const event of likedLiveStreams) {
            const liveData = parseLiveEvent(event);
            if (!liveData) continue;

            const profile = profileCache.get(event.pubkey);
            const isEnded = liveData.status === 'ended';
            const cardHTML = createLiveStreamCard(event, liveData, profile, isEnded);
            if (cardHTML) {
                liveGrid.insertAdjacentHTML('beforeend', cardHTML);
                liveEventIds.push(event.id);
            }
        }

        // Load viewer counts and boosts for live streams
        if (liveEventIds.length > 0) {
            loadLiveStreamCardsViewers(liveEventIds);
            liveEventIds.forEach(id => {
                if (!boostsCache.has(id)) {
                    loadBoostsForVideo(id);
                }
            });
        }
    }

    // Display shorts (only first row initially)
    if (shorts.length > 0) {
        shortsSection.style.display = 'block';
        const initialShorts = shorts.slice(0, maxInitialShorts);
        for (const event of initialShorts) {
            const profile = profileCache.get(event.pubkey);
            const reactions = reactionsCache.get(event.id);
            const cardHTML = createShortCard(event, profile, reactions);
            if (cardHTML) {
                shortsGrid.insertAdjacentHTML('beforeend', cardHTML);
            }
        }

        // Show View More if there are more shorts
        if (shorts.length > maxInitialShorts && shortsViewMore) {
            shortsViewMore.style.display = 'block';
        }
    }

    // Display videos
    if (videos.length > 0) {
        for (const event of videos) {
            const profile = profileCache.get(event.pubkey);
            const reactions = reactionsCache.get(event.id);
            const cardHTML = createVideoCard(event, profile, reactions);
            if (cardHTML) {
                videoGrid.insertAdjacentHTML('beforeend', cardHTML);
            }
        }
    } else {
        videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthLikedVideos')}</p>`;
    }

    // Load profiles and reactions in batches
    const allMedia = [...shorts, ...videos, ...likedLiveStreams];
    const uniquePubkeys = [...new Set(allMedia.map(v => v.pubkey))];
    const profileBatches = [];
    for (let i = 0; i < uniquePubkeys.length; i += BATCH_SIZE) {
        profileBatches.push(uniquePubkeys.slice(i, i + BATCH_SIZE));
    }

    await Promise.all(profileBatches.map(async (batch) => {
        const profileFilter = { kinds: [0], authors: batch };
        await new Promise((resolve) => {
            requestEventsStream(profileFilter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);
                    // Update cards with this profile (in-place to prevent flickering)
                    allMedia.forEach(video => {
                        if (video.pubkey === profileEvent.pubkey) {
                            updateVideoCardInPlace(video.id, profile, reactionsCache.get(video.id));
                        }
                    });
                } catch (e) {}
            }, resolve);
        });
    }));

    // Load reactions
    await loadReactionsForVideos(allMedia.map(v => v.id));

    // Load views for liked videos
    const likedMediaIds = allMedia.map(v => v.id);
    if (likedMediaIds.length > 0) {
        loadViewsForVideos(likedMediaIds, true);
    }

    observeLazyCards();
}

// Watch history management
const WATCH_HISTORY_KEY = 'plebs_watch_history';
const MAX_HISTORY_ITEMS = 200;

function addToWatchHistory(eventId, videoTags = [], authorPubkey = null) {
    try {
        let history = JSON.parse(localStorage.getItem(WATCH_HISTORY_KEY) || '[]');

        // Remove if already exists (to move it to top)
        history = history.filter(item => item.id !== eventId);

        // Add to beginning with timestamp and metadata for recommendations
        history.unshift({
            id: eventId,
            timestamp: Date.now(),
            tags: videoTags || [],
            author: authorPubkey || null
        });

        // Keep only the last MAX_HISTORY_ITEMS
        if (history.length > MAX_HISTORY_ITEMS) {
            history = history.slice(0, MAX_HISTORY_ITEMS);
        }

        localStorage.setItem(WATCH_HISTORY_KEY, JSON.stringify(history));

        // Trigger recommendation refresh if section exists
        if (history.length >= 3) {
            refreshRecommendedSection();
        }

        // Sync to Nostr if logged in and saveToNostr is enabled
        if (currentUser && userSettings?.saveToNostr) {
            saveWatchHistoryToNostr(history).catch(err =>
                console.error('Failed to sync watch history to Nostr:', err)
            );
        }
    } catch (e) {
        console.error('Failed to save watch history:', e);
    }
}

function getWatchHistory() {
    try {
        return JSON.parse(localStorage.getItem(WATCH_HISTORY_KEY) || '[]');
    } catch (e) {
        console.error('Failed to load watch history:', e);
        return [];
    }
}

function clearWatchHistory() {
    localStorage.removeItem(WATCH_HISTORY_KEY);

    // Clear from Nostr if logged in
    if (currentUser && userSettings?.saveToNostr) {
        clearWatchHistoryFromNostr().catch(err =>
            console.error('Failed to clear watch history from Nostr:', err)
        );
    }
}

// Remove a single item from watch history
function removeFromWatchHistory(eventId) {
    try {
        let history = JSON.parse(localStorage.getItem(WATCH_HISTORY_KEY) || '[]');
        history = history.filter(item => item.id !== eventId);
        localStorage.setItem(WATCH_HISTORY_KEY, JSON.stringify(history));

        // Sync to Nostr if logged in
        if (currentUser && userSettings?.saveToNostr) {
            saveWatchHistoryToNostr(history).catch(err =>
                console.error('Failed to sync watch history to Nostr:', err)
            );
        }
    } catch (e) {
        console.error('Failed to remove from watch history:', e);
    }
}

// ===== WATCH HISTORY NOSTR SYNC (NIP-78 kind 30078) =====

const WATCH_HISTORY_APP_IDENTIFIER = 'plebs/watch-history';

// Save watch history to Nostr
async function saveWatchHistoryToNostr(history) {
    if (!currentUser) return false;

    try {
        const event = {
            kind: 30078,
            tags: [
                ['d', WATCH_HISTORY_APP_IDENTIFIER],
                ['t', 'watch-history'],
                ['client', 'Plebs']
            ],
            content: JSON.stringify(history),
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(event);
        return await publishEvent(signedEvent);
    } catch (error) {
        console.error('Failed to save watch history to Nostr:', error);
        return false;
    }
}

// Load watch history from Nostr and merge with localStorage
async function loadWatchHistoryFromNostr() {
    if (!currentUser) return [];

    try {
        const filter = {
            kinds: [30078],
            authors: [currentUser.pubkey],
            '#d': [WATCH_HISTORY_APP_IDENTIFIER],
            limit: 1
        };

        let nostrHistory = null;
        let nostrTimestamp = 0;

        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                try {
                    nostrHistory = JSON.parse(event.content);
                    nostrTimestamp = event.created_at * 1000;
                } catch (e) {
                    console.error('Failed to parse watch history from Nostr:', e);
                }
            }, resolve);
        });

        if (!nostrHistory || !Array.isArray(nostrHistory)) {
            return getWatchHistory();
        }

        // Merge with local history
        const localHistory = getWatchHistory();
        const mergedHistory = mergeWatchHistories(localHistory, nostrHistory);

        // Save merged history to localStorage
        localStorage.setItem(WATCH_HISTORY_KEY, JSON.stringify(mergedHistory));

        return mergedHistory;
    } catch (error) {
        console.error('Failed to load watch history from Nostr:', error);
        return getWatchHistory();
    }
}

// Merge two watch histories, prioritizing more recent entries
function mergeWatchHistories(localHistory, nostrHistory) {
    const merged = new Map();

    // Add nostr history first
    nostrHistory.forEach(item => {
        if (item.id) {
            merged.set(item.id, item);
        }
    });

    // Override with local history if more recent
    localHistory.forEach(item => {
        if (item.id) {
            const existing = merged.get(item.id);
            if (!existing || (item.timestamp && (!existing.timestamp || item.timestamp > existing.timestamp))) {
                merged.set(item.id, item);
            }
        }
    });

    // Convert back to array and sort by timestamp (newest first)
    const result = Array.from(merged.values())
        .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0))
        .slice(0, MAX_HISTORY_ITEMS);

    return result;
}

// Clear watch history from Nostr using NIP-09 deletion
async function clearWatchHistoryFromNostr() {
    if (!currentUser) return false;

    try {
        // First, find the existing watch history event
        const filter = {
            kinds: [30078],
            authors: [currentUser.pubkey],
            '#d': [WATCH_HISTORY_APP_IDENTIFIER],
            limit: 1
        };

        let existingEventId = null;

        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                existingEventId = event.id;
            }, resolve);
        });

        if (existingEventId) {
            // Publish a deletion event (NIP-09)
            const deleteEvent = {
                kind: 5,
                tags: [
                    ['e', existingEventId],
                    ['a', `30078:${currentUser.pubkey}:${WATCH_HISTORY_APP_IDENTIFIER}`]
                ],
                content: 'Cleared watch history',
                created_at: Math.floor(Date.now() / 1000)
            };

            const signedEvent = await signEvent(deleteEvent);
            await publishEvent(signedEvent);
        }

        // Also publish an empty watch history to replace
        await saveWatchHistoryToNostr([]);

        return true;
    } catch (error) {
        console.error('Failed to clear watch history from Nostr:', error);
        return false;
    }
}

// ===== RECOMMENDATION ENGINE =====

const RECOMMENDATION_THRESHOLD = 3; // Minimum videos watched before showing recommendations
const RECOMMENDATION_CACHE_KEY = 'plebs_recommendation_cache';
const RECOMMENDATION_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Calculate user preferences based on watch history
function calculateUserPreferences() {
    const history = getWatchHistory();
    const tagWeights = new Map();
    const authorWeights = new Map();

    // Weight recent views more heavily (exponential decay)
    history.forEach((item, index) => {
        const recencyWeight = Math.exp(-index * 0.1); // More recent = higher weight

        // Accumulate tag weights
        if (item.tags && Array.isArray(item.tags)) {
            item.tags.forEach(tag => {
                // Handle both string tags and nostr tag arrays ['t', 'tagname']
                let tagValue;
                if (typeof tag === 'string') {
                    tagValue = tag;
                } else if (Array.isArray(tag) && tag[0] === 't' && tag[1]) {
                    tagValue = tag[1];
                }
                if (tagValue && typeof tagValue === 'string') {
                    const normalizedTag = tagValue.toLowerCase();
                    const currentWeight = tagWeights.get(normalizedTag) || 0;
                    tagWeights.set(normalizedTag, currentWeight + recencyWeight);
                }
            });
        }

        // Accumulate author weights
        if (item.author) {
            const currentWeight = authorWeights.get(item.author) || 0;
            authorWeights.set(item.author, currentWeight + recencyWeight);
        }
    });

    // Normalize weights
    const maxTagWeight = Math.max(...tagWeights.values(), 1);
    const maxAuthorWeight = Math.max(...authorWeights.values(), 1);

    tagWeights.forEach((weight, tag) => {
        tagWeights.set(tag, weight / maxTagWeight);
    });

    authorWeights.forEach((weight, author) => {
        authorWeights.set(author, weight / maxAuthorWeight);
    });

    return { tagWeights, authorWeights };
}

// Calculate similarity score between a video and user preferences
function calculateVideoScore(videoEvent, preferences, watchedIds = new Set()) {
    // Skip already watched videos
    if (watchedIds.has(videoEvent.id)) {
        return -1;
    }

    const videoData = parseVideoEvent(videoEvent);
    if (!videoData) return -1;

    // Base score so all videos have some chance
    let score = 0.05;
    const { tagWeights, authorWeights } = preferences;

    // Tag matching score (0-0.6)
    if (videoData.tags && videoData.tags.length > 0 && tagWeights.size > 0) {
        let tagScore = 0;
        let matchedTags = 0;
        videoData.tags.forEach(tag => {
            const normalizedTag = tag.toLowerCase();
            if (tagWeights.has(normalizedTag)) {
                tagScore += tagWeights.get(normalizedTag);
                matchedTags++;
            }
        });
        // Normalize by number of tags and apply weight
        if (matchedTags > 0) {
            score += (tagScore / videoData.tags.length) * 0.6;
        }
    }

    // Author matching score (0-0.3)
    if (videoEvent.pubkey && authorWeights.has(videoEvent.pubkey)) {
        score += authorWeights.get(videoEvent.pubkey) * 0.3;
    }

    // Recency boost for newer videos (0-0.15)
    const ageHours = (Date.now() / 1000 - videoEvent.created_at) / 3600;
    const recencyBoost = Math.max(0, 1 - (ageHours / (24 * 7))) * 0.15; // Decay over 1 week
    score += recencyBoost;

    return score;
}

// Calculate similarity between two videos (for "similar videos" feature)
function calculateVideoSimilarity(videoA, videoB) {
    const dataA = parseVideoEvent(videoA);
    const dataB = parseVideoEvent(videoB);

    if (!dataA || !dataB) return 0;

    let score = 0;

    // Same author bonus (0.3)
    if (videoA.pubkey === videoB.pubkey) {
        score += 0.3;
    }

    // Tag overlap (0-0.7)
    if (dataA.tags && dataB.tags && dataA.tags.length > 0 && dataB.tags.length > 0) {
        const tagsA = new Set(dataA.tags.map(t => t.toLowerCase()));
        const tagsB = new Set(dataB.tags.map(t => t.toLowerCase()));

        let overlap = 0;
        tagsA.forEach(tag => {
            if (tagsB.has(tag)) overlap++;
        });

        const jaccardSimilarity = overlap / (tagsA.size + tagsB.size - overlap);
        score += jaccardSimilarity * 0.7;
    }

    return score;
}

// Get personalized recommendations
async function getRecommendations(limit = 12, excludeIds = []) {
    const history = getWatchHistory();
    const watchedIds = new Set(history.map(h => h.id));

    // Check cache first
    try {
        const cached = JSON.parse(localStorage.getItem(RECOMMENDATION_CACHE_KEY) || '{}');
        if (cached.timestamp && Date.now() - cached.timestamp < RECOMMENDATION_CACHE_DURATION) {
            if (cached.recommendations && cached.recommendations.length > 0) {
                // Filter out excluded IDs and already watched videos
                return cached.recommendations.filter(id => !excludeIds.includes(id) && !watchedIds.has(id)).slice(0, limit);
            }
        }
    } catch (e) {
        console.error('Failed to read recommendation cache:', e);
    }

    if (history.length < RECOMMENDATION_THRESHOLD) {
        return [];
    }

    const preferences = calculateUserPreferences();
    excludeIds.forEach(id => watchedIds.add(id));

    // Fetch recent videos to score
    const now = Math.floor(Date.now() / 1000);
    const twoWeeksAgo = now - (14 * 24 * 60 * 60);

    const filter = {
        kinds: ALL_VIDEO_KINDS,
        '#t': ['pv69420'],
        since: twoWeeksAgo,
        limit: 200
    };

    return new Promise((resolve) => {
        const candidateVideos = [];

        requestEventsStream(filter, (event) => {
            if (!watchedIds.has(event.id)) {
                const score = calculateVideoScore(event, preferences, watchedIds);
                if (score >= 0) {
                    candidateVideos.push({ event, score });
                }
            }
        }, () => {
            // Sort by score and take top results
            candidateVideos.sort((a, b) => b.score - a.score);
            const recommendations = candidateVideos.slice(0, limit * 2).map(c => c.event.id);

            // Cache results only if we have recommendations
            if (recommendations.length > 0) {
                try {
                    localStorage.setItem(RECOMMENDATION_CACHE_KEY, JSON.stringify({
                        timestamp: Date.now(),
                        recommendations
                    }));
                } catch (e) {
                    console.error('Failed to cache recommendations:', e);
                }
            }

            resolve(recommendations.slice(0, limit));
        });
    });
}

// Get similar videos to a specific video
// preferShorts: true = prefer shorts, false = prefer normal videos, null = no preference
async function getSimilarVideos(currentVideoEvent, limit = 8, excludeIds = [], preferShorts = null) {
    const videoData = parseAnyVideoEvent(currentVideoEvent);
    if (!videoData) return [];

    const history = getWatchHistory();
    const watchedIds = new Set(history.map(h => h.id));
    watchedIds.add(currentVideoEvent.id);
    excludeIds.forEach(id => watchedIds.add(id));

    // Build filter to find similar videos - just get recent videos and filter locally
    const now = Math.floor(Date.now() / 1000);
    const oneMonthAgo = now - (30 * 24 * 60 * 60);

    // Get general recent videos (we'll filter by similarity locally)
    // Fetch more candidates to support dynamic sidebar capacity
    const filter = {
        kinds: ALL_VIDEO_KINDS,
        '#t': ['pv69420'],
        since: oneMonthAgo,
        limit: Math.max(200, limit * 8)
    };

    // Also get videos from same author
    const authorFilter = {
        kinds: ALL_VIDEO_KINDS,
        '#t': ['pv69420'],
        authors: [currentVideoEvent.pubkey],
        since: oneMonthAgo,
        limit: 50
    };

    // Get videos with matching tags (same topic) - boosts topic relevance
    const currentTags = (videoData.tags || []).map(t => t.toLowerCase()).filter(t => t !== 'pv69420');
    const tagFilters = currentTags.slice(0, 3).map(tag => ({
        kinds: [1],
        '#t': ['pv69420', tag],
        since: oneMonthAgo,
        limit: 50
    }));

    // Helper to calculate type preference boost
    const getTypeBoost = (event) => {
        if (preferShorts === null) return 0;
        const eventIsShort = isShortVideoEvent(event);
        // Matching the preferred type gets a significant boost
        return (eventIsShort === preferShorts) ? 0.5 : 0;
    };

    return new Promise((resolve) => {
        const candidateVideos = [];
        const seenIds = new Set();
        let completedRequests = 0;
        const totalRequests = 2 + Math.max(1, tagFilters.length); // At least 3 requests

        const processComplete = () => {
            completedRequests++;
            if (completedRequests >= totalRequests) {
                // Sort by similarity score (which includes type preference boost)
                candidateVideos.sort((a, b) => b.score - a.score);
                const similarIds = candidateVideos.slice(0, limit).map(c => c.event.id);
                resolve(similarIds);
            }
        };

        // Fetch recent videos and score by similarity
        requestEventsStream(filter, (event) => {
            if (!watchedIds.has(event.id) && !seenIds.has(event.id) && event.id !== currentVideoEvent.id) {
                seenIds.add(event.id);
                const score = calculateVideoSimilarity(currentVideoEvent, event);
                const typeBoost = getTypeBoost(event);
                // Include videos with score >= 0, but prioritize higher scores
                candidateVideos.push({ event, score: Math.max(score, 0.01) + typeBoost });
            }
        }, processComplete);

        // Fetch by author (these get a boost)
        requestEventsStream(authorFilter, (event) => {
            if (!watchedIds.has(event.id) && !seenIds.has(event.id) && event.id !== currentVideoEvent.id) {
                seenIds.add(event.id);
                const score = calculateVideoSimilarity(currentVideoEvent, event);
                const typeBoost = getTypeBoost(event);
                // Author matches get a significant boost
                candidateVideos.push({ event, score: score + 0.4 + typeBoost });
            }
        }, processComplete);

        // Fetch by matching tags (topic-related videos get a boost)
        if (tagFilters.length > 0) {
            tagFilters.forEach(tagFilter => {
                requestEventsStream(tagFilter, (event) => {
                    if (!watchedIds.has(event.id) && !seenIds.has(event.id) && event.id !== currentVideoEvent.id) {
                        seenIds.add(event.id);
                        const score = calculateVideoSimilarity(currentVideoEvent, event);
                        const typeBoost = getTypeBoost(event);
                        // Tag-matched videos get an additional boost
                        candidateVideos.push({ event, score: score + 0.2 + typeBoost });
                    }
                }, processComplete);
            });
        } else {
            // No tags on current video, complete this request immediately
            processComplete();
        }
    });
}

// Get mixed recommendations (similar + personalized) for video page sidebar
// preferShorts: true = prefer shorts, false = prefer normal videos, null = no preference
async function getMixedRecommendations(currentVideoEvent, limit = 8, preferShorts = null) {
    const history = getWatchHistory();
    const hasEnoughHistory = history.length >= RECOMMENDATION_THRESHOLD;

    if (hasEnoughHistory) {
        // Mix similar videos with personalized recommendations
        const similarLimit = Math.ceil(limit * 0.6); // 60% similar
        const personalizedLimit = limit - similarLimit; // 40% personalized

        const [similarIds, recommendedIds] = await Promise.all([
            getSimilarVideos(currentVideoEvent, similarLimit, [], preferShorts),
            getRecommendations(personalizedLimit, [currentVideoEvent.id])
        ]);

        // Combine and deduplicate
        const seenIds = new Set();
        const mixedIds = [];

        // Interleave similar and personalized
        const maxLen = Math.max(similarIds.length, recommendedIds.length);
        for (let i = 0; i < maxLen && mixedIds.length < limit; i++) {
            if (i < similarIds.length && !seenIds.has(similarIds[i])) {
                seenIds.add(similarIds[i]);
                mixedIds.push(similarIds[i]);
            }
            if (i < recommendedIds.length && !seenIds.has(recommendedIds[i]) && mixedIds.length < limit) {
                seenIds.add(recommendedIds[i]);
                mixedIds.push(recommendedIds[i]);
            }
        }

        return mixedIds;
    } else {
        // Just show similar videos
        return getSimilarVideos(currentVideoEvent, limit, [], preferShorts);
    }
}

// Refresh the recommended section on home page - uses progressive rendering
async function refreshRecommendedSection() {
    const recommendedSection = document.getElementById('recommendedSection');
    if (!recommendedSection) return;

    const history = getWatchHistory();
    if (history.length < RECOMMENDATION_THRESHOLD) {
        recommendedSection.style.display = 'none';
        return;
    }

    recommendedSection.style.display = 'block';
    const recommendedGrid = document.getElementById('recommendedGrid');
    if (!recommendedGrid) return;

    recommendedGrid.innerHTML = '<div class="spinner"></div>';

    try {
        const recommendedIds = await getRecommendations(12);

        if (recommendedIds.length === 0) {
            recommendedSection.style.display = 'none';
            return;
        }

        // Fetch video events
        const videoFilter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            ids: recommendedIds
        };

        const videos = [];
        const renderedIds = new Set();
        let hasCleared = false;
        let renderTimeout = null;
        let firstRenderDone = false;

        // Order map for sorting
        const orderMap = new Map(recommendedIds.map((id, i) => [id, i]));

        // Progressive render function
        const renderProgressively = () => {
            if (videos.length === 0) return;

            // Sort by recommendation order
            const sortedVideos = [...videos].sort((a, b) =>
                (orderMap.get(a.id) || 0) - (orderMap.get(b.id) || 0)
            );

            // Clear spinner on first render
            if (!hasCleared && sortedVideos.length > 0) {
                hasCleared = true;
                recommendedGrid.innerHTML = '';
            }

            // Render new cards
            sortedVideos.forEach(event => {
                if (renderedIds.has(event.id)) return;
                renderedIds.add(event.id);

                const profile = profileCache.get(event.pubkey);
                const reactions = reactionsCache.get(event.id);
                // First row loads immediately (non-lazy)
                const isFirstRow = renderedIds.size <= 4;
                const cardHtml = createVideoCard(event, profile, reactions, false, null, !isFirstRow);

                if (cardHtml) {
                    recommendedGrid.insertAdjacentHTML('beforeend', cardHtml);

                    // Load profile immediately if not cached
                    loadProfileAndUpdateCards(event.pubkey);

                    // Load boosts if not cached (fire-and-forget)
                    if (!boostsCache.has(event.id)) {
                        loadBoostsForVideo(event.id, (totalBoosts) => {
                            const card = document.getElementById(`video-card-${event.id}`);
                            if (!card) return;
                            const boostLevel = getBoostLevel(totalBoosts);
                            const isBoosted = boostLevel > 0;
                            if (isBoosted) {
                                card.classList.add('boosted', `boost-level-${boostLevel}`);
                                for (let i = 1; i <= 4; i++) {
                                    if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                                }
                                const thumbnail = card.querySelector('.video-thumbnail');
                                if (thumbnail) {
                                    const existingIndicator = thumbnail.querySelector('.boost-indicator');
                                    const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                                    if (existingIndicator) {
                                        existingIndicator.outerHTML = indicatorHTML;
                                    } else {
                                        thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                                    }
                                }
                            }
                        });
                    }
                }
            });

            observeLazyCards();
            firstRenderDone = true;
        };

        // Debounced render (immediate on first event)
        const scheduleRender = () => {
            if (renderTimeout) clearTimeout(renderTimeout);
            if (!firstRenderDone) {
                renderProgressively();
            } else {
                renderTimeout = setTimeout(renderProgressively, 50);
            }
        };

        // Stream events and render progressively
        requestEventsStream(videoFilter, (event) => {
            allEvents.set(event.id, event);
            // Skip legacy events when addressable counterpart exists
            if (shouldSkipLegacyEvent(event)) return;
            // Never show logged-in user's own videos in recommendations
            if (currentUser && event.pubkey === currentUser.pubkey) return;
            videos.push(event);
            scheduleRender();
        }, () => {
            // On completion
            clearTimeout(renderTimeout);
            renderProgressively();

            if (videos.length === 0) {
                recommendedSection.style.display = 'none';
                return;
            }

            initializeRecommendedCarousel();

            // Load reactions in background
            loadReactionsForVideos(videos.map(v => v.id));
        });
    } catch (error) {
        console.error('Failed to load recommendations:', error);
        recommendedSection.style.display = 'none';
    }
}

// Initialize carousel for recommended section
function initializeRecommendedCarousel() {
    const recommendedGrid = document.getElementById('recommendedGrid');
    const carouselDots = document.getElementById('recommendedCarouselDots');
    const container = recommendedGrid?.parentElement;

    if (!recommendedGrid || !carouselDots || !container) return;

    const cards = recommendedGrid.querySelectorAll('.video-card');
    const totalCards = cards.length;

    if (totalCards === 0) return;

    let itemsPerPage;
    if (window.innerWidth <= 480) {
        itemsPerPage = 2; // 2 on mobile
    } else if (window.innerWidth <= 768) {
        itemsPerPage = 3; // 3 on tablet
    } else {
        itemsPerPage = 4; // 4 on desktop
    }

    itemsPerPage = Math.min(itemsPerPage, totalCards);
    const totalPages = Math.ceil(totalCards / itemsPerPage);

    // Calculate card width in pixels to fit exactly itemsPerPage cards
    const gap = 16; // 1rem gap
    const containerWidth = container.clientWidth;
    const totalGapWidth = (itemsPerPage - 1) * gap;
    const cardWidth = (containerWidth - totalGapWidth) / itemsPerPage;

    cards.forEach(card => {
        card.style.flex = `0 0 ${cardWidth}px`;
        card.style.maxWidth = `${cardWidth}px`;
        card.style.width = `${cardWidth}px`;
    });

    carouselDots.innerHTML = '';
    for (let i = 0; i < totalPages; i++) {
        const dot = document.createElement('div');
        dot.className = `carousel-dot ${i === 0 ? 'active' : ''}`;
        dot.onclick = () => goToRecommendedPage(i);
        carouselDots.appendChild(dot);
    }

    recommendedGrid.dataset.currentPage = '0';
    recommendedGrid.dataset.totalPages = totalPages;
    recommendedGrid.dataset.itemsPerPage = itemsPerPage;
    recommendedGrid.dataset.cardWidth = cardWidth;
    recommendedGrid.dataset.gap = gap;

    updateRecommendedCarouselButtons();
    goToRecommendedPage(0);
}

function goToRecommendedPage(pageIndex) {
    const recommendedGrid = document.getElementById('recommendedGrid');
    const carouselDots = document.getElementById('recommendedCarouselDots');
    if (!recommendedGrid) return;

    const totalPages = parseInt(recommendedGrid.dataset.totalPages) || 1;

    pageIndex = Math.max(0, Math.min(pageIndex, totalPages - 1));
    recommendedGrid.dataset.currentPage = pageIndex;

    const cards = recommendedGrid.querySelectorAll('.video-card');
    if (cards.length === 0) return;

    // Use stored card dimensions for precise scrolling
    const cardWidth = parseFloat(recommendedGrid.dataset.cardWidth) || cards[0].offsetWidth;
    const gap = parseFloat(recommendedGrid.dataset.gap) || 16;
    const itemsPerPage = parseInt(recommendedGrid.dataset.itemsPerPage) || 3;
    const offset = pageIndex * itemsPerPage * (cardWidth + gap);

    recommendedGrid.style.transform = `translateX(-${offset}px)`;

    if (carouselDots) {
        carouselDots.querySelectorAll('.carousel-dot').forEach((dot, i) => {
            dot.classList.toggle('active', i === pageIndex);
        });
    }

    updateRecommendedCarouselButtons();
}

function scrollRecommendedCarousel(direction) {
    const recommendedGrid = document.getElementById('recommendedGrid');
    if (!recommendedGrid) return;

    const currentPage = parseInt(recommendedGrid.dataset.currentPage) || 0;
    goToRecommendedPage(currentPage + direction);
}

function updateRecommendedCarouselButtons() {
    const recommendedGrid = document.getElementById('recommendedGrid');
    const prevBtn = document.querySelector('.recommended-section .carousel-btn.prev');
    const nextBtn = document.querySelector('.recommended-section .carousel-btn.next');

    if (!recommendedGrid || !prevBtn || !nextBtn) return;

    const currentPage = parseInt(recommendedGrid.dataset.currentPage) || 0;
    const totalPages = parseInt(recommendedGrid.dataset.totalPages) || 1;

    prevBtn.disabled = currentPage === 0;
    nextBtn.disabled = currentPage >= totalPages - 1;
}

// Calculate how many video cards fit in the desktop sidebar based on viewport
function calculateSidebarCapacity() {
    const viewportHeight = window.innerHeight;
    const headerHeight = 60; // --header-height
    const sidebarMargin = 32; // 2rem margin from CSS calc
    const sidebarPadding = 32; // 1rem top + 1rem bottom
    const sidebarHeaderHeight = 52; // Header with "Up Next" title + margin + padding
    const cardHeight = 95; // ~79px thumbnail + 16px card padding
    const cardGap = 12; // 0.75rem gap between cards

    const availableHeight = viewportHeight - headerHeight - sidebarMargin - sidebarPadding - sidebarHeaderHeight;
    // Formula: N cards need N*cardHeight + (N-1)*gap space
    // Simplified: (availableHeight + gap) / (cardHeight + gap)
    const cardCount = Math.floor((availableHeight + cardGap) / (cardHeight + cardGap));

    // Return at least 5, at most 30 videos
    return Math.max(5, Math.min(30, cardCount));
}

// Load and render sidebar recommendations on video page - progressive rendering
async function loadSidebarRecommendations(currentVideoEvent) {
    const desktopSidebar = document.getElementById('recommendationsSidebarDesktop');
    const mobileSidebar = document.getElementById('recommendationsSidebarMobile');

    if (!desktopSidebar && !mobileSidebar) return;

    const desktopGrid = desktopSidebar?.querySelector('.sidebar-recommendations-grid');
    const mobileGrid = mobileSidebar?.querySelector('.sidebar-recommendations-grid');

    if (desktopGrid) desktopGrid.innerHTML = '<div class="spinner"></div>';
    if (mobileGrid) mobileGrid.innerHTML = '<div class="spinner"></div>';

    const noRecsMessage = '<p style="color: var(--text-secondary); text-align: center; padding: 1rem;">No recommendations available yet.</p>';

    try {
        // Calculate how many videos fit in the desktop sidebar based on viewport height
        const desktopLimit = calculateSidebarCapacity();

        // Determine if current video is a short - prefer same type in recommendations
        const currentIsShort = isShortVideoEvent(currentVideoEvent);

        // Track all IDs to avoid duplicates - include watched videos
        const watchHistory = getWatchHistory();
        const usedIds = new Set([currentVideoEvent.id, ...watchHistory.map(h => h.id)]);

        // Track video hashes to avoid showing same video in different event kinds (legacy vs addressable)
        const usedHashes = new Set();
        const currentVideoHash = currentVideoEvent.tags?.find(t => t[0] === 'x')?.[1];
        if (currentVideoHash) usedHashes.add(currentVideoHash);

        // Progressive rendering state
        const videoMap = new Map();
        const renderedIds = new Set();
        let hasCleared = false;
        let recommendedIds = [];
        let orderMap = new Map();

        // Render sidebar card in order
        const renderSidebarCard = (event) => {
            if (renderedIds.has(event.id)) return;
            // Never show logged-in user's own videos in Up Next
            if (currentUser && event.pubkey === currentUser.pubkey) return;

            // Skip videos with same hash (same video in different event kind)
            const videoHash = event.tags?.find(t => t[0] === 'x')?.[1];
            if (videoHash && usedHashes.has(videoHash)) return;

            // Skip videos that match content filter packs or custom keywords
            const videoData = parseNip71VideoEvent(event) || parseVideoEvent(event);
            if (videoData) {
                const filterResult = shouldFilterVideoContent(event, videoData);
                if (filterResult.filtered) return;
            }

            // Clear spinner on first render
            if (!hasCleared) {
                hasCleared = true;
                if (desktopGrid) desktopGrid.innerHTML = '';
                if (mobileGrid) mobileGrid.innerHTML = '';
            }

            const profile = profileCache.get(event.pubkey);
            const reactions = reactionsCache.get(event.id);
            const cardHTML = createSidebarVideoCard(event, profile, reactions);
            if (!cardHTML) return;

            // Load profile immediately if not cached
            loadProfileAndUpdateCards(event.pubkey);

            // Load boosts if not cached (fire-and-forget)
            if (!boostsCache.has(event.id)) {
                loadBoostsForVideo(event.id, (totalBoosts) => {
                    updateSidebarCardBoosts(event.id, totalBoosts);
                });
            }

            // Load views if not cached (fire-and-forget)
            if (getCachedViewCount(event.id) === null) {
                loadVideoViews(event.id).then(viewCount => {
                    // Update sidebar cards with view count
                    document.querySelectorAll(`.sidebar-video-card[data-event-id="${event.id}"] .video-views`).forEach(el => {
                        el.textContent = ` • ${formatNumber(viewCount)} ${t('stat.views')}`;
                    });
                });
            }

            // Find correct position based on recommendation order
            const eventOrder = orderMap.get(event.id) ?? 999;
            let wasInserted = false;

            // Insert into desktop grid
            if (desktopGrid) {
                const existingCards = desktopGrid.querySelectorAll('.sidebar-video-card');
                // Only insert if under limit
                if (existingCards.length < desktopLimit) {
                    let inserted = false;
                    for (const card of existingCards) {
                        const existingId = card.dataset.eventId;
                        const existingOrder = orderMap.get(existingId) ?? 999;
                        if (eventOrder < existingOrder) {
                            card.insertAdjacentHTML('beforebegin', cardHTML);
                            inserted = true;
                            wasInserted = true;
                            break;
                        }
                    }
                    if (!inserted) {
                        desktopGrid.insertAdjacentHTML('beforeend', cardHTML);
                        wasInserted = true;
                    }
                }
            }

            // Insert into mobile grid (up to 10)
            if (mobileGrid) {
                const existingCards = mobileGrid.querySelectorAll('.sidebar-video-card');
                if (existingCards.length < 10) {
                    let inserted = false;
                    for (const card of existingCards) {
                        const existingId = card.dataset.eventId;
                        const existingOrder = orderMap.get(existingId) ?? 999;
                        if (eventOrder < existingOrder) {
                            card.insertAdjacentHTML('beforebegin', cardHTML);
                            inserted = true;
                            break;
                        }
                    }
                    if (!inserted) {
                        mobileGrid.insertAdjacentHTML('beforeend', cardHTML);
                    }
                }
            }

            // Only count as rendered if actually inserted into desktop grid
            if (wasInserted) {
                renderedIds.add(event.id);
                // Track hash to avoid showing same video in different event kinds
                if (videoHash) usedHashes.add(videoHash);
            }

            // Set next video data from first rendered video
            if (renderedIds.size === 1) {
                const videoData = parseVideoEvent(event);
                const reactions = reactionsCache.get(event.id) || {};
                const isNSFW = isVideoNSFW(event);
                const isRatioed = isVideoRatioed(reactions);
                // Check validation cache for suspicious profile status
                const validationCached = profileValidationCache.get(event.pubkey);
                const isSuspicious = validationCached ? validationCached.isSuspicious :
                    (profileCache.has(event.pubkey) && (!profile || !profile.picture || !profile.nip05));

                nextVideoData = {
                    eventId: event.id,
                    pubkey: event.pubkey,
                    title: videoData?.title || 'Untitled',
                    thumbnail: videoData?.thumbnail || '',
                    channelName: profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`,
                    isNSFW: isNSFW,
                    isRatioed: isRatioed,
                    isSuspicious: isSuspicious
                };
            }

            observeLazyCards();
        };

        // Step 1: Get recommended video IDs (prefer same type as current video)
        recommendedIds = await getMixedRecommendations(currentVideoEvent, desktopLimit + 10, currentIsShort);
        recommendedIds.forEach(id => usedIds.add(id));
        orderMap = new Map(recommendedIds.map((id, i) => [id, i]));

        // Step 2: Fetch videos progressively
        if (recommendedIds.length > 0) {
            const videoFilter = {
                kinds: ALL_VIDEO_KINDS,
                '#t': ['pv69420'],
                ids: recommendedIds
            };

            requestEventsStream(videoFilter, (event) => {
                videoMap.set(event.id, event);
                allEvents.set(event.id, event);
                renderSidebarCard(event);
            }, async () => {
                // On completion - check if we need more videos
                if (renderedIds.size < desktopLimit) {
                    // Fetch latest videos to fill - prefer same type as current video
                    const needed = desktopLimit - renderedIds.size + 10;

                    // Get preferred kinds based on current video type
                    const preferredKinds = currentIsShort
                        ? [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY]
                        : [NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1];
                    const fallbackKinds = currentIsShort
                        ? [NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1]
                        : [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY];

                    let latestOrder = recommendedIds.length;

                    // First fetch preferred type
                    const preferredFilter = {
                        kinds: preferredKinds,
                        '#t': ['pv69420'],
                        limit: needed + 30
                    };

                    requestEventsStream(preferredFilter, (event) => {
                        if (!usedIds.has(event.id)) {
                            usedIds.add(event.id);
                            orderMap.set(event.id, latestOrder++);
                            videoMap.set(event.id, event);
                            allEvents.set(event.id, event);
                            renderSidebarCard(event);
                        }
                    }, () => {
                        // If still not enough, fetch fallback type
                        if (renderedIds.size < desktopLimit) {
                            const stillNeeded = desktopLimit - renderedIds.size + 10;
                            const fallbackFilter = {
                                kinds: fallbackKinds,
                                '#t': ['pv69420'],
                                limit: stillNeeded + 20
                            };

                            requestEventsStream(fallbackFilter, (event) => {
                                if (!usedIds.has(event.id)) {
                                    usedIds.add(event.id);
                                    orderMap.set(event.id, latestOrder++);
                                    videoMap.set(event.id, event);
                                    allEvents.set(event.id, event);
                                    renderSidebarCard(event);
                                }
                            }, () => {
                                // Final fallback: fill with watched videos if still not full
                                fillWithWatchedVideos(latestOrder, finalizeSidebar);
                            });
                        } else {
                            // Final fallback: fill with watched videos if still not full
                            fillWithWatchedVideos(latestOrder, finalizeSidebar);
                        }
                    });
                } else {
                    // Final fallback: fill with watched videos if still not full
                    fillWithWatchedVideos(recommendedIds.length, finalizeSidebar);
                }
            });
        } else {
            // No recommendations - fetch latest, preferring same type as current video
            const preferredKinds = currentIsShort
                ? [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY]
                : [NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1];
            const fallbackKinds = currentIsShort
                ? [NIP71_VIDEO_KIND, NIP71_VIDEO_KIND_LEGACY, 1]
                : [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY];

            let latestOrder = 0;

            // First fetch preferred type
            const preferredFilter = {
                kinds: preferredKinds,
                '#t': ['pv69420'],
                limit: desktopLimit + 30
            };

            requestEventsStream(preferredFilter, (event) => {
                if (!usedIds.has(event.id)) {
                    usedIds.add(event.id);
                    orderMap.set(event.id, latestOrder++);
                    videoMap.set(event.id, event);
                    allEvents.set(event.id, event);
                    renderSidebarCard(event);
                }
            }, () => {
                // If still not enough, fetch fallback type
                if (renderedIds.size < desktopLimit) {
                    const stillNeeded = desktopLimit - renderedIds.size + 10;
                    const fallbackFilter = {
                        kinds: fallbackKinds,
                        '#t': ['pv69420'],
                        limit: stillNeeded + 20
                    };

                    requestEventsStream(fallbackFilter, (event) => {
                        if (!usedIds.has(event.id)) {
                            usedIds.add(event.id);
                            orderMap.set(event.id, latestOrder++);
                            videoMap.set(event.id, event);
                            allEvents.set(event.id, event);
                            renderSidebarCard(event);
                        }
                    }, () => {
                        // Final fallback: fill with watched videos if still not full
                        fillWithWatchedVideos(latestOrder, finalizeSidebar);
                    });
                } else {
                    // Final fallback: fill with watched videos if still not full
                    fillWithWatchedVideos(latestOrder, finalizeSidebar);
                }
            });
        }

        // Final fallback: fill with watched videos if sidebar still not full
        function fillWithWatchedVideos(latestOrder, callback) {
            if (renderedIds.size >= desktopLimit) {
                callback();
                return;
            }

            // Get recent watch history but exclude very recent watches (last 10)
            const recentHistory = watchHistory.slice(0, 10).map(h => h.id);
            const olderWatchedIds = watchHistory.slice(10).map(h => h.id);

            // Skip if no older watched videos to show
            if (olderWatchedIds.length === 0) {
                callback();
                return;
            }

            const stillNeeded = desktopLimit - renderedIds.size + 5;
            const watchedFilter = {
                kinds: ALL_VIDEO_KINDS,
                '#t': ['pv69420'],
                ids: olderWatchedIds.slice(0, stillNeeded + 10)
            };

            requestEventsStream(watchedFilter, (event) => {
                // Only skip current video and very recent watches
                if (event.id !== currentVideoEvent.id && !recentHistory.includes(event.id) && !renderedIds.has(event.id)) {
                    orderMap.set(event.id, latestOrder++);
                    videoMap.set(event.id, event);
                    allEvents.set(event.id, event);
                    renderSidebarCard(event);
                }
            }, callback);
        }

        // Finalize sidebar after all loading
        function finalizeSidebar() {
            if (renderedIds.size === 0) {
                if (desktopGrid) desktopGrid.innerHTML = noRecsMessage;
                if (mobileGrid) mobileGrid.innerHTML = noRecsMessage;
                nextVideoData = null;
                return;
            }

            // Setup sticky sidebar
            if (window.innerWidth > 1024) {
                setupStickySidebar();
            }

            // Load profiles in background and update cards
            // Load reactions in background
            loadReactionsForVideos([...renderedIds]);
        }

    } catch (error) {
        console.error('Failed to load sidebar recommendations:', error);
        const errorMessage = '<p style="color: var(--text-secondary); text-align: center; padding: 1rem;">Failed to load recommendations.</p>';
        if (desktopGrid) desktopGrid.innerHTML = errorMessage;
        if (mobileGrid) mobileGrid.innerHTML = errorMessage;
    }
}

// Update sidebar card profile in-place
function updateSidebarCardInPlace(eventId, profile) {
    if (!profile) return;

    const cards = document.querySelectorAll(`.sidebar-video-card[data-event-id="${eventId}"]`);
    cards.forEach(card => {
        const displayName = profile.name || profile.display_name || `User ${card.dataset.pubkey?.slice(0, 8) || ''}`;

        // Update channel name (correct selector)
        const nameEl = card.querySelector('.sidebar-channel-name');
        if (nameEl) nameEl.textContent = displayName;
    });
}

// Apply validation result to sidebar cards
// Update sidebar card with boost indicator
function updateSidebarCardBoosts(eventId, boostAmount) {
    const cards = document.querySelectorAll(`.sidebar-video-card[data-event-id="${eventId}"]`);
    if (cards.length === 0) return;

    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;

    cards.forEach(card => {
        // Update card classes
        if (isBoosted) {
            card.classList.add('boosted', `boost-level-${boostLevel}`);
            for (let i = 1; i <= 4; i++) {
                if (i !== boostLevel) {
                    card.classList.remove(`boost-level-${i}`);
                }
            }
        } else {
            card.classList.remove('boosted', 'boost-level-1', 'boost-level-2', 'boost-level-3', 'boost-level-4');
        }

        // Update boost indicator on thumbnail
        const thumbnail = card.querySelector('.sidebar-video-thumbnail');
        if (!thumbnail) return;

        const existingIndicator = thumbnail.querySelector('.boost-indicator');

        if (isBoosted) {
            const indicatorHTML = `
                <div class="boost-indicator" style="font-size: 0.55rem; padding: 0.1rem 0.25rem;">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width: 10px; height: 10px;">
                        <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                    </svg>
                    ${formatSats(boostAmount)}
                </div>
            `;
            if (existingIndicator) {
                existingIndicator.outerHTML = indicatorHTML;
            } else {
                thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
            }
        } else if (existingIndicator) {
            existingIndicator.remove();
        }
    });
}

function applySidebarValidation(card, isSuspiciousProfile) {
    if (!card || !card.classList.contains('sidebar-video-card')) return;

    const eventId = card.dataset.eventId;
    if (!eventId) return;

    const event = allEvents.get(eventId);
    if (!event) return;

    const isNSFW = isVideoNSFW(event);
    const reactions = reactionsCache.get(eventId) || {};
    const isRatioed = isVideoRatioed(reactions);

    // Skip overlays for own videos
    const isOwnVideo = currentUser?.pubkey === event.pubkey;
    const shouldShowNSFWOverlay = !isOwnVideo && isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own videos)
    const isReportedByFollowsCheck = !isOwnVideo && isReportedByFollowsSync(eventId, event.pubkey);
    const shouldShowCommunityWarning = !isOwnVideo && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning();
    const needsOverlay = shouldShowNSFWOverlay || shouldShowCommunityWarning;
    const overlayType = shouldShowNSFWOverlay ? 'nsfw' : 'ratioed';

    const thumbnail = card.querySelector('.sidebar-video-thumbnail');
    if (!thumbnail) return;

    const currentOverlay = thumbnail.querySelector('.ratioed-overlay, .nsfw-overlay');

    // Add overlay if needed and not present
    if (needsOverlay && !currentOverlay) {
        thumbnail.classList.add(overlayType);
        card.setAttribute('onclick',
            overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${eventId}')` : `showRatioedModal('${eventId}')`
        );
        const overlayHTML = `
            <div class="${overlayType}-overlay">
                <div class="${overlayType}-badge" style="font-size: 0.6rem; padding: 0.15rem 0.3rem;">${overlayType === 'nsfw' ? 'NSFW' : 'WARNING'}</div>
            </div>
        `;
        thumbnail.insertAdjacentHTML('beforeend', overlayHTML);

        // Hide duration when overlay shown
        const duration = thumbnail.querySelector('.video-duration');
        if (duration) duration.style.display = 'none';
    } else if (!needsOverlay && currentOverlay) {
        // Remove overlay if not needed
        thumbnail.classList.remove('ratioed', 'nsfw');
        card.setAttribute('onclick', `navigateTo('/video/${eventId}')`);
        currentOverlay.remove();

        // Show duration again
        const duration = thumbnail.querySelector('.video-duration');
        if (duration) duration.style.display = '';
    }

    // Update warning indicator in meta
    const meta = card.querySelector('.sidebar-video-meta');
    if (meta) {
        const existingWarning = meta.querySelector('[style*="color: #ff9800"]');
        if (shouldShowCommunityWarning && !shouldShowNSFWOverlay && !existingWarning) {
            meta.insertAdjacentHTML('beforeend', '<span style="color: #ff9800; font-size: 0.65rem;">⚠</span>');
        } else if ((!shouldShowCommunityWarning || shouldShowNSFWOverlay) && existingWarning) {
            existingWarning.remove();
        }
    }
}

// Create a compact video card for the sidebar
function createSidebarVideoCard(event, profile, reactions) {
    const videoData = parseNip71VideoEvent(event) || parseVideoEvent(event);
    if (!videoData) return '';

    // Skip videos from muted users in recommendations
    if (shouldHideMutedContent(event.pubkey)) return '';

    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';
    const isNSFW = isVideoNSFW(event);
    const isRatioed = isVideoRatioed(reactions || {});

    // Check validation cache first - if we've validated this pubkey, use cached result
    let isSuspiciousProfile = false;
    if (profileValidationCache.has(event.pubkey)) {
        isSuspiciousProfile = profileValidationCache.get(event.pubkey).isSuspicious;
    } else {
        // Fallback to basic field check if not validated yet
        const profileChecked = profileCache.has(event.pubkey);
        isSuspiciousProfile = profileChecked && (!profile || !avatarUrl || !nip05);
    }

    // Check boosts cache for boost highlighting
    const boostAmount = boostsCache.get(event.id) || 0;
    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;
    const boostClasses = isBoosted ? `boosted boost-level-${boostLevel}` : '';

    // Determine what type of overlay to show (skip for own videos)
    const isOwnVideo = currentUser?.pubkey === event.pubkey;
    const showNSFWOverlay = !isOwnVideo && isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own videos)
    const isReportedByFollowsCheck = !isOwnVideo && isReportedByFollowsSync(event.id, event.pubkey);
    const showCommunityWarning = !isOwnVideo && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning();
    const showBlurred = showNSFWOverlay || showCommunityWarning;

    // NSFW takes precedence for overlay type
    const overlayType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    // Determine onclick handler based on overlay type
    const onclickHandler = showBlurred
        ? (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${event.id}')` : `showRatioedModal('${event.id}')`)
        : `navigateTo('/video/${event.id}')`;

    // Boost indicator HTML for sidebar (smaller styling)
    const boostIndicatorHTML = isBoosted ? `
        <div class="boost-indicator" style="font-size: 0.55rem; padding: 0.1rem 0.25rem;">
            <svg viewBox="0 0 24 24" fill="currentColor" style="width: 10px; height: 10px;">
                <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
            </svg>
            ${formatSats(boostAmount)}
        </div>
    ` : '';

    return `
        <div class="sidebar-video-card ${boostClasses}" data-event-id="${event.id}" data-pubkey="${event.pubkey}" onclick="${onclickHandler}">
            <div class="sidebar-video-thumbnail ${showBlurred ? overlayType : ''}"
                 ${videoData.preview ? `data-preview="${escapeHtml(videoData.preview)}" data-thumbnail="${escapeHtml(videoData.thumbnail || '')}"` : ''}>
                ${videoData.thumbnail ?
                    `<img class="thumbnail-img" src="${videoData.thumbnail}" alt="${videoData.title}" onerror="this.style.display='none'">` :
                    `<video src="${videoData.url}" preload="metadata"></video>`
                }
                ${showBlurred ? `
                    <div class="${overlayType}-overlay">
                        <div class="${overlayType}-badge" style="font-size: 0.6rem; padding: 0.15rem 0.3rem;">${overlayType === 'nsfw' ? 'NSFW' : 'WARNING'}</div>
                    </div>
                ` : ''}
                ${!showBlurred && videoData.duration ? `<span class="video-duration" style="font-size: 0.65rem; padding: 0.1rem 0.3rem;">${formatDuration(videoData.duration)}</span>` : ''}
                ${boostIndicatorHTML}
            </div>
            <div class="sidebar-video-info">
                <h4 class="sidebar-video-title">${videoData.title}</h4>
                <div class="sidebar-video-meta">
                    <span class="sidebar-channel-name">${displayName}</span>
                    <span class="sidebar-video-time">${formatTimestamp(event.created_at)}<span class="video-views" data-event-id="${event.id}">${(() => { const c = getCachedViewCount(event.id); return c !== null ? ` • ${formatNumber(c)} ${t('stat.views')}` : ''; })()}</span></span>
                    ${isNSFW ? '<span style="color: #ff0000; font-size: 0.65rem;">NSFW</span>' : ''}
                    ${showCommunityWarning && !showNSFWOverlay ? '<span style="color: #ff9800; font-size: 0.65rem;">⚠</span>' : ''}
                </div>
            </div>
        </div>
    `;
}

// Auto-play next video overlay functions
function showNextVideoOverlay() {
    if (!nextVideoData) return;

    const videoPlayer = document.querySelector('.video-player');
    if (!videoPlayer) return;

    // Remove any existing overlay
    hideNextVideoOverlay();

    const circumference = 2 * Math.PI * 16; // radius = 16

    // Determine warning status
    const showNSFWOverlay = nextVideoData.isNSFW && !shouldShowNSFW();
    const showCommunityWarning = (nextVideoData.isRatioed || nextVideoData.isSuspicious) && !sessionRatioedAllowed.has(nextVideoData.eventId) && !shouldSkipCommunityWarning();
    const hasWarning = showNSFWOverlay || showCommunityWarning;
    const warningType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    // Determine click handler - show modal if has warning
    const clickHandler = hasWarning
        ? (showNSFWOverlay ? `showNSFWModal('playVideo', '${nextVideoData.eventId}')` : `showRatioedModal('${nextVideoData.eventId}')`)
        : 'playNextVideo()';

    const overlay = document.createElement('div');
    overlay.className = 'next-video-overlay';
    overlay.id = 'nextVideoOverlay';
    overlay.innerHTML = `
        <div class="overlay-header">
            <div class="countdown-ring">
                <svg viewBox="0 0 40 40">
                    <circle class="bg" cx="20" cy="20" r="16"></circle>
                    <circle class="progress" cx="20" cy="20" r="16"
                        stroke-dasharray="${circumference}"
                        stroke-dashoffset="0"></circle>
                </svg>
                <span class="countdown-number">${AUTO_PLAY_COUNTDOWN_SECONDS}</span>
            </div>
            <span>Up next</span>
        </div>
        <div class="next-video-card" onclick="${clickHandler}">
            <div class="next-video-thumbnail ${hasWarning ? warningType : ''}">
                ${nextVideoData.thumbnail ?
                    `<img src="${nextVideoData.thumbnail}" alt="${nextVideoData.title}"${hasWarning ? ' style="filter: blur(10px);"' : ''}>` :
                    '<div style="width:100%;height:100%;background:var(--bg-primary);"></div>'
                }
                ${hasWarning ? `
                    <div class="${warningType}-overlay" style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;">
                        <div class="${warningType}-badge" style="font-size:0.7rem;padding:0.2rem 0.4rem;">${showNSFWOverlay ? 'NSFW' : 'WARNING'}</div>
                    </div>
                ` : ''}
            </div>
            <div class="next-video-info">
                <div class="next-video-title">${nextVideoData.title}</div>
                <div class="next-video-channel">
                    ${nextVideoData.channelName}
                    ${nextVideoData.isNSFW ? '<span style="color:#ff0000;font-size:0.7rem;margin-left:0.3rem;">NSFW</span>' : ''}
                    ${showCommunityWarning && !showNSFWOverlay ? '<span style="color:#ff9800;font-size:0.7rem;margin-left:0.3rem;">⚠</span>' : ''}
                </div>
            </div>
        </div>
        <div class="overlay-actions">
            <button class="overlay-btn cancel" onclick="cancelAutoPlay()">Cancel</button>
            <button class="overlay-btn play-now" onclick="${clickHandler}">${hasWarning ? 'View' : 'Play Now'}</button>
        </div>
    `;

    videoPlayer.appendChild(overlay);

    // Start countdown
    let secondsLeft = AUTO_PLAY_COUNTDOWN_SECONDS;
    const progressCircle = overlay.querySelector('.progress');
    const countdownNumber = overlay.querySelector('.countdown-number');

    autoPlayCountdownTimer = setInterval(() => {
        secondsLeft--;
        countdownNumber.textContent = secondsLeft;

        // Update progress ring
        const offset = circumference * (1 - secondsLeft / AUTO_PLAY_COUNTDOWN_SECONDS);
        progressCircle.style.strokeDashoffset = offset;

        if (secondsLeft <= 0) {
            clearInterval(autoPlayCountdownTimer);
            autoPlayCountdownTimer = null;

            // If warning, show modal instead of auto-playing
            if (hasWarning) {
                hideNextVideoOverlay();
                if (showNSFWOverlay) {
                    showNSFWModal('playVideo', nextVideoData.eventId);
                } else {
                    showRatioedModal(nextVideoData.eventId);
                }
            } else {
                playNextVideo();
            }
        }
    }, 1000);
}

function hideNextVideoOverlay() {
    if (autoPlayCountdownTimer) {
        clearInterval(autoPlayCountdownTimer);
        autoPlayCountdownTimer = null;
    }

    const overlay = document.getElementById('nextVideoOverlay');
    if (overlay) {
        overlay.remove();
    }
}

function cancelAutoPlay() {
    hideNextVideoOverlay();
}

function playNextVideo() {
    hideNextVideoOverlay();

    if (nextVideoData && nextVideoData.eventId) {
        navigateTo(`/video/${nextVideoData.eventId}`);
    }
}

// Sticky sidebar scroll handler
let stickyScrollHandler = null;
let sidebarPlaceholder = null;

function setupStickySidebar() {
    // Clean up previous handler if exists
    if (stickyScrollHandler) {
        window.removeEventListener('scroll', stickyScrollHandler);
        window.removeEventListener('resize', stickyScrollHandler);
        stickyScrollHandler = null;
    }

    // Remove any existing placeholder
    if (sidebarPlaceholder) {
        sidebarPlaceholder.remove();
        sidebarPlaceholder = null;
    }

    const sidebar = document.getElementById('recommendationsSidebarDesktop');
    if (!sidebar) return;

    const wrapper = document.querySelector('.video-content-wrapper');
    if (!wrapper) return;

    const headerHeight = 60; // --header-height
    const topOffset = headerHeight + 16; // 1rem gap
    const sidebarWidth = sidebar.offsetWidth;

    // Create placeholder to reserve space when sidebar is fixed
    sidebarPlaceholder = document.createElement('div');
    sidebarPlaceholder.className = 'sidebar-placeholder';
    sidebarPlaceholder.style.width = `${sidebarWidth}px`;
    sidebarPlaceholder.style.flexShrink = '0';
    sidebarPlaceholder.style.display = 'none';
    sidebar.parentNode.insertBefore(sidebarPlaceholder, sidebar.nextSibling);

    stickyScrollHandler = () => {
        const wrapperRect = wrapper.getBoundingClientRect();
        const sidebarHeight = sidebar.offsetHeight;

        // Check if we should be sticky
        if (wrapperRect.top <= topOffset) {
            // Calculate how far down we can go
            const maxScroll = wrapperRect.bottom - sidebarHeight - topOffset;

            if (maxScroll > 0) {
                // Sidebar should be fixed - show placeholder to reserve space
                sidebar.classList.add('is-sticky');
                sidebarPlaceholder.style.display = 'block';
                // Calculate the right position based on wrapper
                const containerRight = window.innerWidth - wrapperRect.right;
                sidebar.style.right = `${containerRight}px`;
                sidebar.style.transform = '';
            } else {
                // Sidebar should stick to bottom of wrapper
                sidebar.classList.remove('is-sticky');
                sidebarPlaceholder.style.display = 'none';
                sidebar.style.right = '';
                sidebar.style.transform = `translateY(${wrapperRect.height - sidebarHeight}px)`;
            }
        } else {
            // Not scrolled enough, sidebar at natural position
            sidebar.classList.remove('is-sticky');
            sidebarPlaceholder.style.display = 'none';
            sidebar.style.right = '';
            sidebar.style.transform = '';
        }
    };

    window.addEventListener('scroll', stickyScrollHandler, { passive: true });
    // Also handle resize
    window.addEventListener('resize', stickyScrollHandler, { passive: true });
    // Initial call
    stickyScrollHandler();
}

// Function to load watch history page
// Progressive watch history loading - renders videos as they arrive
async function loadWatchHistory() {
    currentView = 'history';

    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const skeletonCount = cardsPerRow * 10; // 10 rows of skeletons
    const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');

    mainContent.innerHTML = `
        <div class="history-header" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem;">
            <h2 style="margin: 0;">Watched History</h2>
            <div style="display: flex; gap: 0.75rem; align-items: center;">
                <div class="history-search-container" style="position: relative;">
                    <input type="text" id="historySearch" placeholder="${t('placeholder.searchHistory')}"
                           style="padding: 0.5rem 0.75rem 0.5rem 2.25rem; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-secondary); color: var(--text-primary); width: 200px; font-size: 0.875rem;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); color: var(--text-secondary);">
                        <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                    </svg>
                </div>
                <button id="clearHistoryBtn" class="action-btn" style="padding: 0.5rem 1rem; border-radius: 8px; font-size: 0.875rem;" onclick="confirmClearHistory()">
                    Clear All
                </button>
            </div>
        </div>
        <!-- Live Streams Section -->
        <div id="historyLiveSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <circle cx="12" cy="12" r="4" fill="#f44336"/>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                </svg>
                Live Streams
            </h3>
            <div class="video-grid" id="historyLiveGrid"></div>
        </div>
        <!-- Shorts Section -->
        <div id="historyShortsSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M10 8l6 4-6 4V8z"/>
                </svg>
                Shorts
            </h3>
            <div class="shorts-grid" id="historyShortsGrid"></div>
        </div>
        <!-- Videos Section -->
        <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                </svg>
                Videos
            </h3>
        <div class="video-grid" id="videoGrid">
            ${skeletons}
        </div>
    `;

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('historyShortsGrid');
    const shortsSection = document.getElementById('historyShortsSection');
    const liveGrid = document.getElementById('historyLiveGrid');
    const liveSection = document.getElementById('historyLiveSection');
    const searchInput = document.getElementById('historySearch');

    const history = getWatchHistory();

    if (history.length === 0) {
        videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noWatchHistory')}</p>`;
        return;
    }

    const historyIds = history.map(item => item.id);
    const historyOrder = new Map(historyIds.map((id, i) => [id, i]));

    // Progressive rendering state
    const videoMap = new Map();
    const shortMap = new Map();
    const liveMap = new Map();
    const renderedVideoIds = new Set();
    const renderedShortIds = new Set();
    const renderedLiveIds = new Set();
    let hasCleared = false;
    let renderTimeout = null;
    let firstRenderDone = false;

    // Create card HTML with history remove button
    const createHistoryCard = (event, type = 'video') => {
        const profile = profileCache.get(event.pubkey);
        const reactions = reactionsCache.get(event.id);
        const isFirstRow = type === 'short' ? renderedShortIds.size < cardsPerRow :
                          type === 'live' ? renderedLiveIds.size < cardsPerRow :
                          renderedVideoIds.size < cardsPerRow;

        let cardHTML;
        if (type === 'short') {
            cardHTML = createShortCard(event, profile, reactions);
        } else if (type === 'live') {
            const liveData = parseLiveEvent(event);
            if (!liveData) return null;
            const isEnded = liveData.status === 'ended';
            cardHTML = createLiveStreamCard(event, liveData, profile, isEnded);
        } else {
            cardHTML = createVideoCard(event, profile, reactions, false, null, !isFirstRow);
        }

        if (!cardHTML) return null;

        // Add remove from history button to the card
        const removeBtn = `<button class="history-remove-btn" onclick="event.stopPropagation(); removeFromHistory('${event.id}')" title="${t('button.removeFromHistory')}">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
            </svg>
        </button>`;

        // Add history-card class to the card (both shorts and videos use video-card class)
        // Short cards have "video-card short-card", regular videos have just "video-card"
        cardHTML = cardHTML.replace('<div class="video-card', '<div class="video-card history-card');

        // Insert remove button inside the video-thumbnail div (after opening tag)
        // Find the video-thumbnail div and insert the button right after it opens
        const thumbnailMatch = cardHTML.match(/<div class="video-thumbnail[^>]*>/);
        if (thumbnailMatch) {
            const insertPos = cardHTML.indexOf(thumbnailMatch[0]) + thumbnailMatch[0].length;
            cardHTML = cardHTML.slice(0, insertPos) + removeBtn + cardHTML.slice(insertPos);
        }

        return cardHTML;
    };

    // Render video card in history order
    const renderVideoInOrder = (event, targetGrid, renderedIds, orderMap, type = 'video') => {
        const cardId = type === 'live' ? `live-card-${event.id}` : `video-card-${event.id}`;
        if (document.getElementById(cardId)) return;
        // Also check by data attribute for live streams
        if (type === 'live' && document.querySelector(`[data-live-event-id="${event.id}"]`)) return;

        // Clear skeletons on first render (videos only)
        if (type === 'video' && !hasCleared) {
            hasCleared = true;
            videoGrid.innerHTML = '';
        }

        const cardHTML = createHistoryCard(event, type);
        if (!cardHTML) return;

        // Load profile immediately if not cached
        loadProfileAndUpdateCards(event.pubkey);

        // Load boosts if not cached (fire-and-forget)
        if (!boostsCache.has(event.id)) {
            loadBoostsForVideo(event.id, (totalBoosts) => {
                const card = document.getElementById(`video-card-${event.id}`);
                if (!card) return;
                const boostLevel = getBoostLevel(totalBoosts);
                const isBoosted = boostLevel > 0;
                if (isBoosted) {
                    card.classList.add('boosted', `boost-level-${boostLevel}`);
                    for (let i = 1; i <= 4; i++) {
                        if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                    }
                    const thumbnail = card.querySelector('.video-thumbnail');
                    if (thumbnail) {
                        const existingIndicator = thumbnail.querySelector('.boost-indicator');
                        const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                        if (existingIndicator) {
                            existingIndicator.outerHTML = indicatorHTML;
                        } else {
                            thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                        }
                    }
                }
            });
        }

        // Find correct position based on history order
        const eventOrder = orderMap.get(event.id) ?? 999;
        const cardSelector = type === 'short' ? '.short-card' : '.video-card';
        const existingCards = targetGrid.querySelectorAll(cardSelector);
        let inserted = false;

        for (const card of existingCards) {
            const existingId = card.dataset.liveEventId || card.id.replace('video-card-', '').replace('live-card-', '');
            const existingOrder = orderMap.get(existingId) ?? 999;
            if (eventOrder < existingOrder) {
                card.insertAdjacentHTML('beforebegin', cardHTML);
                inserted = true;
                break;
            }
        }

        if (!inserted) {
            targetGrid.insertAdjacentHTML('beforeend', cardHTML);
        }

        // Set the ID on the card (live stream cards already have data-live-event-id)
        if (type !== 'live') {
            const insertedCard = targetGrid.querySelector(`${cardSelector}:not([id])`);
            if (insertedCard) {
                insertedCard.id = cardId;
            }
        }

        renderedIds.add(event.id);
        observeLazyCards();

        // Load boosts for live streams
        if (type === 'live' && !boostsCache.has(event.id)) {
            loadBoostsForVideo(event.id);
        }
    };

    // Progressive render function
    const renderProgressively = () => {
        // Process all content in history order, separating by type
        historyIds.forEach(id => {
            const event = videoMap.get(id) || shortMap.get(id) || liveMap.get(id);
            if (!event) return;

            // Skip legacy events when addressable counterpart exists
            if (shouldSkipLegacyEvent(event)) return;

            // Determine content type
            const isLive = event.kind === NIP53_LIVE_EVENT_KIND;
            const isShort = isNip71ShortKind(event.kind);

            if (isLive) {
                if (!renderedLiveIds.has(event.id)) {
                    liveSection.style.display = 'block';
                    renderVideoInOrder(event, liveGrid, renderedLiveIds, historyOrder, 'live');
                }
            } else if (isShort) {
                if (!renderedShortIds.has(event.id)) {
                    shortsSection.style.display = 'block';
                    renderVideoInOrder(event, shortsGrid, renderedShortIds, historyOrder, 'short');
                }
            } else {
                if (!renderedVideoIds.has(event.id)) {
                    renderVideoInOrder(event, videoGrid, renderedVideoIds, historyOrder, 'video');
                }
            }
        });
        firstRenderDone = true;
    };

    // Debounced render (immediate on first event)
    const scheduleRender = () => {
        if (renderTimeout) clearTimeout(renderTimeout);
        if (!firstRenderDone) {
            renderProgressively();
        } else {
            renderTimeout = setTimeout(renderProgressively, 50);
        }
    };

    // Fetch history videos in batches with progressive rendering
    const BATCH_SIZE = 50;
    const idBatches = [];
    for (let i = 0; i < historyIds.length; i += BATCH_SIZE) {
        idBatches.push(historyIds.slice(i, i + BATCH_SIZE));
    }

    // Process all batches - render as videos arrive
    idBatches.forEach(batch => {
        // Fetch regular videos
        const videoFilter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            ids: batch
        };

        requestEventsStream(videoFilter, (event) => {
            allEvents.set(event.id, event);

            // Separate shorts from videos
            if (isNip71ShortKind(event.kind)) {
                shortMap.set(event.id, event);
            } else {
                videoMap.set(event.id, event);
            }
            scheduleRender();
        }, () => {
            // Batch complete
            clearTimeout(renderTimeout);
            renderProgressively();
        });

        // Also fetch live streams (they use kind 30311)
        const liveFilter = {
            kinds: [NIP53_LIVE_EVENT_KIND],
            ids: batch
        };

        requestEventsStream(liveFilter, (event) => {
            allEvents.set(event.id, event);
            liveMap.set(event.id, event);
            scheduleRender();
        }, () => {
            // Live stream batch complete
            clearTimeout(renderTimeout);
            renderProgressively();
        });
    });

    // After a delay, check if no content found
    setTimeout(() => {
        if (renderedVideoIds.size === 0 && renderedShortIds.size === 0 && renderedLiveIds.size === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosInHistory')}</p>`;
        } else if (renderedVideoIds.size === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthHistory')}</p>`;
        }
    }, 3000);

    // Display function for search filtering
    function displayHistoryVideos(videos, shorts) {
        videoGrid.innerHTML = '';
        shortsGrid.innerHTML = '';
        renderedVideoIds.clear();
        renderedShortIds.clear();

        if (videos.length === 0 && shorts.length === 0) {
            shortsSection.style.display = 'none';
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noMatchingVideos')}</p>`;
            return;
        }

        // Render shorts
        if (shorts.length > 0) {
            shortsSection.style.display = 'block';
            for (const event of shorts) {
                const cardHTML = createHistoryCard(event, true);
                if (cardHTML) {
                    shortsGrid.insertAdjacentHTML('beforeend', cardHTML);
                    renderedShortIds.add(event.id);
                }
            }
        } else {
            shortsSection.style.display = 'none';
        }

        // Render videos
        if (videos.length > 0) {
            for (const event of videos) {
                const cardHTML = createHistoryCard(event, false);
                if (cardHTML) {
                    videoGrid.insertAdjacentHTML('beforeend', cardHTML);
                    renderedVideoIds.add(event.id);
                }
            }
        } else {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthVideos')}</p>`;
        }

        observeLazyCards();
    }

    // Search functionality
    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.toLowerCase().trim();

        searchTimeout = setTimeout(() => {
            // Get current videos and shorts
            const allMedia = historyIds
                .map(id => videoMap.get(id) || shortMap.get(id))
                .filter(Boolean)
                .filter(event => !shouldSkipLegacyEvent(event));

            if (!query) {
                const shorts = allMedia.filter(e => isNip71ShortKind(e.kind));
                const videos = allMedia.filter(e => !isNip71ShortKind(e.kind));
                displayHistoryVideos(videos, shorts);
                return;
            }

            const filteredMedia = allMedia.filter(event => {
                const videoData = parseAnyVideoEvent(event);
                if (!videoData) return false;

                const title = (videoData.title || '').toLowerCase();
                const description = (videoData.description || '').toLowerCase();
                const tags = (videoData.tags || []).map(t => t.toLowerCase());

                return title.includes(query) ||
                       description.includes(query) ||
                       tags.some(tag => tag.includes(query));
            });

            const filteredShorts = filteredMedia.filter(e => isNip71ShortKind(e.kind));
            const filteredVideos = filteredMedia.filter(e => !isNip71ShortKind(e.kind));
            displayHistoryVideos(filteredVideos, filteredShorts);
        }, 300);
    });
}

// Remove a single video from watch history
function removeFromHistory(eventId) {
    try {
        // Use the removeFromWatchHistory function which syncs to Nostr
        removeFromWatchHistory(eventId);

        // Remove the card from the UI
        const card = document.getElementById(`video-card-${eventId}`);
        if (card) {
            card.remove();
        }

        showToast('Removed from history', 'success');
    } catch (e) {
        console.error('Failed to remove from history:', e);
        showToast('Failed to remove from history', 'error');
    }
}

// Confirm clear history dialog
function confirmClearHistory() {
    showConfirmModal(
        'Clear Watch History',
        'Are you sure you want to clear your entire watch history? This cannot be undone.',
        () => {
            clearWatchHistory();
            loadWatchHistory();
        },
        { confirmText: 'Clear History', danger: true }
    );
}

// Static pages
function loadAboutPage() {
    currentView = 'about';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>About Plebs</h1>

            <section class="static-section">
                <h2>What is Plebs?</h2>
                <p>Plebs is a censorship-resistant, decentralized video platform built on the <a href="https://nostr.com" target="_blank" rel="noopener">Nostr protocol</a>. Unlike traditional video platforms controlled by corporations, Plebs gives you true ownership of your content and identity.</p>
            </section>

            <section class="static-section">
                <h2>Why Nostr?</h2>
                <p>Nostr (Notes and Other Stuff Transmitted by Relays) is a simple, open protocol that enables a truly decentralized social network. Key benefits include:</p>
                <ul>
                    <li><strong>Censorship Resistance:</strong> No single entity can ban you or remove your content</li>
                    <li><strong>Portability:</strong> Your identity and followers work across all Nostr apps</li>
                    <li><strong>No Central Authority:</strong> No company owns or controls the network</li>
                    <li><strong>Cryptographic Identity:</strong> Your keys prove you are who you say you are</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>How It Works</h2>
                <p>Videos on Plebs are stored using <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom</a>, a distributed file storage system, while video metadata and social interactions are broadcast to Nostr relays. This means your content isn't stored on our servers - it's distributed across the network.</p>
            </section>

            <section class="static-section">
                <h2>Features</h2>
                <ul>
                    <li>Upload and share videos with the Nostr community</li>
                    <li>Like, comment, and share videos using Nostr reactions</li>
                    <li>Zap creators with Bitcoin via the Lightning Network</li>
                    <li>Follow your favorite creators across any Nostr app</li>
                    <li>Browse topics and discover new content</li>
                    <li>Works with any Nostr identity (use existing keys)</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>Open Source</h2>
                <p>Plebs is open source software. You can view the code, contribute, or run your own instance:</p>
                <p><a href="https://github.com/Spl0itable/plebs-app" target="_blank" rel="noopener" class="accent-link">GitHub Repository</a></p>
            </section>

            <section class="static-section">
                <h2>Built By</h2>
                <p>Plebs is developed by <a href="https://nostrservices.com" target="_blank" rel="noopener" class="accent-link">21 Million LLC</a>, a company dedicated to building tools for the Bitcoin and Nostr ecosystem.</p>
            </section>
        </div>
    `;
}

function loadContactPage() {
    currentView = 'contact';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>Contact Us</h1>

            <section class="static-section">
                <h2>Get In Touch</h2>
                <p>Have questions, feedback, or need support? We'd love to hear from you!</p>
            </section>

            <section class="static-section">
                <h2>Email</h2>
                <p>The best way to reach us is through Email:</p>
                <p><a href="mailto:support@plebs.app" class="accent-link">support@plebs.app</a></p>
            </section>

            <section class="static-section">
                <h2>GitHub</h2>
                <p>For bug reports, feature requests, or technical issues, please open an issue on our GitHub repository:</p>
                <p><a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener" class="accent-link">GitHub Issues</a></p>
            </section>

            <section class="static-section">
                <h2>Company</h2>
                <p>Plebs is developed by 21 Million LLC</p>
                <p><a href="https://nostrservices.com" target="_blank" rel="noopener" class="accent-link">nostrservices.com</a></p>
            </section>
        </div>
    `;
}

function loadTermsPage() {
    currentView = 'terms';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>Terms of Service</h1>
            <p class="last-updated">Last updated: December 2024</p>

            <section class="static-section">
                <h2>1. Acceptance of Terms</h2>
                <p>By accessing and using Plebs ("the Service"), you agree to be bound by these Terms of Service. If you do not agree to these terms, please do not use the Service.</p>
            </section>

            <section class="static-section">
                <h2>2. Description of Service</h2>
                <p>Plebs is a decentralized video platform built on the Nostr protocol. The Service provides an interface to browse, upload, and interact with video content stored across distributed networks. Plebs does not host or store video content on centralized servers.</p>
            </section>

            <section class="static-section">
                <h2>3. User Responsibilities</h2>
                <p>You are responsible for:</p>
                <ul>
                    <li>Maintaining the security of your Nostr private keys</li>
                    <li>All content you upload or share through the Service</li>
                    <li>Ensuring your use complies with applicable laws</li>
                    <li>Not uploading illegal, infringing, or harmful content</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>4. Content Guidelines</h2>
                <p>You agree not to upload, share, or distribute:</p>
                <ul>
                    <li>Content that infringes on intellectual property rights</li>
                    <li>Illegal content including but not limited to child exploitation material</li>
                    <li>Content that promotes violence or harm to others</li>
                    <li>Spam, malware, or deceptive content</li>
                </ul>
                <p>Adult content (NSFW) must be properly labeled using the NSFW tag when uploading.</p>
            </section>

            <section class="static-section">
                <h2>5. Decentralized Nature</h2>
                <p>Due to the decentralized nature of Nostr and Blossom storage:</p>
                <ul>
                    <li>Content may persist on the network even after deletion requests</li>
                    <li>We cannot guarantee removal of content from all relays or storage servers</li>
                    <li>Your content and interactions are public by default</li>
                    <li>You are solely responsible for your private key security</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>6. No Warranty</h2>
                <p>The Service is provided "as is" without warranties of any kind. We do not guarantee continuous, uninterrupted access to the Service.</p>
            </section>

            <section class="static-section">
                <h2>7. Limitation of Liability</h2>
                <p>To the maximum extent permitted by law, Plebs and its operators shall not be liable for any indirect, incidental, special, or consequential damages arising from your use of the Service.</p>
            </section>

            <section class="static-section">
                <h2>8. Changes to Terms</h2>
                <p>We reserve the right to modify these terms at any time. Continued use of the Service after changes constitutes acceptance of the new terms.</p>
            </section>

            <section class="static-section">
                <h2>9. Contact</h2>
                <p>For questions about these Terms, please <a href="#/contact" class="accent-link">contact us</a>.</p>
            </section>
        </div>
    `;
}

function loadPrivacyPage() {
    currentView = 'privacy';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>Privacy Policy</h1>
            <p class="last-updated">Last updated: December 2024</p>

            <section class="static-section">
                <h2>1. Overview</h2>
                <p>Plebs is committed to protecting your privacy. This policy explains how we handle information when you use our decentralized video platform.</p>
            </section>

            <section class="static-section">
                <h2>2. Decentralized Architecture</h2>
                <p>Plebs is built on Nostr, a decentralized protocol. This means:</p>
                <ul>
                    <li>Your content is broadcast to public relays, not stored on our servers</li>
                    <li>Your Nostr public key serves as your identity</li>
                    <li>Videos are stored on distributed Blossom servers</li>
                    <li>We do not have access to your private keys</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>3. Information We Collect</h2>
                <p><strong>Information stored locally in your browser:</strong></p>
                <ul>
                    <li>Your Nostr public key (when logged in)</li>
                    <li>Watch history and preferences</li>
                    <li>Theme and settings preferences</li>
                    <li>Private key (only if you choose local key storage - not recommended)</li>
                </ul>
                <p><strong>Information we may collect:</strong></p>
                <ul>
                    <li>Basic analytics (page views, feature usage) to improve the service</li>
                    <li>Error logs for debugging purposes</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>4. Public Information</h2>
                <p>When using Nostr, the following is public by design:</p>
                <ul>
                    <li>Your Nostr public key and profile information</li>
                    <li>Videos you upload</li>
                    <li>Comments, likes, and other reactions</li>
                    <li>Who you follow</li>
                    <li>Zaps (Lightning payments) you send or receive</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>5. Data Storage</h2>
                <p>Local data is stored in your browser's localStorage. You can clear this data at any time through your browser settings. Content published to Nostr is distributed across relays and cannot be controlled or deleted by Plebs.</p>
            </section>

            <section class="static-section">
                <h2>6. Third-Party Services</h2>
                <p>Plebs interacts with:</p>
                <ul>
                    <li>Nostr relays (for social data)</li>
                    <li>Blossom servers (for video storage)</li>
                    <li>Lightning Network (for zaps/payments)</li>
                </ul>
                <p>Each of these services has their own privacy practices.</p>
            </section>

            <section class="static-section">
                <h2>7. Your Rights</h2>
                <p>You can:</p>
                <ul>
                    <li>Clear your local browser data at any time</li>
                    <li>Browse videos without creating an account</li>
                    <li>Use a Nostr browser extension for enhanced privacy</li>
                    <li>Choose which relays and Blossom servers to use</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>8. Security</h2>
                <p>We recommend:</p>
                <ul>
                    <li>Using a Nostr browser extension or hardware signer</li>
                    <li>Never sharing your private key (nsec)</li>
                    <li>Using a dedicated browser profile for enhanced privacy</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>9. Changes to This Policy</h2>
                <p>We may update this policy from time to time. Changes will be posted on this page with an updated revision date.</p>
            </section>

            <section class="static-section">
                <h2>10. Contact</h2>
                <p>For privacy-related questions, please <a href="#/contact" class="accent-link">contact us</a>.</p>
            </section>
        </div>
    `;
}

function loadFaqPage() {
    currentView = 'faq';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>Frequently Asked Questions</h1>

            <div class="faq-category">
                <h2>About Plebs</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            What is Plebs?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Plebs is a censorship-resistant, decentralized video platform built on the Nostr protocol. Unlike traditional video platforms controlled by corporations, Plebs gives you true ownership of your content and identity. There are no central servers that can ban you or remove your content.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Is Plebs free to use?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Yes, Plebs is completely free to use for watching videos. You can browse and watch content without creating an account. To upload videos, comment, like, or interact with other users, you'll need a Nostr identity (which is also free).
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Who develops Plebs?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Plebs is developed by <a href="https://nostrservices.com" target="_blank" rel="noopener">21 Million LLC</a>, a company dedicated to building tools for the Bitcoin and Nostr ecosystem. Plebs is open source, and you can view the code or contribute on <a href="https://github.com/Spl0itable/plebs-app" target="_blank" rel="noopener">GitHub</a>.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>Nostr Protocol</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            What is Nostr?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Nostr stands for "Notes and Other Stuff Transmitted by Relays." It's a simple, open protocol that enables a truly decentralized social network. Unlike traditional platforms, Nostr doesn't rely on any central server. Instead, it uses a network of relays to transmit messages between users, and cryptographic keys for identity.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Why does Plebs use Nostr?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Nostr provides several key benefits:
                                <ul>
                                    <li><strong>Censorship Resistance:</strong> No single entity can ban you or remove your content</li>
                                    <li><strong>Portability:</strong> Your identity and followers work across all Nostr apps</li>
                                    <li><strong>No Central Authority:</strong> No company owns or controls the network</li>
                                    <li><strong>Cryptographic Identity:</strong> Your keys prove you are who you say you are</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            What are Nostr keys (npub/nsec)?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Your Nostr identity consists of two keys: a public key (npub) and a private key (nsec). Your npub is like your username - you can share it with anyone. Your nsec is like your password - never share it! Anyone with your nsec can post as you and access your account. We recommend using a browser extension like Alby or nos2x to manage your keys securely.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Can I use my existing Nostr account?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Absolutely! If you already have a Nostr identity from apps like Damus, Primal, Amethyst, or any other Nostr client, you can use the same keys to log into Plebs. Your followers, profile, and reputation carry over automatically.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            What are Nostr relays?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Relays are servers that store and transmit Nostr messages. When you post something, it gets sent to multiple relays. Other users connect to relays to read messages. Because there are many independent relays, no single one can censor you - if one relay blocks you, your content still exists on others.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>Video Storage & Blossom</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Where are videos stored?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Videos are stored on Blossom servers, not on Plebs itself. Blossom is a distributed file storage system designed to work with Nostr. When you upload a video, it goes to one or more Blossom servers of your choice. The video metadata (title, description, etc.) is published to Nostr relays.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            What is Blossom?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Blossom is an open protocol for storing and serving media files in a decentralized way. Files are identified by their SHA-256 hash, which means the same file will have the same address regardless of which server hosts it. This enables redundancy - your files can exist on multiple servers. Learn more at <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom GitHub</a>.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Does Plebs host my videos?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                No. Plebs is a client/interface that helps you browse and upload content, but it doesn't store any video or image files. All media is stored on independent Blossom servers. Plebs simply displays content from these distributed storage providers.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Can I choose which Blossom server to use?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Yes! You can configure which Blossom servers you want to use for uploading in your settings. You can even run your own Blossom server if you want complete control over your media storage.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>Features & Usage</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            How do I create an account?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Click the "Login" button and choose your preferred method:
                                <ul>
                                    <li><strong>Browser Extension:</strong> If you have a Nostr extension like Alby or nos2x installed, you can use it to sign in securely</li>
                                    <li><strong>Generate New Keys:</strong> Create a brand new Nostr identity</li>
                                    <li><strong>Import Keys:</strong> Use your existing Nostr private key (nsec)</li>
                                </ul>
                                We recommend using a browser extension for the best security.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            What are Zaps?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Zaps are Bitcoin payments sent over the Lightning Network. They allow you to send real money (satoshis, or "sats") to content creators as tips or appreciation. Unlike traditional platform tips that take large fees, zaps go directly to the creator. To send zaps, you need a Lightning wallet with a Nostr connection (like Alby or Zeus).
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            How do I upload a video?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                First, make sure you're logged in. Then click the upload button in the header. Select your video file, add a title, description, and tags. The video will be uploaded to your configured Blossom server, and the metadata will be published to Nostr relays.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            What is NSFW content and how do I access it?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                NSFW (Not Safe For Work) content is adult material that is hidden by default. To view NSFW content, go to Settings and enable the NSFW toggle. When uploading adult content, always tag it as NSFW so others can filter appropriately.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            How does the recommendation system work?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Plebs shows recommendations based on what's popular, recent content, and content from creators you follow. There's no algorithmic manipulation trying to maximize your engagement or show you controversial content. What you see is based on transparent metrics like views, likes, and zaps.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Can I watch live streams?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Yes! Plebs supports live streaming via Nostr. You can watch live streams from the Live section in the sidebar. Live streams include real-time chat and zapping capabilities. To go live yourself, you'll need streaming software that supports Nostr.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>Self-Moderation</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            How does moderation work on a decentralized platform?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Unlike traditional platforms with centralized moderators, Plebs puts you in control of what you see. We provide powerful self-moderation tools including content filter packs, user muting, community warnings, and ratioed video indicators. You decide what content is appropriate for you - there's no central authority making those decisions.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            What are Content Filter Packs?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Content Filter Packs are predefined keyword filters you can enable to hide specific types of content. Available packs include:
                                <ul>
                                    <li><strong>Racism & Hate Speech:</strong> Filters racial slurs and discriminatory content</li>
                                    <li><strong>Sexually Explicit:</strong> Filters pornographic and adult content</li>
                                    <li><strong>Violence & Gore:</strong> Filters graphic violence and self-harm content</li>
                                    <li><strong>Drugs & Substances:</strong> Filters drug-related content</li>
                                    <li><strong>Spam & Scams:</strong> Filters common spam and scam patterns</li>
                                    <li><strong>Cryptocurrency:</strong> Filters crypto promotion and token shilling</li>
                                    <li><strong>Political Content:</strong> Filters partisan political content</li>
                                    <li><strong>Strong Profanity:</strong> Filters vulgar language</li>
                                </ul>
                                Enable these in Settings > Content Filters. You can also add custom keywords. Filtered content shows a placeholder with a "Show anyway" button if you want to view it temporarily.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            How do I mute a user?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                To mute a user, visit their profile and click the mute button. Once muted, all their videos will be hidden from your feed, their comments will show as "Message from muted user," and their live chat messages will be hidden. Your mute list is stored on Nostr, so it syncs across devices. You can manage muted users in your Profile Settings under "Muted Users."
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            What does "Ratioed" mean?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                A video is marked as "ratioed" when it has significantly more dislikes than likes, indicating negative community reception. Specifically, a video is ratioed when it has at least 10 reactions, dislikes are at least double the likes, and dislikes make up 70% or more of total reactions. Ratioed videos display a warning badge, and you'll be asked to confirm before viewing.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            How do community warnings work?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Users can report content for various reasons (spam, illegal content, abuse, misleading, etc.). When a video or user receives 5 or more reports from people you follow, a warning indicator appears. This leverages your social graph - warnings come from your trusted network, not anonymous strangers. You can toggle "Show warnings from accounts I follow" in Settings.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            How do I report content?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Click the flag icon on any video, comment, or user profile to report it. Select a reason (Spam, Illegal, Abuse, Misleading, Impersonation, Copyright, or Other) and optionally add details. Reports are published to Nostr as events, making them transparent and decentralized. Your reports help others in your network identify problematic content.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>Privacy & Security</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Is my activity private?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                On Nostr, most activity is public by design. Your likes, comments, follows, and zaps are visible on the public network. However, Plebs stores your watch history locally in your browser - it's never sent to any server. You can clear your local data at any time.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            How do I keep my account secure?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Never share your private key (nsec) with anyone. We strongly recommend using a Nostr browser extension like Alby, nos2x, or a hardware signer. These keep your private key secure and only sign events when you approve them. Avoid storing your nsec directly in websites.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Can I delete my content?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                You can request deletion by publishing a delete event on Nostr. Most well-behaved relays and clients will respect this. However, due to the decentralized nature of the network, content may persist on some relays or Blossom servers. There's no central authority that can force complete deletion across the entire network.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="faq-category">
                <h2>Troubleshooting</h2>
                <div class="faq-accordion">
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            Videos aren't loading - what should I do?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                If videos aren't loading, try these steps:
                                <ul>
                                    <li>Refresh the page</li>
                                    <li>Check your internet connection</li>
                                    <li>The Blossom server hosting the video might be down - this is independent of Plebs</li>
                                    <li>Try disabling browser extensions that might block content</li>
                                    <li>Clear your browser cache and try again</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            I lost my private key - can you help me recover it?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                Unfortunately, no. Nostr keys are cryptographic - there's no password reset or account recovery because there's no central authority. This is why we strongly recommend backing up your keys and using a secure key management solution. If you lose your nsec, you'll need to create a new identity.
                            </div>
                        </div>
                    </div>
                    <div class="faq-item">
                        <button class="faq-question" onclick="toggleFaqItem(this)">
                            How do I report a bug or request a feature?
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </button>
                        <div class="faq-answer">
                            <div class="faq-answer-content">
                                You can report bugs or request features on our <a href="https://github.com/Spl0itable/plebs-app/issues" target="_blank" rel="noopener">GitHub Issues</a> page. You can also reach out to us on Nostr - visit our <a href="#/contact">Contact</a> page for details.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function toggleFaqItem(button) {
    const faqItem = button.parentElement;
    const wasActive = faqItem.classList.contains('active');

    // Close all other FAQ items in the same accordion
    const accordion = faqItem.closest('.faq-accordion');
    accordion.querySelectorAll('.faq-item').forEach(item => {
        item.classList.remove('active');
    });

    // Toggle the clicked item
    if (!wasActive) {
        faqItem.classList.add('active');
    }
}

function loadDmcaPage() {
    currentView = 'dmca';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="static-page">
            <h1>DMCA & Content Policy</h1>
            <p class="last-updated">Last updated: December 2024</p>

            <section class="static-section">
                <h2>Understanding Plebs' Architecture</h2>
                <p>Plebs is a decentralized video platform interface that operates differently from traditional video hosting services. It's important to understand how content is distributed on our platform:</p>
                <ul>
                    <li><strong>Plebs does not host any video or image content.</strong> We are a client/interface that displays content stored elsewhere.</li>
                    <li>All media files (videos, images, thumbnails) are stored on independent <strong>Blossom servers</strong> operated by third parties.</li>
                    <li>Video metadata (titles, descriptions, etc.) is published to <strong>Nostr relays</strong>, which are also independently operated.</li>
                    <li>Plebs simply aggregates and displays this distributed content through a user-friendly interface.</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>Filing a DMCA Claim</h2>
                <p>Because Plebs does not host content, we cannot directly remove infringing material. To address copyright infringement, you must contact the appropriate parties:</p>

                <h3 style="margin-top: 1rem; margin-bottom: 0.5rem; color: var(--text-primary);">1. For Video/Image Content</h3>
                <p>Media files are stored on Blossom servers. You need to:</p>
                <ul>
                    <li>Identify which Blossom server is hosting the content (the URL will indicate this)</li>
                    <li>Contact the Blossom server operator directly with your DMCA takedown request</li>
                    <li>Each Blossom server operates independently and has its own policies</li>
                </ul>

                <h3 style="margin-top: 1rem; margin-bottom: 0.5rem; color: var(--text-primary);">2. For Metadata/Descriptions</h3>
                <p>If infringing content is in the video title, description, or other metadata:</p>
                <ul>
                    <li>This information is stored on Nostr relays</li>
                    <li>Contact the specific Nostr relay operators where the content appears</li>
                    <li>Multiple relays may store the same data due to the distributed nature of Nostr</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>What Plebs Can Do</h2>
                <p>While we don't host content, we can:</p>
                <ul>
                    <li>Help you identify which Blossom servers or relays are hosting specific content</li>
                    <li>Add content to a local blocklist so it doesn't appear on our interface (note: this only affects plebs.app, not other Nostr clients)</li>
                    <li>Provide guidance on how to contact the appropriate service operators</li>
                </ul>
                <p>To request assistance, please <a href="#/contact" class="accent-link">contact us</a> with:</p>
                <ul>
                    <li>The URL or identifier of the infringing content</li>
                    <li>Proof of your copyright ownership</li>
                    <li>A description of the copyrighted work</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>Blossom Server Operators</h2>
                <p>If you operate a Blossom server and receive a DMCA takedown request, you are responsible for handling it according to your jurisdiction's laws. Common Blossom servers include independent operators who each have their own terms of service and takedown procedures.</p>
                <p>For a list of known Blossom servers, refer to the <a href="https://github.com/hzrd149/blossom" target="_blank" rel="noopener">Blossom project documentation</a>.</p>
            </section>

            <section class="static-section">
                <h2>Important Considerations</h2>
                <ul>
                    <li><strong>Decentralization:</strong> Due to the decentralized nature of Nostr and Blossom, complete removal of content from all sources may not be possible.</li>
                    <li><strong>Multiple Copies:</strong> Content may be mirrored across multiple Blossom servers, requiring separate takedown requests to each.</li>
                    <li><strong>Metadata Persistence:</strong> Even if media files are removed, metadata on Nostr relays may persist.</li>
                    <li><strong>No Central Control:</strong> There is no single entity that can remove content from the entire network.</li>
                </ul>
            </section>

            <section class="static-section">
                <h2>Counter-Notification</h2>
                <p>If you believe your content was wrongly removed from a Blossom server, you should contact that server's operator directly to file a counter-notification. Plebs is not involved in the hosting or moderation of content on Blossom servers.</p>
            </section>

            <section class="static-section">
                <h2>Contact</h2>
                <p>For questions about this policy or assistance identifying content hosts, please <a href="#/contact" class="accent-link">contact us</a>.</p>
            </section>
        </div>
    `;
}

// Admin page - only accessible by admin pubkey
async function loadAdminPage() {
    if (!isAdmin()) {
        showToast('Access denied. Admin only.', 'error');
        navigateTo('/');
        return;
    }

    currentView = 'admin';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = `
        <div class="admin-page">
            <div class="admin-header">
                <h1>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
                    </svg>
                    Admin Dashboard
                </h1>
            </div>

            <div class="admin-loading">
                <div class="spinner"></div>
                <p>Loading platform analytics...</p>
            </div>
        </div>
    `;

    // Load platform analytics
    await loadAdminAnalytics();
}

async function loadAdminAnalytics() {
    const mainContent = document.getElementById('mainContent');

    try {
        // Fetch global platform stats
        const now = Math.floor(Date.now() / 1000);
        const thirtyDaysAgo = now - (30 * 24 * 60 * 60);
        const sevenDaysAgo = now - (7 * 24 * 60 * 60);

        // Fetch all videos from the platform (use ALL_VIDEO_KINDS for complete coverage)
        const videoFilter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            limit: 500
        };

        const allVideos = [];
        await requestEventsStream(
            videoFilter,
            event => allVideos.push(event),
            { timeout: 15000 }
        );

        // Get unique creators
        const uniqueCreators = new Set(allVideos.map(v => v.pubkey));

        // Get all video IDs for scoped queries
        const allVideoIds = allVideos.map(v => v.id);

        // Count videos by time period
        const videosLast30Days = allVideos.filter(v => v.created_at >= thirtyDaysAgo).length;
        const videosLast7Days = allVideos.filter(v => v.created_at >= sevenDaysAgo).length;

        // Fetch boost zaps to admin's pubkey (boosts pay to platform)
        const boostZapsFilter = {
            kinds: [9735],
            '#p': [ADMIN_PUBKEY],
            since: thirtyDaysAgo,
            limit: 500
        };

        let totalBoostSats = 0;
        let boostCount = 0;
        await requestEventsStream(
            boostZapsFilter,
            event => {
                // Check if it's a boost payment
                const descTag = event.tags.find(t => t[0] === 'description');
                if (descTag) {
                    try {
                        const zapRequest = JSON.parse(descTag[1]);
                        const purposeTag = zapRequest.tags?.find(t => t[0] === 'purpose');
                        if (purposeTag && purposeTag[1] === 'boost') {
                            boostCount++;
                            const bolt11Tag = event.tags.find(t => t[0] === 'bolt11');
                            if (bolt11Tag) {
                                const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                if (amount) totalBoostSats += amount;
                            }
                        }
                    } catch (e) {}
                }
            },
            { timeout: 10000 }
        );

        // Count reactions only on Plebs videos (batch by video IDs)
        let totalLikes = 0;
        let totalDislikes = 0;

        // Track monthly active users (unique users who interacted per month)
        const sixMonthsAgo = now - (180 * 24 * 60 * 60);
        const userActivityByMonth = new Map(); // month key -> Set of pubkeys

        // Initialize months
        for (let i = 5; i >= 0; i--) {
            const date = new Date();
            date.setMonth(date.getMonth() - i);
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            userActivityByMonth.set(monthKey, new Set());
        }

        // Helper to add user activity for a given timestamp
        const trackUserActivity = (pubkey, timestamp) => {
            const date = new Date(timestamp * 1000);
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            if (userActivityByMonth.has(monthKey)) {
                userActivityByMonth.get(monthKey).add(pubkey);
            }
        };

        // Track creators from videos
        allVideos.forEach(v => {
            if (v.created_at >= sixMonthsAgo) {
                trackUserActivity(v.pubkey, v.created_at);
            }
        });

        if (allVideoIds.length > 0) {
            // Batch video IDs to avoid oversized queries
            const batchSize = 100;
            for (let i = 0; i < allVideoIds.length; i += batchSize) {
                const batch = allVideoIds.slice(i, i + batchSize);
                const reactionFilter = {
                    kinds: [7],
                    '#e': batch,
                    since: sixMonthsAgo,
                    limit: 2000
                };

                await requestEventsStream(
                    reactionFilter,
                    event => {
                        // Track user activity
                        trackUserActivity(event.pubkey, event.created_at);
                        // Count only last 30 days for summary stats
                        if (event.created_at >= thirtyDaysAgo) {
                            if (event.content === '+' || event.content === '🤙') totalLikes++;
                            else if (event.content === '-') totalDislikes++;
                        }
                    },
                    { timeout: 15000 }
                );
            }

            // Also fetch comments for user tracking
            for (let i = 0; i < allVideoIds.length; i += batchSize) {
                const batch = allVideoIds.slice(i, i + batchSize);
                const commentFilter = {
                    kinds: [1],
                    '#e': batch,
                    since: sixMonthsAgo,
                    limit: 1000
                };

                await requestEventsStream(
                    commentFilter,
                    event => {
                        trackUserActivity(event.pubkey, event.created_at);
                    },
                    { timeout: 10000 }
                );
            }
        }

        // Convert to monthly active users data
        const monthlyActiveUsers = Array.from(userActivityByMonth.entries()).map(([month, users]) => ({
            month,
            users: users.size
        }));

        // Render admin dashboard
        renderAdminDashboard({
            totalVideos: allVideos.length,
            videosLast30Days,
            videosLast7Days,
            uniqueCreators: uniqueCreators.size,
            totalBoostSats,
            boostCount,
            totalLikes,
            totalDislikes,
            blockedEvents: adminBlocklist.events.size,
            blockedPubkeys: adminBlocklist.pubkeys.size,
            monthlyActiveUsers
        });

    } catch (error) {
        console.error('Failed to load admin analytics:', error);
        mainContent.innerHTML = `
            <div class="admin-page">
                <div class="admin-header">
                    <h1>Admin Dashboard</h1>
                </div>
                <div class="admin-error">
                    <p>Failed to load analytics. Please try again.</p>
                    <button class="action-btn" onclick="loadAdminPage()">Retry</button>
                </div>
            </div>
        `;
    }
}

// Generate Monthly Active Users chart SVG for admin dashboard
function generateMAUChartSVG(monthlyActiveUsers) {
    if (!monthlyActiveUsers || monthlyActiveUsers.length === 0) {
        return '<p style="color: var(--text-secondary); text-align: center;">No data available</p>';
    }

    const values = monthlyActiveUsers.map(d => d.users);
    const maxValue = Math.max(...values, 1);

    const width = 600;
    const height = 200;
    const padding = { top: 20, right: 20, bottom: 50, left: 50 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;

    // Generate bars
    const barWidth = (chartWidth / monthlyActiveUsers.length) - 8;
    const bars = monthlyActiveUsers.map((d, i) => {
        const x = padding.left + (i / monthlyActiveUsers.length) * chartWidth + 4;
        const barHeight = (d.users / maxValue) * chartHeight;
        const y = padding.top + chartHeight - barHeight;

        // Parse month for label
        const [year, month] = d.month.split('-');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const monthLabel = monthNames[parseInt(month) - 1];

        return `
            <g class="mau-bar-group">
                <rect class="mau-bar" x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="var(--accent)" rx="4" data-value="${d.users}" data-month="${monthLabel} ${year}" />
                <text class="mau-bar-value" x="${x + barWidth / 2}" y="${y - 8}" text-anchor="middle" fill="var(--text-primary)" font-size="12">${d.users > 0 ? formatNumber(d.users) : ''}</text>
            </g>
        `;
    }).join('');

    // X-axis labels (months)
    const xLabels = monthlyActiveUsers.map((d, i) => {
        const x = padding.left + (i / monthlyActiveUsers.length) * chartWidth + barWidth / 2 + 4;
        const [year, month] = d.month.split('-');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return `<text class="chart-label x-label" x="${x}" y="${height - 15}" text-anchor="middle" fill="var(--text-secondary)" font-size="11">${monthNames[parseInt(month) - 1]}</text>`;
    }).join('');

    // Y-axis labels
    const yLabels = [];
    const ySteps = 4;
    for (let i = 0; i <= ySteps; i++) {
        const value = Math.round((maxValue / ySteps) * (ySteps - i));
        const y = padding.top + (i / ySteps) * chartHeight;
        yLabels.push(`<text class="chart-label y-label" x="${padding.left - 10}" y="${y + 4}" text-anchor="end" fill="var(--text-secondary)" font-size="11">${formatNumber(value)}</text>`);
    }

    // Grid lines
    const gridLines = [];
    for (let i = 0; i <= ySteps; i++) {
        const y = padding.top + (i / ySteps) * chartHeight;
        gridLines.push(`<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="var(--border-color)" stroke-opacity="0.3" />`);
    }

    return `
        <svg class="mau-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
            <!-- Grid lines -->
            ${gridLines.join('')}

            <!-- Bars -->
            ${bars}

            <!-- Y-axis labels -->
            ${yLabels.join('')}

            <!-- X-axis labels -->
            ${xLabels}
        </svg>
    `;
}

function renderAdminDashboard(stats) {
    const mainContent = document.getElementById('mainContent');

    // Generate MAU chart
    const mauChartHTML = generateMAUChartSVG(stats.monthlyActiveUsers);

    mainContent.innerHTML = `
        <div class="admin-page">
            <div class="admin-header">
                <h1>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
                    </svg>
                    Admin Dashboard
                </h1>
            </div>

            <!-- Platform Overview -->
            <section class="admin-section">
                <h2>Platform Overview</h2>
                <div class="admin-stats-grid">
                    <div class="admin-stat-card">
                        <div class="stat-icon videos">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M18 4l2 4h-3l-2-4h-2l2 4h-3l-2-4H8l2 4H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.totalVideos)}</div>
                            <div class="stat-label">Total Videos</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon new">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.videosLast7Days)}</div>
                            <div class="stat-label">Videos (7 days)</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon month">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11zM9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.videosLast30Days)}</div>
                            <div class="stat-label">Videos (30 days)</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon creators">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.uniqueCreators)}</div>
                            <div class="stat-label">Unique Creators</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon likes">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.totalLikes)}</div>
                            <div class="stat-label">Likes (30 days)</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon dislikes">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.totalDislikes)}</div>
                            <div class="stat-label">Dislikes (30 days)</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Monthly Active Users Chart -->
            <section class="admin-section">
                <h2>Monthly Active Users</h2>
                <p class="admin-section-desc">Unique users who uploaded videos, reacted, or commented each month (last 6 months)</p>
                <div class="mau-chart-container">
                    ${mauChartHTML}
                </div>
            </section>

            <!-- Boost Revenue -->
            <section class="admin-section">
                <h2>Boost Revenue (Last 30 Days)</h2>
                <div class="admin-stats-grid boost-revenue">
                    <div class="admin-stat-card highlight">
                        <div class="stat-icon boosts">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatSats(stats.totalBoostSats)} sats</div>
                            <div class="stat-label">Total Boost Revenue</div>
                        </div>
                    </div>
                    <div class="admin-stat-card">
                        <div class="stat-icon count">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(stats.boostCount)}</div>
                            <div class="stat-label">Total Boosts</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Blocklist Management -->
            <section class="admin-section">
                <h2>Blocklist Management</h2>
                <p class="admin-section-desc">Block specific videos or users from appearing on the platform. Use this for DMCA compliance or removing illegal content.</p>

                <div class="blocklist-summary">
                    <div class="blocklist-stat">
                        <span class="blocklist-count">${stats.blockedEvents}</span>
                        <span class="blocklist-label">Blocked Videos</span>
                    </div>
                    <div class="blocklist-stat">
                        <span class="blocklist-count">${stats.blockedPubkeys}</span>
                        <span class="blocklist-label">Blocked Users</span>
                    </div>
                </div>

                <!-- Block Event ID -->
                <div class="blocklist-section">
                    <h3>Block Video by Event ID</h3>
                    <div class="blocklist-input-group">
                        <input type="text" id="blockEventInput" placeholder="${t('placeholder.eventId')}" class="blocklist-input">
                        <button class="action-btn danger" onclick="addBlockedEvent()">Block Video</button>
                    </div>
                </div>

                <!-- Block Pubkey -->
                <div class="blocklist-section">
                    <h3>Block User by Pubkey</h3>
                    <div class="blocklist-input-group">
                        <input type="text" id="blockPubkeyInput" placeholder="${t('placeholder.pubkey')}" class="blocklist-input">
                        <button class="action-btn danger" onclick="addBlockedPubkey()">Block User</button>
                    </div>
                </div>

                <!-- Current Blocked Events -->
                <div class="blocklist-section">
                    <h3>Blocked Videos (${stats.blockedEvents})</h3>
                    <div class="blocklist-items" id="blockedEventsList">
                        ${Array.from(adminBlocklist.events).map(eventId => `
                            <div class="blocklist-item">
                                <code>${eventId.slice(0, 16)}...${eventId.slice(-8)}</code>
                                <button class="remove-btn" onclick="removeBlockedEvent('${eventId}')" title="Unblock">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                                    </svg>
                                </button>
                            </div>
                        `).join('') || '<p class="empty-list">No blocked videos</p>'}
                    </div>
                </div>

                <!-- Current Blocked Pubkeys -->
                <div class="blocklist-section">
                    <h3>Blocked Users (${stats.blockedPubkeys})</h3>
                    <div class="blocklist-items" id="blockedPubkeysList">
                        ${Array.from(adminBlocklist.pubkeys).map(pubkey => `
                            <div class="blocklist-item">
                                <code>${pubkey.slice(0, 16)}...${pubkey.slice(-8)}</code>
                                <button class="remove-btn" onclick="removeBlockedPubkey('${pubkey}')" title="Unblock">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                                    </svg>
                                </button>
                            </div>
                        `).join('') || '<p class="empty-list">No blocked users</p>'}
                    </div>
                </div>
            </section>
        </div>
    `;
}

// Blocklist management functions
async function addBlockedEvent() {
    if (!isAdmin()) return;

    const input = document.getElementById('blockEventInput');
    let eventId = input.value.trim();

    if (!eventId) {
        showToast('Please enter an event ID', 'warning');
        return;
    }

    // Try to decode if it's nevent or note format
    if (eventId.startsWith('nevent1') || eventId.startsWith('note1')) {
        try {
            const decoded = window.NostrTools.nip19.decode(eventId);
            eventId = decoded.type === 'nevent' ? decoded.data.id : decoded.data;
        } catch (e) {
            showToast('Invalid event ID format', 'error');
            return;
        }
    }

    // Validate hex format
    if (!/^[a-f0-9]{64}$/i.test(eventId)) {
        showToast('Invalid event ID (must be 64 hex characters)', 'error');
        return;
    }

    eventId = eventId.toLowerCase();

    if (adminBlocklist.events.has(eventId)) {
        showToast('Event already blocked', 'warning');
        return;
    }

    adminBlocklist.events.add(eventId);

    // Publish to Nostr
    showToast('Publishing blocklist to Nostr...', 'info');
    const success = await publishAdminBlocklist();

    if (success) {
        input.value = '';
        showToast('Video blocked and published to Nostr', 'success');
        loadAdminPage();
    } else {
        // Revert on failure
        adminBlocklist.events.delete(eventId);
        showToast('Failed to publish blocklist', 'error');
    }
}

async function removeBlockedEvent(eventId) {
    if (!isAdmin()) return;

    adminBlocklist.events.delete(eventId);

    // Publish to Nostr
    showToast('Publishing blocklist to Nostr...', 'info');
    const success = await publishAdminBlocklist();

    if (success) {
        showToast('Video unblocked and published to Nostr', 'success');
        loadAdminPage();
    } else {
        // Revert on failure
        adminBlocklist.events.add(eventId);
        showToast('Failed to publish blocklist', 'error');
    }
}

async function addBlockedPubkey() {
    if (!isAdmin()) return;

    const input = document.getElementById('blockPubkeyInput');
    let pubkey = input.value.trim();

    if (!pubkey) {
        showToast('Please enter a pubkey', 'warning');
        return;
    }

    // Try to decode if it's npub format
    if (pubkey.startsWith('npub1')) {
        try {
            const decoded = window.NostrTools.nip19.decode(pubkey);
            pubkey = decoded.data;
        } catch (e) {
            showToast('Invalid npub format', 'error');
            return;
        }
    }

    // Validate hex format
    if (!/^[a-f0-9]{64}$/i.test(pubkey)) {
        showToast('Invalid pubkey (must be 64 hex characters)', 'error');
        return;
    }

    pubkey = pubkey.toLowerCase();

    // Don't allow blocking yourself
    if (pubkey === ADMIN_PUBKEY) {
        showToast('Cannot block the admin account', 'error');
        return;
    }

    if (adminBlocklist.pubkeys.has(pubkey)) {
        showToast('User already blocked', 'warning');
        return;
    }

    adminBlocklist.pubkeys.add(pubkey);

    // Publish to Nostr
    showToast('Publishing blocklist to Nostr...', 'info');
    const success = await publishAdminBlocklist();

    if (success) {
        input.value = '';
        showToast('User blocked and published to Nostr', 'success');
        loadAdminPage();
    } else {
        // Revert on failure
        adminBlocklist.pubkeys.delete(pubkey);
        showToast('Failed to publish blocklist', 'error');
    }
}

async function removeBlockedPubkey(pubkey) {
    if (!isAdmin()) return;

    adminBlocklist.pubkeys.delete(pubkey);

    // Publish to Nostr
    showToast('Publishing blocklist to Nostr...', 'info');
    const success = await publishAdminBlocklist();

    if (success) {
        showToast('User unblocked and published to Nostr', 'success');
        loadAdminPage();
    } else {
        // Revert on failure
        adminBlocklist.pubkeys.add(pubkey);
        showToast('Failed to publish blocklist', 'error');
    }
}

// Function to handle boost button click
async function handleBoost(eventId) {
    if (!await ensureLoggedIn()) {
        return;
    }

    // Check if user is blocked
    if (isPubkeyBlocked(currentUser.pubkey)) {
        showToast('Your account has been restricted', 'error');
        return;
    }

    // Fixed 100 sats for boost
    showBoostAmountModal(eventId);
}

// Show boost amount selection modal (100 sats fixed)
function showBoostAmountModal(eventId) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        padding: 1rem;
    `;

    modal.innerHTML = `
    <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center;">
        <h2 style="margin-bottom: 1.5rem; background: linear-gradient(135deg, #f7931a, #ff9500); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Boost This Video</h2>
        <p style="font-size: 1.2rem; margin-bottom: 1.5rem;">Use Bitcoin Lightning + Nostr Zap to Boost for <strong>100 sats</strong> to help this video trend!</p>
        <p style="font-size: 1.2rem; margin-bottom: 1.5rem;">Videos that are boosted will also be highlighted throughout the app and their highlight will grow brighter the more they're boosted.</p>
        
        <div style="display: flex; gap: 0.5rem; justify-content: center;">
            <button onclick="processBoost('${eventId}', 100); this.closest('div[style*=fixed]').remove();"
                    style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #f7931a, #ff9500);
                           color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500;
                           display: flex; align-items: center; gap: 0.5rem;">
                Boost for 100 sats <svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg>
            </button>
            <button onclick="this.closest('div[style*=fixed]').remove();"
                    style="padding: 0.5rem 1.5rem; background: var(--bg-primary); color: var(--text-primary);
                           border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                Cancel
            </button>
        </div>
    </div>
`;

    document.body.appendChild(modal);
}

// Process the boost
async function processBoost(eventId, amount) {
    try {
        // Show generating invoice modal immediately
        showGeneratingInvoiceModal(amount, 'boost');

        // Create boost zap request
        const boostZapRequest = {
            kind: 9734,
            created_at: Math.floor(Date.now() / 1000),
            tags: [
                ['p', 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df'],
                ['amount', amount.toString()],
                ['relays', ...RELAY_URLS],
                ['e', eventId],
                ['purpose', 'boost']
            ],
            content: ''
        };

        // For live streams, also add the #a tag for persistence across stream updates
        const targetEvent = allEvents.get(eventId);
        if (targetEvent && targetEvent.kind === NIP53_LIVE_EVENT_KIND) {
            const liveData = parseLiveEvent(targetEvent);
            if (liveData) {
                const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${targetEvent.pubkey}:${liveData.dTag}`;
                boostZapRequest.tags.push(['a', aTagValue]);
            }
        }

        const signedZapRequest = await signEvent(boostZapRequest);

        // Fetch invoice from walletofsatoshi
        const lnurlResponse = await fetchBoostInvoice(amount, JSON.stringify(signedZapRequest));

        if (lnurlResponse.pr) {
            showBoostInvoice(lnurlResponse.pr, amount, eventId);

            // Poll for zap receipt
            pollForBoostReceipt(eventId, amount);

            if (window.webln) {
                try {
                    await window.webln.enable();
                    const result = await window.webln.sendPayment(lnurlResponse.pr);
                    if (result.preimage) {
                        // Payment successful through WebLN
                    }
                } catch (e) {
                    console.log('WebLN payment failed, waiting for manual payment');
                }
            }
        }
    } catch (error) {
        console.error('Failed to create boost:', error);
        // Remove generating invoice modal on error
        const generatingModal = document.getElementById('generating-invoice-modal');
        if (generatingModal) generatingModal.remove();
        showToast('Failed to create boost. Please try again.', 'error');
    }
}

// Fetch boost invoice from walletofsatoshi
async function fetchBoostInvoice(amount, zapRequest) {
    const url = `https://wallet.yakihonne.com/.well-known/lnurlp/69420`;

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.callback) {
            const invoiceUrl = new URL(data.callback);
            invoiceUrl.searchParams.set('amount', amount * 1000); // millisats
            invoiceUrl.searchParams.set('nostr', zapRequest);

            const invoiceResponse = await fetch(invoiceUrl.toString());
            return await invoiceResponse.json();
        }
    } catch (error) {
        console.error('Failed to fetch boost invoice:', error);
        throw error;
    }
}

// Show boost invoice modal
function showBoostInvoice(invoice, amount, eventId) {
    // Remove generating invoice modal
    const generatingModal = document.getElementById('generating-invoice-modal');
    if (generatingModal) generatingModal.remove();

    const modal = document.createElement('div');
    modal.id = 'boost-invoice-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        padding: 1rem;
    `;

    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center;">
            <h2 style="margin-bottom: 0.5rem; background: linear-gradient(135deg, #f7931a, #ff9500); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Lightning Invoice</h2>
            <p style="margin-bottom: 1rem; color: var(--text-secondary);">Boost ${amount} sats</p>
            <p style="margin-bottom: 1rem;">Scan with your Lightning wallet:</p>
            
            <div style="background: white; padding: 1rem; border-radius: 8px; margin: 1rem auto; display: inline-block;">
                <div id="boost-qrcode"></div>
            </div>
            
            <div style="margin: 1rem 0; color: var(--text-secondary); font-size: 0.875rem;">
                <div id="boost-payment-status">
                    <div class="spinner" style="width: 20px; height: 20px; margin: 0 auto 0.5rem;"></div>
                    Waiting for payment confirmation...
                </div>
            </div>
            
            <textarea readonly style="width: 100%; padding: 0.5rem; margin: 1rem 0; font-size: 0.75rem; word-break: break-all; 
                                     height: 100px; resize: none; background: var(--bg-primary); color: var(--text-primary); 
                                     border: 1px solid var(--border); border-radius: 4px;">${invoice}</textarea>
            
            <div style="display: flex; gap: 0.5rem; justify-content: center;">
                <button onclick="navigator.clipboard.writeText('${invoice}').then(() => {
                    const btn = event.target;
                    const originalText = btn.textContent;
                    btn.textContent = t('button.copied');
                    btn.style.background = 'linear-gradient(135deg, #f7931a, #ff9500)';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 2000);
                });" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #f7931a, #ff9500); color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Copy Invoice
                </button>
                <button onclick="document.getElementById('boost-invoice-modal').remove();" 
                        style="padding: 0.5rem 1rem; background: var(--bg-primary); color: var(--text-primary); 
                               border: 1px solid var(--border); border-radius: 4px; cursor: pointer;">
                    Close
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // Generate QR code
    if (window.QRCode) {
        new QRCode(document.getElementById("boost-qrcode"), {
            text: invoice.toUpperCase(),
            width: 256,
            height: 256,
            colorDark: "#000000",
            colorLight: "#FFFFFF",
            correctLevel: QRCode.CorrectLevel.L
        });
    }
}

// Poll for boost zap receipt
async function pollForBoostReceipt(eventId, amount) {
    const startTime = Date.now();
    const timeout = 60000; // 60 seconds
    const pollInterval = 2000; // 2 seconds

    // Check if this is a live stream to use #a tag for persistence
    const targetEvent = allEvents.get(eventId);
    let aTagValue = null;
    if (targetEvent && targetEvent.kind === NIP53_LIVE_EVENT_KIND) {
        const liveData = parseLiveEvent(targetEvent);
        if (liveData) {
            aTagValue = `${NIP53_LIVE_EVENT_KIND}:${targetEvent.pubkey}:${liveData.dTag}`;
        }
    }

    const checkForReceipt = async () => {
        if (Date.now() - startTime > timeout) {
            console.log('Boost receipt polling timeout');
            return;
        }

        // Use #a tag for live streams, #e tag for regular videos
        const filter = {
            kinds: [9735],
            since: Math.floor(startTime / 1000) - 10
        };
        if (aTagValue) {
            filter['#a'] = [aTagValue];
        } else {
            filter['#e'] = [eventId];
        }

        let foundReceipt = false;

        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                try {
                    // Check if this is a boost zap to walletofsatoshi
                    const pTag = event.tags.find(tag => tag[0] === 'p');
                    if (pTag && pTag[1] === 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df') {
                        const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                        if (bolt11Tag && bolt11Tag[1]) {
                            const receiptAmount = extractAmountFromBolt11(bolt11Tag[1]);

                            if (Math.abs(receiptAmount - amount) < 10) {
                                foundReceipt = true;

                                // Close invoice modal
                                const invoiceModal = document.getElementById('boost-invoice-modal');
                                if (invoiceModal) {
                                    invoiceModal.remove();
                                }

                                // Show success animation
                                showBoostSuccess(amount);

                                // Update boost cache
                                const currentBoosts = boostsCache.get(eventId) || 0;
                                const newBoostTotal = currentBoosts + amount;
                                boostsCache.set(eventId, newBoostTotal);

                                // Update boost button
                                updateBoostButton(eventId, newBoostTotal);

                                // Update video/live stream cards with new boost level and indicator
                                const newBoostLevel = getBoostLevel(newBoostTotal);
                                if (newBoostLevel > 0) {
                                    const boostIndicatorHTML = `
                                        <div class="boost-indicator">
                                            <svg viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                                            </svg>
                                            ${formatSats(newBoostTotal)}
                                        </div>
                                    `;

                                    // Update cards by data-live-event-id (live stream cards)
                                    document.querySelectorAll(`.video-card[data-live-event-id="${eventId}"]`).forEach(card => {
                                        card.classList.add('boosted', `boost-level-${newBoostLevel}`);
                                        for (let i = 1; i <= 4; i++) {
                                            if (i !== newBoostLevel) card.classList.remove(`boost-level-${i}`);
                                        }
                                        // Add or update boost indicator
                                        const thumbnail = card.querySelector('.video-thumbnail');
                                        let indicator = thumbnail?.querySelector('.boost-indicator');
                                        if (indicator) {
                                            indicator.remove();
                                        }
                                        if (thumbnail) {
                                            thumbnail.insertAdjacentHTML('beforeend', boostIndicatorHTML);
                                        }
                                    });
                                    // Update cards by data-event-id (regular video cards)
                                    document.querySelectorAll(`.video-card[data-event-id="${eventId}"]`).forEach(card => {
                                        card.classList.add('boosted', `boost-level-${newBoostLevel}`);
                                        for (let i = 1; i <= 4; i++) {
                                            if (i !== newBoostLevel) card.classList.remove(`boost-level-${i}`);
                                        }
                                        // Add or update boost indicator
                                        const thumbnail = card.querySelector('.video-thumbnail');
                                        let indicator = thumbnail?.querySelector('.boost-indicator');
                                        if (indicator) {
                                            indicator.remove();
                                        }
                                        if (thumbnail) {
                                            thumbnail.insertAdjacentHTML('beforeend', boostIndicatorHTML);
                                        }
                                    });
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error checking boost receipt:', e);
                }
            }, () => {
                resolve();
            });
        });

        if (!foundReceipt) {
            setTimeout(checkForReceipt, pollInterval);
        }
    };

    setTimeout(checkForReceipt, 2000);
}

// Show boost success animation
function showBoostSuccess(amount) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
    `;

    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 3rem; border-radius: 12px; text-align: center;">
            <div class="boost-success-animation">
                <svg width="120" height="120" viewBox="0 0 24 24" fill="url(#boostGradient)" style="margin-bottom: 1rem;">
                    <defs>
                        <linearGradient id="boostGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#f7931a;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff9500;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                </svg>
                <h2 style="background: linear-gradient(135deg, #f7931a, #ff9500); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 0.5rem;">Video Boosted!</h2>
                <p style="font-size: 1.5rem; font-weight: bold;">${amount} sats</p>
            </div>
        </div>
    `;

    const style = document.createElement('style');
    style.textContent = `
        .boost-success-animation {
            animation: boostPulse 0.5s ease-out;
        }
        
        @keyframes boostPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
    `;
    document.head.appendChild(style);

    document.body.appendChild(modal);

    setTimeout(() => {
        modal.style.opacity = '0';
        modal.style.transition = 'opacity 0.3s ease-out';
        setTimeout(() => {
            modal.remove();
            style.remove();
        }, 300);
    }, 2000);
}

// Update boost button UI
function updateBoostButton(eventId, totalBoosts) {
    const boostBtn = document.querySelector(`.action-btn.boost[data-event-id="${eventId}"]`);
    if (boostBtn) {
        boostBtn.querySelector('.count').textContent = totalBoosts > 0 ? formatSats(totalBoosts) : 'Boost';
        if (totalBoosts > 0) {
            boostBtn.classList.add('active');
        }
    }
}

// Update boost indicators on all video cards matching an event ID
function updateBoostIndicatorsOnCards(eventId, totalBoosts) {
    const boostLevel = getBoostLevel(totalBoosts);
    const isBoosted = boostLevel > 0;

    if (!isBoosted) return;

    const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;

    // Find cards by ID (regular video cards)
    const cardById = document.getElementById(`video-card-${eventId}`);
    if (cardById) {
        updateCardBoostClasses(cardById, boostLevel, indicatorHTML);
    }

    // Find cards by data-event-id (sidebar cards, etc.)
    document.querySelectorAll(`.video-card[data-event-id="${eventId}"]`).forEach(card => {
        updateCardBoostClasses(card, boostLevel, indicatorHTML);
    });

    // Find cards by data-live-event-id (live stream cards)
    document.querySelectorAll(`.video-card[data-live-event-id="${eventId}"]`).forEach(card => {
        updateCardBoostClasses(card, boostLevel, indicatorHTML);
    });
}

// Helper to update boost classes and indicator on a single card
function updateCardBoostClasses(card, boostLevel, indicatorHTML) {
    card.classList.add('boosted', `boost-level-${boostLevel}`);
    for (let i = 1; i <= 4; i++) {
        if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
    }
    const thumbnail = card.querySelector('.video-thumbnail');
    if (thumbnail) {
        const existingIndicator = thumbnail.querySelector('.boost-indicator');
        if (existingIndicator) {
            existingIndicator.outerHTML = indicatorHTML;
        } else {
            thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
        }
    }
}

// Load boosts for video
async function loadBoostsForVideo(eventId, onUpdate = null) {
    // Check if this is a live stream to use #a tag for persistence
    const targetEvent = allEvents.get(eventId);
    let filter;

    if (targetEvent && targetEvent.kind === NIP53_LIVE_EVENT_KIND) {
        const liveData = parseLiveEvent(targetEvent);
        if (liveData) {
            const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${targetEvent.pubkey}:${liveData.dTag}`;
            filter = {
                kinds: [9735],
                '#a': [aTagValue],
                '#p': ['d49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df']
            };
        }
    }

    // Fallback to #e tag for regular videos or if live data not available
    if (!filter) {
        filter = {
            kinds: [9735],
            '#e': [eventId],
            '#p': ['d49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df']
        };
    }

    let totalBoosts = 0;

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            try {
                // Check if this has the purpose=boost tag
                const description = event.tags.find(tag => tag[0] === 'description')?.[1];
                if (description) {
                    try {
                        const zapRequest = JSON.parse(description);
                        const hasBoostTag = zapRequest.tags?.some(tag =>
                            tag[0] === 'purpose' && tag[1] === 'boost'
                        );

                        if (hasBoostTag) {
                            const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                            if (bolt11Tag && bolt11Tag[1]) {
                                const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                if (amount > 0) {
                                    totalBoosts += amount;

                                    if (onUpdate) {
                                        onUpdate(totalBoosts);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        // If we can't parse description, skip this event
                    }
                }
            } catch (e) {
                console.error('Failed to parse boost:', e);
            }
        }, () => {
            boostsCache.set(eventId, totalBoosts);
            // Automatically update all cards with this event ID
            if (totalBoosts > 0) {
                updateBoostIndicatorsOnCards(eventId, totalBoosts);
            }
            resolve(totalBoosts);
        });
    });
}

// Load boosts for multiple videos (tracks per-video, not merged)
async function loadBoostsForVideos(eventIds, onUpdate = null) {
    if (!eventIds || eventIds.length === 0) {
        if (onUpdate) onUpdate(0);
        return 0;
    }

    const filter = {
        kinds: [9735],
        '#e': eventIds,
        '#p': ['d49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df']
    };

    const boostsByEvent = new Map(); // Track boosts per event ID
    const seenBoostIds = new Set(); // Prevent double-counting

    // Initialize all event IDs with 0
    eventIds.forEach(id => boostsByEvent.set(id, 0));

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            // Skip if we've already counted this boost
            if (seenBoostIds.has(event.id)) return;
            seenBoostIds.add(event.id);

            try {
                // Check if this has the purpose=boost tag
                const description = event.tags.find(tag => tag[0] === 'description')?.[1];
                if (description) {
                    try {
                        const zapRequest = JSON.parse(description);
                        const hasBoostTag = zapRequest.tags?.some(tag =>
                            tag[0] === 'purpose' && tag[1] === 'boost'
                        );

                        if (hasBoostTag) {
                            const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                            if (bolt11Tag && bolt11Tag[1]) {
                                const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                if (amount > 0) {
                                    // Find which event ID this boost belongs to
                                    const eTag = event.tags.find(tag => tag[0] === 'e' && eventIds.includes(tag[1]));
                                    if (eTag) {
                                        const targetEventId = eTag[1];
                                        const current = boostsByEvent.get(targetEventId) || 0;
                                        boostsByEvent.set(targetEventId, current + amount);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        // If we can't parse description, skip this event
                    }
                }
            } catch (e) {
                console.error('Failed to parse boost:', e);
            }
        }, () => {
            // Cache and update each event ID separately
            let totalBoosts = 0;
            boostsByEvent.forEach((amount, eventId) => {
                boostsCache.set(eventId, amount);
                totalBoosts += amount;
                if (amount > 0) {
                    updateBoostIndicatorsOnCards(eventId, amount);
                }
            });

            if (onUpdate) onUpdate(totalBoosts);
            resolve(totalBoosts);
        });
    });
}

// Calculate boost level for video card highlighting
function getBoostLevel(boostAmount) {
    if (boostAmount >= 10000) return 4;
    if (boostAmount >= 5000) return 3;
    if (boostAmount >= 1000) return 2;
    if (boostAmount >= 100) return 1;
    return 0;
}

// Function to handle zaps
async function handleZap(npub, amount, eventId = null) {
    if (!await ensureLoggedIn()) {
        return;
    }

    // Prevent self-zapping (to avoid gaming trending algorithm)
    try {
        const decoded = window.NostrTools.nip19.decode(npub);
        if (decoded.type === 'npub' && decoded.data === currentUser?.pubkey) {
            return; // Silently ignore self-zap attempts
        }
    } catch (e) {
        // If decoding fails, continue with the zap
    }

    showZapAmountModal(npub, eventId);
}

// Show zap amount selection modal
function showZapAmountModal(npub, eventId = null) {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        padding: 1rem;
    `;

    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center;">
            <h2 style="margin-bottom: 1.5rem;">Select Zap Amount</h2>
            <p style="font-size: 1.2rem; margin-bottom: 1.5rem;">Use Bitcoin Lightning + Nostr Zap to send sats directly to the content creator!</p>
            
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-bottom: 1.5rem;">
                <button class="zap-amount-btn" data-amount="21">21 <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="69">69 <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="420">420 <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="1337">1337 <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="5000">5k <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="10000">10k <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="21000">21k <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
                <button class="zap-amount-btn" data-amount="1000000">1M <svg width="14" height="14" viewBox="0 0 24 24" fill="#f7931a"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg></button>
            </div>
            
            <div style="margin-bottom: 1.5rem;">
                <input type="number" id="customZapAmount" placeholder="${t('placeholder.customAmount')}" min="1" 
                       style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border); 
                              border-radius: 8px; color: var(--text-primary); font-size: 1rem; text-align: center;">
            </div>
            
            <div style="display: flex; gap: 0.5rem; justify-content: center;">
                <button id="proceedZap" style="padding: 0.75rem 1.5rem; background: #f7931a; color: white; 
                                               border: none; border-radius: 8px; cursor: pointer; font-weight: 500;">
                    Continue with Custom Amount
                </button>
                <button onclick="this.closest('div[style*=fixed]').remove();" 
                        style="padding: 0.75rem 1.5rem; background: var(--bg-primary); color: var(--text-primary); 
                               border: 1px solid var(--border); border-radius: 8px; cursor: pointer;">
                    Cancel
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    const style = document.createElement('style');
    style.textContent = `
        .zap-amount-btn {
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        .zap-amount-btn svg {
            flex-shrink: 0;
        }
        .zap-amount-btn:hover {
            background: #f7931a;
            color: white;
            transform: translateY(-2px);
        }
        .zap-amount-btn:hover svg {
            fill: white;
        }
    `;
    modal.appendChild(style);

    modal.querySelectorAll('.zap-amount-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
            const amount = parseInt(btn.getAttribute('data-amount'));
            modal.remove();
            await processZap(npub, amount, eventId);
        });
    });

    const customInput = modal.querySelector('#customZapAmount');
    const proceedBtn = modal.querySelector('#proceedZap');

    customInput.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        if (value > 0) {
            proceedBtn.textContent = `Zap ${value} sats`;
        } else {
            proceedBtn.textContent = t('button.continueCustomAmount');
        }
    });

    proceedBtn.addEventListener('click', async () => {
        const amount = parseInt(customInput.value);
        if (amount > 0) {
            modal.remove();
            await processZap(npub, amount, eventId);
        } else {
            showToast('Please enter a valid amount', 'warning');
        }
    });
}

// Process the actual zap
async function processZap(npub, amount, eventId = null) {
    // Show generating invoice modal immediately
    showGeneratingInvoiceModal(amount);

    try {
        const zapRequest = {
            kind: 9734,
            created_at: Math.floor(Date.now() / 1000),
            tags: [
                ['p', window.NostrTools.nip19.decode(npub).data],
                ['amount', amount.toString()],
                ['relays', ...RELAY_URLS]
            ],
            content: ''
        };

        if (eventId) {
            zapRequest.tags.push(['e', eventId]);

            // For live streams, also add the #a tag for persistence across stream updates
            const targetEvent = allEvents.get(eventId);
            if (targetEvent && targetEvent.kind === NIP53_LIVE_EVENT_KIND) {
                const liveData = parseLiveEvent(targetEvent);
                if (liveData) {
                    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${targetEvent.pubkey}:${liveData.dTag}`;
                    zapRequest.tags.push(['a', aTagValue]);
                }
            }
        }

        const signedZapRequest = await signEvent(zapRequest);

        const lnurlResponse = await fetchLightningInvoice(npub, amount, JSON.stringify(signedZapRequest));

        // Remove generating modal
        const generatingModal = document.getElementById('generating-invoice-modal');
        if (generatingModal) generatingModal.remove();

        if (lnurlResponse.pr) {
            showLightningInvoice(lnurlResponse.pr, amount, !!window.webln);

            const paymentHash = extractPaymentHash(lnurlResponse.pr);
            pollForZapReceipt(window.NostrTools.nip19.decode(npub).data, amount, eventId, paymentHash);

            if (window.webln) {
                try {
                    await window.webln.enable();
                    const result = await window.webln.sendPayment(lnurlResponse.pr);
                    if (result.preimage) {
                        // Payment successful through WebLN
                    }
                } catch (e) {
                    console.log('WebLN payment failed, waiting for manual payment');
                }
            }
        } else {
            showToast('Failed to generate invoice. User may not have Lightning enabled.', 'error');
        }
    } catch (error) {
        // Remove generating modal on error
        const generatingModal = document.getElementById('generating-invoice-modal');
        if (generatingModal) generatingModal.remove();

        console.error('Failed to create zap:', error);
        showToast('Failed to create zap. Please try again.', 'error');
    }
}

// Show modal while generating invoice
function showGeneratingInvoiceModal(amount, type = 'zap') {
    const modal = document.createElement('div');
    modal.id = 'generating-invoice-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        padding: 1rem;
    `;

    const typeLabel = type === 'boost' ? 'boost' : 'zap';
    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 12px; max-width: 400px; width: 90%; text-align: center;">
            <div class="spinner" style="width: 48px; height: 48px; margin: 0 auto 1.5rem;"></div>
            <h2 style="margin-bottom: 0.5rem;">Generating Invoice</h2>
            <p style="color: var(--text-secondary);">Preparing ${formatNumber(amount)} sat ${typeLabel}...</p>
        </div>
    `;

    document.body.appendChild(modal);
}

// Track processed zap receipts to avoid duplicate handling
const processedZapReceipts = new Set();

// Function to poll for zap receipts
async function pollForZapReceipt(recipientPubkey, amount, eventId, paymentHash) {
    const startTime = Date.now();
    const timeout = 60000; // 60 seconds
    const pollInterval = 2000; // 2 seconds

    const checkForReceipt = async () => {
        if (Date.now() - startTime > timeout) {
            console.log('Zap receipt polling timeout');
            return;
        }

        const filter = {
            kinds: [9735],
            '#p': [recipientPubkey],
            since: Math.floor(startTime / 1000) - 10
        };

        if (eventId) {
            filter['#e'] = [eventId];
        }

        let foundReceipt = false;

        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                try {
                    // Skip if we've already processed this receipt
                    if (processedZapReceipts.has(event.id)) {
                        foundReceipt = true; // Still mark as found to stop polling
                        return;
                    }

                    const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                    if (bolt11Tag && bolt11Tag[1]) {
                        const receiptAmount = extractAmountFromBolt11(bolt11Tag[1]);

                        if (Math.abs(receiptAmount - amount) < 10) {
                            // Mark as processed to prevent duplicate handling
                            processedZapReceipts.add(event.id);
                            foundReceipt = true;

                            const invoiceModal = document.getElementById('lightning-invoice-modal');
                            if (invoiceModal) {
                                invoiceModal.remove();
                            }

                            showZapSuccess(amount);

                            if (eventId) {
                                // Check what type of zap this is and update only the relevant UI
                                const chatZapCount = document.querySelector(`.chat-zap-count[data-event-id="${eventId}"]`);
                                const commentZapBtn = document.querySelector(`.comment-zap-btn[data-comment-id="${eventId}"]`);
                                const liveZapBtn = document.querySelector(`.action-btn.zap[data-event-id="${eventId}"]`);

                                if (chatZapCount) {
                                    // This is a chat message zap - only update chat zap count
                                    const current = parseInt(chatZapCount.textContent) || 0;
                                    chatZapCount.textContent = formatSats(current + amount);
                                } else if (commentZapBtn) {
                                    // This is a video comment zap
                                    if (!currentCommentsState.zaps.has(eventId)) {
                                        currentCommentsState.zaps.set(eventId, { totalSats: 0, count: 0 });
                                    }
                                    const commentZapData = currentCommentsState.zaps.get(eventId);
                                    commentZapData.totalSats += amount;
                                    commentZapData.count++;

                                    const zapCountEl = commentZapBtn.querySelector('.zap-count');
                                    if (zapCountEl) {
                                        zapCountEl.textContent = formatNumber(commentZapData.totalSats);
                                    }
                                } else {
                                    // This is a video or live stream zap - load full zap data
                                    setTimeout(async () => {
                                        const zapData = await loadZapsForVideo(eventId);
                                        updateZapButton(eventId, zapData.totalZaps);

                                        // Update live stream zap button if on live stream page
                                        if (liveZapBtn && currentView === 'live') {
                                            liveZapBtn.classList.add('active');
                                        }
                                    }, 500);
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error checking zap receipt:', e);
                }
            }, () => {
                resolve();
            });
        });

        if (!foundReceipt) {
            setTimeout(checkForReceipt, pollInterval);
        }
    };

    setTimeout(checkForReceipt, 2000);
}

// Helper to extract payment hash from bolt11
function extractPaymentHash(bolt11) {
    return bolt11.slice(-20);
}

// Fetch lightning invoice from LNURL service
async function fetchLightningInvoice(npub, amount, zapRequest) {
    const pubkey = window.NostrTools.nip19.decode(npub).data;
    const profile = await loadUserProfile(pubkey);

    if (!profile) {
        throw new Error('Could not load user profile');
    }

    if (profile.lud16) {
        const [name, domain] = profile.lud16.split('@');
        const url = `https://${domain}/.well-known/lnurlp/${name}`;

        try {
            const response = await fetch(url);
            const data = await response.json();

            if (data.callback) {
                const invoiceUrl = new URL(data.callback);
                invoiceUrl.searchParams.set('amount', amount * 1000);
                invoiceUrl.searchParams.set('nostr', zapRequest);

                const invoiceResponse = await fetch(invoiceUrl.toString());
                return await invoiceResponse.json();
            }
        } catch (error) {
            console.error('Failed to fetch from lightning address:', error);
        }
    }

    if (profile.lud06) {
        try {
            const decoded = window.NostrTools.nip19.decode(profile.lud06);
            const url = decoded.data;

            const response = await fetch(url);
            const data = await response.json();

            if (data.callback) {
                const invoiceUrl = new URL(data.callback);
                invoiceUrl.searchParams.set('amount', amount * 1000);
                invoiceUrl.searchParams.set('nostr', zapRequest);

                const invoiceResponse = await fetch(invoiceUrl.toString());
                return await invoiceResponse.json();
            }
        } catch (error) {
            console.error('Failed to fetch from LNURL:', error);
        }
    }

    throw new Error('User does not have Lightning support');
}

// Show lightning invoice modal
function showLightningInvoice(invoice, amount, isWebLN = false) {
    const modal = document.createElement('div');
    modal.id = 'lightning-invoice-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        padding: 1rem;
    `;

    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%; text-align: center;">
            <h2 style="margin-bottom: 0.5rem;">Lightning Invoice</h2>
            <p style="margin-bottom: 1rem; color: var(--text-secondary);">Zap ${amount} sats</p>
            <p style="margin-bottom: 1rem;">${isWebLN ? 'Processing payment...' : 'Scan with your Lightning wallet:'}</p>
            
            <div style="background: white; padding: 1rem; border-radius: 8px; margin: 1rem auto; display: inline-block;">
                <div id="qrcode"></div>
            </div>
            
            <div style="margin: 1rem 0; color: var(--text-secondary); font-size: 0.875rem;">
                <div id="payment-status">
                    <div class="spinner" style="width: 20px; height: 20px; margin: 0 auto 0.5rem;"></div>
                    Waiting for payment confirmation...
                </div>
            </div>
            
            <textarea readonly style="width: 100%; padding: 0.5rem; margin: 1rem 0; font-size: 0.75rem; word-break: break-all; 
                                     height: 100px; resize: none; background: var(--bg-primary); color: var(--text-primary); 
                                     border: 1px solid var(--border); border-radius: 4px;">${invoice}</textarea>
            
            <div style="display: flex; gap: 0.5rem; justify-content: center;">
                <button onclick="navigator.clipboard.writeText('${invoice}').then(() => {
                    const btn = event.target;
                    const originalText = btn.textContent;
                    btn.textContent = t('button.copied');
                    btn.style.background = 'var(--accent)';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#f7931a';
                    }, 2000);
                });" style="padding: 0.5rem 1rem; background: #f7931a; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Copy Invoice
                </button>
                <button onclick="document.getElementById('lightning-invoice-modal').remove();" 
                        style="padding: 0.5rem 1rem; background: var(--bg-primary); color: var(--text-primary); 
                               border: 1px solid var(--border); border-radius: 4px; cursor: pointer;">
                    Close
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    if (window.QRCode) {
        new QRCode(document.getElementById("qrcode"), {
            text: invoice.toUpperCase(),
            width: 256,
            height: 256,
            colorDark: "#000000",
            colorLight: "#FFFFFF",
            correctLevel: QRCode.CorrectLevel.L
        });
    }
}

// Show zap success animation
function showZapSuccess(amount) {
    const invoiceModal = document.getElementById('lightning-invoice-modal');
    if (invoiceModal) {
        invoiceModal.remove();
    }

    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
    `;

    modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 3rem; border-radius: 12px; text-align: center;">
            <div class="zap-success-animation">
                <svg width="120" height="120" viewBox="0 0 24 24" fill="#f7931a" style="margin-bottom: 1rem;">
                    <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                </svg>
                <h2 style="color: #f7931a; margin-bottom: 0.5rem;">Zap Sent!</h2>
                <p style="font-size: 1.5rem; font-weight: bold;">${amount} sats</p>
            </div>
        </div>
    `;

    const style = document.createElement('style');
    style.textContent = `
        .zap-success-animation {
            animation: zapPulse 0.5s ease-out;
        }
        
        .zap-success-animation svg {
            animation: zapBolt 0.8s ease-out;
        }
        
        @keyframes zapPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes zapBolt {
            0% { transform: translateY(-20px) rotate(-10deg); opacity: 0; }
            50% { transform: translateY(0) rotate(5deg); opacity: 1; }
            100% { transform: translateY(0) rotate(0deg); }
        }
    `;
    document.head.appendChild(style);

    document.body.appendChild(modal);

    setTimeout(() => {
        modal.style.opacity = '0';
        modal.style.transition = 'opacity 0.3s ease-out';
        setTimeout(() => {
            modal.remove();
            style.remove();
        }, 300);
    }, 2000);
}

// Update the video player zap button
function updateZapButton(eventId, totalZaps) {
    const zapBtn = document.querySelector(`.action-btn.zap[data-event-id="${eventId}"]`);
    if (zapBtn) {
        zapBtn.querySelector('.count').textContent = totalZaps > 0 ? formatSats(totalZaps) : 'Zap';
        if (totalZaps > 0) {
            zapBtn.classList.add('active');
        }
    }
}

// Check NSFW preference
function shouldShowNSFW() {
    return localStorage.getItem('allowNSFW') === 'true' || sessionNSFWAllowed;
}

// Check community warning preference
function shouldSkipCommunityWarning() {
    return localStorage.getItem('allowCommunityWarning') === 'true';
}

// Allow ratioed/reported content to be shown (for comments)
function allowRatioedContent(eventId) {
    sessionRatioedAllowed.add(eventId);
}

// Unhide a reported/ratioed comment inline (without reloading all comments)
function unhideReportedComment(commentId) {
    sessionRatioedAllowed.add(commentId);

    // Find the placeholder
    const placeholder = document.querySelector(`.reported-comment-placeholder[data-event-id="${commentId}"], .ratioed-comment-placeholder[data-event-id="${commentId}"]`);
    if (!placeholder) return;

    // Find the comment in currentCommentsState
    const comment = currentCommentsState.comments.find(c => c.id === commentId);
    if (comment) {
        // Get depth from placeholder
        const depth = parseInt(placeholder.dataset.depth || '0', 10);
        const commentWithDepth = { ...comment, depth, children: [] };

        // Create the comment element
        const commentElement = createCommentElement(
            commentWithDepth,
            profileCache,
            currentCommentsState.reactions,
            currentCommentsState.zaps
        );

        // Replace placeholder with the actual comment
        placeholder.replaceWith(commentElement);
    }
}

// Scroll carousel
function scrollCarousel(direction) {
    const trendingGrid = document.getElementById('trendingGrid');
    if (!trendingGrid) return;

    const currentPage = parseInt(trendingGrid.dataset.currentPage || '0');
    const totalPages = parseInt(trendingGrid.dataset.totalPages || '1');
    const itemsPerPage = parseInt(trendingGrid.dataset.itemsPerPage || '3');

    const newPage = Math.max(0, Math.min(currentPage + direction, totalPages - 1));

    if (newPage !== currentPage) {
        goToPage(newPage);
    }
}

// Go to specific page
function goToPage(page) {
    const trendingGrid = document.getElementById('trendingGrid');
    const carouselDots = document.getElementById('carouselDots');
    if (!trendingGrid || !carouselDots) return;

    const cards = trendingGrid.querySelectorAll('.video-card');
    if (cards.length === 0) return;

    // Use stored card dimensions for precise scrolling
    const cardWidth = parseFloat(trendingGrid.dataset.cardWidth) || cards[0].offsetWidth;
    const gap = parseFloat(trendingGrid.dataset.gap) || 16;
    const itemsPerPage = parseInt(trendingGrid.dataset.itemsPerPage) || 3;
    const offset = page * itemsPerPage * (cardWidth + gap);

    trendingGrid.style.transform = `translateX(-${offset}px)`;
    trendingGrid.dataset.currentPage = page;

    carouselDots.querySelectorAll('.carousel-dot').forEach((dot, index) => {
        dot.classList.toggle('active', index === page);
    });

    updateCarouselButtons();
}

// Update carousel button states
function updateCarouselButtons() {
    const trendingGrid = document.getElementById('trendingGrid');
    const prevBtn = document.querySelector('.carousel-btn.prev');
    const nextBtn = document.querySelector('.carousel-btn.next');

    if (!trendingGrid || !prevBtn || !nextBtn) return;

    const currentPage = parseInt(trendingGrid.dataset.currentPage || '0');
    const totalPages = parseInt(trendingGrid.dataset.totalPages || '1');

    prevBtn.disabled = currentPage === 0;
    nextBtn.disabled = currentPage === totalPages - 1;
}

// Calculate if video is ratioed (uses PoW-validated reactions only to prevent spam manipulation)
function isVideoRatioed(reactions) {
    // Use PoW-validated counts for ratioed determination (spam-resistant)
    const likes = reactions.powLikes || 0;
    const dislikes = reactions.powDislikes || 0;
    const total = likes + dislikes;

    // Video is ratioed if:
    // 1. At least 10 total PoW-validated reactions
    // 2. Dislikes are at least 2x likes
    // 3. Dislikes make up at least 70% of total reactions
    if (total >= 10) {
        const dislikeRatio = dislikes / total;
        return dislikes >= likes * 2 && dislikeRatio >= 0.7;
    }
    return false;
}

// Connect to a relay
function connectToRelay(url) {
    return new Promise((resolve, reject) => {
        // Check if we have an open connection
        if (relayConnections[url] && relayConnections[url].readyState === WebSocket.OPEN) {
            resolve(relayConnections[url]);
            return;
        }

        // If there's a connection in progress, wait for it
        if (relayConnections[url] && relayConnections[url].readyState === WebSocket.CONNECTING) {
            const checkConnection = setInterval(() => {
                const ws = relayConnections[url];
                if (!ws) {
                    clearInterval(checkConnection);
                    // Connection was removed, try again
                    connectToRelay(url).then(resolve).catch(reject);
                } else if (ws.readyState === WebSocket.OPEN) {
                    clearInterval(checkConnection);
                    resolve(ws);
                } else if (ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
                    clearInterval(checkConnection);
                    delete relayConnections[url];
                    // Try to reconnect
                    connectToRelay(url).then(resolve).catch(reject);
                }
            }, 100);
            return;
        }

        // Create new connection
        try {
            const ws = new WebSocket(url);
            relayConnections[url] = ws;

            ws.onopen = () => {
                console.log(`Connected to ${url}`);
                relayStatus.set(url, 'connected');
                resolve(ws);
            };

            ws.onerror = (error) => {
                console.error(`Failed to connect to ${url}:`, error);
                relayStatus.set(url, 'error');
                delete relayConnections[url];
                reject(error);
            };

            ws.onclose = () => {
                console.log(`Disconnected from ${url}`);
                relayStatus.set(url, 'disconnected');
                delete relayConnections[url];

                // Attempt to reconnect after a delay (reduced from 5s to 3s)
                setTimeout(() => {
                    // Only reconnect if this URL is still in RELAY_URLS or WOT_RELAY_URLS
                    const isActiveRelay = RELAY_URLS.includes(url) || WOT_RELAY_URLS.includes(url) || PUBLISH_ONLY_RELAYS.includes(url);
                    if (isActiveRelay && !relayConnections[url]) {
                        console.log(`Attempting to reconnect to ${url}`);
                        connectToRelay(url).catch(err =>
                            console.error(`Reconnection to ${url} failed:`, err)
                        );
                    }
                }, 3000);
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    handleRelayMessage(url, message);
                } catch (error) {
                    console.error('Failed to parse message:', error);
                }
            };
        } catch (error) {
            console.error(`Failed to create WebSocket for ${url}:`, error);
            delete relayConnections[url];
            reject(error);
        }
    });
}

// Handle messages from relays
function handleRelayMessage(relayUrl, message) {
    if (message[0] === 'EVENT') {
        const subscriptionId = message[1];
        const event = message[2];

        allEvents.set(event.id, event);

        if (event.kind === 0) {
            try {
                const profile = JSON.parse(event.content);
                profileCache.set(event.pubkey, profile);
            } catch (e) {
                console.error('Failed to parse profile:', e);
            }
        }

        if (window.subscriptionHandlers && window.subscriptionHandlers[subscriptionId]) {
            window.subscriptionHandlers[subscriptionId](event);
        }
    }
}

// Get relays sorted by latency (fastest first)
function getRelaysSortedByLatency() {
    return [...RELAY_URLS].sort((a, b) => {
        const latencyA = relayLatency.get(a) || 1000;
        const latencyB = relayLatency.get(b) || 1000;
        return latencyA - latencyB;
    });
}

// Streaming request events (optimized with early delivery)
async function requestEventsStream(filter, onEvent, onComplete) {
    const subscriptionId = Math.random().toString(36).substring(7);
    const eventsMap = new Map();
    const seenEventIds = new Set();
    let completedRelays = 0;
    let earlyCompleteTriggered = false;
    const sortedRelays = getRelaysSortedByLatency();
    const totalRelays = sortedRelays.length;
    // Require more relays if we haven't found any data yet
    const minRelaysForEmptyResult = Math.min(3, totalRelays);
    const activeSubscriptions = new Set();
    const relayStartTimes = new Map();

    if (!window.subscriptionHandlers) {
        window.subscriptionHandlers = {};
    }

    window.subscriptionHandlers[subscriptionId] = (event) => {
        if (!eventsMap.has(event.id)) {
            eventsMap.set(event.id, event);
            if (onEvent && !seenEventIds.has(event.id)) {
                seenEventIds.add(event.id);
                onEvent(event);
            }
        }
    };

    // Trigger early completion when we have enough data
    const triggerEarlyComplete = () => {
        if (!earlyCompleteTriggered && onComplete) {
            earlyCompleteTriggered = true;
            onComplete(Array.from(eventsMap.values()));
        }
    };

    // Final cleanup when all relays complete
    const finalCleanup = () => {
        delete window.subscriptionHandlers[subscriptionId];
        // Trigger onComplete if not already done
        if (!earlyCompleteTriggered && onComplete) {
            onComplete(Array.from(eventsMap.values()));
        }
    };

    // Connect to all relays in parallel for faster initial response
    const connectionPromises = sortedRelays.map(async (url) => {
        try {
            relayStartTimes.set(url, Date.now());
            const ws = await connectToRelay(url);
            const req = JSON.stringify(['REQ', subscriptionId, filter]);
            ws.send(req);
            activeSubscriptions.add(url);

            // Create a dedicated message handler for EOSE
            const handleEOSE = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    if (message[0] === 'EOSE' && message[1] === subscriptionId) {
                        // Update relay latency tracking
                        const startTime = relayStartTimes.get(url);
                        if (startTime) {
                            const latency = Date.now() - startTime;
                            relayLatency.set(url, latency);
                        }

                        completedRelays++;
                        activeSubscriptions.delete(url);
                        ws.removeEventListener('message', handleEOSE);

                        // Send CLOSE command for this subscription
                        if (ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify(['CLOSE', subscriptionId]));
                        }

                        // Trigger early complete:
                        // - If we have events, complete after 2 relays (we found data)
                        // - If no events yet, wait for more relays before giving up
                        const hasEvents = eventsMap.size > 0;
                        const enoughRelays = hasEvents ? completedRelays >= 2 : completedRelays >= minRelaysForEmptyResult;
                        if (enoughRelays && !earlyCompleteTriggered) {
                            triggerEarlyComplete();
                        }

                        if (completedRelays === totalRelays) {
                            finalCleanup();
                        }
                    }
                } catch (error) {
                    // Ignore parse errors
                }
            };

            // Add EOSE handler
            ws.addEventListener('message', handleEOSE);

            // Clean up the EOSE handler after a timeout
            setTimeout(() => {
                ws.removeEventListener('message', handleEOSE);
                if (activeSubscriptions.has(url)) {
                    completedRelays++;
                    activeSubscriptions.delete(url);

                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify(['CLOSE', subscriptionId]));
                    }

                    if (completedRelays === totalRelays) {
                        finalCleanup();
                    }
                }
            }, 15000); // Reduced from 30s to 15s timeout

        } catch (error) {
            console.error(`Failed to connect to ${url}:`, error);
            completedRelays++;
            if (completedRelays === totalRelays) {
                finalCleanup();
            }
        }
    });

    // Wait for all connection attempts to start (not complete)
    await Promise.allSettled(connectionPromises);

    // Trigger early complete after 3 seconds if we have any events
    setTimeout(() => {
        if (!earlyCompleteTriggered && eventsMap.size > 0) {
            triggerEarlyComplete();
        }
    }, 3000);
}

// Persistent subscription that stays open for real-time updates (doesn't close after EOSE)
// Returns an object with an unsubscribe() method to clean up
function subscribePersistent(filter, onEvent) {
    const subscriptionId = 'live_' + Math.random().toString(36).substring(7);
    const seenEventIds = new Set();
    const activeConnections = new Map(); // url -> ws
    let isActive = true;

    if (!window.subscriptionHandlers) {
        window.subscriptionHandlers = {};
    }

    window.subscriptionHandlers[subscriptionId] = (event) => {
        if (!seenEventIds.has(event.id) && isActive) {
            seenEventIds.add(event.id);
            onEvent(event);
        }
    };

    // Connect to relays and keep subscriptions open
    const sortedRelays = getRelaysSortedByLatency();

    sortedRelays.forEach(async (url) => {
        try {
            const ws = await connectToRelay(url);
            if (!isActive) return; // Check if unsubscribed during connection

            activeConnections.set(url, ws);
            const req = JSON.stringify(['REQ', subscriptionId, filter]);
            ws.send(req);

            // Handle EOSE but DON'T close the subscription - keep it open for real-time
            const handleMessages = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    // We just acknowledge EOSE but don't close - subscription stays open
                    if (message[0] === 'EOSE' && message[1] === subscriptionId) {
                        // Subscription is now ready for real-time events
                        console.log(`Live subscription ${subscriptionId} ready on ${url}`);
                    }
                } catch (error) {
                    // Ignore parse errors
                }
            };

            ws.addEventListener('message', handleMessages);

            // Store cleanup function
            if (!ws._persistentHandlers) ws._persistentHandlers = new Map();
            ws._persistentHandlers.set(subscriptionId, handleMessages);

        } catch (error) {
            console.error(`Failed to set up persistent subscription on ${url}:`, error);
        }
    });

    // Return unsubscribe function
    return {
        unsubscribe: () => {
            isActive = false;
            delete window.subscriptionHandlers[subscriptionId];

            // Close subscriptions on all relays
            activeConnections.forEach((ws, url) => {
                try {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify(['CLOSE', subscriptionId]));
                    }
                    // Remove message handler
                    if (ws._persistentHandlers && ws._persistentHandlers.has(subscriptionId)) {
                        ws.removeEventListener('message', ws._persistentHandlers.get(subscriptionId));
                        ws._persistentHandlers.delete(subscriptionId);
                    }
                } catch (error) {
                    console.error(`Error closing subscription on ${url}:`, error);
                }
            });
            activeConnections.clear();
        }
    };
}

// Function to handle streaming video display
async function displayVideosStream(title, filter, clientFilter = null, container = null) {
    if (!container) {
        const mainContent = document.getElementById('mainContent');
        const cardsPerRow = getCardsPerRow();
        const skeletonCount = cardsPerRow * 10; // 10 rows of skeletons
        const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');

        mainContent.innerHTML = `
            <h2 style="margin-bottom: 1.5rem;">${title}</h2>
            <div class="video-grid" id="videoGrid">
                ${skeletons}
            </div>
        `;
        container = document.getElementById('videoGrid');
    }

    const videoGrid = container;
    const renderedVideos = new Map();
    const videoEvents = [];
    const profileQueue = new Set();
    const reactionQueue = new Set();
    const boostQueue = new Set();
    const viewsQueue = new Set();
    let profileTimer = null;
    let reactionTimer = null;
    let boostTimer = null;
    let viewsTimer = null;

    const updateCardBoosts = (eventId, boostAmount) => {
        const card = document.getElementById(`video-card-${eventId}`);
        if (!card) return;

        const boostLevel = getBoostLevel(boostAmount);
        const isBoosted = boostLevel > 0;

        // Update card classes
        if (isBoosted) {
            card.classList.add('boosted', `boost-level-${boostLevel}`);
            // Remove old boost levels
            for (let i = 1; i <= 4; i++) {
                if (i !== boostLevel) {
                    card.classList.remove(`boost-level-${i}`);
                }
            }
        } else {
            card.classList.remove('boosted', 'boost-level-1', 'boost-level-2', 'boost-level-3', 'boost-level-4');
        }

        // Update boost indicator
        const thumbnail = card.querySelector('.video-thumbnail');
        const existingIndicator = thumbnail.querySelector('.boost-indicator');

        if (isBoosted) {
            const indicatorHTML = `
                <div class="boost-indicator">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                    </svg>
                    ${formatSats(boostAmount)}
                </div>
            `;

            if (existingIndicator) {
                existingIndicator.outerHTML = indicatorHTML;
            } else {
                thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
            }
        } else if (existingIndicator) {
            existingIndicator.remove();
        }
    };

    const updateCardReactions = (eventId, reactions) => {
        const card = document.getElementById(`video-card-${eventId}`);
        if (!card) return;

        const thumbnail = card.querySelector('.video-thumbnail');
        const existingReactions = thumbnail.querySelector('.video-reactions');

        const newReactionsHTML = reactions && (reactions.likes > 0 || reactions.dislikes > 0) ? `
            ${reactions.likes > 0 ? `
                <span class="reaction-count likes">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                    ${formatNumber(reactions.likes)}
                </span>
            ` : ''}
            ${reactions.dislikes > 0 ? `
                <span class="reaction-count dislikes">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                    ${formatNumber(reactions.dislikes)}
                </span>
            ` : ''}
        ` : '';

        if (existingReactions) {
            if (newReactionsHTML) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = `<div class="video-reactions">${newReactionsHTML}</div>`;
                existingReactions.innerHTML = tempDiv.firstElementChild.innerHTML;
            } else {
                existingReactions.remove();
            }
        } else if (newReactionsHTML) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = `<div class="video-reactions">${newReactionsHTML}</div>`;
            thumbnail.appendChild(tempDiv.firstElementChild);
        }
    };

    const updateCardProfile = (eventId, profile) => {
        const card = document.getElementById(`video-card-${eventId}`);
        if (!card || !profile) return;

        const displayName = profile.name || profile.display_name || `User ${card.dataset.pubkey.slice(0, 8)}`;
        const avatarUrl = profile.picture || profile.avatar || '';
        const nip05 = profile.nip05 || '';

        const channelName = card.querySelector('.channel-name');
        if (channelName && channelName.textContent !== displayName) {
            channelName.textContent = displayName;
        }

        const channelDetails = card.querySelector('.channel-details');
        const existingNip05 = card.querySelector('.channel-nip05');

        if (nip05) {
            if (existingNip05) {
                if (existingNip05.textContent !== nip05) {
                    existingNip05.textContent = nip05;
                    existingNip05.dataset.nip05 = nip05;
                }
            } else {
                channelDetails.insertAdjacentHTML('beforeend',
                    `<div class="channel-nip05" data-nip05="${nip05}">${nip05}</div>`
                );
            }
        } else if (existingNip05) {
            existingNip05.remove();
        }

        const channelAvatar = card.querySelector('.channel-avatar');
        const existingImg = channelAvatar.querySelector('img');

        if (avatarUrl) {
            if (existingImg) {
                if (existingImg.getAttribute('data-avatar-url') !== avatarUrl) {
                    existingImg.src = avatarUrl;
                    existingImg.setAttribute('data-avatar-url', avatarUrl);
                }
            } else {
                channelAvatar.innerHTML = `<img src="${avatarUrl}" alt="${displayName}" data-avatar-url="${avatarUrl}">`;
            }
        } else if (existingImg) {
            existingImg.remove();
        }

        if ((avatarUrl || nip05) && card.dataset.validationDone !== 'true') {
            card.dataset.needsValidation = 'true';
            setTimeout(() => validateVideoCard(eventId, card.dataset.pubkey, profile, reactionsCache.get(eventId), false), 0);
        }
    };

    const renderVideoCard = (event, profile = null, reactions = null) => {
        const cardId = `video-card-${event.id}`;

        if (document.getElementById(cardId)) {
            if (profile) updateCardProfile(event.id, profile);
            if (reactions) updateCardReactions(event.id, reactions);
            return;
        }

        const cardHTML = createVideoCard(event, profile, reactions);
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = cardHTML;

        if (!tempDiv.firstElementChild) return;

        tempDiv.firstElementChild.id = cardId;

        let inserted = false;
        const cards = videoGrid.querySelectorAll('.video-card');

        for (let i = 0; i < cards.length; i++) {
            const cardEventId = cards[i].id.replace('video-card-', '');
            const cardEvent = renderedVideos.get(cardEventId);
            if (cardEvent && event.created_at > cardEvent.created_at) {
                cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                inserted = true;
                break;
            }
        }

        if (!inserted) {
            videoGrid.appendChild(tempDiv.firstElementChild);
        }

        renderedVideos.set(event.id, event);

        // Observe new card for lazy loading
        observeLazyCards();
    };

    const loadProfilesBatch = async () => {
        if (profileQueue.size === 0) return;

        const pubkeys = Array.from(profileQueue);
        profileQueue.clear();

        // Chunk profiles into batches of 25 to prevent relay timeouts
        const BATCH_SIZE = 25;
        const chunks = [];
        for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
            chunks.push(pubkeys.slice(i, i + BATCH_SIZE));
        }

        // Process all chunks in parallel
        await Promise.all(chunks.map(async (chunk) => {
            const filter = {
                kinds: [0],
                authors: chunk
            };

            await requestEventsStream(filter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);

                    videoEvents.forEach(event => {
                        if (event.pubkey === profileEvent.pubkey) {
                            updateCardProfile(event.id, profile);
                        }
                    });
                } catch (e) {
                    console.error('Failed to parse profile:', e);
                }
            });
        }));
    };

    const loadReactionsBatch = async () => {
        if (reactionQueue.size === 0) return;

        const videoIds = Array.from(reactionQueue);
        reactionQueue.clear();

        await loadReactionsForVideos(videoIds, (videoId, reactions) => {
            updateCardReactions(videoId, reactions);
        });
    };

    const loadBoostsBatch = async () => {
        if (boostQueue.size === 0) return;

        const videoIds = Array.from(boostQueue);
        boostQueue.clear();

        // Load boosts for all videos in parallel
        await Promise.all(videoIds.map(videoId =>
            loadBoostsForVideo(videoId, (totalBoosts) => {
                updateCardBoosts(videoId, totalBoosts);
            })
        ));
    };

    const loadViewsBatch = async () => {
        if (viewsQueue.size === 0) return;

        const videoIds = Array.from(viewsQueue);
        viewsQueue.clear();

        // Load views and update UI
        await loadViewsForVideos(videoIds, true);
    };

    await requestEventsStream(filter, (event) => {
        const tags = event.tags || [];
        if (!tags.some(tag => tag[0] === 'x')) return;

        if (clientFilter && !clientFilter(event)) return;

        if (videoEvents.some(e => e.id === event.id)) {
            return;
        }

        // Store event first so shouldSkipLegacyEvent can find NIP-71 counterparts
        allEvents.set(event.id, event);

        // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
        if (shouldSkipLegacyEvent(event)) {
            return;
        }

        videoEvents.push(event);

        const spinner = videoGrid.querySelector('.spinner');
        if (spinner) spinner.remove();

        const cachedProfile = profileCache.get(event.pubkey);
        const cachedReactions = reactionsCache.get(event.id);
        renderVideoCard(event, cachedProfile, cachedReactions);

        if (!cachedProfile) {
            profileQueue.add(event.pubkey);
            clearTimeout(profileTimer);
            profileTimer = setTimeout(loadProfilesBatch, 100);
        }

        reactionQueue.add(event.id);
        clearTimeout(reactionTimer);
        reactionTimer = setTimeout(loadReactionsBatch, 200);

        boostQueue.add(event.id);
        clearTimeout(boostTimer);
        boostTimer = setTimeout(loadBoostsBatch, 300);

        viewsQueue.add(event.id);
        clearTimeout(viewsTimer);
        viewsTimer = setTimeout(loadViewsBatch, 400);

    }, (allEvents) => {
        // Remove any remaining skeleton loaders
        videoGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());

        if (videoEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosFound')}</p>`;
        }

        if (profileQueue.size > 0) {
            loadProfilesBatch();
        }
        if (reactionQueue.size > 0) {
            loadReactionsBatch();
        }
        if (boostQueue.size > 0) {
            loadBoostsBatch();
        }
        if (viewsQueue.size > 0) {
            loadViewsBatch();
        }

        // Make video cards keyboard accessible
        makeCardsKeyboardAccessible();

        // Enable lazy loading for new cards
        observeLazyCards();
    });
}

// Helper function to update all video cards with the same event ID
function updateAllVideoCardsReactions(eventId, reactions) {
    const cards = document.querySelectorAll(`[data-event-id="${eventId}"]`);
    cards.forEach(card => {
        const thumbnail = card.querySelector('.video-thumbnail');
        if (!thumbnail) return;

        const existingReactions = thumbnail.querySelector('.video-reactions');

        const newReactionsHTML = reactions && (reactions.likes > 0 || reactions.dislikes > 0) ? `
            <div class="video-reactions">
                ${reactions.likes > 0 ? `
                    <span class="reaction-count likes">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                        </svg>
                        ${formatNumber(reactions.likes)}
                    </span>
                ` : ''}
                ${reactions.dislikes > 0 ? `
                    <span class="reaction-count dislikes">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                        </svg>
                        ${formatNumber(reactions.dislikes)}
                    </span>
                ` : ''}
            </div>
        ` : '';

        if (existingReactions) {
            existingReactions.remove();
        }

        if (newReactionsHTML) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newReactionsHTML;
            thumbnail.appendChild(tempDiv.firstElementChild);
        }
    });
}

// Load reactions for videos with batching
async function loadReactionsForVideos(videoIds, onUpdate = null) {
    const BATCH_SIZE = 50;
    const userReactions = new Map();

    // Expand video IDs to include all linked events (for reaction merging)
    const primaryToLinked = new Map(); // Maps primary ID to all linked IDs
    const linkedToPrimary = new Map(); // Maps any linked ID back to primary ID
    const allLinkedIds = new Set();

    videoIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        primaryToLinked.set(id, linkedIds);
        linkedIds.forEach(linkedId => {
            linkedToPrimary.set(linkedId, id);
            allLinkedIds.add(linkedId);
        });
        userReactions.set(id, new Map());
    });

    const allIdsArray = Array.from(allLinkedIds);

    // Batch video IDs for reaction fetching
    const videoBatches = [];
    for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
        videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
    }

    // Fetch reactions in batches (no #t filter to include legacy reactions)
    await Promise.all(videoBatches.map(async (batch) => {
        const filter = {
            kinds: [7],
            '#e': batch
        };

        await new Promise((resolve) => {
            requestEventsStream(filter, (event) => {
                const reactionVideoId = event.tags.find(tag => tag[0] === 'e')?.[1];
                if (!reactionVideoId || !allLinkedIds.has(reactionVideoId)) return;

                // Map back to primary video ID
                const primaryId = linkedToPrimary.get(reactionVideoId);
                if (!primaryId) return;

                const videoReactionMap = userReactions.get(primaryId);
                if (!videoReactionMap) return;

                const userPubkey = event.pubkey;
                const timestamp = event.created_at;

                const existingReaction = videoReactionMap.get(userPubkey);
                if (!existingReaction || existingReaction.timestamp < timestamp) {
                    videoReactionMap.set(userPubkey, {
                        reaction: event.content,
                        timestamp: timestamp,
                        hasPoW: validateEventPoW(event)
                    });
                }
            }, resolve);
        });
    }));

    // Count ALL reactions for video page display (no PoW/NIP-05 filtering)
    // Also track PoW-validated counts separately for ratioed algorithm (spam prevention)
    const reactions = {};
    videoIds.forEach(id => {
        reactions[id] = { likes: 0, dislikes: 0, powLikes: 0, powDislikes: 0, userReaction: null };

        const videoReactionMap = userReactions.get(id);
        videoReactionMap.forEach((data, userPubkey) => {
            // Count ALL reactions for display (not filtered like trending)
            if (data.reaction === '👍') {
                reactions[id].likes++;
                // Track PoW-validated likes for ratioed algorithm
                if (data.hasPoW) {
                    reactions[id].powLikes++;
                }
                if (currentUser && userPubkey === currentUser.pubkey) {
                    reactions[id].userReaction = 'like';
                }
            } else if (data.reaction === '👎') {
                reactions[id].dislikes++;
                // Track PoW-validated dislikes for ratioed algorithm
                if (data.hasPoW) {
                    reactions[id].powDislikes++;
                }
                if (currentUser && userPubkey === currentUser.pubkey) {
                    reactions[id].userReaction = 'dislike';
                }
            }
        });

        reactionsCache.set(id, reactions[id]);

        // Update all linked event IDs with the same reactions
        const linkedIds = primaryToLinked.get(id) || [id];
        linkedIds.forEach(linkedId => {
            reactionsCache.set(linkedId, reactions[id]);
            updateAllVideoCardsReactions(linkedId, reactions[id]);
        });

        // Call the update callback if provided
        if (onUpdate) {
            onUpdate(id, reactions[id]);
        }
    });

    return reactions;
}

// Load zaps for videos (merges zaps from all linked events)
async function loadZapsForVideo(eventId, onUpdate = null) {
    // Expand to all linked event IDs for merging
    const allEventIds = getAllLinkedEventIds(eventId);

    const filter = {
        kinds: [9735],
        '#e': allEventIds
    };

    let totalZaps = 0;
    const zaps = [];

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            try {
                // Check if this is a boost zap (skip if it is)
                const pTag = event.tags.find(tag => tag[0] === 'p');
                if (pTag && pTag[1] === 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df') {
                    // This is a boost, check if it has the purpose tag
                    const description = event.tags.find(tag => tag[0] === 'description')?.[1];
                    if (description) {
                        try {
                            const zapRequest = JSON.parse(description);
                            const hasBoostTag = zapRequest.tags?.some(tag =>
                                tag[0] === 'purpose' && tag[1] === 'boost'
                            );
                            if (hasBoostTag) {
                                // Skip this boost zap
                                return;
                            }
                        } catch (e) {
                            // If we can't parse description, treat as regular zap
                        }
                    }
                }

                const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                if (bolt11Tag && bolt11Tag[1]) {
                    const amount = extractAmountFromBolt11(bolt11Tag[1]);
                    if (amount > 0) {
                        totalZaps += amount;
                        zaps.push({ amount, event });

                        if (onUpdate) {
                            onUpdate(totalZaps, zaps.length);
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to parse zap:', e);
            }
        }, () => {
            resolve({ totalZaps, zaps, count: zaps.length });
        });
    });
}

// Load zaps for multiple videos (for merging from linked events)
async function loadZapsForVideos(eventIds, onUpdate = null) {
    if (!eventIds || eventIds.length === 0) {
        if (onUpdate) onUpdate(0, 0);
        return { totalZaps: 0, zaps: [], count: 0 };
    }

    const filter = {
        kinds: [9735],
        '#e': eventIds
    };

    let totalZaps = 0;
    const zaps = [];
    const seenZapIds = new Set(); // Prevent double-counting

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            // Skip if we've already counted this zap
            if (seenZapIds.has(event.id)) return;
            seenZapIds.add(event.id);

            try {
                // Check if this is a boost zap (skip if it is)
                const pTag = event.tags.find(tag => tag[0] === 'p');
                if (pTag && pTag[1] === 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df') {
                    const description = event.tags.find(tag => tag[0] === 'description')?.[1];
                    if (description) {
                        try {
                            const zapRequest = JSON.parse(description);
                            const hasBoostTag = zapRequest.tags?.some(tag =>
                                tag[0] === 'purpose' && tag[1] === 'boost'
                            );
                            if (hasBoostTag) {
                                return;
                            }
                        } catch (e) {
                            // If we can't parse description, treat as regular zap
                        }
                    }
                }

                const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                if (bolt11Tag && bolt11Tag[1]) {
                    const amount = extractAmountFromBolt11(bolt11Tag[1]);
                    if (amount > 0) {
                        totalZaps += amount;
                        zaps.push({ amount, event });

                        if (onUpdate) {
                            onUpdate(totalZaps, zaps.length);
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to parse zap:', e);
            }
        }, () => {
            resolve({ totalZaps, zaps, count: zaps.length });
        });
    });
}

// Extract amount from bolt11 invoice
function extractAmountFromBolt11(bolt11) {
    try {
        const amountMatch = bolt11.match(/lnbc(\d+)([munp])/i);
        if (amountMatch) {
            const amount = parseInt(amountMatch[1]);
            const multiplier = amountMatch[2];
            switch (multiplier) {
                case 'm': return amount * 100000;
                case 'u': return amount * 100;
                case 'n': return amount * 0.1;
                case 'p': return amount * 0.0001;
                default: return amount * 100000000;
            }
        }
    } catch (e) {
        console.error('Failed to parse bolt11:', e);
    }
    return 0;
}

// Format sats amount
function formatSats(sats) {
    if (sats >= 1000000) {
        return `${(sats / 1000000).toFixed(1)}M`;
    } else if (sats >= 1000) {
        return `${(sats / 1000).toFixed(1)}K`;
    }
    return sats.toString();
}

// Format sats with exact number (for user-set values like zap goals)
function formatSatsExact(sats) {
    return sats.toLocaleString();
}

// Format counts amount
function formatNumber(num) {
    if (num >= 1000000) {
        return `${(num / 1000000).toFixed(1)}M`;
    } else if (num >= 1000) {
        return `${(num / 1000).toFixed(1)}K`;
    }
    return num.toString();
}

// Send reaction event
async function sendReaction(eventId, reaction) {
    if (!currentUser) {
        return false;
    }

    // Show a brief loading state on the button
    const actionBtn = document.querySelector(`.action-btn.${reaction === '👍' ? 'like' : 'dislike'}[data-event-id="${eventId}"]`);
    if (actionBtn) {
        actionBtn.disabled = true;
        actionBtn.classList.add('loading');
    }

    const reactionEvent = {
        kind: 7,
        pubkey: currentUser.pubkey, // Required for PoW calculation
        tags: [
            ['e', eventId],
            ['p', allEvents.get(eventId)?.pubkey || ''],
            ['t', 'pv69420']
        ],
        content: reaction,
        created_at: Math.floor(Date.now() / 1000)
    };

    try {
        // Generate proof of work (NIP-13) - this adds the nonce tag
        await generatePoW(reactionEvent, MIN_POW_DIFFICULTY);

        const signedEvent = await signEvent(reactionEvent);
        const published = await publishEvent(signedEvent);

        if (published) {
            const reactions = reactionsCache.get(eventId) || { likes: 0, dislikes: 0, userReaction: null };

            if (reactions.userReaction === 'like') reactions.likes--;
            if (reactions.userReaction === 'dislike') reactions.dislikes--;

            if (reaction === '👍') {
                reactions.likes++;
                reactions.userReaction = 'like';
            } else if (reaction === '👎') {
                reactions.dislikes++;
                reactions.userReaction = 'dislike';
            }

            reactionsCache.set(eventId, reactions);

            if (actionBtn) {
                actionBtn.disabled = false;
                actionBtn.classList.remove('loading');
            }
            return true;
        }
    } catch (error) {
        console.error('Failed to send reaction:', error);
    }

    if (actionBtn) {
        actionBtn.disabled = false;
        actionBtn.classList.remove('loading');
    }
    return false;
}

// Function to fetch a single profile
async function fetchUserProfile(pubkey) {
    if (profileCache.has(pubkey)) {
        return profileCache.get(pubkey);
    }

    return new Promise((resolve) => {
        let found = false;
        const filter = {
            kinds: [0],
            authors: [pubkey],
            limit: 1
        };

        // Returns immediately when profile is found on any relay
        // If not found, waits for 3+ relays before giving up
        requestEventsStream(filter, (event) => {
            if (!found && event.pubkey === pubkey) {
                found = true;
                try {
                    const profile = JSON.parse(event.content);
                    profileCache.set(event.pubkey, profile);
                    resolve(profile);
                } catch (e) {
                    console.error('Failed to parse profile:', e);
                    resolve(null);
                }
            }
        }, () => {
            if (!found) {
                // Mark as checked even if not found
                profileCache.set(pubkey, null);
                resolve(null);
            }
        });
    });
}

// Load user profile
async function loadUserProfile(pubkey) {
    return fetchUserProfile(pubkey);
}

// Load profile immediately and update all cards/comments for this pubkey when done
// This is fire-and-forget - doesn't block rendering
function loadProfileAndUpdateCards(pubkey) {
    // Skip if invalid or already loading
    if (!pubkey || pendingProfileLoads.has(pubkey)) {
        return;
    }

    // If already cached, still update cards to trigger validation (for NIP-05 checkmark)
    if (profileCache.has(pubkey)) {
        const profile = profileCache.get(pubkey);
        const cards = document.querySelectorAll(`[data-pubkey="${pubkey}"]`);
        cards.forEach(card => {
            const eventId = card.dataset.eventId || card.id?.replace('video-card-', '');
            if (eventId && card.dataset.validationDone !== 'true') {
                updateVideoCardInPlace(eventId, profile, reactionsCache.get(eventId));
            }
        });
        return;
    }

    pendingProfileLoads.add(pubkey);

    fetchUserProfile(pubkey).then(profile => {
        pendingProfileLoads.delete(pubkey);

        // Find all video cards for this pubkey and update them
        const cards = document.querySelectorAll(`[data-pubkey="${pubkey}"]`);
        cards.forEach(card => {
            const eventId = card.dataset.eventId || card.id?.replace('video-card-', '');
            if (eventId) {
                updateVideoCardInPlace(eventId, profile, reactionsCache.get(eventId));
            }
        });

        // Also update sidebar cards
        const sidebarCards = document.querySelectorAll(`.sidebar-video-card[data-pubkey="${pubkey}"]`);
        sidebarCards.forEach(card => {
            const eventId = card.dataset.eventId;
            if (eventId) {
                updateSidebarCardInPlace(eventId, profile);
                // Trigger validation for sidebar card if not already done for this pubkey
                if (!profileValidationCache.has(pubkey)) {
                    // If no video cards exist for this pubkey, we need to validate via sidebar
                    const hasVideoCards = document.querySelector(`.video-card[data-pubkey="${pubkey}"]`);
                    if (!hasVideoCards && profile) {
                        // Do validation directly for sidebar-only pubkeys
                        const avatarUrl = profile.picture || profile.avatar || '';
                        const nip05 = profile.nip05 || '';
                        Promise.all([
                            avatarUrl ? createImageValidationPromise(avatarUrl) : Promise.resolve(false),
                            nip05 ? validateNip05(nip05, pubkey) : Promise.resolve(false)
                        ]).then(([avatarValid, nip05Valid]) => {
                            const isSuspicious = !avatarValid || !nip05Valid;
                            profileValidationCache.set(pubkey, { isSuspicious, avatarValid, nip05Valid });
                            // Apply to all sidebar cards for this pubkey
                            document.querySelectorAll(`.sidebar-video-card[data-pubkey="${pubkey}"]`).forEach(c => {
                                applySidebarValidation(c, isSuspicious);
                            });
                        });
                    }
                } else {
                    // Use cached validation
                    const cached = profileValidationCache.get(pubkey);
                    applySidebarValidation(card, cached.isSuspicious);
                }
            }
        });

        // Also update comments for this pubkey
        if (profile && typeof updateCommentProfileInPlace === 'function') {
            updateCommentProfileInPlace(pubkey, profile);
        }
    }).catch(() => {
        pendingProfileLoads.delete(pubkey);
    });
}

// Load multiple user profiles
async function loadUserProfiles(pubkeys) {
    const uniquePubkeys = [...new Set(pubkeys)];
    const uncachedPubkeys = uniquePubkeys.filter(pk => !profileCache.has(pk));

    if (uncachedPubkeys.length > 0) {
        const filter = {
            kinds: [0],
            authors: uncachedPubkeys
        };

        // Query all relays for profiles - early completion triggers when:
        // - We have data AND 2+ relays responded, OR
        // - We have no data AND 3+ relays responded (give more chance to find)
        await new Promise((resolve) => {
            requestEventsStream(filter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);
                } catch (e) {
                    console.error('Failed to parse profile:', e);
                }
            }, resolve);
        });

        // Mark all looked-up pubkeys as "checked" even if no profile was found
        // This allows community warning logic to know a lookup was attempted
        uncachedPubkeys.forEach(pk => {
            if (!profileCache.has(pk)) {
                profileCache.set(pk, null); // null means "checked but not found"
            }
        });
    }

    const profiles = {};
    uniquePubkeys.forEach(pk => {
        profiles[pk] = profileCache.get(pk) || null;
    });

    return profiles;
}

// Publish event to relays (parallelized for faster publishing)
async function publishEvent(event) {
    const eventMessage = JSON.stringify(['EVENT', event]);
    const allPublishRelays = [...RELAY_URLS, ...PUBLISH_ONLY_RELAYS];

    // Publish to all relays in parallel for faster delivery
    const publishPromises = allPublishRelays.map(async (url) => {
        try {
            const ws = await connectToRelay(url);
            ws.send(eventMessage);
            console.log(`Published to ${url}`);
            return { url, success: true };
        } catch (error) {
            console.error(`Failed to publish to ${url}:`, error);
            return { url, success: false };
        }
    });

    const results = await Promise.all(publishPromises);
    const successCount = results.filter(r => r.success).length;

    return successCount > 0;
}

// Create note identifier from event
function createNote(event) {
    if (!window.NostrTools) {
        console.error('NostrTools not loaded');
        return null;
    }

    const { nip19 } = window.NostrTools;
    const note = nip19.noteEncode(event.id);

    return note;
}

// Initialize hover preview functionality using event delegation
function initializeHoverPreview() {
    const mainContent = document.getElementById('mainContent');
    if (!mainContent) return;

    // Track which thumbnail is currently showing preview to avoid redundant operations
    let currentPreviewThumbnail = null;

    // Use event delegation for better performance
    // Support both regular video cards and sidebar video cards
    mainContent.addEventListener('mouseenter', (e) => {
        const thumbnail = e.target.closest('.video-thumbnail[data-preview], .sidebar-video-thumbnail[data-preview]');
        if (!thumbnail || thumbnail === currentPreviewThumbnail) return;

        const previewUrl = thumbnail.dataset.preview;
        const thumbnailUrl = thumbnail.dataset.thumbnail;
        const img = thumbnail.querySelector('img.thumbnail-img');

        if (!img || !previewUrl) return;

        // Store the current thumbnail URL if not already stored
        if (!img.dataset.originalSrc) {
            img.dataset.originalSrc = img.src || thumbnailUrl;
        }

        // Preload the preview GIF before switching
        const preloadImg = new Image();
        preloadImg.onload = () => {
            // Only switch if still hovering over same thumbnail
            if (thumbnail.matches(':hover')) {
                img.src = previewUrl;
                thumbnail.classList.add('preview-active');
                currentPreviewThumbnail = thumbnail;
            }
        };
        preloadImg.src = previewUrl;
    }, true);

    mainContent.addEventListener('mouseleave', (e) => {
        const thumbnail = e.target.closest('.video-thumbnail[data-preview], .sidebar-video-thumbnail[data-preview]');
        if (!thumbnail) return;

        const img = thumbnail.querySelector('img.thumbnail-img');
        if (!img) return;

        // Restore original thumbnail
        const originalSrc = img.dataset.originalSrc || thumbnail.dataset.thumbnail;
        if (originalSrc && img.src !== originalSrc) {
            img.src = originalSrc;
        }
        thumbnail.classList.remove('preview-active');

        if (currentPreviewThumbnail === thumbnail) {
            currentPreviewThumbnail = null;
        }
    }, true);
}

// Initialize app on DOM load
document.addEventListener('DOMContentLoaded', () => {
    // Initialize language first
    initializeLanguage();
    applyTranslations();

    initializeApp().then(() => {
        // Start monitoring relay connections after initialization
        monitorRelayConnections();
        // Initialize performance optimizations
        initPerformanceOptimizations();
        // Initialize edit video form
        initEditVideoForm();
        // Initialize edit stream form
        initEditStreamForm();
        // Initialize hover preview for video cards
        initializeHoverPreview();
    });

    // Set up hash change listener for routing
    window.addEventListener('hashchange', handleRoute);

    // Set up resize listener for carousel
    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
            updateHeaderHeight();

            // Update carousel if needed
            const trendingGrid = document.getElementById('trendingGrid');
            if (trendingGrid && trendingGrid.querySelector('.video-card')) {
                initializeCarousel();
            }
        }, 250);
    });

    // Update on orientation change for mobile devices
    window.addEventListener('orientationchange', () => {
        setTimeout(updateHeaderHeight, 100);
    });

    updateHeaderHeight();

    // Set up signup form listeners
    const signupUsername = document.getElementById('signupUsername');
    const signupAbout = document.getElementById('signupAbout');

    if (signupUsername) {
        signupUsername.addEventListener('input', updateSignupPreview);
    }
    if (signupAbout) {
        signupAbout.addEventListener('input', updateSignupPreview);
    }

    // Set up file input listeners
    const videoFile = document.getElementById('videoFile');
    const thumbnailFile = document.getElementById('thumbnailFile');

    if (videoFile) {
        videoFile.addEventListener('change', handleFileSelect);
    }
    if (thumbnailFile) {
        thumbnailFile.addEventListener('change', handleFileSelect);
    }

    // Set up upload form listener - now uses pre-uploaded files
    const uploadForm = document.getElementById('uploadForm');
    if (uploadForm) {
        uploadForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            if (!currentUser) {
                if (!await ensureLoggedIn()) {
                    return;
                }
            }

            // Check if video upload is complete
            if (uploadState.video.status !== 'complete') {
                showToast('Please wait for video upload to complete', 'warning');
                return;
            }

            const publishBtn = document.getElementById('publishButton');
            const publishText = document.getElementById('publishButtonText');
            if (publishBtn) {
                publishBtn.disabled = true;
                publishBtn.classList.remove('ready');
            }

            // Auto-generate thumbnail if not provided
            if (uploadState.thumbnail.status !== 'complete') {
                if (publishText) {
                    publishText.textContent = t('status.generatingThumbnail');
                }

                try {
                    // Capture a frame from the video (2 seconds in)
                    const frameData = await captureVideoFrame(uploadState.video.url, 2);

                    if (publishText) {
                        publishText.textContent = t('status.uploadingThumbnail');
                    }

                    // Upload the auto-generated thumbnail
                    const result = await uploadToBlossom(frameData.file, BLOSSOM_SERVERS, 'thumbnailServerStatus');

                    if (result.success && result.url) {
                        uploadState.thumbnail.status = 'complete';
                        uploadState.thumbnail.url = result.url;
                        uploadState.thumbnail.file = frameData.file;
                    } else {
                        throw new Error(result.error || 'Failed to upload auto-generated thumbnail');
                    }
                } catch (error) {
                    console.error('Auto-thumbnail generation failed:', error);
                    showToast('Failed to generate thumbnail. Please upload one manually.', 'error');
                    if (publishBtn) publishBtn.disabled = false;
                    if (publishText) publishText.textContent = t('publish.autoThumbnail');
                    return;
                }
            }

            // Generate animated GIF preview for hover effect
            if (uploadState.preview.status !== 'complete') {
                if (publishText) {
                    publishText.textContent = t('status.generatingPreview');
                }

                try {
                    // Let the function use optimized defaults for iOS/Safari
                    const previewData = await generatePreviewGif(uploadState.video.url, {
                        startTime: 0.5,
                        duration: 4,
                        frameDelay: 150
                    });

                    if (publishText) {
                        publishText.textContent = t('status.uploadingPreview');
                    }

                    const result = await uploadToBlossom(previewData.file, BLOSSOM_SERVERS, 'thumbnailServerStatus');

                    if (result.success && result.url) {
                        uploadState.preview.status = 'complete';
                        uploadState.preview.url = result.url;
                        uploadState.preview.file = previewData.file;
                    } else {
                        // Preview is optional, continue without it
                        console.warn('Preview upload failed, continuing without preview');
                        uploadState.preview.status = 'error';
                    }
                } catch (error) {
                    // Preview generation is optional - don't block publishing
                    console.warn('Preview generation failed:', error);
                    uploadState.preview.status = 'error';
                }
            }

            if (publishText) {
                publishText.textContent = t('status.publishing');
            }

            const title = document.getElementById('videoTitle').value;
            const description = escapeHtml(document.getElementById('videoDescription').value);
            const tags = document.getElementById('videoTags').value.split(',').map(t => t.trim()).filter(t => t);
            const isNSFW = document.getElementById('nsfwCheckbox').checked;

            if (!title.trim()) {
                showToast('Please enter a title', 'warning');
                if (publishBtn) publishBtn.disabled = false;
                if (publishText) publishText.textContent = t('publish.video');
                return;
            }

            if (isNSFW && !tags.includes('nsfw')) {
                tags.push('nsfw');
            }

            try {
                // Use pre-uploaded file info from uploadState
                const videoUrl = uploadState.video.url;
                const videoHash = uploadState.video.hash;
                const thumbnailUrl = uploadState.thumbnail.url;
                const videoDuration = Math.floor(uploadState.video.duration || 0);
                const videoSize = uploadState.video.size;
                const videoType = uploadState.video.type || 'video/mp4';
                const videoDimensions = uploadState.video.dimensions || { width: 0, height: 0 };
                const videoMirrors = uploadState.video.mirrors || [];
                const previewUrl = uploadState.preview.url || null;

                if (publishText) publishText.textContent = t('status.publishingToNostr');

                // Prepare video data for NIP-71 event
                const videoData = {
                    title: title,
                    description: description,
                    url: videoUrl,
                    hash: videoHash,
                    thumbnail: thumbnailUrl,
                    preview: previewUrl,
                    duration: videoDuration,
                    size: videoSize,
                    type: videoType,
                    width: videoDimensions.width,
                    height: videoDimensions.height,
                    mirrors: videoMirrors,
                    tags: tags,
                    isNSFW: isNSFW
                };

                // Generate d-tag for parameterized replaceable event
                const dTag = generateVideoDTag();
                videoData.dTag = dTag;

                // Create addressable NIP-71 video event (kind 34235/34236 - primary, editable)
                const addressableEvent = createNip71VideoEvent(videoData);
                const signedAddressableEvent = await signEvent(addressableEvent);

                // Create legacy NIP-71 video event (kind 21/22 - for reach on other clients)
                const legacyNip71Event = createLegacyNip71VideoEvent(videoData);
                const signedLegacyNip71Event = await signEvent(legacyNip71Event);

                // Create kind 1 event for backwards compatibility (maximum reach)
                const kind1Event = createKind1VideoEvent(videoData);
                const signedKind1Event = await signEvent(kind1Event);

                // Publish all three events in parallel for maximum reach
                if (publishText) publishText.textContent = t('status.publishingVideoToNostr');

                const [addressablePublished, legacyNip71Published, kind1Published] = await Promise.all([
                    publishEvent(signedAddressableEvent),
                    publishEvent(signedLegacyNip71Event),
                    publishEvent(signedKind1Event)
                ]);

                if (!addressablePublished && !legacyNip71Published && !kind1Published) {
                    throw new Error('Failed to publish to any relay');
                }

                // Link all events in our cache for reaction/zap merging
                const eventIds = [signedAddressableEvent.id, signedLegacyNip71Event.id, signedKind1Event.id];
                for (const id1 of eventIds) {
                    for (const id2 of eventIds) {
                        if (id1 !== id2) {
                            videoEventLinks.set(id1, id2);
                        }
                    }
                }

                // Store all events in allEvents cache
                allEvents.set(signedAddressableEvent.id, signedAddressableEvent);
                allEvents.set(signedLegacyNip71Event.id, signedLegacyNip71Event);
                allEvents.set(signedKind1Event.id, signedKind1Event);

                const isShort = isVideoShort(videoDimensions.width, videoDimensions.height, videoDuration);
                if (publishText) {
                    publishText.textContent = `Published ${isShort ? 'Short' : 'Video'} successfully!`;
                }

                // Delete draft if this was published from a draft
                if (uploadState.draftId) {
                    const draft = getDraft(uploadState.draftId);
                    // Delete from Nostr if draft was synced there
                    const deleteFromNostr = !!(draft?.nostrEventId);
                    await deleteDraft(uploadState.draftId, deleteFromNostr);
                    uploadState.draftId = null;
                }

                setTimeout(() => {
                    hideUploadModal();
                    navigateTo('/my-videos');
                }, 1500);

            } catch (error) {
                console.error('Publish failed:', error);
                showToast(error.message || 'Failed to publish video', 'error');

                if (publishBtn) {
                    publishBtn.disabled = false;
                    publishBtn.classList.add('ready');
                }
                if (publishText) {
                    publishText.textContent = t('publish.video');
                }
            }
        });
    }

    // Set up drag and drop for file upload
    const fileUpload = document.getElementById('fileUpload');
    if (fileUpload) {
        fileUpload.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            fileUpload.classList.add('active');
        });

        fileUpload.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            fileUpload.classList.remove('active');
        });

        fileUpload.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            fileUpload.classList.remove('active');

            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                // Create a new FileList-like object for the input
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);

                const videoFileInput = document.getElementById('videoFile');
                videoFileInput.files = dataTransfer.files;

                // Trigger the file select handler
                handleFileSelect({ target: videoFileInput });
            } else if (file) {
                showToast('Please drop a video file', 'warning');
            }
        });
    }

    // Set up search input enter key listener
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchVideos();
            }
        });
    }

    // Set up sidebar link click listeners for mobile
    document.querySelectorAll('.sidebar-item').forEach(item => {
        item.addEventListener('click', () => {
            if (window.innerWidth <= 768) {
                toggleSidebar();
            }
        });
    });
});

// Function to calculate and update header height
function updateHeaderHeight() {
    const header = document.querySelector('header');
    if (header) {
        // Force a reflow to ensure accurate measurement
        header.offsetHeight;
        const headerHeight = header.getBoundingClientRect().height;
        document.documentElement.style.setProperty('--header-height', `${headerHeight}px`);
    }
}

// Clean up WebSocket connections on page unload
window.addEventListener('beforeunload', () => {
    Object.values(relayConnections).forEach(ws => {
        if (ws.readyState === WebSocket.OPEN) {
            ws.close();
        }
    });
});

// Function to load trending videos with streaming
async function loadTrendingVideos(period = 'today') {
    const now = Math.floor(Date.now() / 1000);
    const oneDay = 24 * 60 * 60;
    const oneWeek = 7 * oneDay;

    let since;
    if (period === 'today') {
        since = now - oneDay;
    } else if (period === 'week') {
        since = now - oneWeek;
    }

    const filter = {
        kinds: ALL_VIDEO_KINDS,
        '#t': ['pv69420'],
        since: since,
        limit: 100
    };

    return new Promise((resolve) => {
        const videoEvents = [];
        const videoScores = new Map();
        const globalReactions = new Map();
        const globalZaps = new Map();
        const globalBoosts = new Map();
        const globalComments = new Map(); // Track comment counts per video
        const globalViews = new Map(); // Track view counts per video
        const processedVideos = new Set();
        const validReactionAuthors = new Set();
        const powValidReactions = new Map(); // Track reactions that have PoW (regardless of NIP-05)
        const renderedVideoIds = new Set();
        let trendingVideos = [];
        let videosComplete = false;
        let reactionsComplete = false;
        let zapsComplete = false;
        let boostsComplete = false;
        let commentsComplete = false;
        let viewsComplete = false;
        let profilesComplete = false;
        let lastProcessTime = 0;
        let processTimer = null;
        let resolveTimer = null;
        let hasResolved = false;
        let lastRenderCount = 0;

        // Maps for linked event ID expansion
        const primaryToLinked = new Map(); // Maps primary video ID to all linked IDs
        const linkedToPrimary = new Map(); // Maps any linked ID back to primary ID

        const processTrending = (force = false) => {
            const now = Date.now();
            if (!force && now - lastProcessTime < 200) {
                clearTimeout(processTimer);
                processTimer = setTimeout(() => processTrending(true), 200);
                return;
            }
            lastProcessTime = now;

            const newTrendingVideos = [];
            const seenVideoHashes = new Set(); // Track video hashes to prevent duplicates

            videoEvents.forEach(event => {
                // Get video hash (x tag) to detect duplicate videos with different event IDs
                const videoHash = event.tags?.find(t => t[0] === 'x')?.[1];
                if (videoHash && seenVideoHashes.has(videoHash)) {
                    return; // Skip duplicate video
                }
                if (videoHash) {
                    seenVideoHashes.add(videoHash);
                }
                const reactions = { likes: 0, dislikes: 0 };
                const videoReactions = globalReactions.get(event.id);
                const videoPowReactions = powValidReactions.get(event.id);

                if (videoReactions) {
                    videoReactions.forEach((data, userPubkey) => {
                        // Count reactions that have EITHER NIP-05 validation OR PoW
                        const hasNip05 = validReactionAuthors.has(userPubkey);
                        const hasPow = videoPowReactions?.has(userPubkey);

                        if (hasNip05 || hasPow) {
                            if (data.reaction === '👍') {
                                reactions.likes++;
                            } else if (data.reaction === '👎') {
                                reactions.dislikes++;
                            }
                        }
                    });
                }

                reactionsCache.set(event.id, reactions);

                updateAllVideoCardsReactions(event.id, reactions);

                if (isVideoRatioed(reactions)) {
                    return;
                }

                const zapTotal = globalZaps.get(event.id) || 0;
                const boostTotal = globalBoosts.get(event.id) || 0;
                const commentCount = globalComments.get(event.id) || 0;
                const viewCount = globalViews.get(event.id) || 0;

                const ageHours = (now - event.created_at) / 3600;
                const timeWeight = Math.max(0, 24 - ageHours) / 24;

                // Updated scoring formula including comments and views
                // Zaps (cost money, goes to creator): highest weight
                // Likes (PoW or NIP-05 verified): medium weight
                // Comments (with PoW): engagement indicator
                // Views: cumulative value
                // Boosts (cost money, but goes to platform): lowest weight to prevent gaming
                const likeScore = reactions.likes * 0.5;
                const zapScore = (zapTotal / 1000) * 5;
                const commentScore = commentCount * 0.3;
                const viewScore = viewCount * 0.1;
                const boostScore = (boostTotal / 1000) * 0.1; // Minimal weight - prevents gaming trending
                const score = likeScore - (reactions.dislikes * 2) + zapScore + commentScore + viewScore + boostScore + (timeWeight * 10);

                if (score > 0) {
                    videoScores.set(event.id, score);
                    newTrendingVideos.push(event);
                }
            });

            newTrendingVideos.sort((a, b) => {
                const scoreA = videoScores.get(a.id) || 0;
                const scoreB = videoScores.get(b.id) || 0;
                return scoreB - scoreA;
            });

            trendingVideos = newTrendingVideos.slice(0, 12);

            const trendingGrid = document.getElementById('trendingGrid');
            if (trendingGrid && trendingVideos.length > 0) {
                const currentlyRendered = renderedVideoIds.size;
                const videosToRender = trendingVideos.filter(v => !renderedVideoIds.has(v.id));

                if (videosToRender.length > 0 || trendingVideos.length !== lastRenderCount) {
                    renderTrendingVideosIncremental(trendingVideos, renderedVideoIds);
                    lastRenderCount = trendingVideos.length;
                }
            }

            if (videosComplete && reactionsComplete && zapsComplete && boostsComplete && commentsComplete && viewsComplete && profilesComplete && !hasResolved) {
                clearTimeout(processTimer);
                clearTimeout(resolveTimer);
                hasResolved = true;
                resolve(trendingVideos);
            }
        };

        // Initialize linked event maps after videos are loaded
        const initializeLinkedEventMaps = () => {
            videoEvents.forEach(event => {
                const linkedIds = getAllLinkedEventIds(event.id);
                primaryToLinked.set(event.id, linkedIds);
                linkedIds.forEach(linkedId => {
                    linkedToPrimary.set(linkedId, event.id);
                });
            });
        };

        const loadReactionAuthorsProfiles = async (reactionAuthors) => {
            if (reactionAuthors.size === 0) {
                profilesComplete = true;
                processTrending(true);
                return;
            }

            // Batch profile fetching
            const BATCH_SIZE = 50;
            const authorsArray = Array.from(reactionAuthors);
            const authorBatches = [];
            for (let i = 0; i < authorsArray.length; i += BATCH_SIZE) {
                authorBatches.push(authorsArray.slice(i, i + BATCH_SIZE));
            }

            let profilesLoaded = 0;

            await Promise.all(authorBatches.map(async (batch) => {
                const profileFilter = {
                    kinds: [0],
                    authors: batch
                };

                await new Promise((resolve) => {
                    requestEventsStream(profileFilter, (profileEvent) => {
                        try {
                            const profile = JSON.parse(profileEvent.content);
                            profilesLoaded++;

                            if (profile.nip05) {
                                validateNip05(profile.nip05, profileEvent.pubkey).then(isValid => {
                                    if (isValid) {
                                        validReactionAuthors.add(profileEvent.pubkey);
                                        processTrending();
                                    }
                                });
                            }

                            if (profilesLoaded % 10 === 0) {
                                processTrending();
                            }
                        } catch (e) {
                            console.error('Failed to parse profile:', e);
                        }
                    }, resolve);
                });
            }));

            profilesComplete = true;
            processTrending(true);
        };

        const loadReactions = async () => {
            if (videoEvents.length === 0) {
                reactionsComplete = true;
                profilesComplete = true;
                processTrending(true);
                return;
            }

            // Expand video IDs to include all linked events (for reaction merging)
            const allLinkedIds = new Set();
            videoEvents.forEach(event => {
                const linkedIds = primaryToLinked.get(event.id) || [event.id];
                linkedIds.forEach(id => allLinkedIds.add(id));
            });
            const allIdsArray = Array.from(allLinkedIds);

            const reactionAuthorsToValidate = new Set();

            // Batch video IDs for reaction fetching
            const BATCH_SIZE = 50;
            const videoBatches = [];
            for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
                videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
            }

            await Promise.all(videoBatches.map(async (batch) => {
                const reactionFilter = {
                    kinds: [7],
                    '#e': batch,
                    since: since
                };

                await new Promise((resolve) => {
                    requestEventsStream(reactionFilter, (reactionEvent) => {
                        const reactionVideoId = reactionEvent.tags.find(tag => tag[0] === 'e')?.[1];
                        if (!reactionVideoId || !allLinkedIds.has(reactionVideoId)) return;

                        // Map back to primary video ID
                        const primaryId = linkedToPrimary.get(reactionVideoId);
                        if (!primaryId) return;

                        if (!globalReactions.has(primaryId)) {
                            globalReactions.set(primaryId, new Map());
                        }

                        const videoReactions = globalReactions.get(primaryId);
                        const userPubkey = reactionEvent.pubkey;
                        const timestamp = reactionEvent.created_at;

                        const existingReaction = videoReactions.get(userPubkey);
                        if (!existingReaction || existingReaction.timestamp < timestamp) {
                            videoReactions.set(userPubkey, {
                                reaction: reactionEvent.content,
                                timestamp: timestamp
                            });

                            // Check for PoW validation (NIP-13)
                            if (validateEventPoW(reactionEvent)) {
                                if (!powValidReactions.has(primaryId)) {
                                    powValidReactions.set(primaryId, new Set());
                                }
                                powValidReactions.get(primaryId).add(userPubkey);
                            }

                            // Also validate NIP-05 for authors without PoW
                            if (reactionEvent.content === '👍' && !validateEventPoW(reactionEvent)) {
                                reactionAuthorsToValidate.add(userPubkey);
                            }
                        }
                    }, resolve);
                });
            }));

            reactionsComplete = true;
            loadReactionAuthorsProfiles(reactionAuthorsToValidate);
        };

        const loadZaps = async () => {
            if (videoEvents.length === 0) {
                zapsComplete = true;
                processTrending(true);
                return;
            }

            // Expand video IDs to include all linked events (for zap merging)
            const allLinkedIds = new Set();
            videoEvents.forEach(event => {
                const linkedIds = primaryToLinked.get(event.id) || [event.id];
                linkedIds.forEach(id => allLinkedIds.add(id));
            });
            const allIdsArray = Array.from(allLinkedIds);

            // Batch video IDs for zap fetching
            const BATCH_SIZE = 50;
            const videoBatches = [];
            for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
                videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
            }

            await Promise.all(videoBatches.map(async (batch) => {
                const zapFilter = {
                    kinds: [9735],
                    '#e': batch,
                    since: since
                };

                await new Promise((resolve) => {
                    requestEventsStream(zapFilter, (zapEvent) => {
                        try {
                            const zapVideoId = zapEvent.tags.find(tag => tag[0] === 'e')?.[1];
                            if (!zapVideoId || !allLinkedIds.has(zapVideoId)) return;

                            // Map back to primary video ID
                            const primaryId = linkedToPrimary.get(zapVideoId);
                            if (!primaryId) return;

                            const pTag = zapEvent.tags.find(tag => tag[0] === 'p');
                            if (pTag && pTag[1] === 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df') {
                                const description = zapEvent.tags.find(tag => tag[0] === 'description')?.[1];
                                if (description) {
                                    try {
                                        const zapRequest = JSON.parse(description);
                                        const hasBoostTag = zapRequest.tags?.some(tag =>
                                            tag[0] === 'purpose' && tag[1] === 'boost'
                                        );
                                        if (hasBoostTag) {
                                            return;
                                        }
                                    } catch (e) { }
                                }
                            }

                            const bolt11Tag = zapEvent.tags.find(tag => tag[0] === 'bolt11');
                            if (bolt11Tag && bolt11Tag[1]) {
                                const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                if (amount > 0) {
                                    const currentTotal = globalZaps.get(primaryId) || 0;
                                    globalZaps.set(primaryId, currentTotal + amount);
                                    processTrending();
                                }
                            }
                        } catch (e) {
                            console.error('Failed to parse zap:', e);
                        }
                    }, resolve);
                });
            }));

            zapsComplete = true;
            processTrending(true);
        };

        const loadBoosts = async () => {
            if (videoEvents.length === 0) {
                boostsComplete = true;
                processTrending(true);
                return;
            }

            // Expand video IDs to include all linked events (for boost merging)
            const allLinkedIds = new Set();
            videoEvents.forEach(event => {
                const linkedIds = primaryToLinked.get(event.id) || [event.id];
                linkedIds.forEach(id => allLinkedIds.add(id));
            });
            const allIdsArray = Array.from(allLinkedIds);

            // Batch video IDs for boost fetching
            const BATCH_SIZE = 50;
            const videoBatches = [];
            for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
                videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
            }

            await Promise.all(videoBatches.map(async (batch) => {
                const boostFilter = {
                    kinds: [9735],
                    '#e': batch,
                    '#p': ['d49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df'],
                    since: since
                };

                await new Promise((resolve) => {
                    requestEventsStream(boostFilter, (boostEvent) => {
                        try {
                            const boostVideoId = boostEvent.tags.find(tag => tag[0] === 'e')?.[1];
                            if (!boostVideoId || !allLinkedIds.has(boostVideoId)) return;

                            // Map back to primary video ID
                            const primaryId = linkedToPrimary.get(boostVideoId);
                            if (!primaryId) return;

                            const description = boostEvent.tags.find(tag => tag[0] === 'description')?.[1];
                            if (description) {
                                try {
                                    const zapRequest = JSON.parse(description);
                                    const hasBoostTag = zapRequest.tags?.some(tag =>
                                        tag[0] === 'purpose' && tag[1] === 'boost'
                                    );

                                    if (hasBoostTag) {
                                        const bolt11Tag = boostEvent.tags.find(tag => tag[0] === 'bolt11');
                                        if (bolt11Tag && bolt11Tag[1]) {
                                            const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                            if (amount > 0) {
                                                const currentTotal = globalBoosts.get(primaryId) || 0;
                                                globalBoosts.set(primaryId, currentTotal + amount);
                                                boostsCache.set(primaryId, currentTotal + amount);
                                                processTrending();
                                            }
                                        }
                                    }
                                } catch (e) { }
                            }
                        } catch (e) {
                            console.error('Failed to parse boost:', e);
                        }
                    }, resolve);
                });
            }));

            boostsComplete = true;
            processTrending(true);
        };

        // Load comments with PoW validation for trending
        const loadComments = async () => {
            if (videoEvents.length === 0) {
                commentsComplete = true;
                processTrending(true);
                return;
            }

            // Expand video IDs to include all linked events (for comment merging)
            const allLinkedIds = new Set();
            videoEvents.forEach(event => {
                const linkedIds = primaryToLinked.get(event.id) || [event.id];
                linkedIds.forEach(id => allLinkedIds.add(id));
            });
            const allIdsArray = Array.from(allLinkedIds);

            // Batch video IDs for comment fetching
            const BATCH_SIZE = 50;
            const videoBatches = [];
            for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
                videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
            }

            await Promise.all(videoBatches.map(async (batch) => {
                const commentFilter = {
                    kinds: [1],
                    '#e': batch,
                    since: since
                };

                await new Promise((resolve) => {
                    requestEventsStream(commentFilter, (commentEvent) => {
                        const commentVideoId = commentEvent.tags.find(tag => tag[0] === 'e')?.[1];
                        if (!commentVideoId || !allLinkedIds.has(commentVideoId)) return;

                        // Map back to primary video ID
                        const primaryId = linkedToPrimary.get(commentVideoId);
                        if (!primaryId) return;

                        // Only count comments with PoW to prevent spam
                        if (validateEventPoW(commentEvent)) {
                            const currentCount = globalComments.get(primaryId) || 0;
                            globalComments.set(primaryId, currentCount + 1);
                        }
                    }, resolve);
                });
            }));

            commentsComplete = true;
            processTrending(true);
        };

        // Load view counts for trending
        const loadViews = async () => {
            if (videoEvents.length === 0) {
                viewsComplete = true;
                processTrending(true);
                return;
            }

            // Expand video IDs to include all linked events (for view merging)
            const allLinkedIds = new Set();
            videoEvents.forEach(event => {
                const linkedIds = primaryToLinked.get(event.id) || [event.id];
                linkedIds.forEach(id => allLinkedIds.add(id));
            });
            const allIdsArray = Array.from(allLinkedIds);

            const viewersByVideo = new Map(); // primaryId -> Set of viewer pubkeys

            // Batch video IDs for view fetching
            const BATCH_SIZE = 50;
            const videoBatches = [];
            for (let i = 0; i < allIdsArray.length; i += BATCH_SIZE) {
                videoBatches.push(allIdsArray.slice(i, i + BATCH_SIZE));
            }

            await Promise.all(videoBatches.map(async (batch) => {
                const viewFilter = {
                    kinds: [VIEW_EVENT_KIND],
                    '#e': batch,
                    '#t': ['video-view']
                };

                await new Promise((resolve) => {
                    requestEventsStream(viewFilter, (viewEvent) => {
                        const viewVideoId = viewEvent.tags.find(tag => tag[0] === 'e')?.[1];
                        if (!viewVideoId || !allLinkedIds.has(viewVideoId)) return;

                        // Map back to primary video ID
                        const primaryId = linkedToPrimary.get(viewVideoId);
                        if (!primaryId) return;

                        // Count unique viewers
                        if (!viewersByVideo.has(primaryId)) {
                            viewersByVideo.set(primaryId, new Set());
                        }
                        viewersByVideo.get(primaryId).add(viewEvent.pubkey);
                    }, resolve);
                });
            }));

            // Convert sets to counts and cache
            videoEvents.forEach(event => {
                const viewers = viewersByVideo.get(event.id);
                const count = viewers ? viewers.size : 0;

                globalViews.set(event.id, count);
                setCachedViewCount(event.id, count);
            });

            viewsComplete = true;
            processTrending(true);
        };

        let videoCount = 0;
        requestEventsStream(filter, (event) => {
            const tags = event.tags || [];
            if (tags.some(tag => tag[0] === 'x') && !processedVideos.has(event.id)) {
                processedVideos.add(event.id);
                allEvents.set(event.id, event);

                // Only include addressable video kinds (34235) and live streams (30311)
                // Filter out legacy kinds (1, 21, 22) entirely for trending
                if (event.kind !== NIP71_VIDEO_KIND && event.kind !== NIP53_LIVE_EVENT_KIND) {
                    return;
                }

                // Skip shorts - they're shown in the dedicated Shorts section
                if (isNip71ShortKind(event.kind)) {
                    return;
                }

                videoEvents.push(event);
                videoCount++;

                if (videoCount % 5 === 0) {
                    processTrending();
                }
            }
        }, () => {
            videosComplete = true;

            if (videoEvents.length > 0) {
                // Initialize linked event maps for merging
                initializeLinkedEventMaps();

                // Load all metrics in parallel
                loadReactions();
                loadZaps();
                loadBoosts();
                loadComments();
                loadViews();
            } else {
                reactionsComplete = true;
                zapsComplete = true;
                boostsComplete = true;
                commentsComplete = true;
                viewsComplete = true;
                profilesComplete = true;
                processTrending(true);
            }
        });

        setTimeout(() => {
            if (trendingVideos.length > 0 && !hasResolved) {
                processTrending(true);
            }
        }, 1000);

        setTimeout(() => {
            if (!hasResolved) {
                videosComplete = true;
                reactionsComplete = true;
                zapsComplete = true;
                boostsComplete = true;
                commentsComplete = true;
                viewsComplete = true;
                profilesComplete = true;
                processTrending(true);
                hasResolved = true;
                resolve(trendingVideos);
            }
        }, 15000);
    });
}

// Helper function for incremental rendering
// Progressive rendering for trending videos - renders immediately, updates profiles in-place
function renderTrendingVideosIncremental(trendingVideos, renderedVideoIds) {
    const trendingGrid = document.getElementById('trendingGrid');
    if (!trendingGrid) return;

    // Remove skeleton loaders
    const skeletons = trendingGrid.querySelectorAll('.skeleton-card');
    skeletons.forEach(s => s.remove());

    const spinner = trendingGrid.querySelector('.spinner');
    if (spinner) {
        spinner.remove();
    }

    // Find videos that need profiles loaded
    const newVideos = trendingVideos.filter(v => !renderedVideoIds.has(v.id));
    const uncachedPubkeys = [...new Set(newVideos.map(v => v.pubkey).filter(pk => !profileCache.has(pk)))];

    // Render immediately with available data
    trendingGrid.innerHTML = '';

    const renderedCards = trendingVideos.map((event, index) => {
        const profile = profileCache.get(event.pubkey);
        const reactions = reactionsCache.get(event.id);
        renderedVideoIds.add(event.id);
        return createVideoCard(event, profile, reactions, true);
    }).filter(card => card !== '');

    if (renderedCards.length > 0) {
        trendingGrid.innerHTML = renderedCards.join('');
        observeLazyCards();
        initializeCarousel();

        // Load profiles immediately for trending videos
        trendingVideos.forEach(event => loadProfileAndUpdateCards(event.pubkey));

        // Load boosts for trending videos
        trendingVideos.forEach(event => {
            if (!boostsCache.has(event.id)) {
                loadBoostsForVideo(event.id, (totalBoosts) => {
                    const card = document.getElementById(`video-card-${event.id}`);
                    if (!card) return;
                    const boostLevel = getBoostLevel(totalBoosts);
                    const isBoosted = boostLevel > 0;
                    if (isBoosted) {
                        card.classList.add('boosted', `boost-level-${boostLevel}`);
                        for (let i = 1; i <= 4; i++) {
                            if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                        }
                        const thumbnail = card.querySelector('.video-thumbnail');
                        if (thumbnail) {
                            const existingIndicator = thumbnail.querySelector('.boost-indicator');
                            const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                            if (existingIndicator) {
                                existingIndicator.outerHTML = indicatorHTML;
                            } else {
                                thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                            }
                        }
                    }
                });
            }
        });

        // Load views for trending videos
        const trendingIds = trendingVideos.map(e => e.id);
        if (trendingIds.length > 0) {
            loadViewsForVideos(trendingIds, true);
        }
    } else if (trendingVideos.length === 0) {
        const periodText = currentTrendingPeriod === 'today' ? 'today' : 'this week';
        trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No trending videos ${periodText}.</p>`;
    }
}

// Calculate how many cards fit in one row based on viewport width
function getCardsPerRow() {
    // Get actual content width, accounting for sidebar
    const mainContent = document.getElementById('mainContent');
    const contentWidth = mainContent ? mainContent.clientWidth : window.innerWidth;

    // Based on video-grid minmax(250px, 1fr) with 1rem (16px) gap
    // Calculate how many 250px cards fit with gaps
    const minCardWidth = 250;
    const gap = 16;

    // Calculate cards that fit: (contentWidth + gap) / (minCardWidth + gap)
    const cardsPerRow = Math.floor((contentWidth + gap) / (minCardWidth + gap));

    // Ensure at least 1 card, max 5 cards
    return Math.max(1, Math.min(cardsPerRow, 5));
}

// Calculate cards per row for shorts grid (uses smaller card widths)
function getShortsCardsPerRow() {
    const mainContent = document.getElementById('mainContent');
    const contentWidth = mainContent ? mainContent.clientWidth : window.innerWidth;

    // Shorts use minmax(180px, 1fr) on desktop, minmax(140px, 1fr) on mobile
    const isMobile = window.innerWidth <= 480;
    const minCardWidth = isMobile ? 140 : 180;
    const gap = isMobile ? 8 : 16;

    const cardsPerRow = Math.floor((contentWidth + gap) / (minCardWidth + gap));

    // Ensure at least 2 cards on mobile, max 6 cards
    return Math.max(2, Math.min(cardsPerRow, 6));
}

// Available topics for featured sections - Music, Gaming, Bitcoin
const FEATURED_TOPICS = [
    { tag: 'music', name: 'Music', icon: '<path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>' },
    { tag: 'gaming', name: 'Gaming', icon: '<path d="M15 7.5V2H9v5.5l3 3 3-3zM7.5 9H2v6h5.5l3-3-3-3zM9 16.5V22h6v-5.5l-3-3-3 3zM16.5 9l-3 3 3 3H22V9h-5.5z"/>' },
    { tag: 'bitcoin', name: 'Bitcoin', icon: '<path d="M17.06 11.57c.59-.69.94-1.59.94-2.57 0-1.86-1.27-3.43-3-3.87V3h-2v2h-2V3H9v2H6v2h1c.55 0 1 .45 1 1v8c0 .55-.45 1-1 1H6v2h3v2h2v-2h2v2h2v-2.13c2.39-.54 4-2.65 4-5.07 0-1.37-.53-2.62-1.4-3.55M10 7h4c1.1 0 2 .9 2 2s-.9 2-2 2h-4V7zm5 10h-5v-4h5c1.1 0 2 .9 2 2s-.9 2-2 2z"/>' }
];

// Storage for section videos (to support View More expansion)
let cachedTrendingVideos = [];
let cachedRecommendedVideos = [];
let cachedShorts = [];
let cachedFeaturedVideos = [[], [], []]; // One array per featured topic
let cachedLatestVideos = [];

// Cached shorts for non-homepage sections
let cachedFollowingShorts = [];
let cachedMyVideosShorts = [];
let cachedMyVideosLiveStreams = [];
let cachedLikedShorts = [];
let cachedSearchShorts = [];
let cachedDrafts = [];

// Track expanded state for each section
let sectionExpanded = {
    trending: false,
    recommended: false,
    shorts: false,
    featured1: false,
    featured2: false,
    featured3: false,
    latest: false,
    followingShorts: false,
    myVideosShorts: false,
    likedShorts: false,
    searchShorts: false,
    drafts: false
};

// Expand section to show more rows
async function expandSection(sectionType, index = 0) {
    // Use appropriate cards per row calculation based on section type
    const isShortSection = ['shorts', 'followingShorts', 'myVideosShorts', 'likedShorts', 'searchShorts'].includes(sectionType);
    const cardsPerRow = isShortSection ? getShortsCardsPerRow() : getCardsPerRow();

    let videos, gridId, containerId, initialRows, maxRows;

    switch(sectionType) {
        case 'trending':
            videos = cachedTrendingVideos;
            gridId = 'trendingGrid';
            containerId = 'trendingViewMore';
            initialRows = 1;
            maxRows = 4;
            sectionExpanded.trending = true;
            break;
        case 'recommended':
            videos = cachedRecommendedVideos;
            gridId = 'recommendedGrid';
            containerId = 'recommendedViewMore';
            initialRows = 1;
            maxRows = 4;
            sectionExpanded.recommended = true;
            break;
        case 'shorts':
            videos = cachedShorts;
            gridId = 'shortsGrid';
            containerId = 'shortsViewMore';
            initialRows = 1;
            maxRows = 3;
            sectionExpanded.shorts = true;
            break;
        case 'featured':
            videos = cachedFeaturedVideos[index];
            gridId = `featuredTopic${index + 1}Grid`;
            containerId = `featuredTopic${index + 1}ViewMoreContainer`;
            initialRows = 3;
            maxRows = 6;
            sectionExpanded[`featured${index + 1}`] = true;
            break;
        case 'latest':
            videos = cachedLatestVideos;
            gridId = 'videoGrid';
            containerId = 'latestViewMore';
            initialRows = 5;
            maxRows = 10;
            sectionExpanded.latest = true;
            break;
        case 'followingShorts':
            videos = cachedFollowingShorts;
            gridId = 'followingShortsGrid';
            containerId = 'followingShortsViewMore';
            initialRows = 1;
            maxRows = 3;
            sectionExpanded.followingShorts = true;
            break;
        case 'myVideosShorts':
            videos = cachedMyVideosShorts;
            gridId = 'myVideosShortsGrid';
            containerId = 'myVideosShortsViewMore';
            initialRows = 1;
            maxRows = 3;
            sectionExpanded.myVideosShorts = true;
            break;
        case 'likedShorts':
            videos = cachedLikedShorts;
            gridId = 'likedShortsGrid';
            containerId = 'likedShortsViewMore';
            initialRows = 1;
            maxRows = 3;
            sectionExpanded.likedShorts = true;
            break;
        case 'searchShorts':
            videos = cachedSearchShorts;
            gridId = 'searchShortsGrid';
            containerId = 'searchShortsViewMore';
            initialRows = 1;
            maxRows = 3;
            sectionExpanded.searchShorts = true;
            break;
        case 'drafts':
            videos = cachedDrafts;
            gridId = 'draftsGrid';
            containerId = 'draftsViewMore';
            initialRows = 1;
            maxRows = 4;
            sectionExpanded.drafts = true;
            break;
        case 'liveNow':
            // Handle live streams specially
            await expandLiveNowSection();
            return;
        default:
            return;
    }

    const grid = document.getElementById(gridId);
    const container = document.getElementById(containerId);

    if (!grid || !videos || videos.length === 0) return;

    // Get IDs of already displayed cards to avoid duplicates
    const displayedCards = grid.querySelectorAll('.video-card:not(.skeleton-card), .short-card:not(.skeleton-card), .draft-card:not(.skeleton-card)');
    const displayedIds = new Set();
    displayedCards.forEach(card => {
        const eventId = card.dataset.eventId || card.id.replace('video-card-', '').replace('draft-', '');
        if (eventId) displayedIds.add(eventId);
    });

    const totalToShow = cardsPerRow * maxRows;

    // Get videos that should be shown (up to totalToShow) but aren't displayed yet
    const videosToConsider = videos.slice(0, totalToShow);
    const newVideos = videosToConsider.filter(v => !displayedIds.has(v.id));

    if (newVideos.length === 0) {
        // No new videos to show, just hide the button
        if (container) container.style.display = 'none';
        return;
    }

    // Find uncached profile pubkeys
    const uncachedPubkeys = [...new Set(newVideos.map(v => v.pubkey).filter(pk => !profileCache.has(pk)))];

    // Create cards immediately with available profile data
    const newCards = newVideos.map((event, idx) => {
        // Handle drafts specially - they have different structure
        if (sectionType === 'drafts') {
            const draftId = event.id;
            return createDraftCard(draftId, event);
        }

        const profile = profileCache.get(event.pubkey);
        const reactions = reactionsCache.get(event.id);
        // Use createShortCard for shorts sections, createVideoCard for others
        const shortsTypes = ['shorts', 'followingShorts', 'myVideosShorts', 'likedShorts', 'searchShorts'];
        if (shortsTypes.includes(sectionType)) {
            // Show owner actions for myVideosShorts
            const showOwnerActions = sectionType === 'myVideosShorts';
            return createShortCard(event, profile, reactions, showOwnerActions);
        }
        return createVideoCard(event, profile, reactions, sectionType === 'trending');
    }).filter(card => card !== '');

    // Append new cards to the grid (don't replace existing ones)
    if (newCards.length > 0) {
        grid.insertAdjacentHTML('beforeend', newCards.join(''));
        observeLazyCards();

        // Load profiles immediately for new cards
        newVideos.forEach(event => loadProfileAndUpdateCards(event.pubkey));

        // Load boosts for new cards
        newVideos.forEach(event => {
            if (!boostsCache.has(event.id)) {
                loadBoostsForVideo(event.id, (totalBoosts) => {
                    const card = document.getElementById(`video-card-${event.id}`);
                    if (!card) return;
                    const boostLevel = getBoostLevel(totalBoosts);
                    const isBoosted = boostLevel > 0;
                    if (isBoosted) {
                        card.classList.add('boosted', `boost-level-${boostLevel}`);
                        for (let i = 1; i <= 4; i++) {
                            if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                        }
                        const thumbnail = card.querySelector('.video-thumbnail');
                        if (thumbnail) {
                            const existingIndicator = thumbnail.querySelector('.boost-indicator');
                            const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                            if (existingIndicator) {
                                existingIndicator.outerHTML = indicatorHTML;
                            } else {
                                thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                            }
                        }
                    }
                });
            }
        });
    }

    // Hide the View More container after expanding
    if (container) {
        container.style.display = 'none';
    }
}

// Load home feed with grid-based sections
async function loadHomeFeed() {
    currentView = 'home';

    // Reset caches and expanded state for fresh load
    cachedTrendingVideos = [];
    cachedRecommendedVideos = [];
    cachedShorts = [];
    cachedFeaturedVideos = [[], [], []];
    cachedLatestVideos = [];
    sectionExpanded = {
        trending: false,
        recommended: false,
        shorts: false,
        featured1: false,
        featured2: false,
        featured3: false,
        latest: false
    };

    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const shortsCardsPerRow = getShortsCardsPerRow();

    // Generate skeleton loaders
    const oneRowSkeletons = Array(cardsPerRow).fill(createSkeletonCard()).join('');
    const threeRowSkeletons = Array(cardsPerRow * 3).fill(createSkeletonCard()).join('');
    const fiveRowSkeletons = Array(cardsPerRow * 5).fill(createSkeletonCard()).join('');
    const shortSkeletons = Array(shortsCardsPerRow).fill(createShortSkeletonCard()).join('');

    mainContent.innerHTML = `
        <!-- Trending Section - 1 row -->
        <div class="home-section" id="trendingSection">
            <div class="home-section-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.48,12.35c-1.57-4.08-7.16-4.3-5.81-10.23c0.1-0.44-0.37-0.78-0.75-0.55C9.29,3.71,6.68,8,8.87,13.62 c0.18,0.46-0.36,0.89-0.75,0.59c-1.81-1.37-2-3.34-1.84-4.75c0.06-0.52-0.62-0.77-0.91-0.34C4.69,10.16,4,11.84,4,14.37 c0.38,5.6,5.11,7.32,6.81,7.54c2.43,0.31,5.06-0.14,6.95-1.87C19.84,18.11,20.6,15.03,19.48,12.35z"/>
                    </svg>
                    Trending
                </h2>
                <div class="trending-tabs">
                    <button class="trending-tab ${currentTrendingPeriod === 'week' ? 'active' : ''}"
                            onclick="switchTrendingPeriod('week')">This Week</button>
                    <button class="trending-tab ${currentTrendingPeriod === 'today' ? 'active' : ''}"
                            onclick="switchTrendingPeriod('today')">Today</button>
                </div>
            </div>
            <div class="video-grid" id="trendingGrid">
                ${oneRowSkeletons}
            </div>
            <div class="view-more-container" id="trendingViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('trending')">View More</button>
            </div>
        </div>

        <!-- Recommended Section - 1 row -->
        <div class="home-section" id="recommendedSection" style="display: none;">
            <div class="home-section-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                    Recommended For You
                </h2>
            </div>
            <div class="video-grid" id="recommendedGrid">
                <div class="spinner"></div>
            </div>
            <div class="view-more-container" id="recommendedViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('recommended')">View More</button>
            </div>
        </div>

        <!-- Shorts Section - 1 row of vertical videos -->
        <div class="home-section" id="shortsSection" style="display: none;">
            <div class="home-section-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                        <path d="M10 8l6 4-6 4V8z"/>
                    </svg>
                    Shorts
                </h2>
            </div>
            <div class="shorts-grid" id="shortsGrid">
                ${shortSkeletons}
            </div>
            <div class="view-more-container" id="shortsViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('shorts')">View More</button>
            </div>
        </div>

        <!-- Live Section - 1 row (moved below Shorts) -->
        <div class="home-section" id="liveNowSection" style="display: none;">
            <div class="home-section-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <circle cx="12" cy="12" r="4" fill="#f44336"/>
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                    </svg>
                    Live
                </h2>
            </div>
            <div class="video-grid" id="liveNowGrid">
                <div class="spinner"></div>
            </div>
            <div class="view-more-container" id="liveNowViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('liveNow')">View More</button>
            </div>
        </div>

        <!-- Featured Topic 1 (Music) - 3 rows -->
        <div class="home-section" id="featuredTopic1Section" style="display: none;">
            <div class="home-section-header">
                <h2 id="featuredTopic1Title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="featuredTopic1Icon"></svg>
                    <span id="featuredTopic1Name"></span>
                </h2>
            </div>
            <div class="video-grid" id="featuredTopic1Grid">
                ${threeRowSkeletons}
            </div>
            <div class="view-more-container" id="featuredTopic1ViewMoreContainer" style="display: none;">
                <button class="action-btn view-more-btn" id="featuredTopic1ViewMore">View More</button>
            </div>
        </div>

        <!-- Featured Topic 2 (Gaming) - 3 rows -->
        <div class="home-section" id="featuredTopic2Section" style="display: none;">
            <div class="home-section-header">
                <h2 id="featuredTopic2Title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="featuredTopic2Icon"></svg>
                    <span id="featuredTopic2Name"></span>
                </h2>
            </div>
            <div class="video-grid" id="featuredTopic2Grid">
                ${threeRowSkeletons}
            </div>
            <div class="view-more-container" id="featuredTopic2ViewMoreContainer" style="display: none;">
                <button class="action-btn view-more-btn" id="featuredTopic2ViewMore">View More</button>
            </div>
        </div>

        <!-- Featured Topic 3 (Bitcoin) - 3 rows -->
        <div class="home-section" id="featuredTopic3Section" style="display: none;">
            <div class="home-section-header">
                <h2 id="featuredTopic3Title">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="featuredTopic3Icon"></svg>
                    <span id="featuredTopic3Name"></span>
                </h2>
            </div>
            <div class="video-grid" id="featuredTopic3Grid">
                ${threeRowSkeletons}
            </div>
            <div class="view-more-container" id="featuredTopic3ViewMoreContainer" style="display: none;">
                <button class="action-btn view-more-btn" id="featuredTopic3ViewMore">View More</button>
            </div>
        </div>

        <!-- Latest Videos - 5 rows -->
        <div class="home-section">
            <div class="home-section-header">
                <h2>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                    </svg>
                    Latest Videos
                </h2>
            </div>
            <div class="video-grid" id="videoGrid">
                ${fiveRowSkeletons}
            </div>
            <div class="view-more-container" id="latestViewMore">
                <button class="action-btn view-more-btn" onclick="expandSection('latest')">View More</button>
            </div>
        </div>
    `;

    // Load all sections
    loadTrendingSectionGrid();
    refreshRecommendedSectionGrid();
    loadShortsSection();
    loadLiveNowSection(); // After Shorts section
    loadFeaturedTopics();
    loadLatestVideosSection();
}

// Load trending section as a grid (1 row)
// Note: loadTrendingVideos already does progressive rendering via renderTrendingVideosIncremental
// This function just needs to handle caching and view more button
async function loadTrendingSectionGrid() {
    const trendingGrid = document.getElementById('trendingGrid');
    const viewMoreBtn = document.getElementById('trendingViewMore');
    const cardsPerRow = getCardsPerRow();

    try {
        // loadTrendingVideos already renders progressively as data arrives
        const trendingVideos = await loadTrendingVideos(currentTrendingPeriod);

        if (trendingVideos.length === 0) {
            // Only show message if not already rendered by progressive rendering
            // Use :not(.skeleton-card) to exclude skeleton loaders from the check
            if (!trendingGrid.querySelector('.video-card:not(.skeleton-card)')) {
                const periodText = currentTrendingPeriod === 'today' ? 'today' : 'this week';
                trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No trending videos ${periodText}.</p>`;
            }
            return;
        }

        // Cache all trending videos for View More expansion
        cachedTrendingVideos = trendingVideos;

        // Show View More if there are more videos than one row
        if (trendingVideos.length > cardsPerRow && viewMoreBtn) {
            viewMoreBtn.style.display = 'block';
        }
    } catch (error) {
        console.error('Failed to load trending videos:', error);
        if (!trendingGrid.querySelector('.video-card')) {
            trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.failedLoadTrending')}</p>`;
        }
    }
}

// Cache for live streams for View More expansion
let cachedLiveStreams = [];

// Load Live section for homepage - shows active live streams
async function loadLiveNowSection() {
    const liveNowSection = document.getElementById('liveNowSection');
    const liveNowGrid = document.getElementById('liveNowGrid');
    const viewMoreBtn = document.getElementById('liveNowViewMore');

    if (!liveNowSection || !liveNowGrid) return;

    const cardsPerRow = getCardsPerRow();

    const filter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        '#t': ['pv69420'],
        limit: 50
    };

    const liveStreams = [];

    requestEventsStream(filter, (event) => {
        const liveData = parseLiveEvent(event);
        if (liveData && isLiveStreamActive(liveData)) {
            liveStreams.push({ event, liveData });
            allEvents.set(event.id, event);
        }
    }, async () => {
        if (liveStreams.length === 0) {
            liveNowSection.style.display = 'none';
            return;
        }

        // Show section and render live stream cards
        liveNowSection.style.display = 'block';
        liveNowGrid.innerHTML = '';

        // Sort by viewer count (most viewers first)
        liveStreams.sort((a, b) => (b.liveData.currentParticipants || 0) - (a.liveData.currentParticipants || 0));

        // Cache for View More
        cachedLiveStreams = liveStreams;

        // Show up to one row of live streams initially
        const streamsToShow = liveStreams.slice(0, cardsPerRow);
        const liveEventIds = [];

        for (const { event, liveData } of streamsToShow) {
            const profile = await fetchUserProfile(event.pubkey);
            const card = createLiveStreamCard(event, liveData, profile);
            liveNowGrid.insertAdjacentHTML('beforeend', card);
            liveEventIds.push(event.id);
        }

        // Load actual viewer counts for live streams
        if (liveEventIds.length > 0) {
            loadLiveStreamCardsViewers(liveEventIds);
            // Load boosts for live streams
            liveEventIds.forEach(id => {
                if (!boostsCache.has(id)) {
                    loadBoostsForVideo(id);
                }
            });
        }

        // Show View More button if there are more streams
        if (liveStreams.length > cardsPerRow && viewMoreBtn) {
            viewMoreBtn.style.display = 'block';
        }
    });
}

// Expand Live section to show more streams
async function expandLiveNowSection() {
    const liveNowGrid = document.getElementById('liveNowGrid');
    const viewMoreBtn = document.getElementById('liveNowViewMore');
    const cardsPerRow = getCardsPerRow();

    if (!liveNowGrid || !cachedLiveStreams || cachedLiveStreams.length === 0) return;

    const initialCount = cardsPerRow;
    const maxCount = cardsPerRow * 3; // Show up to 3 rows

    // Get streams to add (skip already displayed)
    const streamsToAdd = cachedLiveStreams.slice(initialCount, maxCount);
    const liveEventIds = [];

    for (const { event, liveData } of streamsToAdd) {
        const profile = await fetchUserProfile(event.pubkey);
        const card = createLiveStreamCard(event, liveData, profile);
        liveNowGrid.insertAdjacentHTML('beforeend', card);
        liveEventIds.push(event.id);
    }

    // Load actual viewer counts for newly added streams
    if (liveEventIds.length > 0) {
        loadLiveStreamCardsViewers(liveEventIds);
        // Load boosts for live streams
        liveEventIds.forEach(id => {
            if (!boostsCache.has(id)) {
                loadBoostsForVideo(id);
            }
        });
    }

    // Hide View More button after expanding
    if (viewMoreBtn) {
        viewMoreBtn.style.display = 'none';
    }

    sectionExpanded.liveNow = true;
}

// Refresh recommended section as a grid (1 row)
// Uses progressive rendering - displays videos as they arrive
async function refreshRecommendedSectionGrid() {
    const history = getWatchHistory();
    const recommendedSection = document.getElementById('recommendedSection');
    const recommendedGrid = document.getElementById('recommendedGrid');
    const viewMoreBtn = document.getElementById('recommendedViewMore');
    const cardsPerRow = getCardsPerRow();

    if (history.length < RECOMMENDATION_THRESHOLD) {
        recommendedSection.style.display = 'none';
        return;
    }

    // Don't show section yet - wait until we know we have recommendations
    try {
        const recommendedIds = await getRecommendations(cardsPerRow * 2);

        if (recommendedIds.length === 0) {
            recommendedSection.style.display = 'none';
            return;
        }

        // Keep section hidden until we have actual videos to show
        // (some recommended IDs may be legacy events that get filtered)

        const videoFilter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            ids: recommendedIds
        };

        const videos = [];
        const renderedIds = new Set();
        let hasCleared = false;
        let renderTimeout = null;
        let firstRenderDone = false;

        // Order map for sorting by recommendation order
        const orderMap = new Map(recommendedIds.map((id, i) => [id, i]));

        // Progressive render function
        const renderProgressively = () => {
            if (videos.length === 0) return;

            // Sort by recommendation order
            const sortedVideos = [...videos].sort((a, b) =>
                (orderMap.get(a.id) ?? 999) - (orderMap.get(b.id) ?? 999)
            );
            const videosToShow = sortedVideos.slice(0, cardsPerRow);

            // Show section and clear spinner on first render
            if (!hasCleared && videosToShow.length > 0) {
                hasCleared = true;
                recommendedSection.style.display = 'block';
                recommendedGrid.innerHTML = '';
            }

            // Render new cards
            videosToShow.forEach(event => {
                if (renderedIds.has(event.id)) return;
                renderedIds.add(event.id);

                const profile = profileCache.get(event.pubkey);
                const reactions = reactionsCache.get(event.id);
                // First row loads immediately (non-lazy)
                const isFirstRow = renderedIds.size <= cardsPerRow;
                const cardHtml = createVideoCard(event, profile, reactions, false, null, !isFirstRow);

                if (cardHtml) {
                    recommendedGrid.insertAdjacentHTML('beforeend', cardHtml);

                    // Load profile immediately if not cached
                    loadProfileAndUpdateCards(event.pubkey);
                }
            });

            observeLazyCards();
            firstRenderDone = true;
        };

        // Debounced render (immediate on first event)
        const scheduleRender = () => {
            if (renderTimeout) clearTimeout(renderTimeout);
            if (!firstRenderDone) {
                renderProgressively();
            } else {
                renderTimeout = setTimeout(renderProgressively, 50);
            }
        };

        // Stream events and render progressively
        requestEventsStream(videoFilter, (event) => {
            allEvents.set(event.id, event);

            // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
            if (shouldSkipLegacyEvent(event)) return;

            // Skip shorts - they're shown in the dedicated Shorts section
            if (isNip71ShortKind(event.kind)) return;

            // Never show logged-in user's own videos in recommendations
            if (currentUser && event.pubkey === currentUser.pubkey) return;

            // Skip videos that match content filter packs or custom keywords
            const videoData = parseNip71VideoEvent(event) || parseVideoEvent(event);
            if (videoData) {
                const filterResult = shouldFilterVideoContent(event, videoData);
                if (filterResult.filtered) return;
            }

            videos.push(event);
            scheduleRender();
        }, () => {
            // On completion
            clearTimeout(renderTimeout);
            renderProgressively();

            if (videos.length === 0) {
                recommendedSection.style.display = 'none';
                return;
            }

            // Sort and cache all videos
            videos.sort((a, b) => (orderMap.get(a.id) ?? 999) - (orderMap.get(b.id) ?? 999));
            cachedRecommendedVideos = videos;

            // Load views for recommended videos
            const recommendedIds = videos.map(e => e.id);
            if (recommendedIds.length > 0) {
                loadViewsForVideos(recommendedIds, true);
            }

            // Show View More if more videos available
            if (videos.length > cardsPerRow && viewMoreBtn) {
                viewMoreBtn.style.display = 'block';
            }
        });
    } catch (error) {
        console.error('Error loading recommendations:', error);
        recommendedSection.style.display = 'none';
    }
}

// Load shorts section (kind 22 vertical videos)
async function loadShortsSection() {
    const shortsSection = document.getElementById('shortsSection');
    const shortsGrid = document.getElementById('shortsGrid');
    const viewMoreBtn = document.getElementById('shortsViewMore');
    const cardsPerRow = getShortsCardsPerRow();

    if (!shortsSection || !shortsGrid) return;

    const filter = {
        kinds: [NIP71_SHORT_KIND, NIP71_SHORT_KIND_LEGACY],
        '#t': ['pv69420'],
        limit: cardsPerRow * 3 // Fetch enough for 3 rows
    };

    const videos = [];
    let renderedCount = 0;
    const maxInitialDisplay = cardsPerRow;

    // Queue for batch loading reactions and boosts
    const reactionQueue = new Set();
    const boostQueue = new Set();
    let reactionTimer = null;
    let boostTimer = null;

    const loadReactionsBatch = async () => {
        if (reactionQueue.size === 0) return;
        const videoIds = Array.from(reactionQueue);
        reactionQueue.clear();
        await loadReactionsForVideos(videoIds);
    };

    const loadBoostsBatch = async () => {
        if (boostQueue.size === 0) return;
        const videoIds = Array.from(boostQueue);
        boostQueue.clear();
        await loadBoostsForVideos(videoIds);
    };

    return new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            // Parse the event
            const videoData = parseNip71VideoEvent(event);
            if (!videoData) return;

            allEvents.set(event.id, event);

            // Skip legacy events (kind 22) if addressable counterpart (kind 34236) exists
            if (shouldSkipLegacyEvent(event)) return;

            videos.push(event);

            // Progressive rendering for first row
            if (renderedCount < maxInitialDisplay) {
                // Clear skeletons on first video
                if (renderedCount === 0) {
                    shortsGrid.innerHTML = '';
                    shortsSection.style.display = 'block';
                }

                const profile = profileCache.get(event.pubkey);
                const reactions = reactionsCache.get(event.id);
                const card = createShortCard(event, profile, reactions);

                if (card) {
                    shortsGrid.insertAdjacentHTML('beforeend', card);
                    renderedCount++;
                    loadProfileAndUpdateCards(event.pubkey);

                    // Queue reactions and boosts loading
                    reactionQueue.add(event.id);
                    boostQueue.add(event.id);
                    clearTimeout(reactionTimer);
                    clearTimeout(boostTimer);
                    reactionTimer = setTimeout(loadReactionsBatch, 200);
                    boostTimer = setTimeout(loadBoostsBatch, 200);
                }
            }
        }, () => {
            // EOSE - finalize
            if (videos.length === 0) {
                // No shorts found, hide section
                shortsSection.style.display = 'none';
                resolve();
                return;
            }

            // Sort by newest first
            videos.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            cachedShorts = videos;

            // Show View More if there are more shorts
            if (videos.length > cardsPerRow && viewMoreBtn) {
                viewMoreBtn.style.display = 'block';
            }

            // Final batch load for any remaining queued items
            if (reactionQueue.size > 0) loadReactionsBatch();
            if (boostQueue.size > 0) loadBoostsBatch();

            // Load views for shorts
            const shortIds = videos.map(e => e.id);
            if (shortIds.length > 0) {
                loadViewsForVideos(shortIds, true);
            }

            observeLazyCards();
            resolve();
        });
    });
}

// Create a short card (vertical video format)
function createShortCard(event, profile, reactions, showOwnerActions = false) {
    const videoData = parseNip71VideoEvent(event);
    if (!videoData) return '';

    // Check if content from this user should be hidden (muted)
    if (shouldHideMutedContent(event.pubkey)) {
        return '';
    }

    // Check if content matches enabled filter packs
    const filterResult = shouldFilterVideoContent(event, videoData);
    if (filterResult.filtered) {
        return createFilteredContentPlaceholder(event, filterResult, 'video');
    }

    const title = videoData.title || 'Untitled Short';
    const thumbnailUrl = videoData.thumbnail || '';
    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';

    // Check NSFW and community warning states
    const isNSFW = videoData.isNSFW || false;
    const isRatioed = isVideoRatioed(reactions || {});

    // Track whether profile has been checked
    const profileChecked = profileCache.has(event.pubkey);
    const isSuspiciousProfile = profileChecked && (!profile || !avatarUrl || !nip05);

    // Get boost data from cache
    const boostAmount = boostsCache.get(event.id) || 0;
    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;

    // Determine what type of overlay to show (skip for own videos)
    const isOwnVideo = currentUser?.pubkey === event.pubkey;
    const showNSFWOverlay = !isOwnVideo && isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own videos)
    const isReportedByFollowsCheck = !isOwnVideo && isReportedByFollowsSync(event.id, event.pubkey);
    const showCommunityWarning = !isOwnVideo && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning();
    const showBlurred = showNSFWOverlay || showCommunityWarning;
    const overlayType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    const cardId = `video-card-${event.id}`;

    return `
        <div class="video-card short-card ${isBoosted ? `boosted boost-level-${boostLevel}` : ''}" id="${cardId}" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-validation-pending="${avatarUrl || nip05 ? 'true' : 'false'}">
            <div class="video-thumbnail short-thumbnail ${showBlurred ? overlayType : ''}" data-thumbnail="${escapeHtml(thumbnailUrl)}"${videoData.preview ? ` data-preview="${escapeHtml(videoData.preview)}"` : ''}
                 onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${event.id}')` : `showRatioedModal('${event.id}')`) : `navigateTo('/video/${event.id}')`}">
                ${thumbnailUrl ? `<img class="thumbnail-img" src="${thumbnailUrl}" alt="${escapeHtml(title)}" loading="lazy">` : '<div class="thumbnail-placeholder"></div>'}
                ${showBlurred ? `
                    <div class="${overlayType}-overlay">
                        <div class="${overlayType}-badge">${overlayType === 'nsfw' ? t('badge.nsfw') : t('badge.communityWarning')}</div>
                        <div>Click to view</div>
                    </div>
                ` : ''}
                ${isBoosted ? `
                    <div class="boost-indicator">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                        </svg>
                        ${formatSats(boostAmount)}
                    </div>
                ` : ''}
                ${!showBlurred && videoData.duration ? `<span class="video-duration">${formatDuration(videoData.duration)}</span>` : ''}
                ${reactions && (reactions.likes > 0 || reactions.dislikes > 0) ? `
                    <div class="video-reactions">
                        ${reactions.likes > 0 ? `
                            <span class="reaction-count likes">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                                </svg>
                                ${formatNumber(reactions.likes)}
                            </span>
                        ` : ''}
                        ${reactions.dislikes > 0 ? `
                            <span class="reaction-count dislikes">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                                </svg>
                                ${formatNumber(reactions.dislikes)}
                            </span>
                        ` : ''}
                    </div>
                ` : ''}
                ${showOwnerActions ? `
                    <div class="video-owner-actions">
                        ${(event.kind === NIP71_VIDEO_KIND || event.kind === NIP71_SHORT_KIND) ? `
                            <button class="owner-edit-btn" onclick="event.stopPropagation(); showEditVideoModal('${event.id}')" title="${t('button.editShort')}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                                </svg>
                            </button>
                        ` : ''}
                        <button class="owner-delete-btn" onclick="event.stopPropagation(); handleDelete('${event.id}')" title="${t('button.deleteShort')}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                        </button>
                    </div>
                ` : ''}
            </div>
            <div class="video-info">
                <a href="#/profile/${event.pubkey}" class="channel-info">
                    <div class="channel-avatar">
                        ${avatarUrl ? `<img src="${escapeHtml(avatarUrl)}" alt="${escapeHtml(displayName)}" loading="lazy"
                             onerror="this.style.display='none'"
                             data-avatar-url="${escapeHtml(avatarUrl)}">` : ''}
                    </div>
                    <div class="channel-details">
                        <div class="channel-name">${escapeHtml(displayName)}</div>
                        ${nip05 ? `<div class="channel-nip05" data-nip05="${nip05}">${nip05}</div>` : ''}
                    </div>
                </a>
                <h3 class="video-title" onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${event.id}')` : `showRatioedModal('${event.id}')`) : `navigateTo('/video/${event.id}')`}">${escapeHtml(title)}</h3>
                <div class="video-meta">
                    ${formatTimestamp(event.created_at)}
                    <span class="video-views" data-event-id="${event.id}">${(() => { const c = getCachedViewCount(event.id); return c !== null ? ` • ${formatNumber(c)} ${t('stat.views')}` : ''; })()}</span>
                    ${isNSFW ? ' • <span style="color: #ff0000;">NSFW</span>' : ''}
                    <span class="community-warning-indicator" style="${showCommunityWarning && !showNSFWOverlay ? '' : 'display: none;'}"> • <span style="color: #ff9800;">Community Warning</span></span>
                </div>
            </div>
        </div>
    `;
}

// Load featured topics (Gaming, Music, Podcasts)
// Uses progressive rendering - loads all topics in parallel and displays as videos arrive
async function loadFeaturedTopics() {
    const cardsPerRow = getCardsPerRow();
    const videosPerTopic = cardsPerRow * 3; // 3 rows

    // Load a single featured topic with progressive rendering
    const loadFeaturedTopic = (topic, index) => {
        const sectionId = `featuredTopic${index + 1}Section`;
        const gridId = `featuredTopic${index + 1}Grid`;
        const iconId = `featuredTopic${index + 1}Icon`;
        const nameId = `featuredTopic${index + 1}Name`;
        const viewMoreId = `featuredTopic${index + 1}ViewMore`;
        const viewMoreContainerId = `featuredTopic${index + 1}ViewMoreContainer`;

        const section = document.getElementById(sectionId);
        const grid = document.getElementById(gridId);
        const iconEl = document.getElementById(iconId);
        const nameEl = document.getElementById(nameId);
        const viewMoreBtn = document.getElementById(viewMoreId);
        const viewMoreContainer = document.getElementById(viewMoreContainerId);

        if (!section || !grid) return;

        // Set topic info
        iconEl.innerHTML = topic.icon;
        nameEl.textContent = topic.name;
        // Set up View More to expand section
        viewMoreBtn.onclick = () => expandSection('featured', index);

        const videos = [];
        const renderedIds = new Set();
        let hasCleared = false;
        let renderTimeout = null;
        let firstRenderDone = false;

        // Progressive render function
        const renderProgressively = () => {
            const minVideos = Math.min(4, videosPerTopic);
            if (videos.length < minVideos) return; // Wait for minimum videos

            // Sort by timestamp (newest first)
            const sortedVideos = [...videos].sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            const videosToShow = sortedVideos.slice(0, videosPerTopic);

            // Clear skeleton loaders on first render
            if (!hasCleared && videosToShow.length >= minVideos) {
                hasCleared = true;
                grid.innerHTML = '';
                section.style.display = 'block';
            }

            if (!hasCleared) return;

            // Render new cards
            videosToShow.forEach(event => {
                if (renderedIds.has(event.id)) return;
                renderedIds.add(event.id);

                const profile = profileCache.get(event.pubkey);
                const reactions = reactionsCache.get(event.id);
                // First row loads immediately (non-lazy)
                const isFirstRow = renderedIds.size <= videosPerTopic;
                const cardHtml = createVideoCard(event, profile, reactions, false, null, !isFirstRow);

                if (cardHtml) {
                    // Insert in sorted position
                    const existingCards = grid.querySelectorAll('.video-card');
                    let inserted = false;

                    for (const existingCard of existingCards) {
                        const existingEventId = existingCard.id.replace('video-card-', '');
                        const existingEvent = allEvents.get(existingEventId);
                        if (existingEvent && (event.created_at || 0) > (existingEvent.created_at || 0)) {
                            existingCard.insertAdjacentHTML('beforebegin', cardHtml);
                            inserted = true;
                            break;
                        }
                    }

                    if (!inserted) {
                        grid.insertAdjacentHTML('beforeend', cardHtml);
                    }

                    // Load profile immediately if not cached
                    loadProfileAndUpdateCards(event.pubkey);

                    // Load boosts if not cached (fire-and-forget)
                    if (!boostsCache.has(event.id)) {
                        loadBoostsForVideo(event.id, (totalBoosts) => {
                            const card = document.getElementById(`video-card-${event.id}`);
                            if (!card) return;
                            const boostLevel = getBoostLevel(totalBoosts);
                            const isBoosted = boostLevel > 0;
                            if (isBoosted) {
                                card.classList.add('boosted', `boost-level-${boostLevel}`);
                                for (let i = 1; i <= 4; i++) {
                                    if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                                }
                                const thumbnail = card.querySelector('.video-thumbnail');
                                if (thumbnail) {
                                    const existingIndicator = thumbnail.querySelector('.boost-indicator');
                                    const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                                    if (existingIndicator) {
                                        existingIndicator.outerHTML = indicatorHTML;
                                    } else {
                                        thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                                    }
                                }
                            }
                        });
                    }
                }
            });

            observeLazyCards();
            firstRenderDone = true;
        };

        // Debounced render (immediate on first event with enough videos)
        const scheduleRender = () => {
            if (renderTimeout) clearTimeout(renderTimeout);
            if (!firstRenderDone && videos.length >= 4) {
                renderProgressively();
            } else {
                renderTimeout = setTimeout(renderProgressively, 50);
            }
        };

        const filter = {
            kinds: ALL_VIDEO_KINDS,
            '#t': ['pv69420'],
            limit: 200
        };

        // Stream events and render progressively
        requestEventsStream(filter, (event) => {
            // Check if video has this tag
            const tags = event.tags || [];
            const hasTag = tags.some(t => t[0] === 't' && t[1].toLowerCase() === topic.tag);
            if (hasTag) {
                allEvents.set(event.id, event);

                // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
                if (shouldSkipLegacyEvent(event)) return;

                // Skip shorts - they're shown in the dedicated Shorts section
                if (isNip71ShortKind(event.kind)) return;

                videos.push(event);
                scheduleRender();
            }
        }, () => {
            // On completion
            clearTimeout(renderTimeout);
            renderProgressively();

            const minVideos = Math.min(4, videosPerTopic);
            if (videos.length < minVideos) {
                section.style.display = 'none';
                return;
            }

            // Sort and cache all videos
            videos.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            cachedFeaturedVideos[index] = videos;

            // Load views for featured videos
            const featuredIds = videos.map(e => e.id);
            if (featuredIds.length > 0) {
                loadViewsForVideos(featuredIds, true);
            }

            // Show View More if more videos available
            if (videos.length > videosPerTopic && viewMoreContainer) {
                viewMoreContainer.style.display = 'block';
            }
        });
    };

    // Load all featured topics in parallel
    FEATURED_TOPICS.forEach((topic, index) => {
        loadFeaturedTopic(topic, index);
    });
}

// Load latest videos section (5 rows initially, expandable to 10)
// Uses progressive rendering - displays videos as they arrive
async function loadLatestVideosSection() {
    const videoGrid = document.getElementById('videoGrid');
    const viewMoreBtn = document.getElementById('latestViewMore');
    const cardsPerRow = getCardsPerRow();
    const initialRows = 5;
    const videosToDisplay = cardsPerRow * initialRows;

    // Include both videos AND live streams
    const filter = {
        kinds: [...ALL_VIDEO_KINDS, NIP53_LIVE_EVENT_KIND],
        limit: 200, // Load more for expansion
        '#t': ['pv69420']
    };

    const videos = [];
    const liveStreamData = new Map(); // Map event.id -> parsed liveData
    const renderedIds = new Set();
    let hasCleared = false;
    let renderTimeout = null;
    let firstRenderDone = false;

    // Progressive render function - called as videos arrive
    const renderProgressively = async () => {
        if (videos.length === 0) return;

        // Sort videos by timestamp (newest first)
        const sortedVideos = [...videos].sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
        const videosToShow = sortedVideos.slice(0, videosToDisplay);

        // Clear skeleton loaders on first render
        if (!hasCleared && videosToShow.length > 0) {
            hasCleared = true;
            videoGrid.innerHTML = '';
        }

        // Render new cards that haven't been rendered yet
        for (const event of videosToShow) {
            if (renderedIds.has(event.id)) continue;
            renderedIds.add(event.id);

            const profile = profileCache.get(event.pubkey) || await fetchUserProfile(event.pubkey);
            const reactions = reactionsCache.get(event.id);
            // First row loads thumbnails immediately (non-lazy) for faster display
            const isFirstRow = renderedIds.size <= cardsPerRow;

            let cardHtml;
            let isLiveStream = false;
            // Check if this is a live stream
            if (event.kind === NIP53_LIVE_EVENT_KIND) {
                const liveData = liveStreamData.get(event.id);
                if (liveData && isLiveStreamActive(liveData)) {
                    cardHtml = createLiveStreamCard(event, liveData, profile);
                    isLiveStream = true;
                } else {
                    continue; // Skip non-active live streams
                }
            } else {
                cardHtml = createVideoCard(event, profile, reactions, false, null, !isFirstRow);
            }

            if (cardHtml) {
                // Load actual viewer count for live streams
                if (isLiveStream) {
                    loadLiveStreamCardViewers(event.id);
                }
                // Insert in sorted position
                const existingCards = videoGrid.querySelectorAll('.video-card');
                let inserted = false;

                for (const existingCard of existingCards) {
                    const existingEventId = existingCard.id.replace('video-card-', '');
                    const existingEvent = allEvents.get(existingEventId);
                    if (existingEvent && (event.created_at || 0) > (existingEvent.created_at || 0)) {
                        existingCard.insertAdjacentHTML('beforebegin', cardHtml);
                        inserted = true;
                        break;
                    }
                }

                if (!inserted) {
                    videoGrid.insertAdjacentHTML('beforeend', cardHtml);
                }

                // Load profile immediately if not cached (fire-and-forget)
                loadProfileAndUpdateCards(event.pubkey);

                // Load boosts if not cached (fire-and-forget)
                if (!boostsCache.has(event.id)) {
                    loadBoostsForVideo(event.id, (totalBoosts) => {
                        // Use a local helper since we're inside the function
                        const card = document.getElementById(`video-card-${event.id}`);
                        if (!card) return;
                        const boostLevel = getBoostLevel(totalBoosts);
                        const isBoosted = boostLevel > 0;
                        if (isBoosted) {
                            card.classList.add('boosted', `boost-level-${boostLevel}`);
                            for (let i = 1; i <= 4; i++) {
                                if (i !== boostLevel) card.classList.remove(`boost-level-${i}`);
                            }
                            const thumbnail = card.querySelector('.video-thumbnail');
                            if (thumbnail) {
                                const existingIndicator = thumbnail.querySelector('.boost-indicator');
                                const indicatorHTML = `<div class="boost-indicator"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/></svg>${formatSats(totalBoosts)}</div>`;
                                if (existingIndicator) {
                                    existingIndicator.outerHTML = indicatorHTML;
                                } else {
                                    thumbnail.insertAdjacentHTML('beforeend', indicatorHTML);
                                }
                            }
                        }
                    });
                }
            }
        }

        // Observe lazy cards after rendering
        observeLazyCards();
        firstRenderDone = true;
    };

    // Debounced render to batch rapid updates (but render immediately on first event)
    const scheduleRender = () => {
        if (renderTimeout) clearTimeout(renderTimeout);
        // Render immediately on first event, then debounce subsequent updates
        if (!firstRenderDone) {
            renderProgressively();
        } else {
            renderTimeout = setTimeout(renderProgressively, 50);
        }
    };

    // Stream events and render progressively
    requestEventsStream(filter, (event) => {
        allEvents.set(event.id, event);

        // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
        if (shouldSkipLegacyEvent(event)) return;

        // Skip shorts - they're shown in the dedicated Shorts section
        if (isNip71ShortKind(event.kind)) return;

        // Handle live streams specially
        if (event.kind === NIP53_LIVE_EVENT_KIND) {
            const liveData = parseLiveEvent(event);
            if (liveData && isLiveStreamActive(liveData)) {
                liveStreamData.set(event.id, liveData);
                videos.push(event);
                scheduleRender();
            }
            return;
        }

        videos.push(event);
        scheduleRender();
    }, () => {
        // On completion, do final render and cache
        clearTimeout(renderTimeout);
        renderProgressively();

        if (videos.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosFound')}</p>`;
            return;
        }

        // Sort and cache all videos for View More expansion
        videos.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
        cachedLatestVideos = videos;

        // Show View More button if there are more videos
        if (videos.length > videosToDisplay && viewMoreBtn) {
            viewMoreBtn.style.display = 'block';
        }
    });
}

// Initialize carousel functionality
function initializeCarousel() {
    const trendingGrid = document.getElementById('trendingGrid');
    const carouselDots = document.getElementById('carouselDots');
    const container = trendingGrid?.parentElement;

    if (!trendingGrid || !carouselDots || !container) return;

    const cards = trendingGrid.querySelectorAll('.video-card');
    const totalCards = cards.length;

    if (totalCards === 0) return;

    let itemsPerPage;
    if (window.innerWidth <= 480) {
        itemsPerPage = 2; // 2 on mobile
    } else if (window.innerWidth <= 768) {
        itemsPerPage = 3; // 3 on tablet
    } else {
        itemsPerPage = 4; // 4 on desktop
    }

    itemsPerPage = Math.min(itemsPerPage, totalCards);

    const totalPages = Math.ceil(totalCards / itemsPerPage);

    // Calculate card width in pixels to fit exactly itemsPerPage cards
    const gap = 16; // 1rem gap
    const containerWidth = container.clientWidth;
    const totalGapWidth = (itemsPerPage - 1) * gap;
    const cardWidth = (containerWidth - totalGapWidth) / itemsPerPage;

    cards.forEach(card => {
        card.style.flex = `0 0 ${cardWidth}px`;
        card.style.maxWidth = `${cardWidth}px`;
        card.style.width = `${cardWidth}px`;
    });

    carouselDots.innerHTML = '';
    for (let i = 0; i < totalPages; i++) {
        const dot = document.createElement('div');
        dot.className = `carousel-dot ${i === 0 ? 'active' : ''}`;
        dot.onclick = () => goToPage(i);
        carouselDots.appendChild(dot);
    }

    trendingGrid.dataset.currentPage = '0';
    trendingGrid.dataset.totalPages = totalPages;
    trendingGrid.dataset.itemsPerPage = itemsPerPage;
    trendingGrid.dataset.cardWidth = cardWidth;
    trendingGrid.dataset.gap = gap;

    updateCarouselButtons();
    goToPage(0);
}

// Function to load trending section asynchronously
async function loadTrendingSection() {
    const trendingGrid = document.getElementById('trendingGrid');
    let hasRendered = false;

    try {
        const trendingPromise = loadTrendingVideos(currentTrendingPeriod);

        const checkInterval = setInterval(async () => {
            const trendingVideos = await Promise.race([
                trendingPromise,
                new Promise(resolve => setTimeout(() => resolve(null), 10))
            ]);

            if (trendingVideos && trendingVideos.length > 0 && !hasRendered) {
                hasRendered = true;
                clearInterval(checkInterval);
                await renderTrendingVideos(trendingVideos);
            }
        }, 500);

        const trendingVideos = await trendingPromise;
        clearInterval(checkInterval);

        if (trendingVideos.length > 0) {
            await renderTrendingVideos(trendingVideos);
        } else if (!hasRendered) {
            trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noTrendingVideos')}</p>`;
        }
    } catch (error) {
        console.error('Failed to load trending videos:', error);
        const trendingSection = document.getElementById('trendingSection');
        if (trendingSection) {
            trendingSection.style.display = 'none';
        }
    }
}

// Helper function to render trending videos - non-blocking profile loading
function renderTrendingVideos(trendingVideos) {
    const trendingGrid = document.getElementById('trendingGrid');

    // Find uncached profile pubkeys
    const uncachedPubkeys = [...new Set(trendingVideos.map(v => v.pubkey).filter(pk => !profileCache.has(pk)))];

    // Render immediately with available profile data
    const renderedCards = trendingVideos.map((event, index) => {
        const profile = profileCache.get(event.pubkey);
        const reactions = reactionsCache.get(event.id);
        return createVideoCard(event, profile, reactions, true, index + 1);
    }).filter(card => card !== '');

    if (renderedCards.length > 0) {
        trendingGrid.innerHTML = renderedCards.join('');
        observeLazyCards();
        initializeCarousel();

        // Load profiles immediately
        trendingVideos.forEach(event => loadProfileAndUpdateCards(event.pubkey));
    } else {
        trendingGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noTrendingVideos')}</p>`;
    }
}

// Function to switch trending period
async function switchTrendingPeriod(period) {
    currentTrendingPeriod = period;

    document.querySelectorAll('.trending-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    event.target.classList.add('active');

    const trendingGrid = document.getElementById('trendingGrid');
    if (trendingGrid) {
        const cardsPerRow = getCardsPerRow();
        trendingGrid.innerHTML = Array(cardsPerRow).fill(createSkeletonCard()).join('');
    }

    await loadTrendingSectionGrid();
}

// Load following
async function loadFollowing() {
    if (!currentUser) {
        await checkStoredLogin(); // Wait for login check
        if (!currentUser) {
            document.getElementById('mainContent').innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.loginToViewFollowing')}</p>`;
            return;
        }
    }

    currentView = 'following';

    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = '<div class="spinner"></div>';

    try {
        const followingFilter = {
            kinds: [3],
            authors: [currentUser.pubkey],
            limit: 1
        };

        let followingList = [];
        await new Promise((resolve) => {
            requestEventsStream(followingFilter, (event) => {
                const pTags = event.tags.filter(tag => tag[0] === 'p');
                followingList = pTags.map(tag => tag[1]);
            }, resolve);
        });

        if (followingList.length === 0) {
            mainContent.innerHTML = `
                <h2 style="margin-bottom: 1.5rem;">Following</h2>
                <p style="text-align: center; color: var(--text-secondary);">You're not following anyone yet. Find creators to follow!</p>
            `;
            return;
        }

        // Create the page layout with users section and videos section
        const cardsPerRow = getCardsPerRow();
        const userSkeletonCount = cardsPerRow * 2; // 2 rows of user skeletons
        const videoSkeletonCount = cardsPerRow * 10; // 10 rows of video skeletons
        const userSkeletons = Array(userSkeletonCount).fill(createSkeletonFollowingUserCard()).join('');
        const videoSkeletons = Array(videoSkeletonCount).fill(createSkeletonCard()).join('');
        const liveSkeletons = Array(cardsPerRow).fill(createLiveStreamSkeletonCard()).join('');
        const shortSkeletons = Array(getShortsCardsPerRow()).fill(createShortSkeletonCard()).join('');

        mainContent.innerHTML = `
            <h2 style="margin-bottom: 1.5rem;">Following</h2>
            <div class="following-users-section">
                <div class="following-users-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.75rem;">
                    <h3 style="margin: 0; color: var(--text-secondary);">Users You Follow</h3>
                    <div class="following-search-container" style="position: relative;">
                        <input type="text" id="followingUserSearch" placeholder="${t('placeholder.searchUsers')}"
                               style="padding: 0.5rem 0.75rem 0.5rem 2.25rem; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-secondary); color: var(--text-primary); width: 200px; font-size: 0.875rem;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); color: var(--text-secondary);">
                            <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                        </svg>
                    </div>
                </div>
                <div class="following-users-grid" id="followingUsersGrid">
                    ${userSkeletons}
                </div>
                <div id="viewMoreUsersContainer" style="display: none; text-align: center; margin-top: 1rem;">
                    <button id="viewMoreUsersBtn" class="action-btn view-more-btn">
                        View More
                    </button>
                </div>
            </div>
            <hr class="section-divider">
            <!-- Live Streams Section -->
            <div id="followingLiveSection" style="margin-bottom: 2rem;">
                <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                        <circle cx="12" cy="12" r="4" fill="#f44336"/>
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                    </svg>
                    Live Streams
                </h3>
                <div class="video-grid" id="followingLiveGrid">${liveSkeletons}</div>
            </div>
            <!-- Shorts Section -->
            <div id="followingShortsSection" style="margin-bottom: 2rem;">
                <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                        <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                        <path d="M10 8l6 4-6 4V8z"/>
                    </svg>
                    Shorts
                </h3>
                <div class="shorts-grid" id="followingShortsGrid">${shortSkeletons}</div>
                <div class="view-more-container" id="followingShortsViewMore" style="display: none;">
                    <button class="action-btn view-more-btn" onclick="expandSection('followingShorts')">View More</button>
                </div>
            </div>
            <!-- Videos Section -->
            <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                </svg>
                Latest Videos
            </h3>
            <div class="video-grid" id="followingVideoGrid">
                ${videoSkeletons}
            </div>
        `;

        const followingUsersGrid = document.getElementById('followingUsersGrid');
        const videoGrid = document.getElementById('followingVideoGrid');
        const shortsGrid = document.getElementById('followingShortsGrid');
        const shortsSection = document.getElementById('followingShortsSection');
        const shortsViewMore = document.getElementById('followingShortsViewMore');
        const liveGrid = document.getElementById('followingLiveGrid');
        const liveSection = document.getElementById('followingLiveSection');
        const viewMoreContainer = document.getElementById('viewMoreUsersContainer');
        const viewMoreBtn = document.getElementById('viewMoreUsersBtn');
        const searchInput = document.getElementById('followingUserSearch');
        const renderedVideos = new Map();
        const renderedShorts = new Map();
        const renderedLiveStreams = new Map();
        const videoEvents = [];
        const shortEvents = [];
        const liveEvents = [];
        const reactionQueue = new Set();
        let reactionTimer = null;
        let shortsRenderedCount = 0;
        const maxInitialShorts = getShortsCardsPerRow(); // Show one row initially

        // Reset cached following shorts
        cachedFollowingShorts = [];
        sectionExpanded.followingShorts = false;

        // Store all user data for filtering
        const allFollowedUsers = [];
        let showingAllUsers = false;

        // Calculate dynamic user limit based on grid width (show 2 rows)
        const calculateUserLimit = () => {
            const gridWidth = followingUsersGrid.offsetWidth;
            const minCardWidth = window.innerWidth <= 768 ? 150 : 200; // Match CSS minmax values
            const gap = 16; // 1rem gap
            const cardsPerRow = Math.floor((gridWidth + gap) / (minCardWidth + gap)) || 1;
            return cardsPerRow * 2; // Show 2 rows
        };

        let INITIAL_USER_LIMIT = calculateUserLimit();

        // Recalculate on resize
        let resizeTimeout;
        const handleResize = () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (!showingAllUsers && !searchInput.value.trim()) {
                    INITIAL_USER_LIMIT = calculateUserLimit();
                    displayUsers(allFollowedUsers, INITIAL_USER_LIMIT);
                }
            }, 150);
        };
        window.addEventListener('resize', handleResize);

        // Create a user card for the following section
        const createFollowingUserCard = (pubkey, profile) => {
            const displayName = profile?.name || profile?.display_name || `User ${pubkey.slice(0, 8)}`;
            const avatarUrl = profile?.picture || profile?.avatar || '';
            const nip05 = profile?.nip05 || '';

            return `
                <a href="#/profile/${pubkey}" class="following-user-card" data-pubkey="${pubkey}">
                    <div class="following-user-avatar">
                        ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}" onerror="this.style.display='none'">` : ''}
                    </div>
                    <div class="following-user-name">${displayName}</div>
                    ${nip05 ? `<div class="following-user-nip05">${nip05}</div>` : ''}
                </a>
            `;
        };

        // Track rendered user pubkeys to avoid re-rendering
        const renderedUserPubkeys = new Set();

        // Display users with limit (only renders new users, doesn't replace existing)
        const displayUsers = (users, limit = null, forceRerender = false) => {
            // Remove skeleton cards on first render
            const skeletons = followingUsersGrid.querySelectorAll('.skeleton-user-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            if (users.length === 0) {
                if (followingUsersGrid.children.length === 0) {
                    followingUsersGrid.innerHTML = `<p style="color: var(--text-secondary); grid-column: 1/-1; text-align: center;">${t('empty.noMatchingUsers')}</p>`;
                }
                viewMoreContainer.style.display = 'none';
                return;
            }

            const usersToShow = limit ? users.slice(0, limit) : users;

            if (forceRerender) {
                // For search filtering, we need to re-render
                renderedUserPubkeys.clear();
                followingUsersGrid.innerHTML = '';
            }

            // Only render users that haven't been rendered yet
            const newUsers = usersToShow.filter(user => !renderedUserPubkeys.has(user.pubkey));

            if (newUsers.length > 0) {
                const cardsHTML = newUsers.map(user => {
                    renderedUserPubkeys.add(user.pubkey);
                    return createFollowingUserCard(user.pubkey, user.profile);
                }).join('');
                followingUsersGrid.insertAdjacentHTML('beforeend', cardsHTML);
            }

            // Show/hide "View More" button
            if (limit && users.length > limit) {
                viewMoreContainer.style.display = 'block';
                viewMoreBtn.textContent = `View More (${users.length - limit} more)`;
            } else {
                viewMoreContainer.style.display = 'none';
            }
        };

        // Expand users to show all (appends new users without re-rendering existing)
        const expandUsers = () => {
            const currentCount = renderedUserPubkeys.size;
            const usersToAdd = allFollowedUsers.slice(currentCount);

            if (usersToAdd.length > 0) {
                const cardsHTML = usersToAdd.map(user => {
                    renderedUserPubkeys.add(user.pubkey);
                    return createFollowingUserCard(user.pubkey, user.profile);
                }).join('');
                followingUsersGrid.insertAdjacentHTML('beforeend', cardsHTML);
            }

            viewMoreContainer.style.display = 'none';
        };

        // Fetch profiles in batches to handle relay limits
        const BATCH_SIZE = 50;
        const loadedPubkeys = new Set();

        const fetchProfileBatch = async (pubkeyBatch) => {
            const profileFilter = {
                kinds: [0],
                authors: pubkeyBatch
            };

            await new Promise((resolve) => {
                requestEventsStream(profileFilter, (profileEvent) => {
                    try {
                        const profile = JSON.parse(profileEvent.content);
                        profileCache.set(profileEvent.pubkey, profile);

                        if (!loadedPubkeys.has(profileEvent.pubkey)) {
                            loadedPubkeys.add(profileEvent.pubkey);
                            allFollowedUsers.push({ pubkey: profileEvent.pubkey, profile });

                            // Render new user if not searching and within limit
                            if (!searchInput.value.trim() && !showingAllUsers) {
                                if (allFollowedUsers.length <= INITIAL_USER_LIMIT) {
                                    displayUsers(allFollowedUsers, INITIAL_USER_LIMIT);
                                } else if (renderedUserPubkeys.size < INITIAL_USER_LIMIT) {
                                    displayUsers(allFollowedUsers, INITIAL_USER_LIMIT);
                                } else {
                                    // Just update the View More button count
                                    viewMoreContainer.style.display = 'block';
                                    viewMoreBtn.textContent = `View More (${allFollowedUsers.length - INITIAL_USER_LIMIT} more)`;
                                }
                            }
                        }
                    } catch (e) {
                        // Ignore invalid profile JSON
                    }
                }, resolve);
            });
        };

        // Split followingList into batches and fetch all
        const profileBatches = [];
        for (let i = 0; i < followingList.length; i += BATCH_SIZE) {
            profileBatches.push(followingList.slice(i, i + BATCH_SIZE));
        }

        // Fetch all batches in parallel
        const profilesPromise = Promise.all(profileBatches.map(batch => fetchProfileBatch(batch))).then(() => {
            // After all batches complete, add any remaining users without profiles
            followingList.forEach(pubkey => {
                if (!loadedPubkeys.has(pubkey)) {
                    loadedPubkeys.add(pubkey);
                    const profile = profileCache.get(pubkey) || null;
                    allFollowedUsers.push({ pubkey, profile });
                }
            });

            // Final display
            if (!searchInput.value.trim()) {
                displayUsers(allFollowedUsers, showingAllUsers ? null : INITIAL_USER_LIMIT);
            }

            // If no users were loaded, show a message
            if (allFollowedUsers.length === 0) {
                followingUsersGrid.innerHTML = `<p style="color: var(--text-secondary);">${t('empty.unableLoadProfiles')}</p>`;
            }
        });

        // View More button handler - append new users without re-rendering
        viewMoreBtn.addEventListener('click', () => {
            showingAllUsers = true;
            const query = searchInput.value.toLowerCase().trim();
            if (query) {
                const filteredUsers = filterUsers(query);
                displayUsers(filteredUsers, null, true);
            } else {
                expandUsers();
            }
        });

        // Filter users by search query
        const filterUsers = (query) => {
            return allFollowedUsers.filter(user => {
                const name = (user.profile?.name || '').toLowerCase();
                const displayName = (user.profile?.display_name || '').toLowerCase();
                const nip05 = (user.profile?.nip05 || '').toLowerCase();
                const about = (user.profile?.about || '').toLowerCase();
                const pubkeyShort = user.pubkey.slice(0, 8).toLowerCase();

                return name.includes(query) ||
                       displayName.includes(query) ||
                       nip05.includes(query) ||
                       about.includes(query) ||
                       pubkeyShort.includes(query);
            });
        };

        // Search functionality
        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            const query = e.target.value.toLowerCase().trim();

            searchTimeout = setTimeout(() => {
                if (!query) {
                    // Reset to initial state
                    showingAllUsers = false;
                    displayUsers(allFollowedUsers, INITIAL_USER_LIMIT);
                    return;
                }

                const filteredUsers = filterUsers(query);
                // Show all matching users when searching (no limit)
                displayUsers(filteredUsers, null);
            }, 300);
        });

        // Helper functions for video cards
        const updateVideoCard = (event, profile, reactions) => {
            // Use in-place update to prevent image flickering
            updateVideoCardInPlace(event.id, profile, reactions);
        };

        const renderVideoCard = (event, profile = null, reactions = null) => {
            const cardId = `video-card-${event.id}`;

            if (document.getElementById(cardId)) {
                // Use in-place update to prevent image flickering
                updateVideoCardInPlace(event.id, profile, reactions);
                return;
            }

            // Remove skeleton cards on first video
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            const cardHTML = createVideoCard(event, profile, reactions);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHTML;

            if (!tempDiv.firstElementChild) return;

            tempDiv.firstElementChild.id = cardId;

            let inserted = false;
            const cards = videoGrid.querySelectorAll('.video-card');

            for (let i = 0; i < cards.length; i++) {
                const cardEventId = cards[i].id.replace('video-card-', '');
                const cardEvent = renderedVideos.get(cardEventId);
                if (cardEvent && event.created_at > cardEvent.created_at) {
                    cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) {
                videoGrid.appendChild(tempDiv.firstElementChild);
            }

            renderedVideos.set(event.id, event);
            observeLazyCards();
        };

        const renderShortCard = (event, profile = null, reactions = null) => {
            const cardId = `video-card-${event.id}`;

            if (document.getElementById(cardId)) {
                updateVideoCardInPlace(event.id, profile, reactions);
                return;
            }

            // Only render up to maxInitialShorts initially
            if (shortsRenderedCount >= maxInitialShorts) {
                return;
            }

            // Remove skeleton cards on first short
            const skeletons = shortsGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            // Show shorts section
            shortsSection.style.display = 'block';

            const cardHTML = createShortCard(event, profile, reactions);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHTML;

            if (!tempDiv.firstElementChild) return;

            tempDiv.firstElementChild.id = cardId;

            let inserted = false;
            const cards = shortsGrid.querySelectorAll('.short-card');

            for (let i = 0; i < cards.length; i++) {
                const cardEventId = cards[i].id.replace('video-card-', '');
                const cardEvent = renderedShorts.get(cardEventId);
                if (cardEvent && event.created_at > cardEvent.created_at) {
                    cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) {
                shortsGrid.appendChild(tempDiv.firstElementChild);
            }

            renderedShorts.set(event.id, event);
            shortsRenderedCount++;
            observeLazyCards();
        };

        const renderLiveStreamCard = (event, profile = null) => {
            const cardId = `live-card-${event.id}`;

            if (document.getElementById(cardId) || renderedLiveStreams.has(event.id)) {
                return;
            }

            // Remove skeleton cards on first live stream
            const skeletons = liveGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            const liveData = parseLiveEvent(event);
            if (!liveData) return;

            const isEnded = liveData.status === 'ended';
            const cardHTML = createLiveStreamCard(event, liveData, profile, isEnded);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHTML;

            if (!tempDiv.firstElementChild) return;

            // Insert sorted by created_at (newest first)
            let inserted = false;
            const cards = liveGrid.querySelectorAll('.video-card');

            for (let i = 0; i < cards.length; i++) {
                const cardEventId = cards[i].dataset.liveEventId;
                const cardEvent = renderedLiveStreams.get(cardEventId);
                if (cardEvent && event.created_at > cardEvent.created_at) {
                    cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                    inserted = true;
                    break;
                }
            }

            if (!inserted) {
                liveGrid.appendChild(tempDiv.firstElementChild);
            }

            renderedLiveStreams.set(event.id, event);
            liveEvents.push(event);
            observeLazyCards();
        };

        const loadReactionsBatch = async () => {
            if (reactionQueue.size === 0) return;

            const videoIds = Array.from(reactionQueue);
            reactionQueue.clear();

            await loadReactionsForVideos(videoIds, (videoId, reactions) => {
                const event = videoEvents.find(e => e.id === videoId);
                if (event) {
                    const profile = profileCache.get(event.pubkey);
                    updateVideoCard(event, profile, reactions);
                }
            });
        };

        // Fetch videos from followed users in batches
        const VIDEO_BATCH_SIZE = 50;
        const seenVideoIds = new Set();

        const fetchVideoBatch = async (authorBatch) => {
            const videoFilter = {
                kinds: ALL_VIDEO_KINDS,
                authors: authorBatch,
                '#t': ['pv69420'],
                limit: 100
            };

            await new Promise((resolve) => {
                requestEventsStream(videoFilter, (event) => {
                    const tags = event.tags || [];
                    if (!tags.some(tag => tag[0] === 'x')) return;

                    if (seenVideoIds.has(event.id)) return;
                    seenVideoIds.add(event.id);

                    allEvents.set(event.id, event);

                    // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
                    if (shouldSkipLegacyEvent(event)) return;

                    // Separate shorts from videos
                    const isShort = isNip71ShortKind(event.kind);

                    if (isShort) {
                        shortEvents.push(event);
                    } else {
                        videoEvents.push(event);
                    }

                    const spinner = videoGrid.querySelector('.spinner');
                    if (spinner) spinner.remove();

                    const cachedProfile = profileCache.get(event.pubkey);
                    const cachedReactions = reactionsCache.get(event.id);

                    if (isShort) {
                        renderShortCard(event, cachedProfile, cachedReactions);
                    } else {
                        renderVideoCard(event, cachedProfile, cachedReactions);
                    }

                    reactionQueue.add(event.id);
                    clearTimeout(reactionTimer);
                    reactionTimer = setTimeout(loadReactionsBatch, 200);
                }, resolve);
            });
        };

        // Split followingList into batches for video fetching
        const videoBatches = [];
        for (let i = 0; i < followingList.length; i += VIDEO_BATCH_SIZE) {
            videoBatches.push(followingList.slice(i, i + VIDEO_BATCH_SIZE));
        }

        // Live stream fetching function
        const seenLiveIds = new Set();
        const liveStreamsByDTag = new Map(); // Deduplicate by d-tag

        const fetchLiveStreamBatch = async (authorBatch) => {
            const liveFilter = {
                kinds: [NIP53_LIVE_EVENT_KIND],
                authors: authorBatch,
                '#t': ['pv69420'],
                limit: 50
            };

            await new Promise((resolve) => {
                requestEventsStream(liveFilter, (event) => {
                    if (seenLiveIds.has(event.id)) return;
                    seenLiveIds.add(event.id);

                    const liveData = parseLiveEvent(event);
                    if (!liveData) return;

                    allEvents.set(event.id, event);

                    // Deduplicate by d-tag (keep most recent version)
                    const dTagKey = `${event.pubkey}:${liveData.dTag}`;
                    const existing = liveStreamsByDTag.get(dTagKey);
                    if (existing && existing.created_at >= event.created_at) return;
                    liveStreamsByDTag.set(dTagKey, event);

                    const cachedProfile = profileCache.get(event.pubkey);
                    renderLiveStreamCard(event, cachedProfile);
                }, resolve);
            });
        };

        // Fetch all video and live stream batches in parallel
        await Promise.all([
            ...videoBatches.map(batch => fetchVideoBatch(batch)),
            ...videoBatches.map(batch => fetchLiveStreamBatch(batch))
        ]);

        // Final cleanup after all batches complete
        // Clear remaining skeletons
        liveGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());
        shortsGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());

        // Hide sections if no content
        if (liveEvents.length === 0) {
            liveSection.style.display = 'none';
        } else {
            // Load viewer counts and boosts for live streams
            const activeLiveIds = liveEvents
                .filter(e => {
                    const liveData = parseLiveEvent(e);
                    return liveData && isLiveStreamActive(liveData);
                })
                .map(e => e.id);
            if (activeLiveIds.length > 0) {
                loadLiveStreamCardsViewers(activeLiveIds);
            }
            liveEvents.forEach(e => {
                if (!boostsCache.has(e.id)) {
                    loadBoostsForVideo(e.id);
                }
            });
        }

        if (shortEvents.length === 0) {
            shortsSection.style.display = 'none';
        }

        if (videoEvents.length === 0 && shortEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFollowingVideos')}</p>`;
        } else if (videoEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthFollowing')}</p>`;
        }

        // Sort and cache shorts, show View More if needed
        if (shortEvents.length > 0) {
            shortEvents.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            cachedFollowingShorts = shortEvents;

            // Show View More if there are more shorts than initially displayed
            if (shortEvents.length > maxInitialShorts && shortsViewMore) {
                shortsViewMore.style.display = 'block';
            }
        }

        if (reactionQueue.size > 0) {
            loadReactionsBatch();
        }

        // Load views for all videos and shorts
        const allVideoIds = [...videoEvents.map(e => e.id), ...shortEvents.map(e => e.id)];
        if (allVideoIds.length > 0) {
            loadViewsForVideos(allVideoIds, true);
        }

        // Wait for profiles to finish loading
        await profilesPromise;

    } catch (error) {
        console.error('Failed to load following:', error);
        mainContent.innerHTML = `<div class="error-message">${t('empty.failedLoadFollowing')}</div>`;
    }
}

// Load my videos with streaming
async function loadMyVideos() {
    if (!currentUser) {
        await checkStoredLogin(); // Wait for login check
        if (!currentUser) {
            document.getElementById('mainContent').innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.loginToViewVideos')}</p>`;
            return;
        }
    }

    currentView = 'my-videos';

    // Include all video kinds (kind 1 legacy, NIP-71 addressable, and NIP-71 legacy)
    const filter = {
        kinds: ALL_VIDEO_KINDS,
        authors: [currentUser.pubkey],
        '#t': ['pv69420']
    };

    await displayVideosStreamWithDrafts('My Videos', filter);
}

// Load user's live streams for My Videos page
async function loadMyLiveStreams() {
    if (!currentUser) return [];

    const liveSection = document.getElementById('myVideosLiveSection');
    const liveGrid = document.getElementById('myVideosLiveGrid');
    if (!liveSection || !liveGrid) return [];

    const filter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        authors: [currentUser.pubkey],
        '#t': ['pv69420'],
        limit: 50
    };

    // Use a Map to deduplicate by d-tag (replaceable events)
    const streamsByDTag = new Map();
    const profile = profileCache.get(currentUser.pubkey) || await fetchUserProfile(currentUser.pubkey);

    await new Promise(resolve => {
        requestEventsStream(filter, (event) => {
            const liveData = parseLiveEvent(event);
            if (liveData) {
                const dTag = liveData.dTag;
                const existing = streamsByDTag.get(dTag);
                // Keep the most recent version (highest created_at)
                if (!existing || event.created_at > existing.event.created_at) {
                    streamsByDTag.set(dTag, { event, liveData });
                    allEvents.set(event.id, event);
                }
            }
        }, resolve);
    });

    const liveStreams = Array.from(streamsByDTag.values());

    // Cache live streams for search functionality
    cachedMyVideosLiveStreams = liveStreams;

    if (liveStreams.length === 0) {
        // Hide section if no live streams found
        liveSection.style.display = 'none';
        return [];
    }

    // Sort by created_at (newest first)
    liveStreams.sort((a, b) => b.event.created_at - a.event.created_at);

    // Render cards
    liveGrid.innerHTML = '';
    const liveEventIds = [];

    for (const { event, liveData } of liveStreams) {
        const card = createMyLiveStreamCard(event, liveData, profile);
        liveGrid.insertAdjacentHTML('beforeend', card);
        if (isLiveStreamActive(liveData)) {
            liveEventIds.push(event.id);
        }
    }

    // Load actual viewer counts for active live streams
    if (liveEventIds.length > 0) {
        loadLiveStreamCardsViewers(liveEventIds);
    }

    // Load boosts for all live streams (active and ended)
    const allLiveEventIds = liveStreams.map(({ event }) => event.id);
    allLiveEventIds.forEach(id => {
        if (!boostsCache.has(id)) {
            loadBoostsForVideo(id);
        }
    });

    return liveStreams;
}

// Create a live stream card for My Videos page (shows status including ended)
function createMyLiveStreamCard(event, liveData, profile) {
    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';
    const isEnded = isLiveStreamEnded(liveData);
    const isScheduled = isLiveStreamScheduled(liveData);
    const isActive = isLiveStreamActive(liveData);

    // Check boost level
    const boostAmount = boostsCache.get(event.id) || 0;
    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;
    const boostClasses = isBoosted ? `boosted boost-level-${boostLevel}` : '';

    // Check if NIP-05 is validated (from cache)
    const validationCached = profileValidationCache.get(event.pubkey);
    const nip05Valid = validationCached?.nip05Valid || false;

    let statusBadge = '';
    let statusClass = '';
    if (isActive) {
        statusBadge = '<div class="live-badge">LIVE</div>';
        statusClass = '';
    } else if (isScheduled) {
        statusBadge = '<div class="live-badge scheduled">SCHEDULED</div>';
        statusClass = 'scheduled';
    } else if (isEnded) {
        statusBadge = '<div class="live-badge ended">ENDED</div>';
        statusClass = 'ended';
    }

    const timeAgo = isEnded
        ? `Ended ${formatTimestamp(liveData.ends || event.created_at)}`
        : isScheduled
            ? `Scheduled for ${new Date(liveData.starts * 1000).toLocaleDateString()}`
            : `Started ${formatTimestamp(liveData.starts)}`;

    // Validate nip05 async if not cached and has nip05
    if (nip05 && !validationCached) {
        setTimeout(() => {
            validateNip05(nip05, event.pubkey).then(isValid => {
                if (isValid) {
                    const card = document.querySelector(`.live-stream-card[data-event-id="${event.id}"] .channel-nip05`);
                    if (card) applyNip05Checkmark(card, true);
                }
            });
        }, 0);
    }

    return `
        <div class="video-card live-stream-card ${statusClass} ${boostClasses}" data-event-id="${event.id}" data-live-event-id="${event.id}" data-pubkey="${event.pubkey}" onclick="navigateTo('/live/${event.id}')">
            <div class="video-thumbnail">
                ${liveData.thumbnail
                    ? `<img src="${liveData.thumbnail}" alt="${escapeHtml(liveData.title)}" loading="lazy">`
                    : '<div style="width:100%; height:100%; background: var(--bg-secondary); display: flex; align-items: center; justify-content: center;"><svg width="48" height="48" viewBox="0 0 24 24" fill="var(--text-secondary)"><circle cx="12" cy="12" r="4"/><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg></div>'
                }
                ${statusBadge}
                ${isActive ? `
                    <div class="live-viewers" data-event-id="${event.id}">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <span class="viewer-count">-</span>
                    </div>
                ` : ''}
                ${isBoosted ? `
                    <div class="boost-indicator">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                        </svg>
                        ${formatSats(boostAmount)}
                    </div>
                ` : ''}
                <div class="video-owner-actions">
                    <button class="owner-edit-btn" onclick="event.stopPropagation(); showEditStreamModal('${event.id}')" title="${t('button.editStream')}">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                        </svg>
                    </button>
                    ${isActive ? `
                        <button class="owner-delete-btn" onclick="event.stopPropagation(); endLiveStream('${event.id}')" title="${t('button.endStream')}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M6 6h12v12H6z"/>
                            </svg>
                        </button>
                    ` : ''}
                </div>
            </div>
            <div class="video-info">
                <a href="#/profile/${event.pubkey}" class="channel-info" onclick="event.stopPropagation()">
                    <div class="channel-avatar">
                        ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}" loading="lazy">` : ''}
                    </div>
                    <div class="channel-details">
                        <div class="channel-name">${escapeHtml(displayName)}</div>
                        ${nip05 ? `<div class="channel-nip05">${nip05}${nip05Valid ? getNip05CheckmarkSVG(12) : ''}</div>` : ''}
                    </div>
                </a>
                <h3 class="video-title">${escapeHtml(liveData.title)}</h3>
                <div class="video-meta">
                    ${timeAgo}
                    ${liveData.isNSFW ? ' • <span style="color: #f44336;">NSFW</span>' : ''}
                </div>
            </div>
        </div>
    `;
}

// Display videos stream with drafts section for My Videos page
async function displayVideosStreamWithDrafts(title, filter) {
    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const skeletonCount = cardsPerRow * 5;
    const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');
    const liveSkeletons = Array(cardsPerRow).fill(createLiveStreamSkeletonCard()).join('');
    const shortSkeletons = Array(getShortsCardsPerRow()).fill(createShortSkeletonCard()).join('');

    // Load and merge drafts from Nostr (if logged in) with localStorage
    let drafts;
    if (currentUser) {
        try {
            drafts = await loadDraftsFromNostr();
        } catch (e) {
            console.error('Failed to load drafts from Nostr:', e);
            drafts = getDrafts();
        }
    } else {
        drafts = getDrafts();
    }
    const draftEntries = Object.entries(drafts);
    const hasDrafts = draftEntries.length > 0;

    // Calculate how many drafts to show initially (one row)
    const maxInitialDrafts = cardsPerRow;
    const sortedDraftEntries = draftEntries.sort((a, b) => (b[1].updatedAt || 0) - (a[1].updatedAt || 0));

    // Cache drafts for View More expansion
    cachedDrafts = sortedDraftEntries.map(([draftId, draft]) => ({ id: draftId, ...draft }));
    sectionExpanded.drafts = false;

    let draftsHTML = '';
    if (hasDrafts) {
        const initialDrafts = sortedDraftEntries.slice(0, maxInitialDrafts);
        const draftCards = initialDrafts
            .map(([draftId, draft]) => createDraftCard(draftId, draft))
            .join('');

        const showDraftsViewMore = draftEntries.length > maxInitialDrafts;

        draftsHTML = `
            <div class="drafts-section" style="margin-bottom: 2rem;">
                <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                    </svg>
                    Drafts (${draftEntries.length})
                </h3>
                <div class="video-grid draft-grid" id="draftsGrid">
                    ${draftCards}
                </div>
                <div class="view-more-container" id="draftsViewMore" style="display: ${showDraftsViewMore ? 'block' : 'none'};">
                    <button class="action-btn view-more-btn" onclick="expandSection('drafts')">View More</button>
                </div>
            </div>
        `;
    }

    mainContent.innerHTML = `
        <div class="my-videos-header" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem;">
            <h2 style="margin: 0;">${title}</h2>
            <div style="display: flex; gap: 0.75rem; align-items: center;">
                <div class="my-videos-search-container" style="position: relative;">
                    <input type="text" id="myVideosSearch" placeholder="${t('placeholder.searchMyVideos')}"
                           style="padding: 0.5rem 0.75rem 0.5rem 2.25rem; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-secondary); color: var(--text-primary); width: 200px; font-size: 0.875rem;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); color: var(--text-secondary);">
                        <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
                    </svg>
                </div>
                <button class="action-btn analytics-btn" onclick="navigateTo('/analytics')" title="${t('button.viewAnalytics')}">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 13h2v8H3v-8zm4-5h2v13H7V8zm4-5h2v18h-2V3zm4 8h2v10h-2V11zm4-3h2v13h-2V8z"/>
                    </svg>
                    Analytics
                </button>
            </div>
        </div>
        ${draftsHTML}
        <!-- Live Streams Section -->
        <div id="myVideosLiveSection" style="margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <circle cx="12" cy="12" r="4" fill="#f44336"/>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                </svg>
                Live Streams
            </h3>
            <div class="video-grid" id="myVideosLiveGrid">${liveSkeletons}</div>
        </div>
        <!-- Shorts Section -->
        <div id="myVideosShortsSection" style="margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M10 8l6 4-6 4V8z"/>
                </svg>
                Shorts
            </h3>
            <div class="shorts-grid" id="myVideosShortsGrid">${shortSkeletons}</div>
            <div class="view-more-container" id="myVideosShortsViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('myVideosShorts')">View More</button>
            </div>
        </div>
        <!-- Videos Section -->
        <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                </svg>
                Videos
            </h3>
        <div class="video-grid" id="videoGrid">
            ${skeletons}
        </div>
    `;

    // Load user's live streams
    loadMyLiveStreams();

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('myVideosShortsGrid');
    const shortsSection = document.getElementById('myVideosShortsSection');
    const shortsViewMore = document.getElementById('myVideosShortsViewMore');

    const videoEvents = [];
    const shortEvents = [];
    const profileQueue = new Set();
    const reactionQueue = new Set();
    let profileTimer = null;
    let reactionTimer = null;
    let shortsRenderedCount = 0;
    const maxInitialShorts = getShortsCardsPerRow();

    // Reset cached my videos shorts and live streams
    cachedMyVideosShorts = [];
    cachedMyVideosLiveStreams = [];
    sectionExpanded.myVideosShorts = false;

    const loadProfilesBatch = async () => {
        if (profileQueue.size === 0) return;
        const pubkeys = Array.from(profileQueue);
        profileQueue.clear();

        const BATCH_SIZE = 25;
        const chunks = [];
        for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
            chunks.push(pubkeys.slice(i, i + BATCH_SIZE));
        }

        await Promise.all(chunks.map(async (chunk) => {
            const filter = { kinds: [0], authors: chunk };
            await requestEventsStream(filter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);
                    [...videoEvents, ...shortEvents].forEach(event => {
                        if (event.pubkey === profileEvent.pubkey) {
                            updateVideoCardInPlace(event.id, profile, reactionsCache.get(event.id));
                        }
                    });
                } catch (e) {}
            });
        }));
    };

    const loadReactionsBatch = async () => {
        if (reactionQueue.size === 0) return;
        const videoIds = Array.from(reactionQueue);
        reactionQueue.clear();
        await loadReactionsForVideos(videoIds);
    };

    await requestEventsStream(filter, (event) => {
        const tags = event.tags || [];
        if (!tags.some(tag => tag[0] === 'x')) return;

        allEvents.set(event.id, event);
        if (shouldSkipLegacyEvent(event)) return;

        const isShort = isNip71ShortKind(event.kind);
        const targetEvents = isShort ? shortEvents : videoEvents;

        targetEvents.push(event);

        // Remove skeleton cards
        if (isShort) {
            const skeletons = shortsGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }
        } else {
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }
        }

        const cachedProfile = profileCache.get(event.pubkey);
        const cachedReactions = reactionsCache.get(event.id);

        // For shorts, only render up to maxInitialShorts initially
        if (isShort) {
            if (shortsRenderedCount < maxInitialShorts) {
                // Pass showOwnerActions=true for My Videos page
                const cardHTML = createShortCard(event, cachedProfile, cachedReactions, true);
                if (cardHTML) {
                    shortsGrid.insertAdjacentHTML('beforeend', cardHTML);
                    shortsRenderedCount++;
                }
            }
        } else {
            // Pass showOwnerActions=true for My Videos page (isTrending=false, trendingRank=null, lazy=true, showOwnerActions=true)
            const cardHTML = createVideoCard(event, cachedProfile, cachedReactions, false, null, true, true);
            if (cardHTML) {
                videoGrid.insertAdjacentHTML('beforeend', cardHTML);
            }
        }

        if (!cachedProfile) {
            profileQueue.add(event.pubkey);
            clearTimeout(profileTimer);
            profileTimer = setTimeout(loadProfilesBatch, 100);
        }

        reactionQueue.add(event.id);
        clearTimeout(reactionTimer);
        reactionTimer = setTimeout(loadReactionsBatch, 200);

    }, () => {
        // Remove remaining skeletons
        videoGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());
        shortsGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());

        // Sort and cache shorts, show View More if needed
        if (shortEvents.length > 0) {
            shortEvents.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            cachedMyVideosShorts = shortEvents;

            if (shortEvents.length > maxInitialShorts && shortsViewMore) {
                shortsViewMore.style.display = 'block';
            }
        } else {
            // Hide shorts section if no shorts found
            shortsSection.style.display = 'none';
        }

        if (videoEvents.length === 0 && shortEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosUploadFirst')}</p>`;
        } else if (videoEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthVideos')}</p>`;
        }

        if (profileQueue.size > 0) loadProfilesBatch();
        if (reactionQueue.size > 0) loadReactionsBatch();

        // Load views for all my videos and shorts
        const allMyVideoIds = [...videoEvents.map(e => e.id), ...shortEvents.map(e => e.id)];
        if (allMyVideoIds.length > 0) {
            loadViewsForVideos(allMyVideoIds, true);
        }

        observeLazyCards();

        // Setup search functionality
        setupMyVideosSearch(videoEvents, shortEvents);
    });
}

// Setup search functionality for My Videos page
function setupMyVideosSearch(videoEvents, shortEvents) {
    const searchInput = document.getElementById('myVideosSearch');
    if (!searchInput) return;

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('myVideosShortsGrid');
    const shortsSection = document.getElementById('myVideosShortsSection');
    const shortsViewMore = document.getElementById('myVideosShortsViewMore');
    const liveSection = document.getElementById('myVideosLiveSection');
    const liveGrid = document.getElementById('myVideosLiveGrid');
    const maxInitialShorts = getShortsCardsPerRow();

    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.toLowerCase().trim();

        searchTimeout = setTimeout(() => {
            // Filter videos
            const filteredVideos = query ? videoEvents.filter(event => {
                const videoData = parseAnyVideoEvent(event);
                if (!videoData) return false;

                const title = (videoData.title || '').toLowerCase();
                const description = (videoData.description || '').toLowerCase();
                const tags = (videoData.tags || []).map(t => t.toLowerCase());

                return title.includes(query) ||
                       description.includes(query) ||
                       tags.some(tag => tag.includes(query));
            }) : videoEvents;

            // Filter shorts
            const filteredShorts = query ? shortEvents.filter(event => {
                const videoData = parseAnyVideoEvent(event);
                if (!videoData) return false;

                const title = (videoData.title || '').toLowerCase();
                const description = (videoData.description || '').toLowerCase();
                const tags = (videoData.tags || []).map(t => t.toLowerCase());

                return title.includes(query) ||
                       description.includes(query) ||
                       tags.some(tag => tag.includes(query));
            }) : shortEvents;

            // Filter live streams
            const liveStreams = cachedMyVideosLiveStreams;
            const filteredLiveStreams = query ? liveStreams.filter(({ liveData }) => {
                const title = (liveData.title || '').toLowerCase();
                const summary = (liveData.summary || '').toLowerCase();
                const tags = (liveData.tags || []).map(t => t.toLowerCase());

                return title.includes(query) ||
                       summary.includes(query) ||
                       tags.some(tag => tag.includes(query));
            }) : liveStreams;

            // Re-render live streams
            if (liveGrid && liveSection) {
                liveGrid.innerHTML = '';
                if (filteredLiveStreams.length > 0) {
                    liveSection.style.display = 'block';
                    const profile = profileCache.get(currentUser?.pubkey);
                    for (const { event, liveData } of filteredLiveStreams) {
                        const card = createMyLiveStreamCard(event, liveData, profile);
                        liveGrid.insertAdjacentHTML('beforeend', card);
                    }
                } else {
                    liveSection.style.display = query ? 'block' : (liveStreams.length > 0 ? 'block' : 'none');
                    if (query && liveStreams.length > 0) {
                        liveGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noMatchingLiveStreams')}</p>`;
                    }
                }
            }

            // Re-render videos
            videoGrid.innerHTML = '';
            if (filteredVideos.length > 0) {
                for (const event of filteredVideos) {
                    const profile = profileCache.get(event.pubkey);
                    const reactions = reactionsCache.get(event.id);
                    const cardHTML = createVideoCard(event, profile, reactions, false, null, true, true);
                    if (cardHTML) {
                        videoGrid.insertAdjacentHTML('beforeend', cardHTML);
                    }
                }
            } else {
                videoGrid.innerHTML = query
                    ? `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noMatchingVideos')}</p>`
                    : `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthVideos')}</p>`;
            }

            // Re-render shorts
            shortsGrid.innerHTML = '';
            if (filteredShorts.length > 0) {
                shortsSection.style.display = 'block';
                const displayShorts = query ? filteredShorts : filteredShorts.slice(0, maxInitialShorts);
                for (const event of displayShorts) {
                    const profile = profileCache.get(event.pubkey);
                    const reactions = reactionsCache.get(event.id);
                    const cardHTML = createShortCard(event, profile, reactions, true);
                    if (cardHTML) {
                        shortsGrid.insertAdjacentHTML('beforeend', cardHTML);
                    }
                }
                // Show/hide View More based on search and count
                if (shortsViewMore) {
                    shortsViewMore.style.display = (!query && filteredShorts.length > maxInitialShorts) ? 'block' : 'none';
                }
            } else {
                shortsSection.style.display = query ? 'block' : 'none';
                if (query) {
                    shortsGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noMatchingShorts')}</p>`;
                }
            }

            observeLazyCards();

            // Load views for filtered content
            const filteredIds = [...filteredVideos.map(e => e.id), ...filteredShorts.map(e => e.id), ...filteredLiveStreams.map(({ event }) => event.id)];
            if (filteredIds.length > 0) {
                loadViewsForVideos(filteredIds, true);
            }
        }, 300);
    });
}

// ===== Analytics Page Functions =====

// Load analytics page
// Store current analytics data for re-rendering with different time periods
let currentAnalyticsContent = null;

async function loadAnalytics(periodDays = 30) {
    if (!currentUser) {
        await checkStoredLogin();
        if (!currentUser) {
            document.getElementById('mainContent').innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.loginToViewAnalytics')}</p>`;
            return;
        }
    }

    currentView = 'analytics';
    const mainContent = document.getElementById('mainContent');

    // Show loading state
    mainContent.innerHTML = `
        <div class="analytics-page">
            <div class="analytics-header">
                <button class="back-btn" onclick="navigateTo('/my-videos')" title="${t('button.backToMyVideos')}">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                    </svg>
                </button>
                <h1>Channel Analytics</h1>
            </div>
            <div class="analytics-loading">
                <div class="spinner"></div>
                <p>Loading your analytics...</p>
            </div>
        </div>
    `;

    try {
        // Fetch all user's content (videos, shorts, live streams)
        const [videos, shorts, liveStreams] = await Promise.all([
            fetchUserVideos(currentUser.pubkey),
            fetchUserShorts(currentUser.pubkey),
            fetchUserLiveStreams(currentUser.pubkey)
        ]);

        const allContent = [...videos, ...shorts, ...liveStreams];

        // Store content for re-rendering with different time periods
        currentAnalyticsContent = { videos, shorts, liveStreams, allContent };

        // Fetch engagement data and follower growth in parallel
        const [analyticsData, followerData] = await Promise.all([
            fetchAnalyticsData(allContent, periodDays),
            fetchFollowerGrowthData(currentUser.pubkey, periodDays)
        ]);

        // Render analytics page
        renderAnalyticsPage(videos, shorts, liveStreams, analyticsData, followerData);
    } catch (error) {
        console.error('Failed to load analytics:', error);
        mainContent.innerHTML = `
            <div class="analytics-page">
                <div class="analytics-header">
                    <button class="back-btn" onclick="navigateTo('/my-videos')" title="${t('button.backToMyVideos')}">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                        </svg>
                    </button>
                    <h1>Channel Analytics</h1>
                </div>
                <p style="text-align: center; color: var(--text-secondary); margin-top: 2rem;">Failed to load analytics. Please try again.</p>
            </div>
        `;
    }
}

// Fetch user's videos (excluding shorts)
async function fetchUserVideos(pubkey) {
    const filter = {
        kinds: ALL_VIDEO_KINDS,
        authors: [pubkey],
        '#t': ['pv69420'],
        limit: 500
    };

    const videos = [];
    const seenDTags = new Set();

    await new Promise(resolve => {
        requestEventsStream(filter, (event) => {
            // Skip shorts
            if (isNip71ShortKind(event.kind)) return;
            if (!event.tags?.some(tag => tag[0] === 'x')) return;

            // Deduplicate by d-tag for addressable events
            const dTag = event.tags?.find(t => t[0] === 'd')?.[1];
            if (dTag) {
                if (seenDTags.has(dTag)) return;
                seenDTags.add(dTag);
            }

            allEvents.set(event.id, event);
            if (!shouldSkipLegacyEvent(event)) {
                videos.push(event);
            }
        }, resolve);
    });

    return videos.sort((a, b) => b.created_at - a.created_at);
}

// Fetch user's shorts
async function fetchUserShorts(pubkey) {
    const filter = {
        kinds: [NIP71_SHORT_KIND],
        authors: [pubkey],
        '#t': ['pv69420'],
        limit: 500
    };

    const shorts = [];
    const seenDTags = new Set();

    await new Promise(resolve => {
        requestEventsStream(filter, (event) => {
            if (!event.tags?.some(tag => tag[0] === 'x')) return;

            const dTag = event.tags?.find(t => t[0] === 'd')?.[1];
            if (dTag) {
                if (seenDTags.has(dTag)) return;
                seenDTags.add(dTag);
            }

            allEvents.set(event.id, event);
            shorts.push(event);
        }, resolve);
    });

    return shorts.sort((a, b) => b.created_at - a.created_at);
}

// Fetch user's live streams
async function fetchUserLiveStreams(pubkey) {
    const filter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        authors: [pubkey],
        '#t': ['pv69420'],
        limit: 100
    };

    const streamsByDTag = new Map();

    await new Promise(resolve => {
        requestEventsStream(filter, (event) => {
            const liveData = parseLiveEvent(event);
            if (liveData) {
                const dTag = liveData.dTag;
                const existing = streamsByDTag.get(dTag);
                if (!existing || event.created_at > existing.created_at) {
                    streamsByDTag.set(dTag, event);
                    allEvents.set(event.id, event);
                }
            }
        }, resolve);
    });

    return Array.from(streamsByDTag.values()).sort((a, b) => b.created_at - a.created_at);
}

// Fetch analytics data for all content
async function fetchAnalyticsData(events, periodDays = 30) {
    const eventIds = events.map(e => e.id);
    const periodStart = Math.floor(Date.now() / 1000) - (periodDays * 24 * 60 * 60);

    // Fetch all engagement metrics in parallel with time filtering
    const [viewsResult, reactionsData, zapsData, boostsData, sharesData, commentsData] = await Promise.all([
        fetchBatchViewCountsWithTimestamps(eventIds, periodStart, periodDays),
        fetchBatchReactionsWithTime(eventIds, periodStart),
        fetchBatchZapsWithTime(eventIds, periodStart),
        fetchBatchBoostsWithTime(eventIds, periodStart),
        fetchBatchSharesWithTime(eventIds, periodStart),
        fetchBatchCommentsWithTime(eventIds, periodStart)
    ]);

    const { viewCounts: viewsData, viewsByDay } = viewsResult;

    // Calculate totals
    let totalViews = 0;
    let totalLikes = 0;
    let totalDislikes = 0;
    let totalZapAmount = 0;
    let totalZapCount = 0;
    let totalBoostCount = 0;
    let totalShares = 0;
    let totalComments = 0;

    const perVideoData = new Map();

    for (const event of events) {
        const views = viewsData.get(event.id) || 0;
        const reactions = reactionsData.get(event.id) || { likes: 0, dislikes: 0 };
        const zaps = zapsData.get(event.id) || { amount: 0, count: 0 };
        const boostAmount = boostsData.get(event.id) || 0;
        const boostCount = Math.floor(boostAmount / 100); // Each boost is 100 sats
        const shares = sharesData.get(event.id) || 0;
        const comments = commentsData.get(event.id) || 0;

        totalViews += views;
        totalLikes += reactions.likes;
        totalDislikes += reactions.dislikes;
        totalZapAmount += zaps.amount;
        totalZapCount += zaps.count;
        totalBoostCount += boostCount;
        totalShares += shares;
        totalComments += comments;

        perVideoData.set(event.id, {
            views,
            likes: reactions.likes,
            dislikes: reactions.dislikes,
            zapAmount: zaps.amount,
            zapCount: zaps.count,
            boosts: boostCount,
            shares,
            comments,
            engagementScore: views + (reactions.likes * 2) + (zaps.count * 5) + (shares * 3) + (comments * 2)
        });
    }

    return {
        totals: {
            views: totalViews,
            likes: totalLikes,
            dislikes: totalDislikes,
            zapAmount: totalZapAmount,
            zapCount: totalZapCount,
            boostCount: totalBoostCount,
            shares: totalShares,
            comments: totalComments
        },
        perVideo: perVideoData,
        viewsByDay,
        periodDays
    };
}

// Batch fetch view counts with timestamps for chart
async function fetchBatchViewCountsWithTimestamps(eventIds, sinceTimestamp, periodDays = 30) {
    const viewCounts = new Map();
    const viewsByDay = new Map(); // date string -> count

    if (eventIds.length === 0) return { viewCounts, viewsByDay };

    // Initialize days for the period (limit chart to 365 days max for performance)
    const chartDays = Math.min(periodDays, 365);
    const now = new Date();
    for (let i = chartDays - 1; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        viewsByDay.set(dateStr, 0);
    }

    // Process in batches with pagination
    const BATCH_SIZE = 50;
    const EVENTS_PER_REQUEST = 500;

    for (let i = 0; i < eventIds.length; i += BATCH_SIZE) {
        const batch = eventIds.slice(i, i + BATCH_SIZE);
        const allLinkedIds = [];
        const linkedToPrimary = new Map();

        batch.forEach(id => {
            const linkedIds = getAllLinkedEventIds(id);
            linkedIds.forEach(linkedId => {
                allLinkedIds.push(linkedId);
                linkedToPrimary.set(linkedId, id);
            });
        });

        // Paginate through results
        let until = Math.floor(Date.now() / 1000);
        let hasMore = true;
        const seenEvents = new Set();
        const viewers = new Map();

        while (hasMore) {
            const filter = {
                kinds: [VIEW_EVENT_KIND],
                '#e': allLinkedIds,
                '#t': ['video-view'],
                since: sinceTimestamp,
                until: until,
                limit: EVENTS_PER_REQUEST
            };

            let eventCount = 0;
            let oldestTimestamp = until;

            await new Promise(resolve => {
                requestEventsStream(filter, (event) => {
                    if (seenEvents.has(event.id)) return;
                    seenEvents.add(event.id);
                    eventCount++;

                    if (event.created_at < oldestTimestamp) {
                        oldestTimestamp = event.created_at;
                    }

                    const eTag = event.tags?.find(t => t[0] === 'e')?.[1];
                    if (eTag && linkedToPrimary.has(eTag)) {
                        const primaryId = linkedToPrimary.get(eTag);

                        // Track unique viewers per video
                        if (!viewers.has(primaryId)) {
                            viewers.set(primaryId, new Set());
                        }
                        const viewerKey = event.pubkey;
                        if (!viewers.get(primaryId).has(viewerKey)) {
                            viewers.get(primaryId).add(viewerKey);

                            // Track views by day
                            const viewDate = new Date(event.created_at * 1000).toISOString().split('T')[0];
                            if (viewsByDay.has(viewDate)) {
                                viewsByDay.set(viewDate, viewsByDay.get(viewDate) + 1);
                            }
                        }
                    }
                }, resolve);
            });

            // Check if we need to paginate more
            if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
                hasMore = false;
            } else {
                until = oldestTimestamp - 1;
            }
        }

        viewers.forEach((viewerSet, id) => {
            viewCounts.set(id, viewerSet.size);
        });
    }

    return { viewCounts, viewsByDay };
}

// Batch fetch reactions with time filter
async function fetchBatchReactionsWithTime(eventIds, sinceTimestamp) {
    const reactions = new Map();

    if (eventIds.length === 0) return reactions;

    eventIds.forEach(id => reactions.set(id, { likes: 0, dislikes: 0 }));

    const allLinkedIds = [];
    const linkedToPrimary = new Map();

    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => {
            allLinkedIds.push(linkedId);
            linkedToPrimary.set(linkedId, id);
        });
    });

    // Paginate through results
    const EVENTS_PER_REQUEST = 1000;
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenEvents = new Set();
    const userReactions = new Map();

    while (hasMore) {
        const filter = {
            kinds: [7],
            '#e': allLinkedIds,
            since: sinceTimestamp,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenEvents.has(event.id)) return;
                seenEvents.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const eTag = event.tags?.find(t => t[0] === 'e')?.[1];
                if (eTag && linkedToPrimary.has(eTag)) {
                    const primaryId = linkedToPrimary.get(eTag);
                    const key = `${primaryId}:${event.pubkey}`;
                    const existing = userReactions.get(key);
                    if (!existing || existing.timestamp < event.created_at) {
                        userReactions.set(key, {
                            reaction: event.content,
                            timestamp: event.created_at,
                            primaryId
                        });
                    }
                }
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    // Count final reactions
    userReactions.forEach(({ reaction, primaryId }) => {
        const data = reactions.get(primaryId);
        if (data) {
            if (reaction === '👍') data.likes++;
            else if (reaction === '👎') data.dislikes++;
        }
    });

    return reactions;
}

// Batch fetch zaps with time filter
async function fetchBatchZapsWithTime(eventIds, sinceTimestamp) {
    const zaps = new Map();

    if (eventIds.length === 0) return zaps;

    eventIds.forEach(id => zaps.set(id, { amount: 0, count: 0 }));

    // Build map of all linked IDs (including legacy events) to primary IDs
    const allLinkedIds = [];
    const linkedToPrimary = new Map();
    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => {
            allLinkedIds.push(linkedId);
            linkedToPrimary.set(linkedId, id);
        });
    });

    // Paginate through results
    const EVENTS_PER_REQUEST = 1000;
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenZaps = new Set();

    while (hasMore) {
        const filter = {
            kinds: [9735],
            '#e': allLinkedIds,
            since: sinceTimestamp,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenZaps.has(event.id)) return;
                seenZaps.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                // Skip boost zaps
                const pTag = event.tags?.find(tag => tag[0] === 'p');
                if (pTag && pTag[1] === 'd49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df') {
                    const description = event.tags?.find(tag => tag[0] === 'description')?.[1];
                    if (description) {
                        try {
                            const zapRequest = JSON.parse(description);
                            if (zapRequest.tags?.some(tag => tag[0] === 'purpose' && tag[1] === 'boost')) {
                                return;
                            }
                        } catch (e) {}
                    }
                }

                const eTag = event.tags?.find(t => t[0] === 'e' && linkedToPrimary.has(t[1]))?.[1];
                if (eTag) {
                    const primaryId = linkedToPrimary.get(eTag);
                    const bolt11 = event.tags?.find(t => t[0] === 'bolt11')?.[1];
                    if (bolt11) {
                        const amount = extractAmountFromBolt11(bolt11);
                        if (amount > 0) {
                            const data = zaps.get(primaryId);
                            if (data) {
                                data.amount += amount;
                                data.count++;
                            }
                        }
                    }
                }
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    return zaps;
}

// Batch fetch boosts with time filter
async function fetchBatchBoostsWithTime(eventIds, sinceTimestamp) {
    const boosts = new Map();

    if (eventIds.length === 0) return boosts;

    eventIds.forEach(id => boosts.set(id, 0));

    // Build map of all linked IDs (including legacy events) to primary IDs
    const allLinkedIds = [];
    const linkedToPrimary = new Map();
    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => {
            allLinkedIds.push(linkedId);
            linkedToPrimary.set(linkedId, id);
        });
    });

    // Paginate through results
    const EVENTS_PER_REQUEST = 1000;
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenBoosts = new Set();

    while (hasMore) {
        const filter = {
            kinds: [9735],
            '#e': allLinkedIds,
            '#p': ['d49a9023a21dba1b3c8306ca369bf3243d8b44b8f0b6d1196607f7b0990fa8df'],
            since: sinceTimestamp,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenBoosts.has(event.id)) return;
                seenBoosts.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const description = event.tags?.find(tag => tag[0] === 'description')?.[1];
                if (description) {
                    try {
                        const zapRequest = JSON.parse(description);
                        if (zapRequest.tags?.some(tag => tag[0] === 'purpose' && tag[1] === 'boost')) {
                            const eTag = event.tags?.find(t => t[0] === 'e' && linkedToPrimary.has(t[1]))?.[1];
                            if (eTag) {
                                const primaryId = linkedToPrimary.get(eTag);
                                const bolt11 = event.tags?.find(t => t[0] === 'bolt11')?.[1];
                                if (bolt11) {
                                    const amount = extractAmountFromBolt11(bolt11);
                                    if (amount > 0) {
                                        boosts.set(primaryId, (boosts.get(primaryId) || 0) + amount);
                                    }
                                }
                            }
                        }
                    } catch (e) {}
                }
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    return boosts;
}

// Batch fetch shares with time filter
async function fetchBatchSharesWithTime(eventIds, sinceTimestamp) {
    const shares = new Map();

    if (eventIds.length === 0) return shares;

    eventIds.forEach(id => shares.set(id, 0));

    // Build map of all linked IDs (including legacy events) to primary IDs
    const allLinkedIds = [];
    const linkedToPrimary = new Map();
    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => {
            allLinkedIds.push(linkedId);
            linkedToPrimary.set(linkedId, id);
        });
    });

    // Paginate through results
    const EVENTS_PER_REQUEST = 1000;
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenShares = new Set();

    while (hasMore) {
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#e': allLinkedIds,
            '#t': ['video-share'],
            since: sinceTimestamp,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const eTag = event.tags?.find(t => t[0] === 'e' && linkedToPrimary.has(t[1]))?.[1];
                if (eTag) {
                    const primaryId = linkedToPrimary.get(eTag);
                    const key = `${primaryId}:${event.pubkey}`;
                    if (!seenShares.has(key)) {
                        seenShares.add(key);
                        shares.set(primaryId, (shares.get(primaryId) || 0) + 1);
                    }
                }
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    return shares;
}

// Batch fetch comments with time filter
async function fetchBatchCommentsWithTime(eventIds, sinceTimestamp) {
    const comments = new Map();

    if (eventIds.length === 0) return comments;

    eventIds.forEach(id => comments.set(id, 0));

    // Expand to include all linked event IDs
    const allLinkedIds = [];
    const linkedToPrimary = new Map();

    // Also track live stream 'a' tags for chat messages
    const liveStreamATags = [];
    const aTagToPrimary = new Map();

    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => {
            allLinkedIds.push(linkedId);
            linkedToPrimary.set(linkedId, id);
        });

        // Check if this is a live stream and build 'a' tag for chat lookup
        const event = allEvents.get(id);
        if (event && event.kind === NIP53_LIVE_EVENT_KIND) {
            const liveData = parseLiveEvent(event);
            if (liveData && liveData.dTag) {
                const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${event.pubkey}:${liveData.dTag}`;
                liveStreamATags.push(aTagValue);
                aTagToPrimary.set(aTagValue, id);
            }
        }
    });

    // Paginate through regular comments (kind 1)
    const EVENTS_PER_REQUEST = 1000;
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenComments = new Set();

    while (hasMore) {
        const filter = {
            kinds: [1],
            '#e': allLinkedIds,
            since: sinceTimestamp,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenComments.has(event.id)) return;
                seenComments.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const eTag = event.tags?.find(t => t[0] === 'e' && linkedToPrimary.has(t[1]))?.[1];
                if (eTag) {
                    const primaryId = linkedToPrimary.get(eTag);
                    if (primaryId) {
                        comments.set(primaryId, (comments.get(primaryId) || 0) + 1);
                    }
                }
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    // Also fetch live chat messages (kind 1311) for live streams
    if (liveStreamATags.length > 0) {
        until = Math.floor(Date.now() / 1000);
        hasMore = true;

        while (hasMore) {
            const chatFilter = {
                kinds: [NIP53_LIVE_CHAT_KIND],
                '#a': liveStreamATags,
                since: sinceTimestamp,
                until: until,
                limit: EVENTS_PER_REQUEST
            };

            let eventCount = 0;
            let oldestTimestamp = until;

            await new Promise(resolve => {
                requestEventsStream(chatFilter, (event) => {
                    if (seenComments.has(event.id)) return;
                    seenComments.add(event.id);
                    eventCount++;

                    if (event.created_at < oldestTimestamp) {
                        oldestTimestamp = event.created_at;
                    }

                    // Find the 'a' tag that matches one of our live streams
                    const aTag = event.tags?.find(t => t[0] === 'a' && aTagToPrimary.has(t[1]))?.[1];
                    if (aTag) {
                        const primaryId = aTagToPrimary.get(aTag);
                        if (primaryId) {
                            comments.set(primaryId, (comments.get(primaryId) || 0) + 1);
                        }
                    }
                }, resolve);
            });

            if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= sinceTimestamp) {
                hasMore = false;
            } else {
                until = oldestTimestamp - 1;
            }
        }
    }

    return comments;
}

// Fetch follower growth/degrowth data for analytics
async function fetchFollowerGrowthData(channelPubkey, periodDays = 30) {
    const periodStart = Math.floor(Date.now() / 1000) - (periodDays * 24 * 60 * 60);
    const EVENTS_PER_REQUEST = 500;

    // Initialize days for the period (limit chart to 365 days max for performance)
    const chartDays = Math.min(periodDays, 365);
    const subscribersByDay = new Map();
    const now = new Date();
    for (let i = chartDays - 1; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        subscribersByDay.set(dateStr, { follows: 0, unfollows: 0 });
    }

    let totalNewFollowers = 0;
    let totalUnfollows = 0;

    // Fetch follow events
    let until = Math.floor(Date.now() / 1000);
    let hasMore = true;
    const seenFollows = new Set();

    while (hasMore) {
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#p': [channelPubkey],
            '#t': ['channel-follow'],
            since: periodStart,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenFollows.has(event.id)) return;
                seenFollows.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const date = new Date(event.created_at * 1000).toISOString().split('T')[0];
                if (subscribersByDay.has(date)) {
                    subscribersByDay.get(date).follows++;
                }
                totalNewFollowers++;
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= periodStart) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    // Fetch unfollow events
    until = Math.floor(Date.now() / 1000);
    hasMore = true;
    const seenUnfollows = new Set();

    while (hasMore) {
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#p': [channelPubkey],
            '#t': ['channel-unfollow'],
            since: periodStart,
            until: until,
            limit: EVENTS_PER_REQUEST
        };

        let eventCount = 0;
        let oldestTimestamp = until;

        await new Promise(resolve => {
            requestEventsStream(filter, (event) => {
                if (seenUnfollows.has(event.id)) return;
                seenUnfollows.add(event.id);
                eventCount++;

                if (event.created_at < oldestTimestamp) {
                    oldestTimestamp = event.created_at;
                }

                const date = new Date(event.created_at * 1000).toISOString().split('T')[0];
                if (subscribersByDay.has(date)) {
                    subscribersByDay.get(date).unfollows++;
                }
                totalUnfollows++;
            }, resolve);
        });

        if (eventCount < EVENTS_PER_REQUEST || oldestTimestamp <= periodStart) {
            hasMore = false;
        } else {
            until = oldestTimestamp - 1;
        }
    }

    return {
        subscribersByDay,
        totalNewFollowers,
        totalUnfollows,
        netGrowth: totalNewFollowers - totalUnfollows
    };
}

// Generate subscribers chart SVG (shows net gain/loss per day)
function generateSubscribersChartSVG(subscribersByDay, periodDays = 30) {
    const days = Array.from(subscribersByDay.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    const values = days.map(d => d[1].follows - d[1].unfollows); // Net change per day
    const maxValue = Math.max(...values.map(Math.abs), 1);

    const width = 800;
    const height = 200;
    const padding = { top: 20, right: 20, bottom: 40, left: 50 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;
    const zeroY = padding.top + chartHeight / 2;

    // Generate bars for positive/negative values
    const barWidth = chartWidth / values.length - 2;
    const bars = values.map((v, i) => {
        const x = padding.left + (i / values.length) * chartWidth + 1;
        const barHeight = (Math.abs(v) / maxValue) * (chartHeight / 2);
        const y = v >= 0 ? zeroY - barHeight : zeroY;
        const color = v >= 0 ? 'var(--accent)' : '#ef4444';
        const date = new Date(days[i][0]);
        const dateLabel = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

        return `<rect class="chart-bar" x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${color}" data-value="${v}" data-date="${dateLabel}" rx="2" />`;
    }).join('');

    // Y-axis labels
    const yLabels = [];
    const ySteps = 4;
    for (let i = 0; i <= ySteps; i++) {
        const value = Math.round(maxValue - (2 * maxValue / ySteps) * i);
        const y = padding.top + (i / ySteps) * chartHeight;
        yLabels.push({ value: value >= 0 ? `+${value}` : value, y });
    }

    // X-axis labels (show every nth day)
    const xLabels = [];
    const labelInterval = Math.ceil(days.length / 6);
    for (let i = 0; i < days.length; i += labelInterval) {
        const x = padding.left + (i / days.length) * chartWidth + barWidth / 2;
        const date = new Date(days[i][0]);
        const label = `${date.getMonth() + 1}/${date.getDate()}`;
        xLabels.push({ label, x });
    }

    return `
        <svg class="subscribers-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
            <!-- Grid lines -->
            ${yLabels.map(l => `<line class="chart-grid" x1="${padding.left}" y1="${l.y}" x2="${width - padding.right}" y2="${l.y}" />`).join('')}

            <!-- Zero line -->
            <line class="chart-zero-line" x1="${padding.left}" y1="${zeroY}" x2="${width - padding.right}" y2="${zeroY}" stroke="var(--text-secondary)" stroke-width="1" />

            <!-- Bars -->
            ${bars}

            <!-- Y-axis labels -->
            ${yLabels.map(l => `<text class="chart-label y-label" x="${padding.left - 10}" y="${l.y + 4}" text-anchor="end">${l.value}</text>`).join('')}

            <!-- X-axis labels -->
            ${xLabels.map(l => `<text class="chart-label x-label" x="${l.x}" y="${height - 10}" text-anchor="middle">${l.label}</text>`).join('')}
        </svg>
    `;
}

// Generate views chart SVG
function generateViewsChartSVG(viewsByDay, periodDays = 30) {
    const days = Array.from(viewsByDay.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    const values = days.map(d => d[1]);
    const maxValue = Math.max(...values, 1);

    const width = 800;
    const height = 200;
    const padding = { top: 20, right: 20, bottom: 40, left: 50 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;

    // Generate path for the area chart
    const points = values.map((v, i) => {
        const x = padding.left + (i / (values.length - 1 || 1)) * chartWidth;
        const y = padding.top + chartHeight - (v / maxValue) * chartHeight;
        return { x, y, value: v, date: days[i][0] };
    });

    // Create smooth path
    let pathD = `M ${points[0]?.x || padding.left} ${points[0]?.y || padding.top + chartHeight}`;
    for (let i = 1; i < points.length; i++) {
        pathD += ` L ${points[i].x} ${points[i].y}`;
    }

    // Area fill path
    const areaPath = pathD + ` L ${points[points.length - 1]?.x || padding.left + chartWidth} ${padding.top + chartHeight} L ${padding.left} ${padding.top + chartHeight} Z`;

    // Y-axis labels
    const yLabels = [];
    const ySteps = 4;
    for (let i = 0; i <= ySteps; i++) {
        const value = Math.round((maxValue / ySteps) * (ySteps - i));
        const y = padding.top + (i / ySteps) * chartHeight;
        yLabels.push({ value: formatNumber(value), y });
    }

    // X-axis labels (show every 5th day)
    const xLabels = [];
    const labelInterval = Math.ceil(days.length / 6);
    for (let i = 0; i < days.length; i += labelInterval) {
        const x = padding.left + (i / (days.length - 1 || 1)) * chartWidth;
        const date = new Date(days[i][0]);
        const label = `${date.getMonth() + 1}/${date.getDate()}`;
        xLabels.push({ label, x });
    }

    // Hover points
    const hoverPoints = points.map((p, i) => {
        const date = new Date(days[i][0]);
        const dateLabel = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        return `<circle class="chart-point" cx="${p.x}" cy="${p.y}" r="4" data-value="${p.value}" data-date="${dateLabel}" />`;
    }).join('');

    return `
        <svg class="views-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">
            <defs>
                <linearGradient id="areaGradient" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0%" stop-color="var(--accent)" stop-opacity="0.3"/>
                    <stop offset="100%" stop-color="var(--accent)" stop-opacity="0.05"/>
                </linearGradient>
            </defs>

            <!-- Grid lines -->
            ${yLabels.map(l => `<line class="chart-grid" x1="${padding.left}" y1="${l.y}" x2="${width - padding.right}" y2="${l.y}" />`).join('')}

            <!-- Area fill -->
            <path class="chart-area" d="${areaPath}" fill="url(#areaGradient)" />

            <!-- Line -->
            <path class="chart-line" d="${pathD}" fill="none" stroke="var(--accent)" stroke-width="2" />

            <!-- Y-axis labels -->
            ${yLabels.map(l => `<text class="chart-label y-label" x="${padding.left - 10}" y="${l.y + 4}" text-anchor="end">${l.value}</text>`).join('')}

            <!-- X-axis labels -->
            ${xLabels.map(l => `<text class="chart-label x-label" x="${l.x}" y="${height - 10}" text-anchor="middle">${l.label}</text>`).join('')}

            <!-- Hover points -->
            ${hoverPoints}
        </svg>
    `;
}

// Render analytics page
function renderAnalyticsPage(videos, shorts, liveStreams, analyticsData, followerData = null) {
    const mainContent = document.getElementById('mainContent');
    const { totals, perVideo, viewsByDay, periodDays } = analyticsData;

    // Get top performing content
    const allContent = [...videos, ...shorts, ...liveStreams];
    const sortedByViews = [...allContent].sort((a, b) => {
        const aData = perVideo.get(a.id) || { views: 0 };
        const bData = perVideo.get(b.id) || { views: 0 };
        return bData.views - aData.views;
    }).slice(0, 5);

    const sortedByEngagement = [...allContent].sort((a, b) => {
        const aData = perVideo.get(a.id) || { engagementScore: 0 };
        const bData = perVideo.get(b.id) || { engagementScore: 0 };
        return bData.engagementScore - aData.engagementScore;
    }).slice(0, 5);

    const likeRatio = totals.likes + totals.dislikes > 0
        ? Math.round((totals.likes / (totals.likes + totals.dislikes)) * 100)
        : 0;

    // Generate views chart
    const viewsChartHTML = generateViewsChartSVG(viewsByDay, periodDays);

    // Generate subscribers chart if data available
    const subscribersChartHTML = followerData ? generateSubscribersChartSVG(followerData.subscribersByDay, periodDays) : '';

    // Time period options
    const periodOptions = [
        { value: 7, label: 'Last 7 days' },
        { value: 30, label: 'Last 30 days' },
        { value: 90, label: 'Last 90 days' },
        { value: 365, label: 'Last year' },
        { value: 0, label: 'All time' }
    ];

    mainContent.innerHTML = `
        <div class="analytics-page">
            <div class="analytics-header">
                <button class="back-btn" onclick="navigateTo('/my-videos')" title="${t('button.backToMyVideos')}">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                    </svg>
                </button>
                <h1>Channel Analytics</h1>
                <div class="analytics-period-selector">
                    <select id="analyticsPeriodSelect" onchange="changeAnalyticsPeriod(this.value)">
                        ${periodOptions.map(opt => `<option value="${opt.value}" ${opt.value === periodDays ? 'selected' : ''}>${opt.label}</option>`).join('')}
                    </select>
                </div>
            </div>

            <!-- Overview Stats -->
            <section class="analytics-section">
                <div class="section-header-row">
                    <h2>Overview</h2>
                    <span class="period-label">${periodDays === 0 ? 'All time' : `Last ${periodDays} days`}</span>
                </div>
                <div class="analytics-stats-grid">
                    <div class="analytics-stat-card">
                        <div class="stat-icon views">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.views)}</div>
                            <div class="stat-label">Total Views</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon likes">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.likes)}</div>
                            <div class="stat-label">Likes (${likeRatio}% ratio)</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon dislikes">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.dislikes)}</div>
                            <div class="stat-label">Dislikes</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon zaps">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatSats(totals.zapAmount)} sats</div>
                            <div class="stat-label">${totals.zapCount} Zaps Received</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon boosts">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.boostCount)}</div>
                            <div class="stat-label">Boosts Received</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon shares">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.shares)}</div>
                            <div class="stat-label">Shares</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon comments">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${formatNumber(totals.comments)}</div>
                            <div class="stat-label">Comments</div>
                        </div>
                    </div>
                    <div class="analytics-stat-card">
                        <div class="stat-icon content">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8 12.5v-9l6 4.5-6 4.5z"/>
                            </svg>
                        </div>
                        <div class="stat-content">
                            <div class="stat-value">${videos.length + shorts.length + liveStreams.length}</div>
                            <div class="stat-label">${videos.length} Videos, ${shorts.length} Shorts, ${liveStreams.length} Streams</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Views Chart -->
            <section class="analytics-section">
                <div class="section-header-row">
                    <h2>Views</h2>
                    <span class="period-label">${periodDays === 0 ? 'All time' : `Last ${periodDays} days`}</span>
                </div>
                <div class="views-chart-container">
                    ${viewsChartHTML}
                    <div class="chart-tooltip" id="chartTooltip"></div>
                </div>
            </section>

            ${followerData ? `
            <!-- Followers Chart -->
            <section class="analytics-section">
                <div class="section-header-row">
                    <h2>Followers</h2>
                    <span class="period-label">${periodDays === 0 ? 'All time' : `Last ${periodDays} days`}</span>
                </div>
                <div class="subscribers-summary">
                    <div class="subscriber-stat ${followerData.netGrowth >= 0 ? 'positive' : 'negative'}">
                        <span class="subscriber-value">${followerData.netGrowth >= 0 ? '+' : ''}${formatNumber(followerData.netGrowth)}</span>
                        <span class="subscriber-label">Net Growth</span>
                    </div>
                    <div class="subscriber-stat positive">
                        <span class="subscriber-value">+${formatNumber(followerData.totalNewFollowers)}</span>
                        <span class="subscriber-label">New Followers</span>
                    </div>
                    <div class="subscriber-stat negative">
                        <span class="subscriber-value">-${formatNumber(followerData.totalUnfollows)}</span>
                        <span class="subscriber-label">Unfollowed</span>
                    </div>
                </div>
                <div class="views-chart-container">
                    ${subscribersChartHTML}
                    <div class="chart-tooltip" id="subscribersTooltip"></div>
                </div>
            </section>
            ` : ''}

            <!-- Top Performing Content -->
            ${sortedByViews.length > 0 ? `
            <section class="analytics-section">
                <h2>Top Videos by Views</h2>
                <div class="analytics-video-list">
                    ${sortedByViews.map((event, index) => createAnalyticsVideoRow(event, perVideo.get(event.id), index + 1)).join('')}
                </div>
            </section>
            ` : ''}

            ${sortedByEngagement.length > 0 ? `
            <section class="analytics-section">
                <h2>Top Videos by Engagement</h2>
                <div class="analytics-video-list">
                    ${sortedByEngagement.map((event, index) => createAnalyticsVideoRow(event, perVideo.get(event.id), index + 1)).join('')}
                </div>
            </section>
            ` : ''}

            <!-- All Content Performance -->
            <section class="analytics-section">
                <h2>All Content Performance</h2>
                <div class="analytics-tabs">
                    <button class="analytics-tab active" data-tab="videos" onclick="switchAnalyticsTab('videos')">
                        Videos (${videos.length})
                    </button>
                    <button class="analytics-tab" data-tab="shorts" onclick="switchAnalyticsTab('shorts')">
                        Shorts (${shorts.length})
                    </button>
                    <button class="analytics-tab" data-tab="streams" onclick="switchAnalyticsTab('streams')">
                        Live Streams (${liveStreams.length})
                    </button>
                </div>
                <div class="analytics-tab-content" id="analyticsVideosTab">
                    ${videos.length > 0 ? `
                        <div class="analytics-video-list">
                            ${videos.map((event, index) => createAnalyticsVideoRow(event, perVideo.get(event.id), index + 1)).join('')}
                        </div>
                    ` : '<p class="empty-message">No videos yet</p>'}
                </div>
                <div class="analytics-tab-content" id="analyticsShortsTab" style="display: none;">
                    ${shorts.length > 0 ? `
                        <div class="analytics-video-list">
                            ${shorts.map((event, index) => createAnalyticsVideoRow(event, perVideo.get(event.id), index + 1)).join('')}
                        </div>
                    ` : '<p class="empty-message">No shorts yet</p>'}
                </div>
                <div class="analytics-tab-content" id="analyticsStreamsTab" style="display: none;">
                    ${liveStreams.length > 0 ? `
                        <div class="analytics-video-list">
                            ${liveStreams.map((event, index) => createAnalyticsLiveStreamRow(event, perVideo.get(event.id), index + 1)).join('')}
                        </div>
                    ` : '<p class="empty-message">No live streams yet</p>'}
                </div>
            </section>
        </div>
    `;

    // Setup chart tooltip interactivity
    setupChartTooltips();
}

// Setup chart tooltip interactions
function setupChartTooltips() {
    // Views chart tooltips
    const chartPoints = document.querySelectorAll('.chart-point');
    const viewsTooltip = document.getElementById('chartTooltip');

    if (viewsTooltip) {
        chartPoints.forEach(point => {
            point.addEventListener('mouseenter', (e) => {
                const value = point.getAttribute('data-value');
                const date = point.getAttribute('data-date');
                viewsTooltip.innerHTML = `
                    <div class="chart-tooltip-date">${date}</div>
                    <div class="chart-tooltip-value">${formatNumber(parseInt(value))} views</div>
                `;
                viewsTooltip.classList.add('visible');

                // Position tooltip near the point
                const rect = point.getBoundingClientRect();
                const container = viewsTooltip.parentElement.getBoundingClientRect();
                viewsTooltip.style.left = `${rect.left - container.left + rect.width / 2}px`;
                viewsTooltip.style.top = `${rect.top - container.top - 40}px`;
                viewsTooltip.style.transform = 'translateX(-50%)';
            });

            point.addEventListener('mouseleave', () => {
                viewsTooltip.classList.remove('visible');
            });
        });
    }

    // Subscribers chart tooltips
    const chartBars = document.querySelectorAll('.chart-bar');
    const subscribersTooltip = document.getElementById('subscribersTooltip');

    if (subscribersTooltip) {
        chartBars.forEach(bar => {
            bar.addEventListener('mouseenter', (e) => {
                const value = parseInt(bar.getAttribute('data-value'));
                const date = bar.getAttribute('data-date');
                subscribersTooltip.innerHTML = `
                    <div class="chart-tooltip-date">${date}</div>
                    <div class="chart-tooltip-value">${value >= 0 ? '+' : ''}${formatNumber(value)} subscribers</div>
                `;
                subscribersTooltip.classList.add('visible');

                // Position tooltip near the bar
                const rect = bar.getBoundingClientRect();
                const container = subscribersTooltip.parentElement.getBoundingClientRect();
                subscribersTooltip.style.left = `${rect.left - container.left + rect.width / 2}px`;
                subscribersTooltip.style.top = `${Math.min(rect.top, rect.bottom) - container.top - 40}px`;
                subscribersTooltip.style.transform = 'translateX(-50%)';
            });

            bar.addEventListener('mouseleave', () => {
                subscribersTooltip.classList.remove('visible');
            });
        });
    }
}

// Change analytics time period
async function changeAnalyticsPeriod(periodValue) {
    const periodDays = parseInt(periodValue);
    // Use a very large number for "all time" to effectively get all data
    const effectivePeriod = periodDays === 0 ? 36500 : periodDays; // ~100 years for all time

    const mainContent = document.getElementById('mainContent');

    // Show loading state (same as initial load)
    mainContent.innerHTML = `
        <div class="analytics-page">
            <div class="analytics-header">
                <button class="back-btn" onclick="navigateTo('/my-videos')" title="${t('button.backToMyVideos')}">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                    </svg>
                </button>
                <h1>Channel Analytics</h1>
            </div>
            <div class="analytics-loading">
                <div class="spinner"></div>
                <p>Loading your analytics...</p>
            </div>
        </div>
    `;

    try {
        if (!currentAnalyticsContent) {
            // Fallback to full reload
            await loadAnalytics(effectivePeriod);
            return;
        }

        const { videos, shorts, liveStreams, allContent } = currentAnalyticsContent;

        // Fetch new data for the selected period
        const [analyticsData, followerData] = await Promise.all([
            fetchAnalyticsData(allContent, effectivePeriod),
            fetchFollowerGrowthData(currentUser.pubkey, effectivePeriod)
        ]);

        // Override periodDays in analytics data for display
        analyticsData.periodDays = periodDays;

        // Re-render with new data
        renderAnalyticsPage(videos, shorts, liveStreams, analyticsData, followerData);
    } catch (error) {
        console.error('Failed to change analytics period:', error);
        showToast('Failed to update analytics. Please try again.', 'error');
        // Reload the page on error
        await loadAnalytics(effectivePeriod);
    }
}

// Create analytics video row
function createAnalyticsVideoRow(event, data, rank) {
    const videoData = parseAnyVideoEvent(event);
    if (!videoData) return '';

    const stats = data || { views: 0, likes: 0, dislikes: 0, zapAmount: 0, zapCount: 0, boosts: 0, shares: 0, comments: 0 };
    const isShort = isNip71ShortKind(event.kind);

    return `
        <div class="analytics-video-row" onclick="navigateTo('/video/${event.id}')">
            <div class="analytics-rank">#${rank}</div>
            <div class="analytics-thumbnail">
                ${videoData.thumbnail ? `<img src="${videoData.thumbnail}" alt="">` : '<div class="no-thumb"></div>'}
                ${isShort ? '<span class="content-type-badge short">Short</span>' : ''}
            </div>
            <div class="analytics-video-info">
                <div class="analytics-video-title">${escapeHtml(videoData.title || 'Untitled')}</div>
                <div class="analytics-video-date">${formatTimestamp(event.created_at)}</div>
            </div>
            <div class="analytics-video-stats">
                <div class="stat-item">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/>
                    </svg>
                    <span>${formatNumber(stats.views)}</span>
                </div>
                <div class="stat-item likes">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                    <span>${formatNumber(stats.likes)}</span>
                </div>
                <div class="stat-item dislikes">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                    <span>${formatNumber(stats.dislikes)}</span>
                </div>
                <div class="stat-item zaps">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                    </svg>
                    <span>${formatSats(stats.zapAmount)}</span>
                </div>
                <div class="stat-item comments">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                    </svg>
                    <span>${formatNumber(stats.comments || 0)}</span>
                </div>
                <div class="stat-item shares">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/>
                    </svg>
                    <span>${formatNumber(stats.shares)}</span>
                </div>
            </div>
        </div>
    `;
}

// Create analytics live stream row
function createAnalyticsLiveStreamRow(event, data, rank) {
    const liveData = parseLiveEvent(event);
    if (!liveData) return '';

    const stats = data || { views: 0, likes: 0, dislikes: 0, zapAmount: 0, zapCount: 0, boosts: 0, shares: 0, comments: 0 };
    const isEnded = isLiveStreamEnded(liveData);
    const isActive = isLiveStreamActive(liveData);

    let statusBadge = '';
    if (isActive) statusBadge = '<span class="content-type-badge live">LIVE</span>';
    else if (isEnded) statusBadge = '<span class="content-type-badge ended">ENDED</span>';
    else statusBadge = '<span class="content-type-badge scheduled">SCHEDULED</span>';

    return `
        <div class="analytics-video-row" onclick="navigateTo('/live/${event.id}')">
            <div class="analytics-rank">#${rank}</div>
            <div class="analytics-thumbnail">
                ${liveData.thumbnail ? `<img src="${liveData.thumbnail}" alt="">` : '<div class="no-thumb"></div>'}
                ${statusBadge}
            </div>
            <div class="analytics-video-info">
                <div class="analytics-video-title">${escapeHtml(liveData.title || 'Untitled Stream')}</div>
                <div class="analytics-video-date">${formatTimestamp(event.created_at)}</div>
            </div>
            <div class="analytics-video-stats">
                <div class="stat-item">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/>
                    </svg>
                    <span>${formatNumber(stats.views)}</span>
                </div>
                <div class="stat-item likes">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                    <span>${formatNumber(stats.likes)}</span>
                </div>
                <div class="stat-item dislikes">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                    <span>${formatNumber(stats.dislikes)}</span>
                </div>
                <div class="stat-item zaps">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                    </svg>
                    <span>${formatSats(stats.zapAmount)}</span>
                </div>
                <div class="stat-item comments">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                        <path d="M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                    </svg>
                    <span>${formatNumber(stats.comments || 0)}</span>
                </div>
            </div>
        </div>
    `;
}

// Switch analytics tab
function switchAnalyticsTab(tab) {
    // Update tab buttons
    document.querySelectorAll('.analytics-tab').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tab);
    });

    // Update tab content
    document.getElementById('analyticsVideosTab').style.display = tab === 'videos' ? 'block' : 'none';
    document.getElementById('analyticsShortsTab').style.display = tab === 'shorts' ? 'block' : 'none';
    document.getElementById('analyticsStreamsTab').style.display = tab === 'streams' ? 'block' : 'none';
}

// Create a draft card for display
function createDraftCard(draftId, draft) {
    const thumbnailUrl = draft.thumbnailUrl || '';
    const title = draft.title || 'Untitled Draft';
    const updatedAt = draft.updatedAt ? new Date(draft.updatedAt).toLocaleDateString() : '';

    return `
        <div class="video-card draft-card" data-draft-id="${draftId}">
            <div class="video-thumbnail draft-thumbnail" onclick="editDraft('${draftId}')">
                ${thumbnailUrl ? `<img src="${thumbnailUrl}" alt="${escapeHtml(title)}">` : `
                    <div class="draft-placeholder">
                        <svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor" style="opacity: 0.5;">
                            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                        </svg>
                    </div>
                `}
                <div class="draft-badge">DRAFT</div>
            </div>
            <div class="video-info">
                <div class="video-details">
                    <div class="video-title">${escapeHtml(title)}</div>
                    <div class="channel-details">
                        <span class="channel-name" style="color: var(--text-secondary);">Last updated: ${updatedAt}</span>
                    </div>
                </div>
            </div>
            <div class="draft-actions">
                <button class="draft-edit-btn" onclick="editDraft('${draftId}')" title="${t('button.editDraft')}">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                    </svg>
                </button>
                <button class="draft-delete-btn" onclick="confirmDeleteDraft('${draftId}')" title="${t('button.deleteDraft')}">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                    </svg>
                </button>
            </div>
        </div>
    `;
}

// Edit a draft
function editDraft(draftId) {
    const draft = getDraft(draftId);
    if (!draft) {
        showToast('Draft not found', 'error');
        return;
    }

    // Open upload modal with draft data populated
    showUploadModal();

    // Populate form with draft data after a short delay for modal to render
    setTimeout(() => {
        const titleInput = document.getElementById('videoTitle');
        const descInput = document.getElementById('videoDescription');
        const tagsInput = document.getElementById('videoTags');
        const nsfwCheckbox = document.getElementById('nsfwCheckbox');
        const syncToNostrCheckbox = document.getElementById('saveDraftToNostr');

        if (titleInput) titleInput.value = draft.title || '';
        if (descInput) descInput.value = draft.description || '';
        if (tagsInput) tagsInput.value = (draft.tags || []).join(', ');
        if (nsfwCheckbox) nsfwCheckbox.checked = draft.isNSFW || false;
        if (syncToNostrCheckbox) syncToNostrCheckbox.checked = draft.syncToNostr || draft.nostrEventId ? true : false;

        // Store draft ID for when publishing
        uploadState.draftId = draftId;

        // Restore video preview if draft has video URL
        if (draft.videoUrl) {
            uploadState.video = {
                file: null,
                status: 'complete',
                progress: 100,
                url: draft.videoUrl,
                hash: draft.videoHash || null,
                error: null,
                size: draft.videoSize || 0,
                type: draft.videoType || 'video/mp4',
                duration: draft.videoDuration || 0,
                dimensions: draft.videoDimensions || null,
                mirrors: draft.mirrors || []
            };

            // Show video preview
            const videoPreview = document.getElementById('videoPreview');
            const videoPlayer = document.getElementById('videoPreviewPlayer');
            const videoUploadProgress = document.getElementById('videoUploadProgress');
            const videoUpload = document.getElementById('videoUpload');

            if (videoPlayer) videoPlayer.src = draft.videoUrl;
            if (videoPreview) videoPreview.style.display = 'block';
            if (videoUploadProgress) videoUploadProgress.style.display = 'block';
            if (videoUpload) videoUpload.style.display = 'none';

            // Update status text
            const videoUploadStatus = document.getElementById('videoUploadStatus');
            if (videoUploadStatus) videoUploadStatus.textContent = t('status.fromDraft');
        }

        // Restore thumbnail preview if draft has thumbnail URL
        if (draft.thumbnailUrl) {
            uploadState.thumbnail = {
                file: null,
                status: 'complete',
                progress: 100,
                url: draft.thumbnailUrl,
                error: null
            };

            // Show thumbnail preview
            const thumbnailPreview = document.getElementById('thumbnailPreview');
            const thumbnailImage = document.getElementById('thumbnailPreviewImage');
            const thumbnailUploadProgress = document.getElementById('thumbnailUploadProgress');
            const thumbnailUpload = document.getElementById('thumbnailUpload');

            if (thumbnailImage) thumbnailImage.src = draft.thumbnailUrl;
            if (thumbnailPreview) thumbnailPreview.style.display = 'block';
            if (thumbnailUploadProgress) thumbnailUploadProgress.style.display = 'block';
            if (thumbnailUpload) thumbnailUpload.style.display = 'none';

            // Update status text
            const thumbnailUploadStatus = document.getElementById('thumbnailUploadStatus');
            if (thumbnailUploadStatus) thumbnailUploadStatus.textContent = t('status.fromDraft');
        }

        // Update publish button state
        updatePublishButton();

        showToast('Draft loaded. Complete your upload and publish.', 'info');
    }, 100);
}

// Confirm and delete a draft
async function confirmDeleteDraft(draftId) {
    showConfirmModal(
        'Delete Draft',
        'Are you sure you want to delete this draft?',
        async () => {
            // Delete from both localStorage and Nostr (if the user is logged in)
            const deleteFromNostr = currentUser;
            await deleteDraft(draftId, deleteFromNostr);
            showToast('Draft deleted', 'info');
            loadMyVideos(); // Refresh the page
        },
        { confirmText: 'Delete', danger: true }
    );
}

// Save current upload form as a draft
async function saveCurrentAsDraft() {
    const title = document.getElementById('videoTitle')?.value || '';
    const description = document.getElementById('videoDescription')?.value || '';
    const tagsInput = document.getElementById('videoTags')?.value || '';
    const tags = tagsInput.split(',').map(t => t.trim()).filter(t => t);
    const isNSFW = document.getElementById('nsfwCheckbox')?.checked || false;

    // Get video and thumbnail URLs if uploaded
    const videoUrl = uploadState.video?.url || null;
    const videoHash = uploadState.video?.hash || null;
    const thumbnailUrl = uploadState.thumbnail?.url || null;

    if (!title.trim() && !description.trim() && !videoUrl) {
        showToast('Nothing to save - add a title or upload a video first', 'warning');
        return;
    }

    const draftData = {
        id: uploadState.draftId || null, // Use existing draft ID if editing
        title: title,
        description: description,
        tags: tags,
        isNSFW: isNSFW,
        videoUrl: videoUrl,
        videoHash: videoHash,
        thumbnailUrl: thumbnailUrl,
        videoDuration: uploadState.video?.duration || 0,
        videoSize: uploadState.video?.size || 0,
        videoType: uploadState.video?.type || null,
        videoDimensions: uploadState.video?.dimensions || null,
        mirrors: uploadState.video?.mirrors || [],
        syncToNostr: true // Always sync drafts to Nostr
    };

    // Always sync drafts to Nostr (user must be logged in to access upload page)
    const draftId = await saveDraft(draftData, true);

    // Update the uploadState with the draft ID so future saves update the same draft
    uploadState.draftId = draftId;

    showToast('Draft saved! You can continue later from My Videos.', 'success');
}

// Load videos by tag with streaming
async function loadTag(tag) {
    const normalizedTag = tag.toLowerCase();
    currentView = `tag-${normalizedTag}`;

    const displayTag = normalizedTag.charAt(0).toUpperCase() + normalizedTag.slice(1);

    // Setup page with shorts section and video grid
    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const skeletonCount = cardsPerRow * 5;
    const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');

    mainContent.innerHTML = `
        <h2 style="margin-bottom: 1.5rem;">${displayTag} Videos</h2>
        <!-- Shorts Section -->
        <div id="tagShortsSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M10 8l6 4-6 4V8z"/>
                </svg>
                Shorts
            </h3>
            <div class="shorts-grid" id="tagShortsGrid"></div>
        </div>
        <!-- Videos Section -->
        <div class="video-grid" id="videoGrid">
            ${skeletons}
        </div>
    `;

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('tagShortsGrid');
    const shortsSection = document.getElementById('tagShortsSection');

    // Fetch all videos and live streams for this tag
    const filter = {
        kinds: [...ALL_VIDEO_KINDS, NIP53_LIVE_EVENT_KIND],
        '#t': ['pv69420'],
        limit: 500
    };

    // Store live stream data for rendering
    const liveStreamData = new Map();

    const tagFilter = (event) => {
        const tags = event.tags || [];
        // For NSFW tag page, also include events with content-warning: nsfw (case-insensitive)
        if (normalizedTag === 'nsfw') {
            return tags.some(t => t[0] === 't' && t[1].toLowerCase() === 'nsfw') ||
                   tags.some(t => t[0] === 'content-warning' && t[1]?.toLowerCase() === 'nsfw');
        }
        return tags.some(t => t[0] === 't' && t[1].toLowerCase() === normalizedTag);
    };

    const videoEvents = [];
    const shortEvents = [];
    const profileQueue = new Set();
    const reactionQueue = new Set();
    let profileTimer = null;
    let reactionTimer = null;

    const loadProfilesBatch = async () => {
        if (profileQueue.size === 0) return;
        const pubkeys = Array.from(profileQueue);
        profileQueue.clear();

        const BATCH_SIZE = 25;
        const chunks = [];
        for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
            chunks.push(pubkeys.slice(i, i + BATCH_SIZE));
        }

        await Promise.all(chunks.map(async (chunk) => {
            const profileFilter = { kinds: [0], authors: chunk };
            await requestEventsStream(profileFilter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);
                    [...videoEvents, ...shortEvents].forEach(event => {
                        if (event.pubkey === profileEvent.pubkey) {
                            updateVideoCardInPlace(event.id, profile, reactionsCache.get(event.id));
                        }
                    });
                } catch (e) {}
            });
        }));
    };

    const loadReactionsBatch = async () => {
        if (reactionQueue.size === 0) return;
        const videoIds = Array.from(reactionQueue);
        reactionQueue.clear();
        await loadReactionsForVideos(videoIds);
    };

    await requestEventsStream(filter, (event) => {
        const tags = event.tags || [];

        // Handle live streams separately
        if (event.kind === NIP53_LIVE_EVENT_KIND) {
            if (!tagFilter(event)) return;

            const liveData = parseLiveEvent(event);
            if (!liveData || !isLiveStreamActive(liveData)) return;

            allEvents.set(event.id, event);
            liveStreamData.set(event.id, liveData);
            videoEvents.push(event);

            // Remove skeleton cards
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            const cachedProfile = profileCache.get(event.pubkey);
            const cardHTML = createLiveStreamCard(event, liveData, cachedProfile);

            if (cardHTML) {
                // Insert live streams at the beginning (they're more time-sensitive)
                videoGrid.insertAdjacentHTML('afterbegin', cardHTML);
                // Load boosts for live stream
                if (!boostsCache.has(event.id)) {
                    loadBoostsForVideo(event.id);
                }
            }

            if (!cachedProfile) {
                profileQueue.add(event.pubkey);
                clearTimeout(profileTimer);
                profileTimer = setTimeout(loadProfilesBatch, 100);
            }
            return;
        }

        // Regular video handling
        if (!tags.some(tag => tag[0] === 'x')) return;
        if (!tagFilter(event)) return;

        allEvents.set(event.id, event);
        if (shouldSkipLegacyEvent(event)) return;

        const isShort = isNip71ShortKind(event.kind);
        const targetGrid = isShort ? shortsGrid : videoGrid;
        const targetEvents = isShort ? shortEvents : videoEvents;

        targetEvents.push(event);

        if (isShort && shortsSection) {
            shortsSection.style.display = 'block';
        }

        // Remove skeleton cards
        if (!isShort) {
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }
        }

        const cachedProfile = profileCache.get(event.pubkey);
        const cachedReactions = reactionsCache.get(event.id);
        const cardHTML = isShort
            ? createShortCard(event, cachedProfile, cachedReactions)
            : createVideoCard(event, cachedProfile, cachedReactions);

        if (cardHTML) {
            targetGrid.insertAdjacentHTML('beforeend', cardHTML);
        }

        if (!cachedProfile) {
            profileQueue.add(event.pubkey);
            clearTimeout(profileTimer);
            profileTimer = setTimeout(loadProfilesBatch, 100);
        }

        reactionQueue.add(event.id);
        clearTimeout(reactionTimer);
        reactionTimer = setTimeout(loadReactionsBatch, 200);

    }, () => {
        // Remove remaining skeletons
        videoGrid.querySelectorAll('.skeleton-card').forEach(s => s.remove());

        if (videoEvents.length === 0 && shortEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosForTag')}</p>`;
        } else if (videoEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noFullLengthForTag')}</p>`;
        }

        if (profileQueue.size > 0) loadProfilesBatch();
        if (reactionQueue.size > 0) loadReactionsBatch();

        // Load views for tag page videos
        const tagVideoIds = [...videoEvents.map(e => e.id), ...shortEvents.map(e => e.id)];
        if (tagVideoIds.length > 0) {
            loadViewsForVideos(tagVideoIds, true);
        }

        observeLazyCards();
    });
}

// Handle deleting video
async function handleDelete(eventId) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to delete videos', 'warning');
            return;
        }
    }

    showConfirmModal(
        'Delete Video',
        'Are you sure you want to delete this video? This action cannot be undone.',
        async () => {
            try {
                // Get the event to check if it has a linked NIP-71 event
                const event = allEvents.get(eventId);
                const linkedEventId = videoEventLinks.get(eventId);

                // Create deletion tags for both events if linked
                const deletionTags = [['e', eventId], ['t', 'pv69420']];
                if (linkedEventId) {
                    deletionTags.push(['e', linkedEventId]);
                }

                // If this is a NIP-71 event with a d-tag, add an 'a' tag for the addressable deletion
                if (event && isNip71Kind(event.kind)) {
                    const dTag = event.tags?.find(t => t[0] === 'd')?.[1];
                    if (dTag) {
                        deletionTags.push(['a', `${event.kind}:${event.pubkey}:${dTag}`]);
                    }
                }

                const deleteEvent = {
                    kind: 5,
                    tags: deletionTags,
                    content: 'Deletion request',
                    created_at: Math.floor(Date.now() / 1000)
                };

                const signedEvent = await signEvent(deleteEvent);
                const published = await publishEvent(signedEvent);

                if (published) {
                    // Remove the card from DOM if it exists on the current page
                    const card = document.getElementById(`video-card-${eventId}`);
                    if (card) {
                        // Animate removal
                        card.style.transition = 'opacity 0.3s, transform 0.3s';
                        card.style.opacity = '0';
                        card.style.transform = 'scale(0.9)';
                        setTimeout(() => {
                            card.remove();

                            // Check if we need to show empty state messages
                            const videoGrid = document.getElementById('videoGrid');
                            const shortsGrid = document.getElementById('myVideosShortsGrid');
                            const shortsSection = document.getElementById('myVideosShortsSection');

                            // Check if videos grid is empty (excluding empty state messages)
                            if (videoGrid && videoGrid.querySelectorAll('.video-card').length === 0) {
                                const existingMsg = videoGrid.querySelector('p');
                                if (!existingMsg) {
                                    videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noVideosUploadFirst')}</p>`;
                                }
                            }

                            // Check if shorts grid is empty
                            if (shortsGrid && shortsGrid.querySelectorAll('.short-card, .video-card').length === 0) {
                                if (shortsSection) {
                                    shortsSection.style.display = 'none';
                                }
                            }
                        }, 300);

                        // Remove from allEvents cache
                        allEvents.delete(eventId);
                        if (linkedEventId) {
                            allEvents.delete(linkedEventId);
                        }

                        showToast('Video deleted successfully', 'success');
                    } else {
                        // Card not on current page, navigate to my-videos
                        showToast('Deletion request sent to relays. The video may take some time to be removed.', 'info');
                        navigateTo('/my-videos');
                    }
                } else {
                    showToast('Failed to send deletion request. Please try again.', 'error');
                }
            } catch (error) {
                console.error('Failed to delete video:', error);
                showToast('Failed to delete video: ' + error.message, 'error');
            }
        },
        { confirmText: 'Delete', danger: true }
    );
}

// ===== VIDEO EDITING FUNCTIONS =====

// Current edit state
let editVideoState = {
    eventId: null,
    event: null,
    videoData: null,
    newThumbnailUrl: null
};

// Show the edit video modal
async function showEditVideoModal(eventId) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to edit videos', 'warning');
            return;
        }
    }

    const event = allEvents.get(eventId);
    if (!event) {
        showToast('Video not found', 'error');
        return;
    }

    // Verify ownership
    if (event.pubkey !== currentUser.pubkey) {
        showToast('You can only edit your own videos', 'error');
        return;
    }

    // Parse video data
    const videoData = parseAnyVideoEvent(event);
    if (!videoData) {
        showToast('Could not parse video data', 'error');
        return;
    }

    // Store edit state
    editVideoState = {
        eventId: eventId,
        event: event,
        videoData: videoData,
        newThumbnailUrl: null
    };

    // Populate the form
    document.getElementById('editVideoTitle').value = videoData.title || '';
    document.getElementById('editVideoDescription').value = videoData.description || '';
    document.getElementById('editVideoTags').value = (videoData.tags || []).join(', ');
    document.getElementById('editNsfwCheckbox').checked = videoData.isNSFW || false;

    // Set hidden fields
    document.getElementById('editVideoEventId').value = eventId;
    // Get d-tag from parsed data or directly from event tags
    const dTag = videoData.dTag || event.tags?.find(t => t[0] === 'd')?.[1] || '';
    document.getElementById('editVideoDTag').value = dTag;
    document.getElementById('editVideoHash').value = videoData.hash || '';
    document.getElementById('editVideoUrl').value = videoData.url || '';
    document.getElementById('editVideoType').value = videoData.type || 'video/mp4';
    document.getElementById('editVideoSize').value = videoData.size || 0;
    document.getElementById('editVideoDuration').value = videoData.duration || 0;
    document.getElementById('editVideoWidth').value = videoData.width || 0;
    document.getElementById('editVideoHeight').value = videoData.height || 0;
    document.getElementById('editVideoPublishedAt').value = videoData.publishedAt || event.created_at;
    document.getElementById('editNewThumbnailUrl').value = '';

    // Set video preview
    const videoPreview = document.getElementById('editVideoPreview');
    if (videoPreview && videoData.url) {
        videoPreview.src = videoData.url;
    }

    // Set thumbnail preview
    const thumbnailPreview = document.getElementById('editThumbnailPreview');
    if (thumbnailPreview && videoData.thumbnail) {
        thumbnailPreview.src = videoData.thumbnail;
        thumbnailPreview.style.display = 'block';
    }

    // Show the modal
    const modal = document.getElementById('editVideoModal');
    if (modal) {
        modal.classList.add('active');
    }
}

// Hide the edit video modal
function hideEditVideoModal() {
    const modal = document.getElementById('editVideoModal');
    if (modal) {
        modal.classList.remove('active');
    }

    // Pause video preview
    const videoPreview = document.getElementById('editVideoPreview');
    if (videoPreview) {
        videoPreview.pause();
        videoPreview.src = '';
    }

    // Reset edit state
    editVideoState = {
        eventId: null,
        event: null,
        videoData: null,
        newThumbnailUrl: null
    };
}

// Handle edit form submission
async function handleEditVideoSubmit(e) {
    e.preventDefault();

    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to edit videos', 'warning');
            return;
        }
    }

    const saveBtn = document.getElementById('saveEditButton');
    const originalText = saveBtn.textContent;
    saveBtn.textContent = t('status.saving');
    saveBtn.disabled = true;

    try {
        const title = document.getElementById('editVideoTitle').value.trim();
        const description = document.getElementById('editVideoDescription').value.trim();
        const tagsInput = document.getElementById('editVideoTags').value;
        const tags = tagsInput.split(',').map(t => t.trim()).filter(t => t);
        const isNSFW = document.getElementById('editNsfwCheckbox').checked;

        if (!title) {
            showToast('Please enter a title', 'warning');
            saveBtn.textContent = originalText;
            saveBtn.disabled = false;
            return;
        }

        // Add nsfw tag if checked
        if (isNSFW && !tags.includes('nsfw')) {
            tags.push('nsfw');
        }

        // Get video data from hidden fields
        const videoHash = document.getElementById('editVideoHash').value;
        const videoUrl = document.getElementById('editVideoUrl').value;
        const videoType = document.getElementById('editVideoType').value;
        const videoSize = parseInt(document.getElementById('editVideoSize').value) || 0;
        const videoDuration = parseInt(document.getElementById('editVideoDuration').value) || 0;
        const videoWidth = parseInt(document.getElementById('editVideoWidth').value) || 0;
        const videoHeight = parseInt(document.getElementById('editVideoHeight').value) || 0;
        const publishedAt = parseInt(document.getElementById('editVideoPublishedAt').value) || Math.floor(Date.now() / 1000);
        const originalDTag = document.getElementById('editVideoDTag').value;

        // Ensure we have a d-tag for replacement - without it, we'd create a new video
        if (!originalDTag) {
            showToast('This video cannot be edited because it lacks a replacement identifier (d-tag). This may be a legacy video.', 'warning', 5000);
            saveBtn.textContent = originalText;
            saveBtn.disabled = false;
            return;
        }

        // Check if video was replaced
        const videoReplaced = document.getElementById('editVideoReplaced').value === 'true';
        const newVideoMirrorsJson = document.getElementById('editNewVideoMirrors').value;

        // Use new thumbnail if uploaded, otherwise keep original
        const newThumbnailUrl = document.getElementById('editNewThumbnailUrl').value;
        const thumbnailUrl = newThumbnailUrl || editVideoState.videoData?.thumbnail || '';

        // Get mirrors - use new ones if video was replaced, otherwise use original fallbacks
        let mirrors = [];
        if (videoReplaced && newVideoMirrorsJson) {
            try {
                mirrors = JSON.parse(newVideoMirrorsJson);
            } catch (e) {
                console.warn('Failed to parse new video mirrors:', e);
            }
        } else if (editVideoState.videoData?.fallbackUrls) {
            mirrors = editVideoState.videoData.fallbackUrls.map(url => ({ url }));
        }

        // Prepare video data for republishing
        const videoData = {
            title: title,
            description: description,
            url: videoUrl,
            hash: videoHash,
            thumbnail: thumbnailUrl,
            duration: videoDuration,
            size: videoSize,
            type: videoType,
            width: videoWidth,
            height: videoHeight,
            mirrors: mirrors,
            tags: tags,
            isNSFW: isNSFW,
            dTag: originalDTag, // Use existing d-tag for replacement (validated above)
            publishedAt: publishedAt,
            originalKind: editVideoState.event?.kind // Preserve original kind to ensure proper replacement
        };

        saveBtn.textContent = t('status.publishingChanges');

        // Create NIP-71 video event (kind 21 or 22 depending on orientation)
        const nip71Event = createNip71VideoEvent(videoData);
        const signedNip71Event = await signEvent(nip71Event);

        // Publish the new event first
        const published = await publishEvent(signedNip71Event);

        if (!published) {
            throw new Error('Failed to publish to any relay');
        }

        // Handle old event cleanup based on event kind
        const oldEventId = editVideoState.eventId;
        const oldEvent = editVideoState.event;

        // For addressable events (34235/34236), the new event replaces the old one automatically
        // For legacy events (21/22), we need to explicitly delete the old version
        const isAddressableKind = oldEvent && (oldEvent.kind === NIP71_VIDEO_KIND || oldEvent.kind === NIP71_SHORT_KIND);
        const isLegacyKind = oldEvent && (oldEvent.kind === NIP71_VIDEO_KIND_LEGACY || oldEvent.kind === NIP71_SHORT_KIND_LEGACY);

        if (isLegacyKind && oldEventId && oldEventId !== signedNip71Event.id) {
            saveBtn.textContent = t('status.removingOldVersion');

            const deletionTags = [['e', oldEventId], ['t', 'pv69420']];

            const dTag = oldEvent.tags?.find(t => t[0] === 'd')?.[1];
            if (dTag) {
                deletionTags.push(['a', `${oldEvent.kind}:${oldEvent.pubkey}:${dTag}`]);
            }

            const deleteEvent = {
                kind: 5,
                tags: deletionTags,
                content: 'Replaced by updated version',
                created_at: Math.floor(Date.now() / 1000)
            };

            const signedDeleteEvent = await signEvent(deleteEvent);
            await publishEvent(signedDeleteEvent);
        }

        // Remove old event from cache (for both addressable and legacy)
        if (oldEventId && oldEventId !== signedNip71Event.id) {
            allEvents.delete(oldEventId);
        }

        // Update the event in our cache
        allEvents.set(signedNip71Event.id, signedNip71Event);

        saveBtn.textContent = t('status.saved');
        showToast('Video updated successfully', 'success');

        setTimeout(() => {
            hideEditVideoModal();
            // Reload the video page to show updated content
            playVideo(signedNip71Event.id);
        }, 1000);

    } catch (error) {
        console.error('Edit failed:', error);
        showToast(error.message || 'Failed to save changes', 'error');
        saveBtn.textContent = originalText;
        saveBtn.disabled = false;
    }
}

// Handle thumbnail change in edit modal
async function handleEditThumbnailChange(file) {
    if (!file || !file.type.startsWith('image/')) {
        showToast('Please select an image file', 'warning');
        return;
    }

    const progressDiv = document.getElementById('editThumbnailUploadProgress');
    const statusEl = document.getElementById('editThumbnailStatus');
    const progressFill = document.getElementById('editThumbnailProgressFill');

    if (progressDiv) progressDiv.style.display = 'block';
    if (statusEl) statusEl.textContent = t('status.validatingThumbnail');
    if (progressFill) progressFill.style.width = '0%';

    try {
        // Validate thumbnail orientation matches the original video type
        if (editVideoState && editVideoState.event) {
            const thumbnailDimensions = await getImageDimensions(file);
            const originalIsShort = isNip71ShortKind(editVideoState.event.kind);

            if (!isThumbnailOrientationValid(thumbnailDimensions.width, thumbnailDimensions.height, originalIsShort)) {
                if (progressDiv) progressDiv.style.display = 'none';

                if (originalIsShort) {
                    showToast('Thumbnail must be vertical (portrait) to match your Short video', 'error');
                } else {
                    showToast('Thumbnail must be horizontal (landscape) to match your video', 'error');
                }
                return;
            }
        }

        if (statusEl) statusEl.textContent = t('status.uploadingThumbnail');
        const result = await uploadToBlossom(file, BLOSSOM_SERVERS);

        if (result.success && result.url) {
            // Update preview
            const thumbnailPreview = document.getElementById('editThumbnailPreview');
            if (thumbnailPreview) {
                thumbnailPreview.src = result.url;
                thumbnailPreview.style.display = 'block';
            }

            // Store new thumbnail URL
            document.getElementById('editNewThumbnailUrl').value = result.url;
            editVideoState.newThumbnailUrl = result.url;

            if (statusEl) statusEl.textContent = t('status.thumbnailUploaded');
            if (progressFill) progressFill.style.width = '100%';

            showToast('Thumbnail updated', 'success');

            setTimeout(() => {
                if (progressDiv) progressDiv.style.display = 'none';
            }, 1500);
        } else {
            throw new Error(result.error || 'Upload failed');
        }
    } catch (error) {
        console.error('Thumbnail upload failed:', error);
        if (statusEl) statusEl.textContent = `Upload failed: ${error.message}`;
        showToast('Failed to upload thumbnail', 'error');
    }
}

// Handle video replacement in edit modal
async function handleEditVideoChange(file) {
    if (!file || !file.type.startsWith('video/')) {
        showToast('Please select a video file', 'warning');
        return;
    }

    const progressDiv = document.getElementById('editVideoUploadProgress');
    const statusEl = document.getElementById('editVideoStatus');
    const progressFill = document.getElementById('editVideoProgressFill');
    const saveBtn = document.getElementById('saveEditButton');
    const noteEl = document.getElementById('editVideoReplaceNote');

    if (progressDiv) progressDiv.style.display = 'block';
    if (statusEl) statusEl.textContent = t('status.processingVideo');
    if (progressFill) progressFill.style.width = '0%';
    if (saveBtn) saveBtn.disabled = true;
    if (noteEl) noteEl.style.display = 'none';

    try {
        // Get video metadata
        const metadata = await VideoCompressor.getVideoMetadata(file);
        const videoDimensions = { width: metadata.width, height: metadata.height };

        // Validate that the new video type matches the original video type
        // (prevent swapping a Short for a regular video or vice versa)
        if (editVideoState && editVideoState.event) {
            const originalIsShort = isNip71ShortKind(editVideoState.event.kind);
            const newIsShort = isVideoShort(metadata.width, metadata.height, metadata.duration);

            if (originalIsShort && !newIsShort) {
                if (progressDiv) progressDiv.style.display = 'none';
                if (saveBtn) saveBtn.disabled = false;
                if (noteEl) noteEl.style.display = 'block';
                showToast('Cannot replace a Short with a regular video. Please upload a vertical video (60 seconds or less).', 'error');
                return;
            }

            if (!originalIsShort && newIsShort) {
                if (progressDiv) progressDiv.style.display = 'none';
                if (saveBtn) saveBtn.disabled = false;
                if (noteEl) noteEl.style.display = 'block';
                showToast('Cannot replace a regular video with a Short. Please upload a horizontal/landscape video.', 'error');
                return;
            }
        }

        // Check if compression is needed
        let fileToUpload = file;
        const MAX_SIZE = 100 * 1024 * 1024; // 100MB

        if (file.size > MAX_SIZE) {
            if (statusEl) statusEl.textContent = t('status.compressingVideo');

            // Compress the video
            fileToUpload = await VideoCompressor.compressVideo(file, {
                maxSizeMB: 95,
                onProgress: (progress) => {
                    if (progressFill) progressFill.style.width = `${progress * 50}%`;
                    if (statusEl) statusEl.textContent = `Compressing: ${Math.round(progress * 100)}%`;
                }
            });
        }

        if (statusEl) statusEl.textContent = t('status.uploadingVideo');
        if (progressFill) progressFill.style.width = '0%';

        // Upload to blossom servers with progress callback
        const result = await uploadToBlossom(
            fileToUpload,
            BLOSSOM_SERVERS,
            'editVideoServerStatus',
            (progress, completed, total) => {
                if (progressFill) progressFill.style.width = `${progress}%`;
                if (statusEl) statusEl.textContent = `Uploading video... (${completed}/${total} servers)`;
            }
        );

        if (result.success && result.url) {
            // Update preview
            const videoPreview = document.getElementById('editVideoPreview');
            if (videoPreview) {
                videoPreview.src = result.url;
            }

            // Store new video data in hidden fields
            document.getElementById('editNewVideoUrl').value = result.url;
            document.getElementById('editNewVideoHash').value = result.hash;
            document.getElementById('editNewVideoMirrors').value = JSON.stringify(result.mirrors || []);
            document.getElementById('editVideoReplaced').value = 'true';

            // Update the existing fields with new video data
            document.getElementById('editVideoUrl').value = result.url;
            document.getElementById('editVideoHash').value = result.hash;
            document.getElementById('editVideoType').value = fileToUpload.type || 'video/mp4';
            document.getElementById('editVideoSize').value = fileToUpload.size;
            document.getElementById('editVideoDuration').value = Math.floor(metadata.duration || 0);
            document.getElementById('editVideoWidth').value = videoDimensions.width;
            document.getElementById('editVideoHeight').value = videoDimensions.height;

            // Update edit state
            editVideoState.newVideoUrl = result.url;
            editVideoState.newVideoHash = result.hash;
            editVideoState.newVideoMirrors = result.mirrors || [];
            editVideoState.videoDimensions = videoDimensions;

            if (statusEl) statusEl.textContent = t('status.videoUploaded');
            if (progressFill) progressFill.style.width = '100%';
            if (saveBtn) saveBtn.disabled = false;

            showToast('Video replaced successfully', 'success');

            setTimeout(() => {
                if (progressDiv) progressDiv.style.display = 'none';
            }, 1500);
        } else {
            throw new Error(result.error || 'Upload failed');
        }
    } catch (error) {
        console.error('Video upload failed:', error);
        if (statusEl) statusEl.textContent = `Upload failed: ${error.message}`;
        if (saveBtn) saveBtn.disabled = false;
        if (noteEl) noteEl.style.display = 'block';
        showToast('Failed to upload video', 'error');
    }
}

// Initialize edit video form listeners
function initEditVideoForm() {
    const editForm = document.getElementById('editVideoForm');
    if (editForm) {
        editForm.addEventListener('submit', handleEditVideoSubmit);
    }

    const editThumbnailFile = document.getElementById('editThumbnailFile');
    if (editThumbnailFile) {
        editThumbnailFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleEditThumbnailChange(file);
            }
        });
    }

    const editVideoFile = document.getElementById('editVideoFile');
    if (editVideoFile) {
        editVideoFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleEditVideoChange(file);
            }
        });
    }
}

// Get cached author stats (video count and follower count)
async function getAuthorStats(pubkey) {
    const cached = authorStatsCache.get(pubkey);
    if (cached && Date.now() - cached.timestamp < AUTHOR_STATS_CACHE_TTL) {
        return cached.stats;
    }

    // Fetch video count and follower count sequentially to reduce relay load
    try {
        const videoCount = await fetchAuthorVideoCount(pubkey);
        const followerCount = await fetchAuthorFollowerCount(pubkey);

        const stats = { videoCount, followerCount };
        authorStatsCache.set(pubkey, { stats, timestamp: Date.now() });
        return stats;
    } catch (error) {
        console.error('Failed to fetch author stats:', error);
        // Return cached data even if expired, or zeros
        if (cached) {
            return cached.stats;
        }
        return { videoCount: 0, followerCount: 0 };
    }
}

// Fetch author's video count from relays with pagination
async function fetchAuthorVideoCount(pubkey) {
    const videoIds = new Set();
    let oldestTimestamp = Math.floor(Date.now() / 1000);
    let hasMore = true;
    let batchCount = 0;
    const maxBatches = 10; // Safety limit
    const batchSize = 100;

    // Overall timeout for the entire operation
    const startTime = Date.now();
    const maxTime = 15000; // 15 seconds max

    while (hasMore && batchCount < maxBatches && (Date.now() - startTime) < maxTime) {
        const filter = {
            kinds: ALL_VIDEO_KINDS,
            authors: [pubkey],
            '#t': ['pv69420'],
            until: oldestTimestamp,
            limit: batchSize
        };

        let batchEvents = [];

        try {
            await new Promise((resolve) => {
                const timeout = setTimeout(() => resolve(), 5000); // 5s per batch

                requestEventsStream(filter, (event) => {
                    const tags = event.tags || [];
                    if (tags.some(tag => tag[0] === 'x') && !videoIds.has(event.id)) {
                        videoIds.add(event.id);
                        batchEvents.push(event);
                    }
                }, () => {
                    clearTimeout(timeout);
                    resolve();
                });
            });
        } catch (error) {
            console.warn('Video count batch failed:', error);
            break;
        }

        batchCount++;

        // Check if we got fewer events than limit - means no more data
        if (batchEvents.length < batchSize / 2) {
            hasMore = false;
        } else {
            // Get oldest timestamp for next batch
            const oldestEvent = batchEvents.reduce((oldest, e) =>
                e.created_at < oldest.created_at ? e : oldest, batchEvents[0]);
            if (oldestEvent && oldestEvent.created_at < oldestTimestamp) {
                oldestTimestamp = oldestEvent.created_at - 1;
            } else {
                hasMore = false;
            }
        }
    }

    return videoIds.size;
}

// Fetch author's follower count from relays with pagination
async function fetchAuthorFollowerCount(pubkey) {
    const followers = new Set();
    let oldestTimestamp = Math.floor(Date.now() / 1000);
    let hasMore = true;
    let batchCount = 0;
    const maxBatches = 10; // Safety limit
    const batchSize = 200;

    // Overall timeout for the entire operation
    const startTime = Date.now();
    const maxTime = 20000; // 20 seconds max for followers (can be larger)

    while (hasMore && batchCount < maxBatches && (Date.now() - startTime) < maxTime) {
        const filter = {
            kinds: [3],
            '#p': [pubkey],
            until: oldestTimestamp,
            limit: batchSize
        };

        let batchEvents = [];
        const prevSize = followers.size;

        try {
            await new Promise((resolve) => {
                const timeout = setTimeout(() => resolve(), 8000); // 8s per batch

                requestEventsStream(filter, (event) => {
                    if (!followers.has(event.pubkey)) {
                        followers.add(event.pubkey);
                        batchEvents.push(event);
                    }
                }, () => {
                    clearTimeout(timeout);
                    resolve();
                });
            });
        } catch (error) {
            console.warn('Follower count batch failed:', error);
            break;
        }

        batchCount++;

        // Check if we got fewer new followers than expected - means no more data
        if (batchEvents.length < batchSize / 3 || followers.size === prevSize) {
            hasMore = false;
        } else {
            // Get oldest timestamp for next batch
            const oldestEvent = batchEvents.reduce((oldest, e) =>
                e.created_at < oldest.created_at ? e : oldest, batchEvents[0]);
            if (oldestEvent && oldestEvent.created_at < oldestTimestamp) {
                oldestTimestamp = oldestEvent.created_at - 1;
            } else {
                hasMore = false;
            }
        }
    }

    return followers.size;
}

// Load and display channel stats on video page
async function loadChannelStats(pubkey) {
    const statsEl = document.getElementById(`channel-stats-${pubkey}`);
    const actionsEl = document.getElementById(`channel-actions-${pubkey}`);

    try {
        // Load stats and follow status in parallel
        const [stats, isFollowingUser] = await Promise.all([
            getAuthorStats(pubkey),
            currentUser ? isFollowing(pubkey) : Promise.resolve(false)
        ]);

        // Update stats display
        if (statsEl) {
            const videoCountEl = statsEl.querySelector('.channel-stat:first-child');
            const followerCountEl = statsEl.querySelector('.channel-stat:last-child');

            if (videoCountEl) {
                videoCountEl.classList.remove('loading');
                videoCountEl.innerHTML = `<span class="stat-value">${formatNumber(stats.videoCount)}</span> video${stats.videoCount !== 1 ? 's' : ''}`;
            }
            if (followerCountEl) {
                followerCountEl.classList.remove('loading');
                followerCountEl.innerHTML = `<span class="stat-value">${formatNumber(stats.followerCount)}</span> follower${stats.followerCount !== 1 ? 's' : ''}`;
            }
        }

        // Update follow button
        if (actionsEl && currentUser && currentUser.pubkey !== pubkey) {
            const existingBtn = actionsEl.querySelector('.channel-follow-btn');
            if (existingBtn) {
                existingBtn.classList.remove('loading');
                existingBtn.disabled = false;
                existingBtn.innerHTML = isFollowingUser ? t('button.unfollow') : t('button.follow');
                existingBtn.classList.toggle('following', isFollowingUser);
                existingBtn.onclick = () => handleChannelFollow(pubkey, isFollowingUser);
            }

            // Update mute button
            const muteBtn = actionsEl.querySelector('.channel-mute-btn');
            if (muteBtn) {
                const isMuted = isUserMuted(pubkey);
                muteBtn.classList.remove('loading');
                muteBtn.disabled = false;
                muteBtn.classList.toggle('muted', isMuted);
                muteBtn.innerHTML = `${getMuteIconSVG()} ${isMuted ? t('button.unmute') : t('button.mute')}`;
                muteBtn.title = isMuted ? 'Unmute this user' : 'Mute this user';
                muteBtn.onclick = () => handleMute(pubkey, isMuted);
            }
        }
    } catch (error) {
        console.error('Failed to load channel stats:', error);
        // Remove loading states on error
        if (statsEl) {
            statsEl.querySelectorAll('.channel-stat.loading').forEach(el => {
                el.classList.remove('loading');
            });
        }
        if (actionsEl) {
            const btn = actionsEl.querySelector('.channel-follow-btn.loading');
            if (btn) {
                btn.classList.remove('loading');
                btn.disabled = false;
                btn.innerHTML = 'Follow';
            }
            // Also handle mute button error state
            const muteBtn = actionsEl.querySelector('.channel-mute-btn.loading');
            if (muteBtn) {
                muteBtn.classList.remove('loading');
                muteBtn.disabled = false;
                muteBtn.innerHTML = `${getMuteIconSVG()} Mute`;
            }
        }
    }
}

// Handle follow/unfollow from video channel info
async function handleChannelFollow(pubkey, isCurrentlyFollowing) {
    const actionsEl = document.getElementById(`channel-actions-${pubkey}`);
    const button = actionsEl?.querySelector('.channel-follow-btn');

    if (!button) return;

    button.disabled = true;
    button.innerHTML = '<span class="spinner-small"></span>';

    let success;
    if (isCurrentlyFollowing) {
        success = await unfollowUser(pubkey);
    } else {
        success = await followUser(pubkey);
    }

    if (success) {
        const newFollowState = !isCurrentlyFollowing;
        button.classList.toggle('following', newFollowState);
        button.innerHTML = newFollowState ? t('button.unfollow') : t('button.follow');
        button.onclick = () => handleChannelFollow(pubkey, newFollowState);

        // Update the cached follower count
        const cached = authorStatsCache.get(pubkey);
        if (cached) {
            cached.stats.followerCount += newFollowState ? 1 : -1;
            const statsEl = document.getElementById(`channel-stats-${pubkey}`);
            if (statsEl) {
                const followerCountEl = statsEl.querySelector('.channel-stat:last-child');
                if (followerCountEl) {
                    const count = cached.stats.followerCount;
                    followerCountEl.innerHTML = `<span class="stat-value">${formatNumber(count)}</span> follower${count !== 1 ? 's' : ''}`;
                }
            }
        }
    } else {
        button.innerHTML = isCurrentlyFollowing ? t('button.unfollow') : t('button.follow');
        showToast('Failed to update follow status. Please try again.', 'error');
    }

    button.disabled = false;
}

// Check if current user is following a pubkey
async function isFollowing(pubkey) {
    if (!currentUser) return false;

    const filter = {
        kinds: [3],
        authors: [currentUser.pubkey],
        limit: 1
    };

    let following = false;
    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            const pTags = event.tags.filter(tag => tag[0] === 'p');
            following = pTags.some(tag => tag[1] === pubkey);
        }, resolve);
    });

    return following;
}

// Follow a user
async function followUser(pubkey) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to follow users', 'warning');
            return false;
        }
    }

    try {
        const followingFilter = {
            kinds: [3],
            authors: [currentUser.pubkey],
            limit: 1
        };

        let currentFollowingTags = [];
        let currentRelayTags = [];

        await new Promise((resolve) => {
            requestEventsStream(followingFilter, (event) => {
                currentFollowingTags = event.tags.filter(tag => tag[0] === 'p');
                currentRelayTags = event.tags.filter(tag => tag[0] === 'r');
            }, resolve);
        });

        if (!currentFollowingTags.some(tag => tag[1] === pubkey)) {
            currentFollowingTags.push(['p', pubkey]);
        }

        const contactListEvent = {
            kind: 3,
            tags: [...currentFollowingTags, ...currentRelayTags],
            content: '',
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(contactListEvent);
        const published = await publishEvent(signedEvent);

        // Record follow event for analytics (non-blocking)
        if (published) {
            recordChannelFollow(pubkey);
        }

        return published;
    } catch (error) {
        console.error('Failed to follow user:', error);
        return false;
    }
}

// Unfollow a user
async function unfollowUser(pubkey) {
    if (!currentUser) {
        showToast('Please login to unfollow users', 'warning');
        return false;
    }

    try {
        const followingFilter = {
            kinds: [3],
            authors: [currentUser.pubkey],
            limit: 1
        };

        let currentFollowingTags = [];
        let currentRelayTags = [];

        await new Promise((resolve) => {
            requestEventsStream(followingFilter, (event) => {
                currentFollowingTags = event.tags.filter(tag => tag[0] === 'p');
                currentRelayTags = event.tags.filter(tag => tag[0] === 'r');
            }, resolve);
        });

        currentFollowingTags = currentFollowingTags.filter(tag => tag[1] !== pubkey);

        const contactListEvent = {
            kind: 3,
            tags: [...currentFollowingTags, ...currentRelayTags],
            content: '',
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(contactListEvent);
        const published = await publishEvent(signedEvent);

        // Record unfollow event for analytics (non-blocking)
        if (published) {
            recordChannelUnfollow(pubkey);
        }

        return published;
    } catch (error) {
        console.error('Failed to unfollow user:', error);
        return false;
    }
}

// Handle follow/unfollow button click
async function handleFollow(pubkey, isCurrentlyFollowing) {
    const button = event.target;
    button.disabled = true;
    button.textContent = t('status.processing');

    let success;
    if (isCurrentlyFollowing) {
        success = await unfollowUser(pubkey);
    } else {
        success = await followUser(pubkey);
    }

    if (success) {
        button.classList.toggle('following');
        button.textContent = isCurrentlyFollowing ? t('button.follow') : t('button.unfollow');
        button.setAttribute('onclick', `handleFollow('${pubkey}', ${!isCurrentlyFollowing})`);
    } else {
        button.textContent = isCurrentlyFollowing ? t('button.unfollow') : t('button.follow');
        showToast('Failed to update follow status. Please try again.', 'error');
    }

    button.disabled = false;
}

// ===== MUTE LIST MANAGEMENT (NIP-51 Kind 10000) =====

// Fetch user's mute list from relays
async function fetchMuteList() {
    if (!currentUser) {
        mutedUsersCache.clear();
        muteListLoaded = false;
        return;
    }

    const filter = {
        kinds: [10000],
        authors: [currentUser.pubkey],
        limit: 1
    };

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            mutedUsersCache.clear();
            const pTags = event.tags.filter(tag => tag[0] === 'p');
            pTags.forEach(tag => mutedUsersCache.add(tag[1]));
        }, resolve);
    });

    muteListLoaded = true;

    // Re-filter live chat messages if currently on live stream page
    if (currentView === 'live') {
        filterMutedChatMessages();
    }
}

// Re-filter chat messages to hide any from newly-identified muted users
function filterMutedChatMessages() {
    if (!currentUser || mutedUsersCache.size === 0) return;

    const container = document.getElementById('live-chat-messages');
    if (!container) return;

    // Find all chat messages from muted users that aren't already hidden
    mutedUsersCache.forEach(mutedPubkey => {
        if (sessionUnhiddenMutedUsers.has(mutedPubkey)) return;

        const messages = container.querySelectorAll(`.chat-message[data-pubkey="${mutedPubkey}"]:not(.muted-chat-message)`);
        messages.forEach(msgEl => {
            const eventId = msgEl.dataset.eventId;
            const timestamp = msgEl.dataset.timestamp;

            // Replace with placeholder
            const placeholderHTML = `
                <div class="chat-message muted-chat-message" data-event-id="${eventId}" data-pubkey="${mutedPubkey}" data-timestamp="${timestamp}">
                    <div class="chat-hidden-placeholder">
                        ${getMuteIconSVG(12)}
                        <span>Message from muted user</span>
                        <button class="chat-unhide-btn" onclick="unhideChatMessage('${eventId}', '${mutedPubkey}')">Show</button>
                    </div>
                </div>
            `;
            msgEl.outerHTML = placeholderHTML;
        });
    });
}

// Check if a user is muted
function isUserMuted(pubkey) {
    if (!currentUser || !muteListLoaded) return false;
    return mutedUsersCache.has(pubkey);
}

// Check if muted content should be shown (temporarily unhidden)
function shouldShowMutedContent(pubkey) {
    return sessionUnhiddenMutedUsers.has(pubkey);
}

// Temporarily unhide a muted user's content for this session
function unhideMutedUser(pubkey) {
    sessionUnhiddenMutedUsers.add(pubkey);
}

// Handle mute from live chat (wrapper to provide feedback)
async function handleChatMute(pubkey) {
    const success = await muteUser(pubkey);
    if (success) {
        showToast('User muted', 'success');
    } else {
        showToast('Failed to mute user', 'error');
    }
}

// Hide all comments and chat messages from a muted user immediately
function hideContentFromMutedUser(pubkey) {
    // Hide video comments from this user
    const comments = document.querySelectorAll(`.comment[data-pubkey="${pubkey}"]:not(.muted-comment-placeholder)`);
    comments.forEach(comment => {
        const depth = comment.dataset.depth || 0;
        const commentId = comment.dataset.commentId;
        const placeholderHTML = `
            <div class="muted-placeholder-content muted-comment">
                <span class="muted-icon-small">${getMuteIconSVG(14)}</span>
                <span>Comment from muted user hidden</span>
                <button class="unhide-muted-btn-small" onclick="unhideMutedComment('${commentId}', '${pubkey}')">
                    Show
                </button>
            </div>
        `;
        comment.className = 'comment muted-comment-placeholder';
        comment.dataset.commentId = commentId;
        comment.dataset.pubkey = pubkey;
        comment.dataset.depth = Math.min(depth, 3);
        comment.innerHTML = placeholderHTML;
    });

    // Hide live chat messages from this user
    const chatMessages = document.querySelectorAll(`.chat-message[data-pubkey="${pubkey}"]:not(.muted-chat-message)`);
    chatMessages.forEach(msg => {
        const eventId = msg.dataset.eventId;
        const timestamp = msg.dataset.timestamp;
        const placeholderHTML = `
            <div class="chat-hidden-placeholder">
                ${getMuteIconSVG(12)}
                <span>Message from muted user</span>
                <button class="chat-unhide-btn" onclick="unhideChatMessage('${eventId}', '${pubkey}')">Show</button>
            </div>
        `;
        msg.className = 'chat-message muted-chat-message';
        msg.dataset.eventId = eventId;
        msg.dataset.pubkey = pubkey;
        msg.dataset.timestamp = timestamp;
        msg.innerHTML = placeholderHTML;
    });
}

// Unhide a specific muted comment inline (without reloading all comments)
function unhideMutedComment(commentId, pubkey) {
    sessionUnhiddenMutedUsers.add(pubkey);
    showToast('Showing content from this user for this session', 'info');

    // Find the placeholder
    const placeholder = document.querySelector(`.muted-comment-placeholder[data-comment-id="${commentId}"]`);
    if (!placeholder) return;

    // Find the comment in currentCommentsState
    const comment = currentCommentsState.comments.find(c => c.id === commentId);
    if (comment) {
        // Get depth from placeholder
        const depth = parseInt(placeholder.dataset.depth || '0', 10);
        const commentWithDepth = { ...comment, depth, children: [] };

        // Create the comment element
        const commentElement = createCommentElement(
            commentWithDepth,
            profileCache,
            currentCommentsState.reactions,
            currentCommentsState.zaps
        );

        // Replace placeholder with the actual comment
        placeholder.replaceWith(commentElement);
    }
}

// Mute a user (add to mute list)
async function muteUser(pubkey) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to mute users', 'warning');
            return false;
        }
    }

    try {
        // Fetch current mute list (kind 10000)
        const muteFilter = {
            kinds: [10000],
            authors: [currentUser.pubkey],
            limit: 1
        };

        let currentMuteTags = [];

        await new Promise((resolve) => {
            requestEventsStream(muteFilter, (event) => {
                currentMuteTags = event.tags.filter(tag => tag[0] === 'p');
            }, resolve);
        });

        // Check if already muted
        if (!currentMuteTags.some(tag => tag[1] === pubkey)) {
            currentMuteTags.push(['p', pubkey]);
        } else {
            return true; // Already muted
        }

        // Create new mute list event
        const muteListEvent = {
            kind: 10000,
            tags: currentMuteTags,
            content: '',
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(muteListEvent);
        const published = await publishEvent(signedEvent);

        if (published) {
            mutedUsersCache.add(pubkey);
            // Remove from temporarily unhidden if present
            sessionUnhiddenMutedUsers.delete(pubkey);
            // Immediately hide comments and chat messages from this user
            hideContentFromMutedUser(pubkey);
        }

        return published;
    } catch (error) {
        console.error('Failed to mute user:', error);
        return false;
    }
}

// Unmute a user (remove from mute list)
async function unmuteUser(pubkey) {
    if (!currentUser) {
        showToast('Please login to unmute users', 'warning');
        return false;
    }

    try {
        // Fetch current mute list
        const muteFilter = {
            kinds: [10000],
            authors: [currentUser.pubkey],
            limit: 1
        };

        let currentMuteTags = [];

        await new Promise((resolve) => {
            requestEventsStream(muteFilter, (event) => {
                currentMuteTags = event.tags.filter(tag => tag[0] === 'p');
            }, resolve);
        });

        // Remove the pubkey
        currentMuteTags = currentMuteTags.filter(tag => tag[1] !== pubkey);

        // Create updated mute list event
        const muteListEvent = {
            kind: 10000,
            tags: currentMuteTags,
            content: '',
            created_at: Math.floor(Date.now() / 1000)
        };

        const signedEvent = await signEvent(muteListEvent);
        const published = await publishEvent(signedEvent);

        if (published) {
            mutedUsersCache.delete(pubkey);
            sessionUnhiddenMutedUsers.delete(pubkey);
        }

        return published;
    } catch (error) {
        console.error('Failed to unmute user:', error);
        return false;
    }
}

// Handle mute/unmute button click
async function handleMute(pubkey, isCurrentlyMuted) {
    const button = event.target.closest('.mute-btn, .profile-mute-btn, .channel-mute-btn, .comment-mute-btn');
    if (!button) return;

    button.disabled = true;
    const originalContent = button.innerHTML;
    button.innerHTML = '<span class="spinner-small"></span>';

    let success;
    if (isCurrentlyMuted) {
        success = await unmuteUser(pubkey);
    } else {
        success = await muteUser(pubkey);
    }

    if (success) {
        const newMutedState = !isCurrentlyMuted;
        button.classList.toggle('muted', newMutedState);

        // Update button content based on type
        if (button.classList.contains('comment-mute-btn')) {
            button.innerHTML = `${getMuteIconSVG(14)}<span>${newMutedState ? t('button.unmute') : t('button.mute')}</span>`;
            button.title = newMutedState ? 'Unmute user' : 'Mute user';
        } else {
            button.innerHTML = `${getMuteIconSVG()} ${newMutedState ? t('button.unmute') : t('button.mute')}`;
        }
        button.setAttribute('onclick', `handleMute('${pubkey}', ${newMutedState})`);

        // Show toast notification
        showToast(newMutedState ? 'User muted' : 'User unmuted', 'success');

        // If we just muted, reload the page to filter out their content
        if (newMutedState && (currentView.startsWith('home') || currentView === 'home')) {
            setTimeout(() => handleRoute(), 500);
        }
    } else {
        button.innerHTML = originalContent;
        showToast('Failed to update mute status. Please try again.', 'error');
    }

    button.disabled = false;
}

// ===== FOLLOWS-BASED REPORT WARNINGS (NIP-56) =====

// Minimum number of follows who must report for warning to show
const REPORT_WARNING_THRESHOLD = 5;

// Fetch user's follow list (kind 3)
async function fetchUserFollows() {
    if (!currentUser) {
        userFollowsCache.clear();
        userFollowsLoaded = false;
        return;
    }

    const filter = {
        kinds: [3],
        authors: [currentUser.pubkey],
        limit: 1
    };

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            userFollowsCache.clear();
            const pTags = event.tags.filter(tag => tag[0] === 'p');
            pTags.forEach(tag => userFollowsCache.add(tag[1]));
        }, resolve);
    });

    userFollowsLoaded = true;
}

// Fetch reports for a specific event (video/comment)
async function fetchReportsForEvent(eventId) {
    // Return empty set for null/undefined eventId
    if (!eventId) {
        return new Set();
    }

    if (reportsCache.loadedEvents.has(eventId)) {
        return reportsCache.eventReports.get(eventId) || new Set();
    }

    const filter = {
        kinds: [1984],
        '#e': [eventId]
    };

    const reporters = new Set();

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            reporters.add(event.pubkey);
        }, resolve);
    });

    reportsCache.eventReports.set(eventId, reporters);
    reportsCache.loadedEvents.add(eventId);

    return reporters;
}

// Fetch reports for a specific pubkey (user)
async function fetchReportsForPubkey(pubkey) {
    if (reportsCache.loadedPubkeys.has(pubkey)) {
        return reportsCache.pubkeyReports.get(pubkey) || new Set();
    }

    const filter = {
        kinds: [1984],
        '#p': [pubkey]
    };

    const reporters = new Set();

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            // Only count reports that specifically target this pubkey (not just mentions)
            const pTags = event.tags.filter(t => t[0] === 'p' && t[1] === pubkey);
            if (pTags.length > 0) {
                reporters.add(event.pubkey);
            }
        }, resolve);
    });

    reportsCache.pubkeyReports.set(pubkey, reporters);
    reportsCache.loadedPubkeys.add(pubkey);

    return reporters;
}

// Check if event has been reported by enough follows to trigger warning
async function isReportedByFollows(eventId, authorPubkey = null) {
    if (!currentUser || !userSettings.showFollowsReportWarnings) {
        return false;
    }

    // Ensure follows are loaded
    if (!userFollowsLoaded) {
        await fetchUserFollows();
    }

    if (userFollowsCache.size === 0) {
        return false;
    }

    let followsWhoReported = 0;

    // Check event reports only if eventId is provided
    if (eventId) {
        const eventReporters = await fetchReportsForEvent(eventId);
        for (const reporter of eventReporters) {
            if (userFollowsCache.has(reporter)) {
                followsWhoReported++;
                if (followsWhoReported >= REPORT_WARNING_THRESHOLD) {
                    return true;
                }
            }
        }
    }

    // Also check author reports if provided
    if (authorPubkey) {
        const authorReporters = await fetchReportsForPubkey(authorPubkey);
        for (const reporter of authorReporters) {
            if (userFollowsCache.has(reporter)) {
                followsWhoReported++;
                if (followsWhoReported >= REPORT_WARNING_THRESHOLD) {
                    return true;
                }
            }
        }
    }

    return false;
}

// Synchronous check using cached data (for render-time checks)
function isReportedByFollowsSync(eventId, authorPubkey = null) {
    if (!currentUser || !userSettings.showFollowsReportWarnings || !userFollowsLoaded) {
        return false;
    }

    if (userFollowsCache.size === 0) {
        return false;
    }

    let followsWhoReported = 0;

    // Check event reports from cache only if eventId is provided
    if (eventId) {
        const eventReporters = reportsCache.eventReports.get(eventId);
        if (eventReporters) {
            for (const reporter of eventReporters) {
                if (userFollowsCache.has(reporter)) {
                    followsWhoReported++;
                    if (followsWhoReported >= REPORT_WARNING_THRESHOLD) {
                        return true;
                    }
                }
            }
        }
    }

    // Check author reports from cache
    if (authorPubkey) {
        const authorReporters = reportsCache.pubkeyReports.get(authorPubkey);
        if (authorReporters) {
            for (const reporter of authorReporters) {
                if (userFollowsCache.has(reporter)) {
                    followsWhoReported++;
                    if (followsWhoReported >= REPORT_WARNING_THRESHOLD) {
                        return true;
                    }
                }
            }
        }
    }

    return false;
}

// Batch fetch reports for multiple events (for efficiency)
async function fetchReportsForEvents(eventIds) {
    const unfetchedIds = eventIds.filter(id => !reportsCache.loadedEvents.has(id));

    if (unfetchedIds.length === 0) return;

    const filter = {
        kinds: [1984],
        '#e': unfetchedIds
    };

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            const eTags = event.tags.filter(t => t[0] === 'e');
            eTags.forEach(tag => {
                const eventId = tag[1];
                if (!reportsCache.eventReports.has(eventId)) {
                    reportsCache.eventReports.set(eventId, new Set());
                }
                reportsCache.eventReports.get(eventId).add(event.pubkey);
            });
        }, resolve);
    });

    // Mark all as loaded
    unfetchedIds.forEach(id => reportsCache.loadedEvents.add(id));
}

// Batch fetch reports for multiple pubkeys (for efficiency)
async function fetchReportsForPubkeys(pubkeys) {
    const unfetchedPubkeys = pubkeys.filter(pk => !reportsCache.loadedPubkeys.has(pk));

    if (unfetchedPubkeys.length === 0) return;

    const filter = {
        kinds: [1984],
        '#p': unfetchedPubkeys
    };

    await new Promise((resolve) => {
        requestEventsStream(filter, (event) => {
            const pTags = event.tags.filter(t => t[0] === 'p');
            pTags.forEach(tag => {
                const pubkey = tag[1];
                if (!reportsCache.pubkeyReports.has(pubkey)) {
                    reportsCache.pubkeyReports.set(pubkey, new Set());
                }
                reportsCache.pubkeyReports.get(pubkey).add(event.pubkey);
            });
        }, resolve);
    });

    // Mark all as loaded
    unfetchedPubkeys.forEach(pk => reportsCache.loadedPubkeys.add(pk));
}

// Get mute icon SVG
function getMuteIconSVG(size = 16) {
    return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z"/>
    </svg>`;
}

// Check if content from a pubkey should be completely hidden (muted and not temporarily shown)
function shouldHideMutedContent(pubkey) {
    if (!currentUser || !muteListLoaded) return false;
    return isUserMuted(pubkey) && !shouldShowMutedContent(pubkey);
}

// Create hidden content placeholder for muted users
function createMutedContentPlaceholder(pubkey, type = 'video', eventId = null) {
    const profile = profileCache.get(pubkey);
    const displayName = profile?.name || profile?.display_name || `User ${pubkey.slice(0, 8)}`;

    if (type === 'video') {
        return `
            <div class="video-card muted-content-placeholder" data-pubkey="${pubkey}" data-event-id="${eventId || ''}">
                <div class="muted-placeholder-content">
                    <div class="muted-icon">${getMuteIconSVG(32)}</div>
                    <p>Content from <strong>${escapeHtml(displayName)}</strong> is hidden</p>
                    <button class="unhide-muted-btn" onclick="handleUnhideMutedContent('${pubkey}', 'video', '${eventId || ''}')">
                        Show anyway
                    </button>
                </div>
            </div>
        `;
    } else if (type === 'comment') {
        return `
            <div class="comment muted-comment-placeholder" data-pubkey="${pubkey}">
                <div class="muted-placeholder-content muted-comment">
                    <span class="muted-icon-small">${getMuteIconSVG(14)}</span>
                    <span>Comment from muted user hidden</span>
                    <button class="unhide-muted-btn-small" onclick="handleUnhideMutedContent('${pubkey}', 'comment')">
                        Show
                    </button>
                </div>
            </div>
        `;
    }
    return '';
}

// Handle unhide muted content button click
function handleUnhideMutedContent(pubkey, type, eventId = null) {
    unhideMutedUser(pubkey);
    showToast('Showing content from this user for this session', 'info');

    // Replace placeholders in-place instead of reloading
    if (type === 'video') {
        // Find all video placeholders for this pubkey and replace with actual content
        const placeholders = document.querySelectorAll(`.muted-content-placeholder[data-pubkey="${pubkey}"]`);
        let replacedCount = 0;

        placeholders.forEach(placeholder => {
            const placeholderEventId = placeholder.dataset.eventId || eventId;
            if (placeholderEventId) {
                const event = allEvents.get(placeholderEventId);
                if (event) {
                    const profile = profileCache.get(event.pubkey);
                    const reactions = reactionsCache.get(event.id);
                    const cardHTML = createVideoCard(event, profile, reactions, false, null, true);

                    if (cardHTML) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = cardHTML;
                        if (tempDiv.firstElementChild) {
                            placeholder.replaceWith(tempDiv.firstElementChild);
                            replacedCount++;
                            observeLazyCards();
                        }
                    }
                }
            }
        });

        // If we couldn't replace any (missing event data), fall back to reload
        if (placeholders.length > 0 && replacedCount === 0) {
            handleRoute();
        }
    } else if (type === 'comment') {
        // For comments, reload just the comments section
        const commentsContainer = document.getElementById('comments-container');
        if (commentsContainer) {
            // Get the video event ID from the current URL
            const hash = window.location.hash;
            const videoMatch = hash.match(/#\/video\/([a-f0-9]+)/);
            if (videoMatch) {
                commentsContainer.innerHTML = '<div class="spinner"></div>';
                loadComments([videoMatch[1]]);
            }
        }
    } else if (type === 'chat') {
        // For live chat, find muted messages from this user and re-render them
        const chatContainer = document.getElementById('liveChatMessages');
        if (chatContainer && currentLiveChat?.messages) {
            const mutedMessages = chatContainer.querySelectorAll(`.muted-chat-message[data-pubkey="${pubkey}"]`);
            mutedMessages.forEach(placeholder => {
                const eventId = placeholder.dataset.eventId;
                const event = currentLiveChat.messages.find(m => m.id === eventId);
                if (event) {
                    // Re-render the chat message
                    placeholder.remove();
                    renderChatMessage(event, chatContainer);
                }
            });
        }
    }
}

// Load user profile page
async function loadProfile(pubkey) {
    currentView = `profile-${pubkey}`;

    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = '<div class="spinner"></div>';

    try {
        const profile = await fetchUserProfile(pubkey);
        const displayName = profile?.name || profile?.display_name || `User ${pubkey.slice(0, 8)}`;
        const avatarUrl = profile?.picture || profile?.avatar || '';
        const nip05 = profile?.nip05 || '';
        const about = profile?.about || '';
        const website = profile?.website || '';

        const npub = window.NostrTools.nip19.npubEncode(pubkey);

        const isFollowingPromise = isFollowing(pubkey);
        const isOwnProfile = currentUser && currentUser.pubkey === pubkey;

        const cardsPerRow = getCardsPerRow();
        const skeletonCount = cardsPerRow * 10; // 10 rows of skeletons
        const skeletons = Array(skeletonCount).fill(createSkeletonCard()).join('');

        // Format website URL for display
        const websiteDisplay = website ? website.replace(/^https?:\/\//, '').replace(/\/$/, '') : '';
        const websiteHref = website && !website.startsWith('http') ? `https://${website}` : website;

        mainContent.innerHTML = `
            <div class="profile-header">
                <div class="profile-avatar">
                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                </div>
                <div class="profile-info">
                    <h1 class="profile-name">${displayName}</h1>
                    ${nip05 ? `<div class="profile-nip05">${nip05}</div>` : ''}
                    <div class="profile-stats" id="profile-stats-${pubkey}">
                        <span class="profile-stat loading">
                            <span class="stat-value">-</span> videos
                        </span>
                        <span class="profile-stat-separator">•</span>
                        <span class="profile-stat loading">
                            <span class="stat-value">-</span> followers
                        </span>
                    </div>
                    ${website ? `
                        <div class="profile-website">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                            </svg>
                            <a href="${websiteHref}" target="_blank" rel="noopener noreferrer">${websiteDisplay}</a>
                        </div>
                    ` : ''}
                    ${about ? `
                        <div class="profile-bio-container">
                            <div id="profile-bio" class="profile-bio ${about.length > 300 ? 'collapsed' : ''}">
                                <p style="white-space: pre-wrap; margin: 0;">${processTextWithLinks(about)}</p>
                            </div>
                            ${about.length > 300 ? `
                                <button id="bio-toggle" class="bio-toggle-btn" onclick="toggleBio()">
                                    Show More
                                </button>
                            ` : ''}
                        </div>
                    ` : ''}
                </div>
                <div class="profile-actions" id="profile-actions-${pubkey}">
                    ${isOwnProfile ? `
                        <button class="profile-edit-btn" onclick="showEditProfileModal()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                            </svg>
                            Edit
                        </button>
                    ` : ''}
                    <button class="profile-zap-btn ${isOwnProfile ? 'self-content' : ''}"
                            onclick="${isOwnProfile ? '' : `handleZap('${npub}', 1000)`}"
                            ${isOwnProfile ? `title="${t('zap.cannotZapYourself')}"` : ''}>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                        </svg>
                        Zap
                    </button>
                </div>
            </div>
            <!-- Shorts Section -->
            <div id="profileShortsSection" style="display: none; margin-bottom: 2rem;">
                <h2 style="margin-bottom: 1rem;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                        <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                        <path d="M10 8l6 4-6 4V8z"/>
                    </svg>
                    Shorts
                </h2>
                <div class="shorts-grid" id="profileShortsGrid"></div>
            </div>
            <!-- Videos Section -->
            <h2 style="margin-bottom: 1.5rem;">Videos</h2>
            <div class="video-grid" id="profileVideoGrid">
                ${skeletons}
            </div>
        `;

        // Check if profile is reported by follows (async, show banner after load)
        if (!isOwnProfile && currentUser && userSettings.showFollowsReportWarnings) {
            isReportedByFollows(null, pubkey).then(isReported => {
                if (isReported && !sessionRatioedAllowed.has(pubkey)) {
                    const profileHeader = document.querySelector('.profile-header');
                    if (profileHeader) {
                        const warningBanner = document.createElement('div');
                        warningBanner.className = 'profile-warning-banner';
                        warningBanner.style.cssText = 'background: rgba(255, 152, 0, 0.15); border: 1px solid #ff9800; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.75rem;';
                        warningBanner.innerHTML = `
                            <span style="color: #ff9800; font-size: 1.5rem;">⚠</span>
                            <div style="flex: 1;">
                                <strong style="color: #ff9800;">Community Warning</strong>
                                <p style="margin: 0.25rem 0 0 0; font-size: 0.875rem; color: var(--text-secondary);">
                                    This user has been reported by multiple people you follow.
                                </p>
                            </div>
                            <button onclick="this.parentElement.remove(); sessionRatioedAllowed.add('${pubkey}');"
                                    style="background: none; border: 1px solid var(--text-secondary); color: var(--text-primary); padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">
                                Dismiss
                            </button>
                        `;
                        profileHeader.parentElement.insertBefore(warningBanner, profileHeader);
                    }
                }
            });
        }

        // Validate NIP-05 and add checkmark if valid
        if (nip05) {
            // Check cache first
            if (profileValidationCache.has(pubkey)) {
                const cached = profileValidationCache.get(pubkey);
                if (cached.nip05Valid) {
                    const profileNip05 = document.querySelector('.profile-nip05');
                    applyNip05Checkmark(profileNip05, true, 16);
                }
            } else {
                // Validate and cache
                validateNip05(nip05, pubkey).then(isValid => {
                    if (isValid) {
                        const profileNip05 = document.querySelector('.profile-nip05');
                        applyNip05Checkmark(profileNip05, true, 16);
                    }
                    // Update or create cache entry
                    if (!profileValidationCache.has(pubkey)) {
                        const avatarValid = avatarUrl ? true : false; // Simplified for profile page
                        profileValidationCache.set(pubkey, {
                            isSuspicious: !avatarValid || !isValid,
                            avatarValid,
                            nip05Valid: isValid
                        });
                    }
                });
            }
        }

        // Defer profile stats loading to not block video grid loading
        setTimeout(() => {
            getAuthorStats(pubkey).then(stats => {
                const statsEl = document.getElementById(`profile-stats-${pubkey}`);
                if (statsEl) {
                    const videoCountEl = statsEl.querySelector('.profile-stat:first-child');
                    const followerCountEl = statsEl.querySelector('.profile-stat:last-child');

                    if (videoCountEl) {
                        videoCountEl.classList.remove('loading');
                        videoCountEl.innerHTML = `<span class="stat-value">${formatNumber(stats.videoCount)}</span> video${stats.videoCount !== 1 ? 's' : ''}`;
                    }
                    if (followerCountEl) {
                        followerCountEl.classList.remove('loading');
                        followerCountEl.innerHTML = `<span class="stat-value">${formatNumber(stats.followerCount)}</span> follower${stats.followerCount !== 1 ? 's' : ''}`;
                    }
                }
            }).catch(error => {
                console.error('Failed to load profile stats:', error);
                const statsEl = document.getElementById(`profile-stats-${pubkey}`);
                if (statsEl) {
                    statsEl.querySelectorAll('.profile-stat.loading').forEach(el => {
                        el.classList.remove('loading');
                    });
                }
            });
        }, 1000); // Wait 1 second for videos to start loading first

        isFollowingPromise.then(isFollowingUser => {
            const actionsDiv = document.getElementById(`profile-actions-${pubkey}`);
            if (actionsDiv && !isOwnProfile && currentUser) {
                // Add follow button
                const followBtn = document.createElement('button');
                followBtn.className = `profile-follow-btn ${isFollowingUser ? 'following' : ''}`;
                followBtn.onclick = () => handleFollow(pubkey, isFollowingUser);
                followBtn.textContent = isFollowingUser ? t('button.unfollow') : t('button.follow');
                actionsDiv.insertBefore(followBtn, actionsDiv.firstChild);

                // Add mute button
                const isMuted = isUserMuted(pubkey);
                const muteBtn = document.createElement('button');
                muteBtn.className = `profile-mute-btn ${isMuted ? 'muted' : ''}`;
                muteBtn.onclick = () => handleMute(pubkey, isMuted);
                muteBtn.innerHTML = `${getMuteIconSVG()} ${isMuted ? t('button.unmute') : t('button.mute')}`;
                muteBtn.title = isMuted ? 'Unmute this user' : 'Mute this user';
                actionsDiv.insertBefore(muteBtn, followBtn.nextSibling);

                // Add report button
                const reportBtn = document.createElement('button');
                reportBtn.className = 'profile-report-btn';
                reportBtn.onclick = () => showReportModal(null, pubkey, 'user');
                reportBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"/></svg> Report`;
                reportBtn.title = 'Report this user';
                actionsDiv.insertBefore(reportBtn, muteBtn.nextSibling);
            }
        });

        const filter = {
            kinds: ALL_VIDEO_KINDS,
            authors: [pubkey],
            '#t': ['pv69420']
        };

        const videoGrid = document.getElementById('profileVideoGrid');
        const shortsGrid = document.getElementById('profileShortsGrid');
        const shortsSection = document.getElementById('profileShortsSection');
        const videoEvents = [];
        const shortEvents = [];
        const reactionQueue = new Set();
        let reactionTimer = null;

        await requestEventsStream(filter, (event) => {
            const tags = event.tags || [];
            if (!tags.some(tag => tag[0] === 'x')) return;

            allEvents.set(event.id, event);

            // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
            if (shouldSkipLegacyEvent(event)) return;

            // Separate shorts from regular videos
            const isShort = isNip71ShortKind(event.kind);
            const targetGrid = isShort ? shortsGrid : videoGrid;
            const targetEvents = isShort ? shortEvents : videoEvents;

            targetEvents.push(event);

            // Show shorts section if we have shorts
            if (isShort && shortsSection) {
                shortsSection.style.display = 'block';
            }

            // Remove skeleton cards on first video
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            const cachedReactions = reactionsCache.get(event.id);
            const cardHTML = isShort
                ? createShortCard(event, profile, cachedReactions)
                : createVideoCard(event, profile, cachedReactions);

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHTML;

            if (tempDiv.firstElementChild) {
                let inserted = false;
                const existingCards = targetGrid.querySelectorAll('.video-card, .short-card');

                for (let i = 0; i < existingCards.length; i++) {
                    const cardEvent = targetEvents.find(e =>
                        existingCards[i].innerHTML.includes(e.id)
                    );
                    if (cardEvent && event.created_at > cardEvent.created_at) {
                        existingCards[i].parentNode.insertBefore(tempDiv.firstElementChild, existingCards[i]);
                        inserted = true;
                        break;
                    }
                }

                if (!inserted) {
                    targetGrid.appendChild(tempDiv.firstElementChild);
                }

                // Observe new card for lazy loading
                observeLazyCards();
            }

            reactionQueue.add(event.id);
            clearTimeout(reactionTimer);
            reactionTimer = setTimeout(async () => {
                if (reactionQueue.size > 0) {
                    const videoIds = Array.from(reactionQueue);
                    reactionQueue.clear();

                    await loadReactionsForVideos(videoIds, (videoId, reactions) => {
                        // Use in-place update to prevent image flickering
                        updateVideoCardInPlace(videoId, profile, reactions);
                    });
                }
            }, 200);

        }, () => {
            if (videoEvents.length === 0) {
                videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">${t('empty.noUploadedVideos')}</p>`;
            }
        });

    } catch (error) {
        console.error('Failed to load profile:', error);
        mainContent.innerHTML = `<div class="error-message">${t('empty.failedLoadProfile')}</div>`;
    }
}

// Search videos
async function searchVideos() {
    const query = document.getElementById('searchInput').value.trim();
    if (!query) return;

    navigateTo(`/search/${encodeURIComponent(query)}`);
}

async function performSearch(query) {
    const decodedQuery = decodeURIComponent(query).toLowerCase();
    currentView = `search-${decodedQuery}`;

    const mainContent = document.getElementById('mainContent');
    const cardsPerRow = getCardsPerRow();
    const videoSkeletonCount = cardsPerRow * 10; // 10 rows of video skeletons
    const videoSkeletons = Array(videoSkeletonCount).fill(createSkeletonCard()).join('');

    mainContent.innerHTML = `
        <h2 style="margin-bottom: 1.5rem;">Search Results for "${decodedQuery}"</h2>
        <!-- Shorts Section -->
        <div id="searchShortsSection" style="display: none; margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1rem;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                    <rect x="6" y="2" width="12" height="20" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="2"/>
                    <path d="M10 8l6 4-6 4V8z"/>
                </svg>
                Shorts
            </h3>
            <div class="shorts-grid" id="searchShortsGrid"></div>
            <div class="view-more-container" id="searchShortsViewMore" style="display: none;">
                <button class="action-btn view-more-btn" onclick="expandSection('searchShorts')">View More</button>
            </div>
        </div>
        <!-- Videos Section -->
        <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 0.5rem;">
                <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
            </svg>
            Videos
        </h3>
        <div class="video-grid" id="videoGrid">
            ${videoSkeletons}
        </div>
        <!-- Users Section -->
        <div id="usersSection" style="display: none; margin-top: 2rem;">
            <hr class="section-divider" style="margin-bottom: 1.5rem;">
            <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">Users</h3>
            <div class="user-results-grid" id="userResultsGrid"></div>
            <div id="viewMoreUsersSearchContainer" style="display: none; text-align: center; margin-top: 1rem; margin-bottom: 1rem;">
                <button id="viewMoreUsersSearchBtn" class="action-btn view-more-btn">
                    View More
                </button>
            </div>
        </div>
    `;

    const videoGrid = document.getElementById('videoGrid');
    const shortsGrid = document.getElementById('searchShortsGrid');
    const shortsSection = document.getElementById('searchShortsSection');
    const shortsViewMore = document.getElementById('searchShortsViewMore');
    const maxInitialShorts = getShortsCardsPerRow();
    const userResultsGrid = document.getElementById('userResultsGrid');
    const usersSection = document.getElementById('usersSection');

    // Reset cached search shorts
    cachedSearchShorts = [];
    sectionExpanded.searchShorts = false;
    const viewMoreUsersContainer = document.getElementById('viewMoreUsersSearchContainer');
    const viewMoreUsersBtn = document.getElementById('viewMoreUsersSearchBtn');
    const renderedVideos = new Map();
    const renderedShorts = new Map();
    const videoEvents = [];
    const shortEvents = [];
    const profileQueue = new Set();
    const reactionQueue = new Set();
    let profileTimer = null;
    let reactionTimer = null;
    let shortsRenderedCount = 0;

    // Store all matching users for "View More" functionality
    const allMatchingUsers = [];
    let showingAllUsers = false;

    // Track rendered user pubkeys to avoid re-rendering
    const renderedSearchUserPubkeys = new Set();

    // Calculate dynamic user limit based on grid width (show 1 row for search)
    const calculateUserLimit = () => {
        const gridWidth = userResultsGrid.offsetWidth || document.querySelector('.main-content')?.offsetWidth || 800;
        const minCardWidth = window.innerWidth <= 768 ? 280 : 300; // user-search-card min width
        const gap = 16; // 1rem gap
        const cardsPerRow = Math.floor((gridWidth + gap) / (minCardWidth + gap)) || 1;
        return Math.max(cardsPerRow, 3); // Show at least 3 users, or 1 full row
    };

    let INITIAL_USER_LIMIT = calculateUserLimit();

    // Helper to escape special regex characters
    const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    // Check if a user profile matches the search query
    const profileMatchesSearch = (profile, pubkey) => {
        const queryWords = decodedQuery.split(/\s+/).filter(w => w.length > 0);
        const name = (profile.name || '').toLowerCase();
        const displayName = (profile.display_name || '').toLowerCase();
        const nip05 = (profile.nip05 || '').toLowerCase();
        const about = (profile.about || '').toLowerCase();
        const pubkeyLower = pubkey.toLowerCase();

        // Check if any query word matches any of the profile fields
        return queryWords.every(word => {
            const wordLower = word.toLowerCase();
            return name.includes(wordLower) ||
                   displayName.includes(wordLower) ||
                   nip05.includes(wordLower) ||
                   about.includes(wordLower) ||
                   pubkeyLower.includes(wordLower);
        });
    };

    // Create a user card for search results
    const createUserSearchCard = (pubkey, profile) => {
        const displayName = profile?.name || profile?.display_name || `User ${pubkey.slice(0, 8)}`;
        const avatarUrl = profile?.picture || profile?.avatar || '';
        const nip05 = profile?.nip05 || '';
        const about = profile?.about || '';
        const truncatedAbout = about.length > 100 ? about.slice(0, 100) + '...' : about;

        return `
            <a href="#/profile/${pubkey}" class="user-search-card">
                <div class="user-search-avatar">
                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}" onerror="this.style.display='none'">` : ''}
                </div>
                <div class="user-search-info">
                    <div class="user-search-name">${displayName}</div>
                    ${nip05 ? `<div class="user-search-nip05">${nip05}</div>` : ''}
                    ${truncatedAbout ? `<div class="user-search-about">${truncatedAbout}</div>` : ''}
                </div>
            </a>
        `;
    };

    // Display users with limit (only renders new users, doesn't replace existing)
    const displayMatchingUsers = (limit = null) => {
        if (allMatchingUsers.length === 0) {
            usersSection.style.display = 'none';
            return;
        }

        usersSection.style.display = 'block';
        const usersToShow = limit ? allMatchingUsers.slice(0, limit) : allMatchingUsers;

        // Only render users that haven't been rendered yet
        const newUsers = usersToShow.filter(user => !renderedSearchUserPubkeys.has(user.pubkey));

        if (newUsers.length > 0) {
            const cardsHTML = newUsers.map(user => {
                renderedSearchUserPubkeys.add(user.pubkey);
                return createUserSearchCard(user.pubkey, user.profile);
            }).join('');
            userResultsGrid.insertAdjacentHTML('beforeend', cardsHTML);
        }

        // Show/hide "View More" button
        if (limit && allMatchingUsers.length > limit) {
            viewMoreUsersContainer.style.display = 'block';
            viewMoreUsersBtn.textContent = `View More (${allMatchingUsers.length - limit} more)`;
        } else {
            viewMoreUsersContainer.style.display = 'none';
        }
    };

    // Expand users to show all (appends new users without re-rendering existing)
    const expandSearchUsers = () => {
        const currentCount = renderedSearchUserPubkeys.size;
        const usersToAdd = allMatchingUsers.slice(currentCount);

        if (usersToAdd.length > 0) {
            const cardsHTML = usersToAdd.map(user => {
                renderedSearchUserPubkeys.add(user.pubkey);
                return createUserSearchCard(user.pubkey, user.profile);
            }).join('');
            userResultsGrid.insertAdjacentHTML('beforeend', cardsHTML);
        }

        viewMoreUsersContainer.style.display = 'none';
    };

    // View More button handler - append new users without re-rendering
    viewMoreUsersBtn.addEventListener('click', () => {
        showingAllUsers = true;
        expandSearchUsers();
    });

    const matchesSearch = (event) => {
        // Parse both kind 1 and NIP-71 events
        let videoData;
        if (isNip71Kind(event.kind)) {
            videoData = parseNip71VideoEvent(event);
        } else {
            videoData = parseVideoEvent(event);
        }
        if (!videoData) return false;

        // Split query into words for matching
        const queryWords = decodedQuery.split(/\s+/).filter(w => w.length > 0);

        // Combine all searchable text (title, description, tags)
        const tagsText = (videoData.tags || []).join(' ');
        const searchText = `${videoData.title || ''} ${videoData.description || ''} ${tagsText}`.toLowerCase();

        // All query words must match at word boundaries (start of words)
        // e.g., "bitcoin" matches "bitcoin", "bitcoiner", "bitcoiners"
        // but "coin" does NOT match "bitcoin" (only matches "coin", "coins", etc.)
        return queryWords.every(word => {
            const wordRegex = new RegExp(`\\b${escapeRegex(word)}`, 'i');
            return wordRegex.test(searchText);
        });
    };

    const updateVideoCard = (event, profile, reactions) => {
        // Use in-place update to prevent image flickering
        updateVideoCardInPlace(event.id, profile, reactions);
    };

    const renderVideoCard = (event, profile = null, reactions = null) => {
        const cardId = `video-card-${event.id}`;

        if (document.getElementById(cardId)) {
            // Use in-place update to prevent image flickering
            updateVideoCardInPlace(event.id, profile, reactions);
            return;
        }

        // Remove skeleton cards on first video
        const skeletons = videoGrid.querySelectorAll('.skeleton-card');
        if (skeletons.length > 0) {
            skeletons.forEach(s => s.remove());
        }

        const cardHTML = createVideoCard(event, profile, reactions);
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = cardHTML;

        if (!tempDiv.firstElementChild) return;

        tempDiv.firstElementChild.id = cardId;

        let inserted = false;
        const cards = videoGrid.querySelectorAll('.video-card');

        for (let i = 0; i < cards.length; i++) {
            const cardEventId = cards[i].id.replace('video-card-', '');
            const cardEvent = renderedVideos.get(cardEventId);
            if (cardEvent && event.created_at > cardEvent.created_at) {
                cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                inserted = true;
                break;
            }
        }

        if (!inserted) {
            videoGrid.appendChild(tempDiv.firstElementChild);
        }

        renderedVideos.set(event.id, event);

        // Observe new card for lazy loading
        observeLazyCards();
    };

    const renderShortCard = (event, profile = null, reactions = null) => {
        const cardId = `video-card-${event.id}`;

        if (document.getElementById(cardId)) {
            // Use in-place update to prevent image flickering
            updateVideoCardInPlace(event.id, profile, reactions);
            return;
        }

        // Only render up to maxInitialShorts initially
        if (shortsRenderedCount >= maxInitialShorts) {
            return;
        }

        // Show shorts section
        shortsSection.style.display = 'block';

        const cardHTML = createShortCard(event, profile, reactions);
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = cardHTML;

        if (!tempDiv.firstElementChild) return;

        tempDiv.firstElementChild.id = cardId;

        let inserted = false;
        const cards = shortsGrid.querySelectorAll('.short-card');

        for (let i = 0; i < cards.length; i++) {
            const cardEventId = cards[i].id.replace('video-card-', '');
            const cardEvent = renderedShorts.get(cardEventId);
            if (cardEvent && event.created_at > cardEvent.created_at) {
                cards[i].parentNode.insertBefore(tempDiv.firstElementChild, cards[i]);
                inserted = true;
                break;
            }
        }

        if (!inserted) {
            shortsGrid.appendChild(tempDiv.firstElementChild);
        }

        renderedShorts.set(event.id, event);
        shortsRenderedCount++;

        // Observe new card for lazy loading
        observeLazyCards();
    };

    const loadProfilesBatch = async () => {
        if (profileQueue.size === 0) return;

        const pubkeys = Array.from(profileQueue);
        profileQueue.clear();

        // Chunk profiles into batches to prevent relay limits
        const PROFILE_BATCH_SIZE = 25;
        const chunks = [];
        for (let i = 0; i < pubkeys.length; i += PROFILE_BATCH_SIZE) {
            chunks.push(pubkeys.slice(i, i + PROFILE_BATCH_SIZE));
        }

        // Process all chunks in parallel
        await Promise.all(chunks.map(async (chunk) => {
            const filter = {
                kinds: [0],
                authors: chunk
            };

            await requestEventsStream(filter, (profileEvent) => {
                try {
                    const profile = JSON.parse(profileEvent.content);
                    profileCache.set(profileEvent.pubkey, profile);

                    // Update video cards
                    videoEvents.forEach(event => {
                        if (event.pubkey === profileEvent.pubkey) {
                            const reactions = reactionsCache.get(event.id);
                            updateVideoCard(event, profile, reactions);
                        }
                    });

                    // Update short cards
                    shortEvents.forEach(event => {
                        if (event.pubkey === profileEvent.pubkey) {
                            const reactions = reactionsCache.get(event.id);
                            updateVideoCardInPlace(event.id, profile, reactions);
                        }
                    });
                } catch (e) {
                    console.error('Failed to parse profile:', e);
                }
            });
        }));
    };

    const loadReactionsBatch = async () => {
        if (reactionQueue.size === 0) return;

        const videoIds = Array.from(reactionQueue);
        reactionQueue.clear();

        await loadReactionsForVideos(videoIds, (videoId, reactions) => {
            // Check videos
            const videoEvent = videoEvents.find(e => e.id === videoId);
            if (videoEvent) {
                const profile = profileCache.get(videoEvent.pubkey);
                updateVideoCard(videoEvent, profile, reactions);
                return;
            }

            // Check shorts
            const shortEvent = shortEvents.find(e => e.id === videoId);
            if (shortEvent) {
                const profile = profileCache.get(shortEvent.pubkey);
                updateVideoCardInPlace(shortEvent.id, profile, reactions);
            }
        });
    };

    // Search for user profiles using NIP-50 search (kind 0)
    // Use the original query for search, not lowercased
    const originalQuery = decodeURIComponent(query);
    const userFilter = {
        kinds: [0],
        search: originalQuery,
        limit: 50
    };

    const seenPubkeys = new Set();

    // Fetch user profiles using NIP-50 search
    const userSearchPromise = requestEventsStream(userFilter, (profileEvent) => {
        try {
            if (seenPubkeys.has(profileEvent.pubkey)) return;
            seenPubkeys.add(profileEvent.pubkey);

            const profile = JSON.parse(profileEvent.content);
            profileCache.set(profileEvent.pubkey, profile);

            // Double-check profile matches (relay search may be fuzzy)
            if (profileMatchesSearch(profile, profileEvent.pubkey)) {
                allMatchingUsers.push({ pubkey: profileEvent.pubkey, profile });
                // Update display with limit
                displayMatchingUsers(showingAllUsers ? null : INITIAL_USER_LIMIT);
            }
        } catch (e) {
            // Ignore invalid profile JSON
        }
    }, () => {
        // Final display update when search completes
        displayMatchingUsers(showingAllUsers ? null : INITIAL_USER_LIMIT);
    });

    const filter = {
        kinds: [...ALL_VIDEO_KINDS, NIP53_LIVE_EVENT_KIND],
        '#t': ['pv69420'],
        limit: 200
    };

    // Store live stream data for rendering
    const liveStreamData = new Map();

    // Check if live stream matches search
    const liveStreamMatchesSearch = (event, liveData) => {
        if (!liveData) return false;
        const queryWords = decodedQuery.split(/\s+/).filter(w => w.length > 0);
        const tagsText = (liveData.tags || []).join(' ');
        const searchText = `${liveData.title || ''} ${liveData.summary || ''} ${tagsText}`.toLowerCase();
        return queryWords.every(word => {
            const wordRegex = new RegExp(`\\b${escapeRegex(word)}`, 'i');
            return wordRegex.test(searchText);
        });
    };

    await requestEventsStream(filter, (event) => {
        const tags = event.tags || [];

        // Handle live streams separately
        if (event.kind === NIP53_LIVE_EVENT_KIND) {
            const liveData = parseLiveEvent(event);
            if (!liveData || !isLiveStreamActive(liveData)) return;
            if (!liveStreamMatchesSearch(event, liveData)) return;

            if (videoEvents.some(e => e.id === event.id)) return;

            allEvents.set(event.id, event);
            liveStreamData.set(event.id, liveData);
            videoEvents.push(event);

            const spinner = videoGrid.querySelector('.spinner');
            if (spinner) spinner.remove();

            // Remove skeleton cards
            const skeletons = videoGrid.querySelectorAll('.skeleton-card');
            if (skeletons.length > 0) {
                skeletons.forEach(s => s.remove());
            }

            const cachedProfile = profileCache.get(event.pubkey);
            const cardHTML = createLiveStreamCard(event, liveData, cachedProfile);

            if (cardHTML) {
                // Insert live streams at the beginning
                videoGrid.insertAdjacentHTML('afterbegin', cardHTML);
                // Load actual viewer count for this live stream
                loadLiveStreamCardViewers(event.id);
                // Load boosts for live stream
                if (!boostsCache.has(event.id)) {
                    loadBoostsForVideo(event.id);
                }
            }

            if (!cachedProfile) {
                profileQueue.add(event.pubkey);
                clearTimeout(profileTimer);
                profileTimer = setTimeout(loadProfilesBatch, 100);
            }
            return;
        }

        // Regular video handling
        if (!tags.some(tag => tag[0] === 'x')) return;

        if (!matchesSearch(event)) return;

        if (videoEvents.some(e => e.id === event.id)) {
            return;
        }

        allEvents.set(event.id, event);

        // Skip legacy events (kind 1 and 21/22) if addressable counterpart exists
        if (shouldSkipLegacyEvent(event)) return;

        const isShort = isNip71ShortKind(event.kind);

        if (isShort) {
            if (shortEvents.some(e => e.id === event.id)) return;
            shortEvents.push(event);
        } else {
            videoEvents.push(event);
        }

        const spinner = videoGrid.querySelector('.spinner');
        if (spinner) spinner.remove();

        const cachedProfile = profileCache.get(event.pubkey);
        const cachedReactions = reactionsCache.get(event.id);

        if (isShort) {
            renderShortCard(event, cachedProfile, cachedReactions);
        } else {
            renderVideoCard(event, cachedProfile, cachedReactions);
        }

        if (!cachedProfile) {
            profileQueue.add(event.pubkey);
            clearTimeout(profileTimer);
            profileTimer = setTimeout(loadProfilesBatch, 100);
        }

        reactionQueue.add(event.id);
        clearTimeout(reactionTimer);
        reactionTimer = setTimeout(loadReactionsBatch, 200);

    }, (allEvts) => {
        // Sort and cache shorts, show View More if needed
        if (shortEvents.length > 0) {
            shortEvents.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
            cachedSearchShorts = shortEvents;

            if (shortEvents.length > maxInitialShorts && shortsViewMore) {
                shortsViewMore.style.display = 'block';
            }
        }

        if (videoEvents.length === 0 && shortEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No videos found matching "${query}".</p>`;
        } else if (videoEvents.length === 0) {
            videoGrid.innerHTML = `<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No full-length videos found matching "${query}".</p>`;
        }

        if (profileQueue.size > 0) {
            loadProfilesBatch();
        }
        if (reactionQueue.size > 0) {
            loadReactionsBatch();
        }

        // Load views for search results
        const searchVideoIds = [...videoEvents.map(e => e.id), ...shortEvents.map(e => e.id)];
        if (searchVideoIds.length > 0) {
            loadViewsForVideos(searchVideoIds, true);
        }
    });

    // Wait for user search to complete
    await userSearchPromise;
}

// Update sidebar active state
function updateSidebarActive() {
    const items = document.querySelectorAll('.sidebar-item');
    items.forEach(item => item.classList.remove('active'));

    const hash = window.location.hash;
    items.forEach(item => {
        if (item.getAttribute('href') === hash ||
            (hash === '' && item.getAttribute('href') === '#/')) {
            item.classList.add('active');
        }
    });
}

// Function to fetch a single video event and return immediately when found
// Supports both kind 1 (legacy) and NIP-71 (kind 21/22) video events
async function fetchVideoEvent(eventId) {
    return new Promise((resolve) => {
        let found = false;

        // First, try to fetch by ID (works for any kind)
        const idFilter = {
            ids: [eventId]
        };

        requestEventsStream(idFilter, (event) => {
            if (!found && event.id === eventId) {
                // Verify it's a video event
                if (isVideoEvent(event)) {
                    found = true;
                    allEvents.set(event.id, event);
                    resolve(event);
                }
            }
        }, () => {
            if (!found) {
                resolve(null);
            }
        });
    });
}

// Fetch video event by d-tag (for NIP-71 parameterized replaceable events)
async function fetchVideoEventByDTag(pubkey, dTag) {
    return new Promise((resolve) => {
        let found = false;
        const filter = {
            kinds: [NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY],
            authors: [pubkey],
            '#d': [dTag],
            '#t': ['pv69420']
        };

        requestEventsStream(filter, (event) => {
            if (!found) {
                found = true;
                allEvents.set(event.id, event);
                resolve(event);
            }
        }, () => {
            if (!found) {
                resolve(null);
            }
        });
    });
}

// Play video
async function playVideo(eventId, skipNSFWCheck = false, skipRatioedCheck = false) {
    // Clear any existing auto-play countdown and sticky scroll handler
    hideNextVideoOverlay();
    nextVideoData = null;
    if (stickyScrollHandler) {
        window.removeEventListener('scroll', stickyScrollHandler);
        window.removeEventListener('resize', stickyScrollHandler);
        stickyScrollHandler = null;
    }
    if (sidebarPlaceholder) {
        sidebarPlaceholder.remove();
        sidebarPlaceholder = null;
    }

    const mainContent = document.getElementById('mainContent');

    // Clean up any existing video element to prevent audio from continuing to play
    // when the video is replaced (fixes double audio bug)
    const existingVideo = mainContent.querySelector('video');
    if (existingVideo) {
        existingVideo.pause();
        existingVideo.src = '';
        existingVideo.load();
        existingVideo.remove();
    }

    if (!mainContent.querySelector('.spinner')) {
        mainContent.innerHTML = '<div class="spinner"></div>';
    }

    try {
        let event = allEvents.get(eventId);

        if (!event) {
            event = await fetchVideoEvent(eventId);
        }

        if (!event) {
            mainContent.innerHTML = `<div class="error-message">${t('error.videoNotFound')}</div>`;
            return;
        }

        // Check if video or user is blocked by admin
        if (isBlockedByAdmin(event.id, event.pubkey)) {
            mainContent.innerHTML = `<div class="error-message">${t('error.contentNotAvailable')}</div>`;
            return;
        }

        // Parse video data (supports both kind 1 and NIP-71 formats)
        const videoData = parseAnyVideoEvent(event);
        if (!videoData) {
            mainContent.innerHTML = `<div class="error-message">${t('error.invalidVideoData')}</div>`;
            return;
        }

        // Store event info for potential editing
        videoData.eventId = event.id;
        videoData.eventKind = event.kind;

        const profile = await fetchUserProfile(event.pubkey);
        const avatarUrl = profile?.picture || profile?.avatar || '';
        const nip05 = profile?.nip05 || '';

        // Validate profile first
        const [avatarValid, nip05Valid] = await Promise.all([
            avatarUrl ? createImageValidationPromise(avatarUrl) : Promise.resolve(false),
            nip05 ? validateNip05(nip05, event.pubkey) : Promise.resolve(false)
        ]);

        const isProfileSuspicious = !avatarValid || !nip05Valid;

        // Check NSFW independently from suspicious profile
        const isNSFW = isVideoNSFW(event);

        // Skip NSFW/Community Warning modals for own videos
        const isOwnVideo = currentUser?.pubkey === event.pubkey;

        // Check if NSFW should be shown first (separate from community warning, skip for own videos)
        if (!isOwnVideo && !skipNSFWCheck && isNSFW && !shouldShowNSFW()) {
            showNSFWModal('playVideo', eventId);
            return;
        }

        const cachedReactions = reactionsCache.get(eventId) || { likes: 0, dislikes: 0 };
        const isCachedRatioed = isVideoRatioed(cachedReactions);

        // Check if reported by follows (skip for own videos)
        const isReportedByFollowsCheck = !isOwnVideo && isReportedByFollowsSync(eventId, event.pubkey);

        // Only show community warning for suspicious profiles, ratioed videos, or reported by follows (skip for own videos)
        if (!isOwnVideo && !skipRatioedCheck && (isCachedRatioed || isProfileSuspicious || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning()) {
            showRatioedModal(eventId);
            return;
        }

        if (videoData && profile) {
            const authorName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;

            document.title = `${videoData.title} - Plebs`;

            const setMetaTag = (selector, attribute, value) => {
                let tag = document.querySelector(selector);
                if (tag) tag.setAttribute(attribute, value);
            };

            setMetaTag('meta[property="og:title"]', 'content', `${videoData.title} - Plebs`);
            setMetaTag('meta[property="og:description"]', 'content',
                videoData.description ? videoData.description.slice(0, 155) : `Watch "${videoData.title}" by ${authorName} on Plebs`);
            if (videoData.thumbnail) {
                setMetaTag('meta[property="og:image"]', 'content', videoData.thumbnail);
            }
        }

        const authorNpub = window.NostrTools.nip19.npubEncode(event.pubkey);

        // Add to watch history with video metadata for recommendations
        addToWatchHistory(eventId, videoData.tags || [], event.pubkey);

        const note = createNote(event);
        const userNpub = currentUser ? window.NostrTools.nip19.npubEncode(currentUser.pubkey) : '';

        const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;

        // Render page immediately with video loading state - video URL is resolved async
        mainContent.innerHTML = `
            <div class="video-player-container">
                <div class="video-player">
                    <div class="video-loading-state" id="video-loading-${eventId}">
                        <div class="spinner"></div>
                        <p>Loading video...</p>
                    </div>
                    <video controls playsinline>
                        Your browser does not support the video tag.
                    </video>
                </div>
                <div class="video-content-wrapper">
                    <div class="video-details">
                        <h1>${videoData.title}</h1>
                        <div class="video-meta">
                            ${formatTimestamp(event.created_at)}
                            • <span class="video-page-views" id="video-views-${event.id}">${videoViewsCache.has(event.id) ? `${formatNumber(videoViewsCache.get(event.id))} views` : 'Loading views...'}</span>
                            ${isNSFW ? ' • <span style="color: #ff0000;">NSFW</span>' : ''}
                            <span class="ratioed-indicator" style="${isProfileSuspicious || isCachedRatioed ? '' : 'display: none;'}"> • <span style="color: #ff9800;">Community Warning</span></span>
                            • <span class="report-flag" onclick="showReportModal('${event.id}', '${event.pubkey}')" title="${t('action.reportVideo')}">${t('action.report')}</span>
                        </div>
                        <div class="video-channel-info">
                            <a href="#/profile/${event.pubkey}" class="channel-info" style="text-decoration: none;">
                                <div class="channel-avatar">
                                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                                </div>
                                <div class="channel-details">
                                    <div class="channel-name">${displayName}</div>
                                    ${nip05 ? `<div class="channel-nip05">${nip05}</div>` : ''}
                                    <div class="channel-stats" id="channel-stats-${event.pubkey}">
                                        <span class="channel-stat loading">
                                            <span class="stat-value">-</span> videos
                                        </span>
                                        <span class="channel-stat-separator">•</span>
                                        <span class="channel-stat loading">
                                            <span class="stat-value">-</span> followers
                                        </span>
                                    </div>
                                </div>
                            </a>
                            <div class="channel-actions" id="channel-actions-${event.pubkey}">
                                ${currentUser && currentUser.pubkey !== event.pubkey ? `
                                    <button class="channel-follow-btn loading" disabled>
                                        <span class="spinner-small"></span>
                                    </button>
                                    <button class="channel-mute-btn loading" disabled>
                                        <span class="spinner-small"></span>
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                        <div class="video-actions" id="video-actions-${eventId}">
                            <button class="action-btn like ${cachedReactions.userReaction === 'like' ? 'active' : ''}"
                                    onclick="handleLike('${event.id}')"
                                    data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                                </svg>
                                <span class="count">${formatNumber(cachedReactions.likes || 0)}</span>
                            </button>
                            <button class="action-btn dislike ${cachedReactions.userReaction === 'dislike' ? 'active' : ''}"
                                    onclick="handleDislike('${event.id}')"
                                    data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                                </svg>
                                <span class="count">${formatNumber(cachedReactions.dislikes || 0)}</span>
                            </button>
                            <button class="action-btn zap ${currentUser && currentUser.pubkey === event.pubkey ? 'self-content' : ''}"
                                    onclick="${currentUser && currentUser.pubkey === event.pubkey ? '' : `handleZap('${authorNpub}', 1000, '${event.id}')`}"
                                    data-event-id="${event.id}"
                                    ${currentUser && currentUser.pubkey === event.pubkey ? `title="${t('zap.cannotZapOwnContent')}"` : ''}>
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                                </svg>
                                <span class="count">Zap</span>
                            </button>
                            <button class="action-btn boost"
                                    onclick="handleBoost('${event.id}')"
                                    data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                                </svg>
                                <span class="count">Boost</span>
                            </button>
                            <button class="action-btn" onclick="shareVideo('${event.id}')">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
                                </svg>
                                Share
                            </button>
                            <button class="action-btn" id="download-btn-${eventId}" disabled title="${t('status.loadingVideo')}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                                </svg>
                                Download
                            </button>
                            ${currentUser && currentUser.pubkey === event.pubkey ? `
                                <div class="video-owner-actions-row">
                                    ${(() => {
                                        const editableId = getEditableEventId(event.id);
                                        return editableId ? `
                                            <button class="action-btn edit" onclick="showEditVideoModal('${editableId}')">
                                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                                                </svg>
                                                Edit
                                            </button>
                                        ` : '';
                                    })()}
                                    <button class="action-btn delete" onclick="handleDelete('${event.id}')">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                                        </svg>
                                        Delete
                                    </button>
                                </div>
                            ` : ''}
                        </div>

                        <div style="margin-top: 1.5rem;">
                            <h3>Description</h3>
                            <div class="video-description-container">
                                <div id="video-description" class="video-description ${videoData.description && videoData.description.length > 300 ? 'collapsed' : ''}">
                                    <p style="white-space: pre-wrap; margin-top: 0.5rem;">${videoData.description ? processTextWithLinks(videoData.description) : 'No description provided.'}</p>
                                </div>
                                ${videoData.description && videoData.description.length > 300 ? `
                                    <button id="description-toggle" class="description-toggle-btn" onclick="toggleDescription()">
                                        Show More
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                        ${videoData.tags.length > 0 ? `
                            <div class="tags">
                                ${videoData.tags.map(tag => `<span class="tag" onclick="navigateTo('/tag/${tag.toLowerCase()}')">#${tag}</span>`).join('')}
                            </div>
                        ` : ''}

                        <div class="recommendations-sidebar mobile-only" id="recommendationsSidebarMobile">
                            <div class="sidebar-header">
                                <h3>
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                                    </svg>
                                    Up Next
                                </h3>
                            </div>
                            <div class="sidebar-recommendations-grid">
                                <div class="spinner"></div>
                            </div>
                        </div>

                        <div class="comments-section">
                            <div class="comments-header">
                                <h3>Comments</h3>
                                <div class="comments-sort-dropdown">
                                    <select id="comments-sort" onchange="handleCommentSort(this.value)">
                                        <option value="newest">Newest</option>
                                        <option value="likes">Most Likes</option>
                                        <option value="zaps">Most Zaps</option>
                                    </select>
                                </div>
                            </div>
                            <div id="main-comment-input"></div>
                            <div id="comments-container">
                                <div class="spinner"></div>
                            </div>
                        </div>
                    </div>
                    <div class="recommendations-sidebar desktop-only" id="recommendationsSidebarDesktop">
                        <div class="sidebar-header">
                            <h3>
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h18v14zM9 8l7 4-7 4V8z"/>
                                </svg>
                                Up Next
                            </h3>
                        </div>
                        <div class="sidebar-recommendations-grid">
                            <div class="spinner"></div>
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Validate NIP-05 and add checkmark if valid
        if (nip05) {
            // Check cache first
            if (profileValidationCache.has(event.pubkey)) {
                const cached = profileValidationCache.get(event.pubkey);
                if (cached.nip05Valid) {
                    const channelNip05 = mainContent.querySelector('.video-channel-info .channel-nip05');
                    applyNip05Checkmark(channelNip05, true);
                }
            } else {
                // Validate asynchronously
                validateNip05(nip05, event.pubkey).then(isValid => {
                    if (isValid) {
                        const channelNip05 = mainContent.querySelector('.video-channel-info .channel-nip05');
                        applyNip05Checkmark(channelNip05, true);
                    }
                });
            }
        }

        const video = mainContent.querySelector('video');
        const videoLoadingState = document.getElementById(`video-loading-${eventId}`);
        const downloadBtn = document.getElementById(`download-btn-${eventId}`);

        // Async video URL resolution - doesn't block page render
        (async () => {
            try {
                const videoUrl = await getVideoUrl(videoData.hash) || videoData.url;

                if (!videoUrl) {
                    if (videoLoadingState) {
                        videoLoadingState.innerHTML = `<p class="error-message">${t('error.videoNotAvailable')}</p>`;
                    }
                    return;
                }

                // Set up error handler before setting source
                video.onerror = async () => {
                    const fallbackUrl = await getVideoUrl(videoData.hash, BLOSSOM_SERVERS.slice(1));
                    if (fallbackUrl && fallbackUrl !== videoUrl) {
                        video.src = fallbackUrl;
                        // Update download button with fallback URL
                        if (downloadBtn) {
                            downloadBtn.onclick = () => downloadVideo(fallbackUrl, { title: videoData.title });
                            downloadBtn.disabled = false;
                            downloadBtn.title = '';
                        }
                    } else {
                        // Show error state - recreate loading state if it was removed
                        const videoPlayer = video.parentElement;
                        let errorState = videoLoadingState;
                        if (!errorState || !errorState.parentElement) {
                            errorState = document.createElement('div');
                            errorState.className = 'video-loading-state';
                            videoPlayer.insertBefore(errorState, video);
                        }
                        errorState.style.display = 'flex';
                        errorState.innerHTML = `<p class="error-message">${t('error.failedLoadVideo')}</p>`;
                    }
                };

                // Video loaded successfully - remove loading state from DOM entirely
                video.onloadeddata = () => {
                    if (videoLoadingState) {
                        videoLoadingState.remove();
                    }
                };

                // Show auto-play next video overlay when video ends
                video.onended = () => {
                    showNextVideoOverlay();
                };

                // Record view when video starts playing (works for both logged-in and anonymous)
                video.onplay = () => {
                    recordVideoView(eventId);
                };

                // Set the video source
                video.src = videoUrl;
                video.autoplay = true;
                video.playsInline = true;

                // Enable download button
                if (downloadBtn) {
                    downloadBtn.onclick = () => downloadVideo(videoUrl, { title: videoData.title });
                    downloadBtn.disabled = false;
                    downloadBtn.title = '';
                }
            } catch (error) {
                console.error('Failed to resolve video URL:', error);
                if (videoLoadingState) {
                    videoLoadingState.innerHTML = `<p class="error-message">${t('error.failedLoadVideoShort')}</p>`;
                }
            }
        })();

        const mainCommentInput = createCommentInput();
        document.getElementById('main-comment-input').replaceWith(mainCommentInput);

        // First, try to find linked events (for merging reactions/zaps/comments from legacy events)
        // We await this to ensure we have all linked IDs before loading data
        const additionalIds = await findLinkedVideoEvents(event);

        // Get all linked event IDs (includes any found by findLinkedVideoEvents)
        const linkedEventIds = getAllLinkedEventIds(eventId);
        const videoEventIds = linkedEventIds;

        loadComments(videoEventIds);

        // Load reactions from all linked events (merges kind 1 and kind 21/22)
        // Note: loadReactionsForVideos expands IDs internally via getAllLinkedEventIds
        loadReactionsForVideos([eventId], (videoId, reactions) => {
            updateReactionButtons(eventId, reactions);

            const isRatioed = isVideoRatioed(reactions);
            if ((isRatioed || isProfileSuspicious) && !skipRatioedCheck && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning()) {
                const indicator = mainContent.querySelector('.ratioed-indicator');
                if (indicator) {
                    indicator.style.display = 'inline';
                }
            }
        });

        // Load zaps from all linked events (merges kind 1 and kind 21/22)
        loadZapsForVideos(linkedEventIds, (totalZaps, count) => {
            updateZapButton(eventId, totalZaps);
        });

        // Load boosts from all linked events
        loadBoostsForVideos(linkedEventIds, (totalBoosts) => {
            updateBoostButton(eventId, totalBoosts);
        });

        // Load and display view count, then record this view
        loadVideoViews(eventId).then(viewCount => {
            const viewsElement = document.getElementById(`video-views-${eventId}`);
            if (viewsElement) {
                viewsElement.textContent = `${formatNumber(viewCount)} ${t('stat.views')}`;
            }
            // Update any video cards on the page with this video
            document.querySelectorAll(`.video-views[data-event-id="${eventId}"]`).forEach(el => {
                el.textContent = ` • ${formatNumber(viewCount)} ${t('stat.views')}`;
            });
        });

        // Note: View recording happens in video.onplay handler (supports both logged-in and anonymous)

        // Load sidebar recommendations (similar videos + personalized if enough history)
        loadSidebarRecommendations(event);

        // Load channel stats and follow button asynchronously - defer to not block other loading
        setTimeout(() => loadChannelStats(event.pubkey), 500);

    } catch (error) {
        console.error('Failed to play video:', error);
        mainContent.innerHTML = `<div class="error-message">${t('error.failedLoadVideoShort')}</div>`;
    }
}

// Handle description expand/collapse
function toggleDescription() {
    const descriptionDiv = document.getElementById('video-description');
    const toggleBtn = document.getElementById('description-toggle');

    if (descriptionDiv.classList.contains('collapsed')) {
        descriptionDiv.classList.remove('collapsed');
        toggleBtn.textContent = t('button.showLess');
    } else {
        descriptionDiv.classList.add('collapsed');
        toggleBtn.textContent = t('button.showMore');
    }
}

// Handle bio expand/collapse
function toggleBio() {
    const bioDiv = document.getElementById('profile-bio');
    const toggleBtn = document.getElementById('bio-toggle');

    if (bioDiv.classList.contains('collapsed')) {
        bioDiv.classList.remove('collapsed');
        toggleBtn.textContent = t('button.showLess');
    } else {
        bioDiv.classList.add('collapsed');
        toggleBtn.textContent = t('button.showMore');
    }
}

// Handle like button click
async function handleLike(eventId) {
    if (!await ensureLoggedIn()) {
        return;
    }

    // Check if user is blocked
    if (isPubkeyBlocked(currentUser.pubkey)) {
        showToast('Your account has been restricted', 'error');
        return;
    }

    const success = await sendReaction(eventId, '👍');
    if (success) {
        const reactions = reactionsCache.get(eventId);
        updateReactionButtons(eventId, reactions);
    }
}

// Handle dislike button click
async function handleDislike(eventId) {
    if (!await ensureLoggedIn()) {
        return;
    }

    // Check if user is blocked
    if (isPubkeyBlocked(currentUser.pubkey)) {
        showToast('Your account has been restricted', 'error');
        return;
    }

    const success = await sendReaction(eventId, '👎');
    if (success) {
        const reactions = reactionsCache.get(eventId);
        updateReactionButtons(eventId, reactions);
    }
}

// Handle download button click
async function downloadVideo(videoUrl, videoData) {
    try {
        if (videoUrl.startsWith('https://') && BLOSSOM_SERVERS.some(server => videoUrl.startsWith(server))) {
            const response = await fetch(videoUrl);
            const blob = await response.blob();

            const blobUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = videoData.title || 'video';
            a.click();
            URL.revokeObjectURL(blobUrl);
            a.remove();
        } else {
            const a = document.createElement('a');
            a.href = videoUrl;
            a.download = videoData.title || 'video';
            a.click();
            a.remove();
        }
    } catch (error) {
        console.error('Failed to download video:', error);
        showToast('Failed to download video. Please try again.', 'error');
    }
}

// Update reaction buttons UI
function updateReactionButtons(eventId, reactions) {
    const likeBtn = document.querySelector(`.action-btn.like[data-event-id="${eventId}"]`);
    const dislikeBtn = document.querySelector(`.action-btn.dislike[data-event-id="${eventId}"]`);

    if (likeBtn && dislikeBtn) {
        likeBtn.querySelector('.count').textContent = formatNumber(reactions.likes || 0);
        dislikeBtn.querySelector('.count').textContent = formatNumber(reactions.dislikes || 0);

        likeBtn.classList.toggle('active', reactions.userReaction === 'like');
        dislikeBtn.classList.toggle('active', reactions.userReaction === 'dislike');
    }
}

// Share video
// Current share state
let currentShareEventId = null;

function shareVideo(eventId) {
    currentShareEventId = eventId;
    const isLocal = window.location.protocol === 'file:';
    const baseUrl = isLocal ? window.location.href.split('#')[0] : window.location.origin;
    const shareUrl = `${baseUrl}/#/video/${eventId}`;
    document.getElementById('shareUrlInput').value = shareUrl;

    // Reset to link tab
    switchShareTab('link');

    // Generate embed code
    updateEmbedCode();

    // Show the fallback note for regular videos (uses blossom hosts)
    const fallbackNote = document.getElementById('embedFallbackNote');
    if (fallbackNote) fallbackNote.style.display = '';

    // Record share event for analytics
    recordVideoShare(eventId);

    document.getElementById('shareModal').classList.add('active');
}

// Switch between share tabs
function switchShareTab(tab) {
    // Update tab buttons
    document.querySelectorAll('.share-tab').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tab);
    });

    // Update tab content
    document.getElementById('shareLinkTab').classList.toggle('active', tab === 'link');
    document.getElementById('shareEmbedTab').classList.toggle('active', tab === 'embed');

    // Generate embed code when switching to embed tab
    if (tab === 'embed') {
        updateEmbedCode();
    }
}

// Update embed code based on selected size
function updateEmbedCode() {
    if (!currentShareEventId) return;

    const event = allEvents.get(currentShareEventId);
    if (!event) return;

    const videoData = parseAnyVideoEvent(event);
    if (!videoData) return;

    const sizeSelect = document.getElementById('embedSizeSelect');
    const selectedSize = sizeSelect.value;

    const isLocal = window.location.protocol === 'file:';
    const baseUrl = isLocal ? window.location.href.split('#')[0] : window.location.origin;
    const embedUrl = `${baseUrl}/embed.html?id=${currentShareEventId}`;

    let embedCode;
    if (selectedSize === 'responsive') {
        embedCode = `<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="${embedUrl}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;" allowfullscreen></iframe>
</div>`;
    } else {
        const [width, height] = selectedSize.split('x');
        embedCode = `<iframe width="${width}" height="${height}" src="${embedUrl}" frameborder="0" allowfullscreen></iframe>`;
    }

    document.getElementById('embedCodeInput').value = embedCode;
}

// Copy embed code
function copyEmbedCode() {
    const textarea = document.getElementById('embedCodeInput');
    textarea.select();
    document.execCommand('copy');

    document.getElementById('embedCopySuccess').style.display = 'block';
    setTimeout(() => {
        document.getElementById('embedCopySuccess').style.display = 'none';
    }, 2000);
}

// Copy share URL
function copyShareUrl() {
    const input = document.getElementById('shareUrlInput');
    input.select();
    document.execCommand('copy');

    document.getElementById('copySuccess').style.display = 'block';
    setTimeout(() => {
        document.getElementById('copySuccess').style.display = 'none';
    }, 2000);
}

// Hide share modal
function hideShareModal() {
    document.getElementById('shareModal').classList.remove('active');
    document.getElementById('copySuccess').style.display = 'none';
    document.getElementById('embedCopySuccess').style.display = 'none';
    currentShareEventId = null;
}

// Comment system functions
// Progressive comment loading - renders comments as they arrive
async function loadComments(eventIds) {
    const commentsContainer = document.getElementById('comments-container');
    if (!commentsContainer) return;

    commentsContainer.innerHTML = '<div class="spinner"></div>';

    // Expand event IDs to include all linked events (for comment merging)
    const allLinkedIds = new Set();
    eventIds.forEach(id => {
        const linkedIds = getAllLinkedEventIds(id);
        linkedIds.forEach(linkedId => allLinkedIds.add(linkedId));
    });
    const expandedEventIds = Array.from(allLinkedIds);

    // Reset comments state
    currentCommentsState = {
        comments: [],
        eventIds: eventIds,
        reactions: new Map(),
        zaps: new Map(),
        sortBy: 'newest'
    };

    // Reset sort dropdown to newest
    const sortDropdown = document.getElementById('comments-sort');
    if (sortDropdown) {
        sortDropdown.value = 'newest';
    }

    try {
        const filter = {
            kinds: [1],
            '#e': expandedEventIds,
            limit: 500
        };

        const comments = currentCommentsState.comments;
        const commentReactions = currentCommentsState.reactions;
        const commentZaps = currentCommentsState.zaps;
        const loadedPubkeys = new Set();
        let hasCleared = false;
        let renderTimeout = null;
        let lastRenderTime = 0;
        const RENDER_DEBOUNCE = 100; // ms

        // Progressive render function
        const renderProgressively = () => {
            if (comments.length === 0) return;

            const now = Date.now();
            if (now - lastRenderTime < RENDER_DEBOUNCE) {
                return;
            }
            lastRenderTime = now;

            // Clear spinner on first render
            if (!hasCleared) {
                hasCleared = true;
                commentsContainer.innerHTML = '';
            }

            // Build tree and render
            const commentTree = buildCommentTree(comments, eventIds, currentCommentsState.sortBy, commentReactions, commentZaps);
            renderComments(commentTree, profileCache, commentReactions, commentsContainer, commentZaps);

            // Load profiles immediately for any new pubkeys
            comments.forEach(c => {
                if (!loadedPubkeys.has(c.pubkey)) {
                    loadedPubkeys.add(c.pubkey);
                    loadProfileAndUpdateCards(c.pubkey);
                }
            });
        };

        // Debounced render scheduler
        const scheduleRender = () => {
            if (renderTimeout) clearTimeout(renderTimeout);
            renderTimeout = setTimeout(renderProgressively, RENDER_DEBOUNCE);
        };

        // Stream comments and render progressively
        requestEventsStream(filter, (event) => {
            comments.push(event);
            allEvents.set(event.id, event);
            scheduleRender();
        }, () => {
            // On completion - do final render
            clearTimeout(renderTimeout);
            renderProgressively();

            if (comments.length === 0) {
                commentsContainer.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.noComments')}</p>`;
                return;
            }

            // Load reactions in background and update comments in-place
            const commentIds = comments.map(c => c.id);
            if (commentIds.length > 0) {
                const BATCH_SIZE = 50;
                const commentIdBatches = [];
                for (let i = 0; i < commentIds.length; i += BATCH_SIZE) {
                    commentIdBatches.push(commentIds.slice(i, i + BATCH_SIZE));
                }

                Promise.all(commentIdBatches.map(batch =>
                    new Promise(resolve => {
                        requestEventsStream({ kinds: [7], '#e': batch }, (event) => {
                            const targetId = event.tags.find(t => t[0] === 'e')?.[1];
                            if (targetId && commentIds.includes(targetId)) {
                                if (!commentReactions.has(targetId)) {
                                    commentReactions.set(targetId, new Map());
                                }
                                const reactions = commentReactions.get(targetId);
                                const existingReaction = reactions.get(event.pubkey);
                                if (!existingReaction || existingReaction.timestamp < event.created_at) {
                                    reactions.set(event.pubkey, {
                                        eventId: event.id,
                                        reaction: event.content,
                                        timestamp: event.created_at,
                                        pubkey: event.pubkey,
                                        hasPoW: validateEventPoW(event)
                                    });
                                    // Update comment reaction count in-place
                                    updateCommentReactionsInPlace(targetId, reactions);
                                }
                            }
                        }, resolve);
                    })
                ));

                // Load zaps for comments in background
                Promise.all(commentIdBatches.map(batch =>
                    new Promise(resolve => {
                        requestEventsStream({ kinds: [9735], '#e': batch }, (event) => {
                            try {
                                const targetId = event.tags.find(t => t[0] === 'e')?.[1];
                                if (targetId && commentIds.includes(targetId)) {
                                    const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
                                    if (bolt11Tag && bolt11Tag[1]) {
                                        const amount = extractAmountFromBolt11(bolt11Tag[1]);
                                        if (amount > 0) {
                                            if (!commentZaps.has(targetId)) {
                                                commentZaps.set(targetId, { totalSats: 0, count: 0 });
                                            }
                                            const zapData = commentZaps.get(targetId);
                                            zapData.totalSats += amount;
                                            zapData.count++;
                                            // Update comment zap count in-place
                                            updateCommentZapsInPlace(targetId, zapData);
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error('Failed to parse comment zap:', e);
                            }
                        }, resolve);
                    })
                ));
            }
        });

    } catch (error) {
        console.error('Failed to load comments:', error);
        commentsContainer.innerHTML = `<div class="error-message">${t('empty.failedLoadComments')}</div>`;
    }
}

// Update comment profile display in-place
function updateCommentProfileInPlace(pubkey, profile) {
    const commentElements = document.querySelectorAll(`.comment[data-pubkey="${pubkey}"]`);
    commentElements.forEach(el => {
        const displayName = profile.name || profile.display_name || `User ${pubkey.slice(0, 8)}`;
        const avatarUrl = profile.picture || profile.avatar || '';
        const nip05 = profile.nip05 || '';

        const nameEl = el.querySelector('.comment-author-name');
        if (nameEl) nameEl.textContent = displayName;

        const avatarEl = el.querySelector('.comment-avatar');
        if (avatarEl && avatarUrl) {
            avatarEl.innerHTML = `<img src="${avatarUrl}" alt="${displayName}">`;
        }

        const nip05El = el.querySelector('.comment-author-nip05');
        if (nip05El) {
            nip05El.textContent = nip05;
            nip05El.style.display = nip05 ? 'block' : 'none';
        } else if (nip05) {
            const authorInfo = el.querySelector('.comment-author-info');
            if (authorInfo) {
                const newNip05El = document.createElement('div');
                newNip05El.className = 'comment-author-nip05';
                newNip05El.textContent = nip05;
                authorInfo.appendChild(newNip05El);
            }
        }
    });
}

// Update comment reaction count in-place
function updateCommentReactionsInPlace(commentId, reactions) {
    const commentEl = document.querySelector(`.comment[data-comment-id="${commentId}"]`);
    if (!commentEl) return;

    let likes = 0;
    let dislikes = 0;
    let userReaction = null;

    reactions.forEach((data, pubkey) => {
        if (data.reaction === '👍' || data.reaction === '+') {
            likes++;
            if (currentUser && pubkey === currentUser.pubkey) {
                userReaction = 'like';
            }
        } else if (data.reaction === '👎' || data.reaction === '-') {
            dislikes++;
            if (currentUser && pubkey === currentUser.pubkey) {
                userReaction = 'dislike';
            }
        }
    });

    // Update like count and active state
    const likeBtn = commentEl.querySelector('.comment-like-btn');
    const likeCountEl = commentEl.querySelector('.like-count');
    if (likeCountEl) {
        likeCountEl.textContent = likes > 0 ? formatNumber(likes) : 'Like';
    }
    if (likeBtn) {
        likeBtn.classList.toggle('active', userReaction === 'like');
    }

    // Update dislike count and active state
    const dislikeBtn = commentEl.querySelector('.comment-dislike-btn');
    const dislikeCountEl = commentEl.querySelector('.dislike-count');
    if (dislikeCountEl) {
        dislikeCountEl.textContent = dislikes > 0 ? formatNumber(dislikes) : 'Dislike';
    }
    if (dislikeBtn) {
        dislikeBtn.classList.toggle('active', userReaction === 'dislike');
    }
}

// Update comment zap count in-place
function updateCommentZapsInPlace(commentId, zapData) {
    const commentEl = document.querySelector(`.comment[data-comment-id="${commentId}"]`);
    if (!commentEl) return;

    const zapCountEl = commentEl.querySelector('.zap-count');
    if (zapCountEl) {
        zapCountEl.textContent = zapData.totalSats > 0 ? formatNumber(zapData.totalSats) : 'Zap';
    }
}

// Build hierarchical comment structure
function buildCommentTree(comments, rootEventIds, sortBy = 'newest', reactions = new Map(), zaps = new Map()) {
    const commentMap = new Map();
    const rootComments = [];

    comments.forEach(comment => {
        commentMap.set(comment.id, {
            ...comment,
            children: [],
            depth: 0
        });
    });

    comments.forEach(comment => {
        const eTags = comment.tags.filter(t => t[0] === 'e');

        let parentId = null;
        for (let i = eTags.length - 1; i >= 0; i--) {
            const eventId = eTags[i][1];
            if (!rootEventIds.includes(eventId) && commentMap.has(eventId)) {
                parentId = eventId;
                break;
            }
        }

        const commentNode = commentMap.get(comment.id);

        if (parentId && commentMap.has(parentId)) {
            const parent = commentMap.get(parentId);
            parent.children.push(commentNode);
            commentNode.depth = parent.depth + 1;
        } else {
            rootComments.push(commentNode);
        }
    });

    // Helper to count likes for a comment
    const getLikeCount = (commentId) => {
        const commentReactions = reactions.get(commentId);
        if (!commentReactions) return 0;
        let likes = 0;
        commentReactions.forEach((data) => {
            if (data.reaction === '👍' || data.reaction === '+') {
                likes++;
            }
        });
        return likes;
    };

    // Helper to get zap amount for a comment
    const getZapAmount = (commentId) => {
        const zapData = zaps.get(commentId);
        return zapData ? zapData.totalSats : 0;
    };

    const sortComments = (comments) => {
        if (sortBy === 'likes') {
            comments.sort((a, b) => {
                const likesA = getLikeCount(a.id);
                const likesB = getLikeCount(b.id);
                if (likesB !== likesA) return likesB - likesA;
                return b.created_at - a.created_at; // Fallback to newest
            });
        } else if (sortBy === 'zaps') {
            comments.sort((a, b) => {
                const zapsA = getZapAmount(a.id);
                const zapsB = getZapAmount(b.id);
                if (zapsB !== zapsA) return zapsB - zapsA;
                return b.created_at - a.created_at; // Fallback to newest
            });
        } else {
            // Default: newest first
            comments.sort((a, b) => b.created_at - a.created_at);
        }
        comments.forEach(comment => sortComments(comment.children));
    };

    sortComments(rootComments);

    return rootComments;
}

// Handle comment sorting change
function handleCommentSort(sortBy) {
    currentCommentsState.sortBy = sortBy;

    const commentsContainer = document.getElementById('comments-container');
    if (!commentsContainer || currentCommentsState.comments.length === 0) return;

    const commentTree = buildCommentTree(
        currentCommentsState.comments,
        currentCommentsState.eventIds,
        sortBy,
        currentCommentsState.reactions,
        currentCommentsState.zaps
    );

    renderComments(
        commentTree,
        profileCache,
        currentCommentsState.reactions,
        commentsContainer,
        currentCommentsState.zaps
    );
}

// Render comment tree
function renderComments(comments, profiles, reactions, container, zaps = new Map()) {
    if (comments.length === 0) {
        container.innerHTML = `<p style="text-align: center; color: var(--text-secondary);">${t('empty.noComments')}</p>`;
        return;
    }

    container.innerHTML = '';
    comments.forEach(comment => {
        const commentElement = createCommentElement(comment, profiles, reactions, zaps);
        container.appendChild(commentElement);
    });
}

// Create individual comment element
function createCommentElement(comment, profiles, reactions, zaps = new Map()) {
    // Check if comment is from a muted user
    if (shouldHideMutedContent(comment.pubkey)) {
        const placeholderDiv = document.createElement('div');
        placeholderDiv.className = 'comment muted-comment-placeholder';
        placeholderDiv.dataset.commentId = comment.id;
        placeholderDiv.dataset.pubkey = comment.pubkey;
        placeholderDiv.dataset.depth = Math.min(comment.depth, 3);
        placeholderDiv.innerHTML = `
            <div class="muted-placeholder-content muted-comment">
                <span class="muted-icon-small">${getMuteIconSVG(14)}</span>
                <span>Comment from muted user hidden</span>
                <button class="unhide-muted-btn-small" onclick="unhideMutedComment('${comment.id}', '${comment.pubkey}')">
                    Show
                </button>
            </div>
        `;
        return placeholderDiv;
    }

    // Check if comment matches enabled filter packs
    const filterResult = shouldFilterComment(comment.content);
    if (filterResult.filtered && !sessionFilteredAllowed.has(comment.id)) {
        const packNames = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.name || p.packName).join(', ');
        const packIcons = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.icon || '🚫').join(' ');

        const placeholderDiv = document.createElement('div');
        placeholderDiv.className = 'comment filtered-comment-placeholder';
        placeholderDiv.dataset.eventId = comment.id;
        placeholderDiv.dataset.depth = Math.min(comment.depth, 3);
        placeholderDiv.innerHTML = `
            <div class="filtered-placeholder-content filtered-comment">
                <span class="filtered-icon-small">${packIcons}</span>
                <span>Comment hidden (${escapeHtml(packNames)})</span>
                <button class="unhide-filtered-btn-small" onclick="handleUnhideFilteredContent('${comment.id}')">
                    Show
                </button>
            </div>
        `;
        return placeholderDiv;
    }

    // Check if comment has been reported by follows (skip for own comments)
    const isCommentReported = currentUser?.pubkey !== comment.pubkey &&
        isReportedByFollowsSync(comment.id, comment.pubkey) &&
        !sessionRatioedAllowed.has(comment.id) &&
        !shouldSkipCommunityWarning();

    if (isCommentReported) {
        const placeholderDiv = document.createElement('div');
        placeholderDiv.className = 'comment reported-comment-placeholder';
        placeholderDiv.dataset.eventId = comment.id;
        placeholderDiv.dataset.depth = Math.min(comment.depth, 3);
        placeholderDiv.innerHTML = `
            <div class="filtered-placeholder-content filtered-comment" style="border-color: #ff9800;">
                <span class="filtered-icon-small" style="color: #ff9800;">⚠</span>
                <span>Comment reported by people you follow</span>
                <button class="unhide-filtered-btn-small" onclick="unhideReportedComment('${comment.id}')">
                    Show
                </button>
            </div>
        `;
        return placeholderDiv;
    }

    const profile = profiles.get(comment.pubkey) || {};
    const displayName = profile.name || profile.display_name || `User ${comment.pubkey.slice(0, 8)}`;
    const avatarUrl = profile.picture || profile.avatar || '';
    const nip05 = profile.nip05 || '';

    // Check if NIP-05 is validated
    const validationCached = profileValidationCache.get(comment.pubkey);
    const nip05Valid = validationCached?.nip05Valid || false;

    const commentReactions = reactions.get(comment.id) || new Map();
    let likes = 0;
    let dislikes = 0;
    let powLikes = 0;
    let powDislikes = 0;
    let userReaction = null;

    commentReactions.forEach((data, pubkey) => {
        if (data.reaction === '👍' || data.reaction === '+') {
            likes++;
            if (data.hasPoW) powLikes++;
            if (currentUser && pubkey === currentUser.pubkey) {
                userReaction = 'like';
            }
        } else if (data.reaction === '👎' || data.reaction === '-') {
            dislikes++;
            if (data.hasPoW) powDislikes++;
            if (currentUser && pubkey === currentUser.pubkey) {
                userReaction = 'dislike';
            }
        }
    });

    // Check if comment is ratioed using PoW-validated reactions only (spam-resistant)
    const isCommentRatioed = powDislikes > powLikes && powDislikes >= 3;

    // Show warning for heavily ratioed comments (if community warnings enabled)
    if (isCommentRatioed && currentUser?.pubkey !== comment.pubkey &&
        !sessionRatioedAllowed.has(comment.id) && !shouldSkipCommunityWarning()) {
        const placeholderDiv = document.createElement('div');
        placeholderDiv.className = 'comment ratioed-comment-placeholder';
        placeholderDiv.dataset.eventId = comment.id;
        placeholderDiv.dataset.depth = Math.min(comment.depth, 3);
        placeholderDiv.innerHTML = `
            <div class="filtered-placeholder-content filtered-comment" style="border-color: #ff9800;">
                <span class="filtered-icon-small" style="color: #ff9800;">👎</span>
                <span>Comment heavily downvoted by community</span>
                <button class="unhide-filtered-btn-small" onclick="unhideReportedComment('${comment.id}')">
                    Show
                </button>
            </div>
        `;
        return placeholderDiv;
    }

    // Get zap count for this comment
    const commentZapData = zaps.get(comment.id) || { totalSats: 0, count: 0 };
    const zapCountText = commentZapData.totalSats > 0 ? formatNumber(commentZapData.totalSats) : 'Zap';
    const authorNpub = window.NostrTools.nip19.npubEncode(comment.pubkey);

    const visualDepth = Math.min(comment.depth, 3);

    const commentDiv = document.createElement('div');
    commentDiv.className = 'comment';
    commentDiv.dataset.depth = visualDepth;
    commentDiv.dataset.commentId = comment.id;
    commentDiv.dataset.pubkey = comment.pubkey;

    const depthIndicator = comment.depth > 3 ? `↳ ${comment.depth - 3} more` : '';

    const processedContent = processCommentContent(comment.content);

    const likeCountText = likes > 0 ? formatNumber(likes) : 'Like';
    const dislikeCountText = dislikes > 0 ? formatNumber(dislikes) : 'Dislike';

    commentDiv.innerHTML = `
        <div class="comment-thread-line"></div>
        <div class="comment-content">
            <div class="comment-header">
                <a href="#/profile/${comment.pubkey}" class="comment-author">
                    <div class="comment-avatar">
                        ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                    </div>
                    <div class="comment-author-info">
                        <div class="comment-author-name">${displayName}</div>
                        ${nip05 ? `<div class="comment-author-nip05" data-pubkey="${comment.pubkey}">${nip05}${nip05Valid ? getNip05CheckmarkSVG(12) : ''}</div>` : ''}
                    </div>
                </a>
                <div class="comment-timestamp">${formatTimestamp(comment.created_at)}</div>
            </div>
            ${depthIndicator ? `<div class="comment-depth-indicator">${depthIndicator}</div>` : ''}
            <div class="comment-body">${processedContent}</div>
            <div class="comment-actions">
                <button class="comment-action-btn comment-like-btn ${userReaction === 'like' ? 'active' : ''}"
                        onclick="likeComment('${comment.id}')"
                        ${currentUser ? '' : 'disabled'}
                        data-comment-id="${comment.id}">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                    <span class="like-count">${likeCountText}</span>
                </button>
                <button class="comment-action-btn comment-dislike-btn ${userReaction === 'dislike' ? 'active' : ''}"
                        onclick="dislikeComment('${comment.id}')"
                        ${currentUser ? '' : 'disabled'}
                        data-comment-id="${comment.id}">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                    <span class="dislike-count">${dislikeCountText}</span>
                </button>
                <button class="comment-action-btn comment-reply-btn"
                        onclick="replyToComment('${comment.id}', '${comment.pubkey}')"
                        ${currentUser ? '' : 'disabled'}>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/>
                    </svg>
                    Reply
                </button>
                <button class="comment-action-btn comment-zap-btn ${currentUser && currentUser.pubkey === comment.pubkey ? 'self-content' : ''}"
                        onclick="${currentUser && currentUser.pubkey === comment.pubkey ? '' : `handleZap('${authorNpub}', 1000, '${comment.id}')`}"
                        ${currentUser ? '' : 'disabled'}
                        data-comment-id="${comment.id}"
                        ${currentUser && currentUser.pubkey === comment.pubkey ? `title="${t('zap.cannotZapOwnComment')}"` : ''}>
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                    </svg>
                    <span class="zap-count">${zapCountText}</span>
                </button>
                ${currentUser && currentUser.pubkey !== comment.pubkey ? `
                    <button class="comment-action-btn comment-mute-btn ${isUserMuted(comment.pubkey) ? 'muted' : ''}"
                            onclick="handleMute('${comment.pubkey}', ${isUserMuted(comment.pubkey)})"
                            title="${isUserMuted(comment.pubkey) ? t('button.unmuteUser') : t('button.muteUser')}">
                        ${getMuteIconSVG(14)}
                        <span>${isUserMuted(comment.pubkey) ? t('button.unmute') : t('button.mute')}</span>
                    </button>
                    <button class="comment-action-btn comment-report-btn"
                            onclick="showReportModal('${comment.id}', '${comment.pubkey}', 'comment')"
                            title="${t('action.reportComment')}">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"/>
                        </svg>
                        <span>${t('action.report')}</span>
                    </button>
                ` : ''}
            </div>
        </div>
    `;

    if (comment.children.length > 0) {
        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'comment-children';

        // Count total replies recursively (including nested children)
        function countTotalReplies(children) {
            let count = children.length;
            children.forEach(child => {
                if (child.children && child.children.length > 0) {
                    count += countTotalReplies(child.children);
                }
            });
            return count;
        }

        const totalReplies = countTotalReplies(comment.children);
        const BATCH_SIZE = 5; // Direct children per batch

        // If 2 or more total replies, show in collapsed batches
        if (totalReplies >= 2) {
            let visibleDirectChildren = 0;
            const directChildren = comment.children;

            // Helper to create expand button with thread line wrapper
            function createExpandButtonWrapper(text, onClick) {
                const wrapper = document.createElement('div');
                wrapper.className = 'comment-expand-btn-wrapper';

                const btn = document.createElement('button');
                btn.className = 'comment-expand-btn';
                btn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                    </svg>
                    <span>${text}</span>
                `;
                btn.onclick = onClick;

                wrapper.appendChild(btn);
                return wrapper;
            }

            // Function to render a batch of direct children (with their nested replies)
            function renderBatch() {
                const nextBatch = directChildren.slice(visibleDirectChildren, visibleDirectChildren + BATCH_SIZE);
                nextBatch.forEach(child => {
                    // Use regular createCommentElement which handles nested children properly
                    const childElement = createCommentElement(child, profiles, reactions, zaps);
                    childrenContainer.appendChild(childElement);
                });
                visibleDirectChildren += nextBatch.length;

                // Update or remove the "show more" button wrapper
                const existingWrapper = childrenContainer.querySelector(':scope > .comment-expand-btn-wrapper');
                if (existingWrapper) {
                    existingWrapper.remove();
                }

                // Calculate remaining direct children (what will actually load on next click)
                const remainingDirectCount = directChildren.length - visibleDirectChildren;

                if (remainingDirectCount > 0) {
                    // Show how many direct replies will load (up to BATCH_SIZE)
                    const nextBatchCount = Math.min(BATCH_SIZE, remainingDirectCount);
                    const wrapper = createExpandButtonWrapper(
                        `View ${nextBatchCount} more ${nextBatchCount === 1 ? 'reply' : 'replies'}`,
                        (e) => {
                            e.stopPropagation();
                            renderBatch();
                        }
                    );
                    childrenContainer.appendChild(wrapper);
                }
            }

            // Create initial "show replies" button inside children container
            // Show how many direct replies will load on first click (up to BATCH_SIZE)
            const initialBatchCount = Math.min(BATCH_SIZE, directChildren.length);
            const initialWrapper = createExpandButtonWrapper(
                `View ${initialBatchCount} ${initialBatchCount === 1 ? 'reply' : 'replies'}`,
                (e) => {
                    e.stopPropagation();
                    renderBatch();
                }
            );
            childrenContainer.appendChild(initialWrapper);
        } else {
            // Less than 2 replies, show them all directly
            comment.children.forEach(child => {
                const childElement = createCommentElement(child, profiles, reactions);
                childrenContainer.appendChild(childElement);
            });
        }

        commentDiv.appendChild(childrenContainer);
    }

    return commentDiv;
}

// Process text to make URLs clickable (for descriptions and bios)
function processTextWithLinks(text) {
    if (!text) return '';

    // Escape HTML first
    let processedText = escapeHtml(text);

    // URL regex to match http/https URLs
    const urlRegex = /(https?:\/\/[^\s<]+)/g;

    // Replace URLs with clickable links
    processedText = processedText.replace(urlRegex, (url) => {
        // Clean up any trailing punctuation that shouldn't be part of the URL
        let cleanUrl = url;
        let trailing = '';
        const trailingPunctuation = /[.,;:!?)>\]]+$/;
        const match = cleanUrl.match(trailingPunctuation);
        if (match) {
            // Check if it's likely part of the URL (like query params) or just punctuation
            const beforeMatch = cleanUrl.slice(0, -match[0].length);
            // If the character before is alphanumeric or common URL chars, keep single trailing char
            if (match[0].length === 1 && /[=&]$/.test(beforeMatch)) {
                // Keep it as part of URL
            } else {
                cleanUrl = beforeMatch;
                trailing = match[0];
            }
        }
        return `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer" class="text-link">${cleanUrl}</a>${trailing}`;
    });

    return processedText;
}

function processCommentContent(content) {
    let processedContent = escapeHtml(content);

    const urlRegex = /(https?:\/\/[^\s<]+)/g;
    const imageRegex = /(https?:\/\/[^\s<]+\.(jpg|jpeg|png|gif|webp|svg)(\?[^\s<]*)?)/gi;
    const videoRegex = /(https?:\/\/[^\s<]+\.(mp4|webm|mov)(\?[^\s<]*)?)/gi;
    const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/g;

    const mediaUrls = new Set();

    let match;
    while ((match = imageRegex.exec(content)) !== null) {
        mediaUrls.add(match[1]);
    }

    while ((match = videoRegex.exec(content)) !== null) {
        mediaUrls.add(match[1]);
    }

    const youtubeIds = new Map();
    while ((match = youtubeRegex.exec(content)) !== null) {
        mediaUrls.add(match[0]);
        youtubeIds.set(match[0], match[1]);
    }

    processedContent = processedContent.replace(urlRegex, (url) => {
        if (mediaUrls.has(url)) {
            return url;
        }
        return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="comment-link">${url}</a>`;
    });

    const imageMatches = content.match(imageRegex);
    if (imageMatches) {
        const embedsHtml = imageMatches.map(url =>
            `<div class="comment-media">
                <img src="${url}" alt="Embedded image" loading="lazy" onclick="window.open('${url}', '_blank')">
            </div>`
        ).join('');
        processedContent += embedsHtml;
    }

    const videoMatches = content.match(videoRegex);
    if (videoMatches) {
        const embedsHtml = videoMatches.map(url =>
            `<div class="comment-media">
                <video controls playsinline preload="metadata">
                    <source src="${url}" type="video/mp4">
                    <source src="${url}" type="video/webm">
                </video>
            </div>`
        ).join('');
        processedContent += embedsHtml;
    }

    youtubeIds.forEach((videoId, url) => {
        const embedHtml = `<div class="comment-media youtube-embed">
            <iframe src="https://www.youtube.com/embed/${videoId}" 
                    frameborder="0" 
                    allowfullscreen
                    loading="lazy">
            </iframe>
        </div>`;
        processedContent += embedHtml;
    });

    return processedContent;
}

// Add comment input box
function createCommentInput(replyTo = null) {
    const inputDiv = document.createElement('div');
    inputDiv.className = 'comment-input-container';
    inputDiv.id = replyTo ? `reply-input-${replyTo.id}` : 'main-comment-input';

    const placeholder = replyTo ? 'Write a reply...' : 'Add a comment...';
    const buttonText = replyTo ? 'Reply' : 'Comment';

    inputDiv.innerHTML = `
        <div class="comment-input-box">
            ${replyTo ? `
                <div class="replying-to">
                    Replying to @${replyTo.name || `User ${replyTo.pubkey.slice(0, 8)}`}
                    <button onclick="cancelReply('${replyTo.id}')" class="cancel-reply">×</button>
                </div>
            ` : ''}
            <textarea 
                class="comment-textarea" 
                placeholder="${placeholder}"
                rows="3"
                ${currentUser ? '' : 'disabled'}
            ></textarea>
            <div class="comment-input-actions">
                <button 
                    class="comment-submit-btn" 
                    onclick="submitComment(${replyTo ? `'${replyTo.id}', '${replyTo.pubkey}'` : 'null, null'})"
                    ${currentUser ? '' : 'disabled'}
                >
                    ${buttonText}
                </button>
            </div>
            ${!currentUser ? '<p class="comment-login-prompt">Please <a href="#" onclick="showLoginModal(); return false;" style="color: var(--accent); text-decoration: underline; cursor: pointer;">login</a> to comment</p>' : ''}
        </div>
    `;

    return inputDiv;
}

// Submit comment
async function submitComment(parentId, parentPubkey) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to comment', 'warning');
            return;
        }
    }

    // Check if user is blocked
    if (isPubkeyBlocked(currentUser.pubkey)) {
        showToast('Your account has been restricted', 'error');
        return;
    }

    const container = parentId ? document.getElementById(`reply-input-${parentId}`) : document.getElementById('main-comment-input');
    if (!container) return;

    const textarea = container.querySelector('.comment-textarea');
    const content = textarea.value.trim();

    if (!content) {
        showToast('Please write a comment', 'warning');
        return;
    }

    const button = container.querySelector('.comment-submit-btn');
    button.disabled = true;
    button.textContent = t('status.generatingPoW');

    try {
        const videoEventIds = [];
        const eventId = window.location.hash.split('/')[2];

        videoEventIds.push(eventId);

        const tags = [];

        videoEventIds.forEach(id => {
            tags.push(['e', id, '', 'root']);
        });

        if (parentId) {
            tags.push(['e', parentId, '', 'reply']);
            tags.push(['p', parentPubkey]);
        }

        const videoEvent = allEvents.get(eventId);
        if (videoEvent) {
            tags.push(['p', videoEvent.pubkey]);
        }

        const commentEvent = {
            kind: 1,
            pubkey: currentUser.pubkey, // Required for PoW calculation
            tags: tags,
            content: content,
            created_at: Math.floor(Date.now() / 1000)
        };

        // Generate proof of work (NIP-13) - this adds the nonce tag
        await generatePoW(commentEvent, MIN_POW_DIFFICULTY);

        button.textContent = t('status.posting');

        const signedEvent = await signEvent(commentEvent);
        const published = await publishEvent(signedEvent);

        if (published) {
            textarea.value = '';

            if (parentId) {
                cancelReply(parentId);
            }

            // Add the comment to the DOM immediately
            addCommentToDOM(signedEvent, parentId);
        } else {
            throw new Error('Failed to publish comment');
        }
    } catch (error) {
        console.error('Failed to post comment:', error);
        showToast('Failed to post comment. Please try again.', 'error');
    } finally {
        button.disabled = false;
        button.textContent = parentId ? 'Reply' : 'Comment';
    }
}

// Add comment to DOM without reloading
function addCommentToDOM(commentEvent, parentId = null) {
    // Store the event
    allEvents.set(commentEvent.id, commentEvent);

    // Get user profile
    const profile = profileCache.get(commentEvent.pubkey) || {};
    const displayName = profile.name || profile.display_name || `User ${commentEvent.pubkey.slice(0, 8)}`;
    const avatarUrl = profile.picture || profile.avatar || '';
    const nip05 = profile.nip05 || '';

    // Create comment node
    const commentNode = {
        ...commentEvent,
        children: [],
        depth: parentId ? 1 : 0
    };

    // Create the comment element
    const commentElement = createCommentElement(commentNode, profileCache, new Map());

    // Find where to insert the comment
    if (parentId) {
        // It's a reply - find the parent comment
        const parentComment = document.querySelector(`[data-comment-id="${parentId}"]`);
        if (parentComment) {
            let childrenContainer = parentComment.querySelector('.comment-children');
            if (!childrenContainer) {
                childrenContainer = document.createElement('div');
                childrenContainer.className = 'comment-children';
                parentComment.appendChild(childrenContainer);
            }

            // Update the depth if nested
            const parentDepth = parseInt(parentComment.dataset.depth || 0);
            commentElement.dataset.depth = Math.min(parentDepth + 1, 3);

            // Insert at the beginning of children (newest first)
            childrenContainer.insertBefore(commentElement, childrenContainer.firstChild);
        }
    } else {
        // It's a top-level comment
        const commentsContainer = document.getElementById('comments-container');
        if (commentsContainer) {
            // Remove "no comments" message if it exists
            const noCommentsMsg = commentsContainer.querySelector('p');
            if (noCommentsMsg && noCommentsMsg.textContent.includes('No comments yet')) {
                noCommentsMsg.remove();
            }

            // Insert at the beginning (newest first)
            commentsContainer.insertBefore(commentElement, commentsContainer.firstChild);
        }
    }

    // If profile is not cached, fetch it
    if (!profileCache.has(commentEvent.pubkey)) {
        fetchUserProfile(commentEvent.pubkey).then(profile => {
            if (profile) {
                updateCommentProfile(commentEvent.id, profile);
            }
        });
    }
}

// Update comment profile when fetched
function updateCommentProfile(commentId, profile) {
    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    if (!commentElement) return;

    const displayName = profile.name || profile.display_name || `User ${commentElement.querySelector('.comment-author-name').textContent}`;
    const avatarUrl = profile.picture || profile.avatar || '';
    const nip05 = profile.nip05 || '';

    // Update name
    const nameElement = commentElement.querySelector('.comment-author-name');
    if (nameElement) {
        nameElement.textContent = displayName;
    }

    // Update avatar
    const avatarElement = commentElement.querySelector('.comment-avatar');
    if (avatarElement && avatarUrl) {
        avatarElement.innerHTML = `<img src="${avatarUrl}" alt="${displayName}">`;
    }

    // Update nip05
    const authorInfo = commentElement.querySelector('.comment-author-info');
    if (authorInfo && nip05) {
        const existingNip05 = authorInfo.querySelector('.comment-author-nip05');
        if (!existingNip05) {
            const nip05Element = document.createElement('div');
            nip05Element.className = 'comment-author-nip05';
            nip05Element.textContent = nip05;
            authorInfo.appendChild(nip05Element);
        }
    }
}

// Reply to comment
function replyToComment(commentId, commentPubkey) {
    document.querySelectorAll('.comment-reply-box').forEach(box => box.remove());

    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    if (!commentElement) return;

    const authorName = commentElement.querySelector('.comment-author-name').textContent;

    const replyBox = document.createElement('div');
    replyBox.className = 'comment-reply-box';
    replyBox.id = `reply-box-${commentId}`;

    const replyInput = createCommentInput({
        id: commentId,
        pubkey: commentPubkey,
        name: authorName
    });

    replyBox.appendChild(replyInput);

    const commentContent = commentElement.querySelector('.comment-content');
    commentContent.appendChild(replyBox);

    replyBox.querySelector('.comment-textarea').focus();
}

// Cancel reply
function cancelReply(commentId) {
    const replyBox = document.getElementById(`reply-box-${commentId}`);
    if (replyBox) {
        replyBox.remove();
    }
}

// Like comment
async function likeComment(commentId) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to like comments', 'warning');
            return;
        }
    }

    const likeButton = document.querySelector(`.comment-like-btn[data-comment-id="${commentId}"]`);
    const dislikeButton = document.querySelector(`.comment-dislike-btn[data-comment-id="${commentId}"]`);
    if (!likeButton) return;

    const likeCountSpan = likeButton.querySelector('.like-count');
    const dislikeCountSpan = dislikeButton?.querySelector('.dislike-count');
    const currentLikes = likeCountSpan.textContent === 'Like' ? 0 : parseInt(likeCountSpan.textContent) || 0;
    const currentDislikes = dislikeCountSpan?.textContent === 'Dislike' ? 0 : parseInt(dislikeCountSpan?.textContent) || 0;
    const wasLiked = likeButton.classList.contains('active');
    const wasDisliked = dislikeButton?.classList.contains('active');

    // Get user's existing reaction from cache
    const commentReactions = currentCommentsState.reactions.get(commentId);
    const userReaction = commentReactions?.get(currentUser.pubkey);

    // Optimistically update UI
    if (wasLiked) {
        // Removing like
        likeButton.classList.remove('active');
        const newCount = Math.max(0, currentLikes - 1);
        likeCountSpan.textContent = newCount > 0 ? formatNumber(newCount) : 'Like';
    } else {
        // Adding like
        likeButton.classList.add('active');
        likeCountSpan.textContent = formatNumber(currentLikes + 1);
        // Remove dislike if present
        if (wasDisliked && dislikeButton && dislikeCountSpan) {
            dislikeButton.classList.remove('active');
            const newDislikeCount = Math.max(0, currentDislikes - 1);
            dislikeCountSpan.textContent = newDislikeCount > 0 ? formatNumber(newDislikeCount) : 'Dislike';
        }
    }

    try {
        let published = false;

        if (wasLiked && userReaction?.eventId) {
            // Remove like by publishing kind 5 deletion event
            const deleteEvent = {
                kind: 5,
                tags: [['e', userReaction.eventId]],
                content: 'Removed reaction',
                created_at: Math.floor(Date.now() / 1000)
            };
            const signedDelete = await signEvent(deleteEvent);
            published = await publishEvent(signedDelete);

            // Remove from local cache
            if (published && commentReactions) {
                commentReactions.delete(currentUser.pubkey);
            }
        } else {
            // Add like reaction
            const reactionEvent = {
                kind: 7,
                tags: [
                    ['e', commentId],
                    ['p', allEvents.get(commentId)?.pubkey || ''],
                    ['t', 'pv69420']
                ],
                content: '👍',
                created_at: Math.floor(Date.now() / 1000)
            };
            const signedEvent = await signEvent(reactionEvent);
            published = await publishEvent(signedEvent);

            // Update local cache
            if (published) {
                if (!currentCommentsState.reactions.has(commentId)) {
                    currentCommentsState.reactions.set(commentId, new Map());
                }
                currentCommentsState.reactions.get(commentId).set(currentUser.pubkey, {
                    eventId: signedEvent.id,
                    reaction: '👍',
                    timestamp: signedEvent.created_at,
                    pubkey: currentUser.pubkey,
                    hasPoW: validateEventPoW(signedEvent)
                });
            }
        }

        if (!published) {
            // Revert on failure
            if (wasLiked) {
                likeButton.classList.add('active');
                likeCountSpan.textContent = currentLikes > 0 ? formatNumber(currentLikes) : 'Like';
            } else {
                likeButton.classList.remove('active');
                likeCountSpan.textContent = currentLikes > 0 ? formatNumber(currentLikes) : 'Like';
                if (wasDisliked && dislikeButton && dislikeCountSpan) {
                    dislikeButton.classList.add('active');
                    dislikeCountSpan.textContent = currentDislikes > 0 ? formatNumber(currentDislikes) : 'Dislike';
                }
            }
            throw new Error('Failed to publish reaction');
        }
    } catch (error) {
        console.error('Failed to like comment:', error);
    }
}

// Dislike a comment
async function dislikeComment(commentId) {
    if (!currentUser) {
        if (!await ensureLoggedIn()) {
            showToast('Please login to dislike comments', 'warning');
            return;
        }
    }

    const dislikeButton = document.querySelector(`.comment-dislike-btn[data-comment-id="${commentId}"]`);
    const likeButton = document.querySelector(`.comment-like-btn[data-comment-id="${commentId}"]`);
    if (!dislikeButton) return;

    const dislikeCountSpan = dislikeButton.querySelector('.dislike-count');
    const likeCountSpan = likeButton?.querySelector('.like-count');
    const currentDislikes = dislikeCountSpan.textContent === 'Dislike' ? 0 : parseInt(dislikeCountSpan.textContent) || 0;
    const currentLikes = likeCountSpan?.textContent === 'Like' ? 0 : parseInt(likeCountSpan?.textContent) || 0;
    const wasDisliked = dislikeButton.classList.contains('active');
    const wasLiked = likeButton?.classList.contains('active');

    // Get user's existing reaction from cache
    const commentReactions = currentCommentsState.reactions.get(commentId);
    const userReaction = commentReactions?.get(currentUser.pubkey);

    // Optimistically update UI
    if (wasDisliked) {
        // Removing dislike
        dislikeButton.classList.remove('active');
        const newCount = Math.max(0, currentDislikes - 1);
        dislikeCountSpan.textContent = newCount > 0 ? formatNumber(newCount) : 'Dislike';
    } else {
        // Adding dislike
        dislikeButton.classList.add('active');
        dislikeCountSpan.textContent = formatNumber(currentDislikes + 1);
        // Remove like if present
        if (wasLiked && likeButton && likeCountSpan) {
            likeButton.classList.remove('active');
            const newLikeCount = Math.max(0, currentLikes - 1);
            likeCountSpan.textContent = newLikeCount > 0 ? formatNumber(newLikeCount) : 'Like';
        }
    }

    try {
        let published = false;

        if (wasDisliked && userReaction?.eventId) {
            // Remove dislike by publishing kind 5 deletion event
            const deleteEvent = {
                kind: 5,
                tags: [['e', userReaction.eventId]],
                content: 'Removed reaction',
                created_at: Math.floor(Date.now() / 1000)
            };
            const signedDelete = await signEvent(deleteEvent);
            published = await publishEvent(signedDelete);

            // Remove from local cache
            if (published && commentReactions) {
                commentReactions.delete(currentUser.pubkey);
            }
        } else {
            // Add dislike reaction
            const reactionEvent = {
                kind: 7,
                tags: [
                    ['e', commentId],
                    ['p', allEvents.get(commentId)?.pubkey || ''],
                    ['t', 'pv69420']
                ],
                content: '👎',
                created_at: Math.floor(Date.now() / 1000)
            };
            const signedEvent = await signEvent(reactionEvent);
            published = await publishEvent(signedEvent);

            // Update local cache
            if (published) {
                if (!currentCommentsState.reactions.has(commentId)) {
                    currentCommentsState.reactions.set(commentId, new Map());
                }
                currentCommentsState.reactions.get(commentId).set(currentUser.pubkey, {
                    eventId: signedEvent.id,
                    reaction: '👎',
                    timestamp: signedEvent.created_at,
                    pubkey: currentUser.pubkey,
                    hasPoW: validateEventPoW(signedEvent)
                });
            }
        }

        if (!published) {
            // Revert on failure
            if (wasDisliked) {
                dislikeButton.classList.add('active');
                dislikeCountSpan.textContent = currentDislikes > 0 ? formatNumber(currentDislikes) : 'Dislike';
            } else {
                dislikeButton.classList.remove('active');
                dislikeCountSpan.textContent = currentDislikes > 0 ? formatNumber(currentDislikes) : 'Dislike';
                if (wasLiked && likeButton && likeCountSpan) {
                    likeButton.classList.add('active');
                    likeCountSpan.textContent = currentLikes > 0 ? formatNumber(currentLikes) : 'Like';
                }
            }
            throw new Error('Failed to publish reaction');
        }
    } catch (error) {
        console.error('Failed to dislike comment:', error);
    }
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
    };
    return text.replace(/[&<>]/g, m => map[m]);
}

// Upload modal functions
let currentUploadType = 'video'; // 'video' or 'short'
let mediaRecorder = null;
let recordedChunks = [];
let recordingStream = null;
let recordingTimer = null;
let recordingSeconds = 0;

function showUploadModal(type = 'video') {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    // Check if user is blocked
    if (isPubkeyBlocked(currentUser.pubkey)) {
        showToast('Your account has been restricted from uploading', 'error');
        return;
    }

    currentUploadType = type;
    document.getElementById('uploadType').value = type;

    // Update modal title
    const modalTitle = document.getElementById('uploadModalTitle');
    if (modalTitle) {
        modalTitle.textContent = type === 'short' ? 'Create Short' : 'Upload Video';
    }

    // Show/hide recording option for shorts
    const recordOption = document.getElementById('recordOption');
    if (recordOption) {
        recordOption.style.display = type === 'short' ? 'block' : 'none';
    }

    // Update upload hint text
    const uploadHint = document.getElementById('uploadHint');
    if (uploadHint) {
        uploadHint.textContent = type === 'short'
            ? 'Vertical video, max 60 seconds'
            : 'MP4, AVI, MOV, etc (max 2GB input, will compress to <100MB)';
    }

    document.getElementById('uploadModal').classList.add('active');
}

// Back to create modal from upload modal
function backToCreateModal() {
    hideUploadModal();
    showCreateModal();
}

// Back to create modal from go live modal
function backToCreateModalFromLive() {
    hideGoLiveModal();
    showCreateModal();
}

function hideUploadModal() {
    document.getElementById('uploadModal').classList.remove('active');
    document.getElementById('uploadForm').reset();

    // Reset upload state
    resetUploadState();

    // Reset video file upload display
    const fileUpload = document.getElementById('fileUpload');
    if (fileUpload) {
        fileUpload.classList.remove('active');
        fileUpload.style.display = 'flex';
        fileUpload.innerHTML = `
            <svg width="48" height="48" viewBox="0 0 24 24" fill="currentColor" style="opacity: 0.5;">
                <path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v-2H5z"/>
            </svg>
            <p>Click to select video or drag and drop</p>
            <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem;">
                MP4, AVI, MOV, etc (max 2GB input, will compress to <100MB)
            </p>
        `;
    }

    // Reset thumbnail upload display
    const thumbnailUpload = document.getElementById('thumbnailUpload');
    if (thumbnailUpload) {
        thumbnailUpload.style.display = 'flex';
    }

    // Hide video upload progress and preview
    const videoUploadProgress = document.getElementById('videoUploadProgress');
    if (videoUploadProgress) {
        videoUploadProgress.style.display = 'none';
        document.getElementById('videoProgressFill').style.width = '0%';
        document.getElementById('videoUploadDetails').innerHTML = '';
    }
    const videoServerStatus = document.getElementById('videoServerStatus');
    if (videoServerStatus) {
        videoServerStatus.innerHTML = '';
    }
    // Clean up video preview
    const videoPreview = document.getElementById('videoPreview');
    const videoPlayer = document.getElementById('videoPreviewPlayer');
    if (videoPreview) {
        videoPreview.style.display = 'none';
    }
    if (videoPlayer) {
        videoPlayer.pause();
        if (videoPlayer.src && videoPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(videoPlayer.src);
        }
        videoPlayer.src = '';
    }

    // Hide thumbnail upload progress and preview
    const thumbnailUploadProgress = document.getElementById('thumbnailUploadProgress');
    if (thumbnailUploadProgress) {
        thumbnailUploadProgress.style.display = 'none';
        document.getElementById('thumbnailProgressFill').style.width = '0%';
    }
    const thumbnailServerStatus = document.getElementById('thumbnailServerStatus');
    if (thumbnailServerStatus) {
        thumbnailServerStatus.innerHTML = '';
    }
    // Clean up thumbnail preview
    const thumbnailPreview = document.getElementById('thumbnailPreview');
    const thumbnailImage = document.getElementById('thumbnailPreviewImage');
    if (thumbnailPreview) {
        thumbnailPreview.style.display = 'none';
    }
    if (thumbnailImage && thumbnailImage.src && thumbnailImage.src.startsWith('blob:')) {
        URL.revokeObjectURL(thumbnailImage.src);
        thumbnailImage.src = '';
    }

    // Reset publish button
    const publishBtn = document.getElementById('publishButton');
    const publishText = document.getElementById('publishButtonText');
    if (publishBtn && publishText) {
        publishBtn.disabled = true;
        publishBtn.classList.remove('ready');
        publishText.textContent = t('status.selectVideoAndThumbnail');
    }

    // Reset legacy elements
    document.getElementById('uploadProgress').style.display = 'none';
    const compressionProgress = document.getElementById('compressionProgress');
    if (compressionProgress) {
        compressionProgress.style.display = 'none';
    }
    const serverStatus = document.getElementById('serverStatus');
    if (serverStatus) {
        serverStatus.innerHTML = '';
    }

    // Clear file references
    window.droppedVideoFile = null;
    window.selectedVideoFile = null;

    // Reset recording state
    stopRecordingCleanup();

    // Reset recording UI
    const recordOption = document.getElementById('recordOption');
    if (recordOption) {
        recordOption.style.display = 'none';
    }
    const recordPreviewContainer = document.getElementById('recordPreviewContainer');
    if (recordPreviewContainer) {
        recordPreviewContainer.style.display = 'none';
    }
    const recordVideoBtn = document.getElementById('recordVideoBtn');
    if (recordVideoBtn) {
        recordVideoBtn.classList.remove('recording');
    }
    const recordBtnText = document.getElementById('recordBtnText');
    if (recordBtnText) {
        recordBtnText.textContent = t('button.recordFromCamera');
    }

    // Reset upload type
    currentUploadType = 'video';
}

// ===== Recording Functions for Shorts =====

function stopRecordingCleanup() {
    // Stop any active recording
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
    }
    mediaRecorder = null;
    recordedChunks = [];

    // Stop recording stream
    if (recordingStream) {
        recordingStream.getTracks().forEach(track => track.stop());
        recordingStream = null;
    }

    // Clear timer
    if (recordingTimer) {
        clearInterval(recordingTimer);
        recordingTimer = null;
    }
    recordingSeconds = 0;
}

async function toggleRecording() {
    const recordBtn = document.getElementById('recordVideoBtn');
    const recordBtnText = document.getElementById('recordBtnText');
    const previewContainer = document.getElementById('recordPreviewContainer');
    const preview = document.getElementById('recordPreview');

    if (!mediaRecorder || mediaRecorder.state === 'inactive') {
        // Start recording
        try {
            // Check if mediaDevices API is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert(t('alert.cameraNotSupported'));
                return;
            }

            // Update button to show we're requesting access
            recordBtnText.textContent = t('button.requestingCamera');

            // Request camera access with vertical video preference
            // We request directly without pre-checking enumerateDevices, as that can be
            // unreliable on some systems and may not show cameras until permission is granted
            const constraints = {
                video: {
                    facingMode: 'user',
                    width: { ideal: 1080 },
                    height: { ideal: 1920 },
                    aspectRatio: { ideal: 9/16 }
                },
                audio: true
            };

            recordingStream = await navigator.mediaDevices.getUserMedia(constraints);

            // Show preview
            preview.srcObject = recordingStream;
            previewContainer.style.display = 'block';

            // Setup media recorder
            const options = { mimeType: 'video/webm;codecs=vp9,opus' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm';
            }
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/mp4';
            }

            mediaRecorder = new MediaRecorder(recordingStream, options);
            recordedChunks = [];

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    recordedChunks.push(e.data);
                }
            };

            mediaRecorder.onstop = () => {
                handleRecordingComplete();
            };

            mediaRecorder.start(1000); // Collect data every second

            // Update UI
            recordBtn.classList.add('recording');
            recordBtnText.textContent = t('button.recording');

            // Start timer
            recordingSeconds = 0;
            updateRecordingTimer();
            recordingTimer = setInterval(() => {
                recordingSeconds++;
                updateRecordingTimer();

                // Auto-stop at 60 seconds
                if (recordingSeconds >= 60) {
                    stopRecording();
                }
            }, 1000);

        } catch (err) {
            console.error('Error accessing camera:', err);

            // Reset button text
            recordBtnText.textContent = t('button.recordFromCamera');

            // Provide specific error messages based on error type
            if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                alert(t('alert.noCameraFound'));
            } else if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                alert(t('alert.cameraAccessDenied'));
            } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                alert(t('alert.cameraInUse'));
            } else if (err.name === 'OverconstrainedError') {
                // Try again with simpler constraints
                try {
                    recordBtnText.textContent = t('button.requestingCamera');
                    recordingStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    preview.srcObject = recordingStream;
                    previewContainer.style.display = 'block';
                    const options = { mimeType: 'video/webm' };
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/mp4';
                    }
                    mediaRecorder = new MediaRecorder(recordingStream, options);
                    recordedChunks = [];
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) recordedChunks.push(e.data);
                    };
                    mediaRecorder.onstop = () => handleRecordingComplete();
                    mediaRecorder.start(1000);
                    recordBtn.classList.add('recording');
                    recordBtnText.textContent = t('button.recording');
                    recordingSeconds = 0;
                    updateRecordingTimer();
                    recordingTimer = setInterval(() => {
                        recordingSeconds++;
                        updateRecordingTimer();
                        if (recordingSeconds >= 60) stopRecording();
                    }, 1000);
                } catch (retryErr) {
                    recordBtnText.textContent = t('button.recordFromCamera');
                    alert(t('alert.cameraUnableAccess'));
                }
            } else {
                alert(t('alert.cameraUnableAccessWithError').replace('{error}', err.message));
            }
        }
    }
}

function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
    }

    // Stop timer
    if (recordingTimer) {
        clearInterval(recordingTimer);
        recordingTimer = null;
    }

    // Update UI
    const recordBtn = document.getElementById('recordVideoBtn');
    const recordBtnText = document.getElementById('recordBtnText');
    if (recordBtn) recordBtn.classList.remove('recording');
    if (recordBtnText) recordBtnText.textContent = t('button.recordFromCamera');
}

function updateRecordingTimer() {
    const timerEl = document.getElementById('recordTimer');
    if (timerEl) {
        const mins = Math.floor(recordingSeconds / 60);
        const secs = recordingSeconds % 60;
        timerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        timerEl.classList.toggle('recording', recordingSeconds > 0);
    }
}

function handleRecordingComplete() {
    // Stop stream
    if (recordingStream) {
        recordingStream.getTracks().forEach(track => track.stop());
        recordingStream = null;
    }

    // Hide preview
    const previewContainer = document.getElementById('recordPreviewContainer');
    const preview = document.getElementById('recordPreview');
    if (previewContainer) previewContainer.style.display = 'none';
    if (preview) preview.srcObject = null;

    // Create video file from recorded chunks
    if (recordedChunks.length > 0) {
        const blob = new Blob(recordedChunks, { type: recordedChunks[0].type || 'video/webm' });
        const file = new File([blob], `short_${Date.now()}.webm`, { type: blob.type });

        // Trigger the video file selection handler
        const videoInput = document.getElementById('videoFile');
        if (videoInput) {
            // Create a DataTransfer to simulate file selection
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            videoInput.files = dataTransfer.files;

            // Trigger change event
            const event = new Event('change', { bubbles: true });
            videoInput.dispatchEvent(event);
        }
    }

    // Reset recording state
    recordedChunks = [];
    mediaRecorder = null;
}

// Update publish button state based on upload status
function updatePublishButton() {
    const publishBtn = document.getElementById('publishButton');
    const publishText = document.getElementById('publishButtonText');
    if (!publishBtn || !publishText) return;

    const videoReady = uploadState.video.status === 'complete';
    const thumbnailReady = uploadState.thumbnail.status === 'complete';
    const videoProcessing = ['compressing', 'uploading'].includes(uploadState.video.status);
    const thumbnailProcessing = uploadState.thumbnail.status === 'uploading';

    // Video is required, thumbnail is optional (will be auto-generated if not provided)
    if (videoReady && !thumbnailProcessing) {
        publishBtn.disabled = false;
        publishBtn.classList.add('ready');
        publishText.textContent = thumbnailReady ? 'Publish Video' : 'Publish Video (auto-thumbnail)';
    } else if (videoProcessing || thumbnailProcessing) {
        publishBtn.disabled = true;
        publishBtn.classList.remove('ready');
        if (videoProcessing && thumbnailProcessing) {
            publishText.textContent = t('status.processingVideoAndThumbnail');
        } else if (videoProcessing) {
            publishText.textContent = uploadState.video.status === 'compressing' ? t('status.compressingVideo') : t('status.uploadingVideo');
        } else {
            publishText.textContent = t('status.uploadingThumbnail');
        }
    } else if (uploadState.video.status === 'error' || uploadState.thumbnail.status === 'error') {
        publishBtn.disabled = true;
        publishBtn.classList.remove('ready');
        publishText.textContent = t('status.uploadFailed');
    } else {
        publishBtn.disabled = true;
        publishBtn.classList.remove('ready');
        if (!uploadState.video.file) {
            publishText.textContent = t('status.selectVideoToUpload');
        } else {
            publishText.textContent = t('status.waitingForVideoUpload');
        }
    }
}

// Update video upload UI
function updateVideoUploadUI(status, progress, details = '') {
    const progressDiv = document.getElementById('videoUploadProgress');
    const statusSpan = document.getElementById('videoUploadStatus');
    const progressFill = document.getElementById('videoProgressFill');
    const detailsDiv = document.getElementById('videoUploadDetails');

    if (!progressDiv) return;

    progressDiv.style.display = 'block';
    progressFill.style.width = `${progress}%`;

    statusSpan.className = 'upload-item-status';
    switch (status) {
        case 'compressing':
            statusSpan.textContent = `Compressing... ${progress}%`;
            statusSpan.classList.add('processing');
            break;
        case 'uploading':
            statusSpan.textContent = `Uploading... ${progress}%`;
            statusSpan.classList.add('processing');
            break;
        case 'complete':
            statusSpan.textContent = t('status.ready');
            statusSpan.classList.add('success');
            progressFill.style.width = '100%';
            break;
        case 'error':
            statusSpan.textContent = t('status.failed');
            statusSpan.classList.add('error');
            break;
        default:
            statusSpan.textContent = status;
    }

    if (details) {
        detailsDiv.innerHTML = details;
    }

    updatePublishButton();
}

// Update thumbnail upload UI
function updateThumbnailUploadUI(status, progress) {
    const progressDiv = document.getElementById('thumbnailUploadProgress');
    const statusSpan = document.getElementById('thumbnailUploadStatus');
    const progressFill = document.getElementById('thumbnailProgressFill');

    if (!progressDiv) return;

    progressDiv.style.display = 'block';
    progressFill.style.width = `${progress}%`;

    statusSpan.className = 'upload-item-status';
    switch (status) {
        case 'uploading':
            statusSpan.textContent = `Uploading... ${progress}%`;
            statusSpan.classList.add('processing');
            break;
        case 'complete':
            statusSpan.textContent = t('status.ready');
            statusSpan.classList.add('success');
            progressFill.style.width = '100%';
            break;
        case 'error':
            statusSpan.textContent = t('status.failed');
            statusSpan.classList.add('error');
            break;
        default:
            statusSpan.textContent = status;
    }

    updatePublishButton();
}

// Process and upload video immediately
async function processAndUploadVideo(file) {
    const maxFinalSize = 100 * 1024 * 1024; // 100MB
    const fileSizeMB = file.size / (1024 * 1024);

    uploadState.video.file = file;
    uploadState.video.status = 'pending';
    uploadState.video.size = file.size;

    // Get video metadata
    try {
        const metadata = await VideoCompressor.getVideoMetadata(file);
        uploadState.video.duration = metadata.duration;
        uploadState.video.dimensions = { width: metadata.width, height: metadata.height };

        const detailsHtml = `${metadata.width}x${metadata.height} • ${formatDuration(Math.floor(metadata.duration))} • ${fileSizeMB.toFixed(1)}MB`;
        updateVideoUploadUI('Preparing...', 0, detailsHtml);
    } catch (e) {
        console.log('Could not read video metadata:', e);
        updateVideoUploadUI('Preparing...', 0, `${fileSizeMB.toFixed(1)}MB`);
    }

    let fileToUpload = file;

    // Compress if needed
    if (file.size > maxFinalSize) {
        uploadState.video.status = 'compressing';

        // Check iOS compatibility before starting compression
        const iosCheck = VideoCompressor.checkiOSCompatibility();
        let warningText = '';
        if (!iosCheck.supported) {
            warningText = '<br><span style="color: var(--warning-color);">Note: Your browser will output WebM format (may not play on iOS). For iOS-compatible MP4, use Chrome on Windows/Mac.</span>';
            console.warn('iOS-compatible encoding not supported in this browser');
        }

        updateVideoUploadUI('compressing', 5, `Compressing ${fileSizeMB.toFixed(1)}MB to <100MB...${warningText}`);

        // Always use high quality
        window.suggestedCompressionQuality = 'high';
        window.userSelectedQuality = 'high';

        try {
            fileToUpload = await VideoCompressor.compressVideo(file, {
                maxSizeMB: 100,
                onProgress: (info) => {
                    let progress = 5;
                    let details = '';

                    switch (info.stage) {
                        case 'analyzing':
                            progress = 5;
                            details = 'Analyzing video content...';
                            break;
                        case 'calibrating':
                            progress = 10;
                            details = 'Calibrating encoder settings...';
                            break;
                        case 'preparing':
                            progress = 15;
                            details = `Preparing compression (${info.quality} quality)...`;
                            break;
                        case 'compressing':
                            progress = info.progress || 20;
                            details = `${info.currentTime || 0}s / ${info.duration || '?'}s`;
                            if (info.currentSize) {
                                details += ` • Current: ${info.currentSize}MB`;
                            }
                            break;
                        case 'retrying':
                            details = info.message || 'Adjusting settings...';
                            break;
                        case 'complete':
                            progress = 100;
                            const savedPct = ((1 - info.compressionRatio) * 100).toFixed(0);
                            details = `Compressed: ${(info.compressedSize / 1024 / 1024).toFixed(1)}MB (${savedPct}% smaller)`;
                            break;
                    }

                    updateVideoUploadUI('compressing', Math.min(progress, 95), details);
                }
            });

            const compressedSizeMB = fileToUpload.size / (1024 * 1024);
            if (compressedSizeMB > 100) {
                throw new Error(`Compression failed: ${compressedSizeMB.toFixed(1)}MB exceeds 100MB limit`);
            }

            uploadState.video.size = fileToUpload.size;
            uploadState.video.type = fileToUpload.type;
        } catch (error) {
            console.error('Compression failed:', error);
            uploadState.video.status = 'error';
            uploadState.video.error = error.message;
            updateVideoUploadUI('error', 0, `Compression failed: ${error.message}`);
            return;
        }
    }

    // Upload the file
    uploadState.video.status = 'uploading';
    updateVideoUploadUI('uploading', 0, 'Uploading to blossom servers...');

    try {
        const result = await uploadToBlossom(
            fileToUpload,
            BLOSSOM_SERVERS,
            'videoServerStatus',
            (progress, completed, total) => {
                updateVideoUploadUI('uploading', progress, `Uploading to blossom servers... (${completed}/${total})`);
            }
        );

        if (result.success && result.url) {
            uploadState.video.status = 'complete';
            uploadState.video.url = result.url;
            uploadState.video.hash = result.hash;
            uploadState.video.mirrors = result.mirrors || []; // Store all successful upload URLs
            uploadedVideoHash = result.hash;

            const finalSizeMB = (fileToUpload.size / 1024 / 1024).toFixed(1);
            const mirrorCount = result.mirrors?.length || 1;
            updateVideoUploadUI('complete', 100, `${finalSizeMB}MB • ${mirrorCount} server${mirrorCount > 1 ? 's' : ''} • Ready to publish`);

            // Show video preview
            showVideoPreview(fileToUpload);
        } else {
            throw new Error(result.error || 'Upload failed');
        }
    } catch (error) {
        console.error('Upload failed:', error);
        uploadState.video.status = 'error';
        uploadState.video.error = error.message;
        updateVideoUploadUI('error', 0, `Upload failed: ${error.message}`);
    }
}

// Show video preview after successful upload
function showVideoPreview(file) {
    const previewDiv = document.getElementById('videoPreview');
    const videoPlayer = document.getElementById('videoPreviewPlayer');

    if (previewDiv && videoPlayer) {
        // Revoke any existing URL
        if (videoPlayer.src && videoPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(videoPlayer.src);
        }

        // Create new preview URL
        const previewUrl = URL.createObjectURL(file);
        videoPlayer.src = previewUrl;
        previewDiv.style.display = 'block';

        // Store for cleanup
        uploadState.video.previewUrl = previewUrl;
    }
}

// Delete video upload and reset
function deleteVideoUpload() {
    // Revoke preview URL
    const videoPlayer = document.getElementById('videoPreviewPlayer');
    if (videoPlayer && videoPlayer.src) {
        videoPlayer.pause();
        if (videoPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(videoPlayer.src);
        }
        videoPlayer.src = '';
    }

    // Hide preview
    const previewDiv = document.getElementById('videoPreview');
    if (previewDiv) {
        previewDiv.style.display = 'none';
    }

    // Reset upload state for video
    uploadState.video = {
        file: null,
        status: 'pending',
        progress: 0,
        url: null,
        hash: null,
        error: null,
        size: 0,
        type: null,
        duration: null,
        dimensions: null,
        previewUrl: null,
        mirrors: []
    };
    uploadedVideoHash = null;

    // Reset UI elements
    const fileUpload = document.getElementById('fileUpload');
    if (fileUpload) {
        fileUpload.style.display = 'flex';
    }

    const videoUploadProgress = document.getElementById('videoUploadProgress');
    if (videoUploadProgress) {
        videoUploadProgress.style.display = 'none';
    }

    document.getElementById('videoProgressFill').style.width = '0%';
    document.getElementById('videoUploadDetails').innerHTML = '';
    document.getElementById('videoServerStatus').innerHTML = '';

    // Reset file input
    document.getElementById('videoFile').value = '';
    window.selectedVideoFile = null;

    // Update publish button
    updatePublishButton();
}

// Upload thumbnail immediately
async function uploadThumbnail(file) {
    uploadState.thumbnail.file = file;
    uploadState.thumbnail.status = 'uploading';

    updateThumbnailUploadUI('uploading', 10);

    try {
        // Validate thumbnail orientation matches video type if video has been uploaded
        if (uploadState.video.status === 'complete' && uploadState.video.dimensions) {
            const thumbnailDimensions = await getImageDimensions(file);
            const videoIsShort = isVideoShort(
                uploadState.video.dimensions.width,
                uploadState.video.dimensions.height,
                uploadState.video.duration
            );

            if (!isThumbnailOrientationValid(thumbnailDimensions.width, thumbnailDimensions.height, videoIsShort)) {
                uploadState.thumbnail.status = 'error';
                uploadState.thumbnail.error = 'Thumbnail orientation mismatch';
                updateThumbnailUploadUI('error', 0);

                if (videoIsShort) {
                    showToast('Thumbnail must be vertical (portrait) to match your Short video', 'error');
                } else {
                    showToast('Thumbnail must be horizontal (landscape) to match your video', 'error');
                }
                return;
            }
        }

        const result = await uploadToBlossom(
            file,
            BLOSSOM_SERVERS,
            'thumbnailServerStatus',
            (progress, completed, total) => {
                updateThumbnailUploadUI('uploading', progress);
                const statusSpan = document.getElementById('thumbnailUploadStatus');
                if (statusSpan) {
                    statusSpan.textContent = `Uploading... (${completed}/${total} servers)`;
                }
            }
        );

        if (result.success && result.url) {
            uploadState.thumbnail.status = 'complete';
            uploadState.thumbnail.url = result.url;
            updateThumbnailUploadUI('complete', 100);

            // Show thumbnail preview
            showThumbnailPreview(file);
        } else {
            throw new Error(result.error || 'Upload failed');
        }
    } catch (error) {
        console.error('Thumbnail upload failed:', error);
        uploadState.thumbnail.status = 'error';
        uploadState.thumbnail.error = error.message;
        updateThumbnailUploadUI('error', 0);
    }
}

// Show thumbnail preview after successful upload
function showThumbnailPreview(file) {
    const previewDiv = document.getElementById('thumbnailPreview');
    const previewImage = document.getElementById('thumbnailPreviewImage');

    if (previewDiv && previewImage) {
        // Revoke any existing URL
        if (previewImage.src && previewImage.src.startsWith('blob:')) {
            URL.revokeObjectURL(previewImage.src);
        }

        // Create new preview URL
        const previewUrl = URL.createObjectURL(file);
        previewImage.src = previewUrl;
        previewDiv.style.display = 'block';

        // Store for cleanup
        uploadState.thumbnail.previewUrl = previewUrl;
    }
}

// Delete thumbnail upload and reset
function deleteThumbnailUpload() {
    // Revoke preview URL
    const previewImage = document.getElementById('thumbnailPreviewImage');
    if (previewImage && previewImage.src && previewImage.src.startsWith('blob:')) {
        URL.revokeObjectURL(previewImage.src);
        previewImage.src = '';
    }

    // Hide preview
    const previewDiv = document.getElementById('thumbnailPreview');
    if (previewDiv) {
        previewDiv.style.display = 'none';
    }

    // Reset upload state for thumbnail
    uploadState.thumbnail = {
        file: null,
        status: 'pending',
        progress: 0,
        url: null,
        error: null,
        previewUrl: null
    };

    // Reset UI elements
    const thumbnailUpload = document.getElementById('thumbnailUpload');
    if (thumbnailUpload) {
        thumbnailUpload.style.display = 'flex';
    }

    const thumbnailUploadProgress = document.getElementById('thumbnailUploadProgress');
    if (thumbnailUploadProgress) {
        thumbnailUploadProgress.style.display = 'none';
    }

    document.getElementById('thumbnailProgressFill').style.width = '0%';
    document.getElementById('thumbnailServerStatus').innerHTML = '';

    // Reset file input
    document.getElementById('thumbnailFile').value = '';

    // Update publish button
    updatePublishButton();
}

// Reset upload state
function resetUploadState() {
    uploadState.video = {
        file: null,
        status: 'pending',
        progress: 0,
        url: null,
        hash: null,
        error: null,
        size: 0,
        type: null,
        duration: null,
        dimensions: null,
        mirrors: []
    };
    uploadState.thumbnail = {
        file: null,
        status: 'pending',
        progress: 0,
        url: null,
        error: null
    };
    uploadState.preview = {
        file: null,
        status: 'pending',
        progress: 0,
        url: null,
        error: null
    };
    uploadState.draftId = null;
    uploadedVideoHash = null;
    window.userSelectedQuality = null;
    window.suggestedCompressionQuality = null;
}

// Handle file selection - now starts upload immediately
async function handleFileSelect(event) {
    const input = event.target;
    const file = input.files[0];
    if (!file) return;

    // Allow up to 2GB input files (they will be compressed)
    const maxInputSize = 2 * 1024 * 1024 * 1024; // 2GB

    if (file.size > maxInputSize) {
        showToast(`File size must be less than 2GB. Your file is ${(file.size / 1024 / 1024).toFixed(1)}MB.`, 'error', 5000);
        input.value = '';
        return;
    }

    if (input.id === 'videoFile') {
        const allowedVideoTypes = [
            'video/mp4',
            'video/webm',
            'video/mov',
            'video/avi',
            'video/mkv',
            'video/wmv',
            'video/quicktime'
        ];

        const fileType = file.type || 'video/' + file.name.split('.').pop().toLowerCase();

        if (!allowedVideoTypes.some(type => fileType.includes(type.split('/')[1]))) {
            showToast('Invalid video file type. Please upload a video file (mp4, webm, mov, avi, mkv, wmv)', 'error');
            input.value = '';
            return;
        }

        // If uploading via Create Short modal, validate that video is vertical
        if (currentUploadType === 'short') {
            const isVertical = await validateVideoIsVertical(file);
            if (!isVertical) {
                showToast('This video appears to be horizontal (landscape). Shorts must be vertical (portrait) videos. Please use "Upload Video" for horizontal videos.', 'error', 7000);
                input.value = '';
                return;
            }
        }

        // Hide the file upload drop zone, show progress
        const fileUpload = document.getElementById('fileUpload');
        fileUpload.style.display = 'none';

        // Update filename in progress UI
        document.getElementById('videoFileName').textContent = file.name;
        document.getElementById('videoUploadProgress').style.display = 'block';

        // Store reference
        window.selectedVideoFile = file;

        // Start processing and upload immediately (don't await - let it run in background)
        processAndUploadVideo(file);

    } else if (input.id === 'thumbnailFile') {
        const allowedImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!allowedImageTypes.includes(file.type)) {
            showToast('Invalid thumbnail file type. Please upload an image file (jpg, png, gif, webp)', 'error');
            input.value = '';
            return;
        }

        // Hide the thumbnail drop zone, show progress
        const thumbnailUpload = document.getElementById('thumbnailUpload');
        thumbnailUpload.style.display = 'none';

        // Update filename in progress UI
        document.getElementById('thumbnailFileName').textContent = file.name;
        document.getElementById('thumbnailUploadProgress').style.display = 'block';

        // Start upload immediately
        uploadThumbnail(file);
    }
}

// Calculate SHA-256 hash
async function calculateSHA256(file) {
    const buffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
}

// Create Blossom authorization event
async function createBlossomAuthEvent(hash, server) {
    const expiration = Math.floor(Date.now() / 1000) + 60;
    const authEvent = {
        kind: 24242,
        content: `Upload ${hash}`,
        tags: [
            ['t', 'upload'],
            ['x', hash],
            ['expiration', expiration.toString()],
            ['client', 'Plebs']
        ],
        created_at: Math.floor(Date.now() / 1000)
    };

    const signedEvent = await signEvent(authEvent);
    return signedEvent;
}

// Upload to Blossom with proper authentication
async function uploadToBlossom(file, servers = BLOSSOM_SERVERS, statusElementId = 'serverStatus', onProgress = null) {
    const hash = await calculateSHA256(file);
    const successfulUploads = [];
    let primaryUrl = null;
    const totalServers = servers.length;

    const serverStatusDiv = document.getElementById(statusElementId) || document.getElementById('serverStatus');
    if (serverStatusDiv) {
        serverStatusDiv.innerHTML = '';
    }

    // Report initial progress (hash calculation complete)
    if (onProgress) {
        onProgress(10, 0, totalServers);
    }

    for (let i = 0; i < servers.length; i++) {
        const server = servers[i];
        try {
            const authEvent = await createBlossomAuthEvent(hash, server);
            const authHeader = btoa(JSON.stringify(authEvent));

            const response = await fetch(`${server}/upload`, {
                method: 'PUT',
                body: file,
                headers: {
                    'Content-Type': file.type,
                    'Authorization': `Nostr ${authHeader}`
                }
            });

            if (response.ok) {
                const result = await response.json();
                const url = result.url || `${server}/${hash}`;
                successfulUploads.push({ server, url });

                if (!primaryUrl) {
                    primaryUrl = url;
                }

                console.log(`Successfully uploaded to ${server}`);

                // Create a status element for the current server
                if (serverStatusDiv) {
                    const serverStatus = document.createElement('div');
                    serverStatus.classList.add('server');
                    serverStatus.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z" />
                        </svg>
                        ${server.replace('https://', '')}
                    `;
                    serverStatusDiv.appendChild(serverStatus);
                }
            } else {
                console.error(`Upload to ${server} failed with status ${response.status}`);

                // Create a status element for the current server with failure status
                if (serverStatusDiv) {
                    const serverStatus = document.createElement('div');
                    serverStatus.classList.add('server', 'failure');
                    serverStatus.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
                        </svg>
                        ${server.replace('https://', '')}
                    `;
                    serverStatusDiv.appendChild(serverStatus);
                }
            }
        } catch (error) {
            console.error(`Failed to upload to ${server}:`, error);

            // Create a status element for the current server with failure status
            if (serverStatusDiv) {
                const serverStatus = document.createElement('div');
                serverStatus.classList.add('server', 'failure');
                serverStatus.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" />
                    </svg>
                    ${server.replace('https://', '')}
                `;
                serverStatusDiv.appendChild(serverStatus);
            }
        }

        // Report progress after each server attempt
        if (onProgress) {
            const completedServers = i + 1;
            // Progress goes from 10% to 100% as servers complete
            const progress = 10 + Math.round((completedServers / totalServers) * 90);
            onProgress(progress, completedServers, totalServers);
        }
    }

    if (successfulUploads.length > 0) {
        return {
            success: true,
            hash: hash,
            url: primaryUrl,
            server: successfulUploads[0].server,
            mirrors: successfulUploads
        };
    }

    return { success: false, error: 'Failed to upload to all servers' };
}

// Show ratioed modal
function showRatioedModal(eventId, type = 'video') {
    pendingRatioedAction = { eventId, type };
    document.getElementById('ratioedModal').classList.add('active');
}

// Proceed with ratioed video
function proceedRatioed() {
    if (pendingRatioedAction) {
        const { eventId, type } = pendingRatioedAction;
        const rememberChoice = document.getElementById('rememberCommunityWarning').checked;

        if (rememberChoice) {
            localStorage.setItem('allowCommunityWarning', 'true');
        }

        sessionRatioedAllowed.add(eventId);
        document.getElementById('ratioedModal').classList.remove('active');
        pendingRatioedAction = null;

        if (type === 'live') {
            // Handle live stream
            const needsHashChange = !window.location.hash.includes(`/live/${eventId}`);

            if (needsHashChange) {
                window.location.hash = `/live/${eventId}`;
            } else {
                document.getElementById('mainContent').innerHTML = '<div class="spinner"></div>';
                setTimeout(() => {
                    playLiveStream(eventId, false, true);
                }, 10);
            }
        } else {
            // Handle video (default)
            const needsHashChange = !window.location.hash.includes(`/video/${eventId}`);

            if (needsHashChange) {
                window.location.hash = `/video/${eventId}`;
            } else {
                document.getElementById('mainContent').innerHTML = '<div class="spinner"></div>';
                setTimeout(() => {
                    playVideo(eventId, false, true);
                }, 10);
            }
        }
    }
}

// Cancel ratioed
function cancelRatioed() {
    document.getElementById('ratioedModal').classList.remove('active');
    pendingRatioedAction = null;
    document.getElementById('rememberCommunityWarning').checked = false;
    if (window.location.hash.startsWith('#/video/') || window.location.hash.startsWith('#/live/')) {
        navigateTo('/');
    }
}

// Show NSFW modal
function showNSFWModal(action, eventId) {
    pendingNSFWAction = { action, eventId };
    document.getElementById('nsfwModal').classList.add('active');
}

// Confirm NSFW
async function confirmNSFW() {
    const rememberChoice = document.getElementById('rememberNSFW').checked;

    if (rememberChoice) {
        localStorage.setItem('allowNSFW', 'true');
    }

    sessionNSFWAllowed = true;

    document.getElementById('nsfwModal').classList.remove('active');

    if (pendingNSFWAction && pendingNSFWAction.action === 'playVideo') {
        const eventId = pendingNSFWAction.eventId;
        pendingNSFWAction = null;

        // Check if we need to change the URL (hashchange will trigger playVideo via handleRoute)
        const needsHashChange = !window.location.hash.includes(`/video/${eventId}`);

        if (needsHashChange) {
            // Setting hash triggers hashchange -> handleRoute -> playVideo
            // No need to call playVideo again
            window.location.hash = `/video/${eventId}`;
        } else {
            // Already on this video page, call playVideo directly
            document.getElementById('mainContent').innerHTML = '<div class="spinner"></div>';
            setTimeout(() => {
                playVideo(eventId, true, false);
            }, 10);
        }
    } else if (pendingNSFWAction && pendingNSFWAction.action === 'playLive') {
        const eventId = pendingNSFWAction.eventId;
        pendingNSFWAction = null;

        // Check if we need to change the URL (hashchange will trigger playLiveStream via handleRoute)
        const needsHashChange = !window.location.hash.includes(`/live/${eventId}`);

        if (needsHashChange) {
            window.location.hash = `/live/${eventId}`;
        } else {
            // Already on this live page, call playLiveStream directly
            document.getElementById('mainContent').innerHTML = '<div class="spinner"></div>';
            setTimeout(() => {
                playLiveStream(eventId, true, false);
            }, 10);
        }
    }
}

// Cancel NSFW
function cancelNSFW() {
    document.getElementById('nsfwModal').classList.remove('active');
    pendingNSFWAction = null;
    document.getElementById('rememberNSFW').checked = false;
    if (window.location.hash.startsWith('#/video/') || window.location.hash.startsWith('#/live/')) {
        navigateTo('/');
    }
}

// NIP-56 Report functions
let pendingReport = null;

// Show report modal
// reportType: 'video' (default), 'comment', 'user'
function showReportModal(eventId, pubkey, reportType = 'video') {
    if (!currentUser) {
        showToast('Please log in to report content', 'error');
        return;
    }

    pendingReport = { eventId, pubkey };

    // Update modal title and description based on report type
    const titleEl = document.getElementById('reportModalTitle');
    const descEl = document.getElementById('reportModalDescription');
    if (titleEl && descEl) {
        switch (reportType) {
            case 'comment':
                titleEl.textContent = t('report.titleComment');
                descEl.textContent = t('report.descComment');
                break;
            case 'user':
                titleEl.textContent = t('report.titleUser');
                descEl.textContent = t('report.descUser');
                break;
            default:
                titleEl.textContent = t('report.titleVideo');
                descEl.textContent = t('report.descVideo');
        }
    }

    // Reset form
    const radioButtons = document.querySelectorAll('input[name="reportType"]');
    radioButtons.forEach(rb => rb.checked = false);
    document.getElementById('reportReason').value = '';

    document.getElementById('reportModal').classList.add('active');
}

// Cancel report
function cancelReport() {
    document.getElementById('reportModal').classList.remove('active');
    pendingReport = null;
}

// Submit report (NIP-56 kind 1984)
async function submitReport() {
    if (!pendingReport || !currentUser) {
        showToast('Unable to submit report', 'error');
        return;
    }

    const selectedType = document.querySelector('input[name="reportType"]:checked');
    if (!selectedType) {
        showToast('Please select a report reason', 'error');
        return;
    }

    const reportType = selectedType.value;
    const additionalReason = document.getElementById('reportReason').value.trim();

    const submitBtn = document.getElementById('submitReportBtn');
    submitBtn.disabled = true;
    submitBtn.textContent = t('button.submitting');

    try {
        // Build NIP-56 kind 1984 event
        const tags = [];

        // Only add event tag if we're reporting a specific event (not just a user)
        if (pendingReport.eventId) {
            tags.push(['e', pendingReport.eventId, reportType]);
        }

        // Always report the pubkey
        tags.push(['p', pendingReport.pubkey, reportType]);

        // Add L and l tags for NIP-32 label
        tags.push(['L', 'NIP-56']);
        tags.push(['l', reportType, 'NIP-56']);

        const content = additionalReason || `Reported for: ${reportType}`;

        const event = {
            kind: 1984,
            created_at: Math.floor(Date.now() / 1000),
            tags: tags,
            content: content
        };

        // Sign the event
        const signedEvent = await signEvent(event);
        if (!signedEvent) {
            throw new Error('Failed to sign event');
        }

        // Publish to relays using the existing publishEvent function
        const published = await publishEvent(signedEvent);

        if (published) {
            showToast('Report submitted successfully', 'success');
            cancelReport();
        } else {
            throw new Error('Failed to publish to any relay');
        }

    } catch (error) {
        console.error('Failed to submit report:', error);
        showToast('Failed to submit report: ' + error.message, 'error');
    } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = t('report.submit');
    }
}

// Parse video event
function parseVideoEvent(event) {
    if (event.kind !== 1) {
        return null;
    }

    const tags = event.tags || [];

    if (!tags.some(tag => tag[0] === 't' && tag[1] === 'pv69420')) {
        return null;
    }

    const videoData = {
        title: '',
        description: event.content || '',
        hash: '',
        url: '',
        thumbnail: '',
        duration: 0,
        tags: [],
        author: event.pubkey
    };

    for (const tag of tags) {
        switch (tag[0]) {
            case 'title':
                videoData.title = tag[1];
                break;
            case 'x':
                videoData.hash = tag[1];
                break;
            case 'url':
                videoData.url = tag[1];
                break;
            case 'thumb':
                videoData.thumbnail = tag[1];
                break;
            case 'duration':
                videoData.duration = parseInt(tag[1]);
                break;
            case 't':
                if (tag[1] && tag[1] !== 'pv69420') {
                    videoData.tags.push(tag[1]);
                }
                break;
        }
    }

    // If we have a title from the tags, we need to strip it from the description
    if (videoData.title && videoData.description) {
        const parts = videoData.description.split('\n\n');

        if (parts.length > 1) {
            const firstPart = parts[0];

            const cleanFirstPart = firstPart.replace(/^[^\w\s]+\s*/, '').trim();

            if (cleanFirstPart === videoData.title || firstPart.includes(videoData.title)) {
                videoData.description = parts.slice(1).join('\n\n').trim();
            }
        } else {
            const cleanContent = videoData.description.replace(/^[^\w\s]+\s*/, '').trim();
            if (cleanContent.startsWith(videoData.title)) {
                const titleIndex = videoData.description.indexOf(videoData.title);
                const afterTitle = videoData.description.substring(titleIndex + videoData.title.length).trim();
                videoData.description = afterTitle.startsWith('\n') ? afterTitle.substring(1).trim() : afterTitle;
            }
        }
    }

    if (!videoData.title && videoData.description) {
        const lines = videoData.description.split('\n');

        if (lines[0]) {
            videoData.title = lines[0].replace(/^[^\w\s]+\s*/, '').trim();

            if (lines.length > 1) {
                videoData.description = lines.slice(1).join('\n').trim();
                videoData.description = videoData.description.replace(/^\n+/, '');
            } else {
                videoData.description = '';
            }
        }
    }

    // Remove any video URLs from the description
    const videoExtensions = ['mp4', 'mov', 'webm', 'avi', 'mkv', 'flv', 'wmv'];
    const extensionsPattern = videoExtensions.join('|');

    const urlRegex = new RegExp(
        `https?:\\/\\/[^\\s]*([a-f0-9]{64})\\.(${extensionsPattern})(\\?[^\\s]*)?`,
        'gi'
    );

    videoData.description = videoData.description.replace(urlRegex, '').trim();

    // Also remove the exact URL if it matches
    if (videoData.url && videoData.description.includes(videoData.url)) {
        videoData.description = videoData.description.replace(videoData.url, '').trim();
    }

    return videoData.title ? videoData : null;
}

// Check if video is NSFW (case-insensitive check for content-warning value)
function isVideoNSFW(event) {
    const tags = event.tags || [];
    return tags.some(tag => tag[0] === 'content-warning' && tag[1]?.toLowerCase() === 'nsfw');
}

// Invalid patterns for NIP-05 validation
const INVALID_NIP05 = [
    'r2a.primal.net',
    'blossom.primal.net',
    'localhost',
    '127.0.0.1',
    'files',
    'uploads'
];

// Helper function to validate NIP-05
// Caches the promise to prevent multiple simultaneous requests for the same pubkey
function validateNip05(nip05, pubkey) {
    const cacheKey = `${nip05}:${pubkey}`;

    // Return cached result or pending promise
    if (nip05ValidationCache.has(cacheKey)) {
        const cached = nip05ValidationCache.get(cacheKey);
        // If it's a promise, return it; if it's a boolean, wrap in resolved promise
        return cached instanceof Promise ? cached : Promise.resolve(cached);
    }

    // Create the validation promise
    const validationPromise = (async () => {
        try {
            const [name, domain] = nip05.split('@');
            if (!name || !domain) {
                return false;
            }

            const isBlocked = INVALID_NIP05.some(pattern =>
                domain.toLowerCase().includes(pattern.toLowerCase())
            );

            if (isBlocked) {
                return false;
            }

            const response = await fetch(`https://${domain}/.well-known/nostr.json?name=${name}`, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                return false;
            }

            const data = await response.json();
            return data.names && data.names[name] === pubkey;
        } catch (error) {
            console.error('NIP-05 validation error:', error);
            return false;
        }
    })();

    // Cache the promise immediately to prevent duplicate requests
    nip05ValidationCache.set(cacheKey, validationPromise);

    // When promise resolves, replace with the actual result for faster future lookups
    validationPromise.then(isValid => {
        nip05ValidationCache.set(cacheKey, isValid);
        // Clear cache after 24 hours
        setTimeout(() => nip05ValidationCache.delete(cacheKey), 24 * 60 * 60 * 1000);
    });

    return validationPromise;
}

// Helper to check if image URL is valid
function createImageValidationPromise(url) {
    if (!url) {
        return Promise.resolve(false);
    }

    // Check cache first
    if (imageValidationCache.has(url)) {
        return Promise.resolve(imageValidationCache.get(url));
    }

    return new Promise((resolve) => {
        const img = new Image();
        const timeout = setTimeout(() => {
            img.src = '';
            imageValidationCache.set(url, false);
            resolve(false);
        }, 3000); // Reduced from 5s to 3s

        img.onload = () => {
            clearTimeout(timeout);
            imageValidationCache.set(url, true);
            resolve(true);
        };

        img.onerror = () => {
            clearTimeout(timeout);
            imageValidationCache.set(url, false);
            resolve(false);
        };

        img.src = url;
    });
}

// Function to create cards for videos
function createVideoCard(event, profile, reactions, isTrending = false, trendingRank = null, lazy = true, showOwnerActions = false) {
    // Parse both kind 1 and NIP-71 events
    let videoData;
    if (isNip71Kind(event.kind)) {
        videoData = parseNip71VideoEvent(event);
    } else {
        videoData = parseVideoEvent(event);
    }
    if (!videoData) return '';

    // Check if content is blocked by admin
    if (isBlockedByAdmin(event.id, event.pubkey)) {
        return ''; // Silently skip blocked content
    }

    // Check if content from this user should be hidden (muted)
    if (shouldHideMutedContent(event.pubkey)) {
        // For trending, just skip entirely
        if (isTrending) return '';
        // For other views, show a placeholder with event ID for in-place replacement
        return createMutedContentPlaceholder(event.pubkey, 'video', event.id);
    }

    // Check if content matches enabled filter packs
    const filterResult = shouldFilterVideoContent(event, videoData);
    if (filterResult.filtered) {
        // For trending, just skip entirely
        if (isTrending) return '';
        // For other views, show a filtered content placeholder
        return createFilteredContentPlaceholder(event, filterResult, 'video');
    }

    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';
    const isNSFW = isVideoNSFW(event);
    const isRatioed = isVideoRatioed(reactions || {});

    const cardId = `video-card-${event.id}`;
    // Track whether profile has been checked - with progressive rendering,
    // we render before profile loads. Warning should only show after profile check.
    // profileChecked means we've attempted to load the profile (even if it returned null)
    const profileChecked = profileCache.has(event.pubkey);
    // Suspicious if: profile was checked AND (no profile OR missing avatar/nip05)
    const isSuspiciousProfile = profileChecked && (!profile || !avatarUrl || !nip05);

    // Get boost data from cache
    const boostAmount = boostsCache.get(event.id) || 0;
    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;

    // Determine what type of overlay to show (skip for own videos)
    const isOwnVideo = currentUser?.pubkey === event.pubkey;
    const showNSFWOverlay = !isOwnVideo && isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own videos)
    const isReportedByFollowsCheck = !isOwnVideo && isReportedByFollowsSync(event.id, event.pubkey);
    const showCommunityWarning = !isOwnVideo && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning();
    const showBlurred = showNSFWOverlay || showCommunityWarning;

    // NSFW takes precedence
    const overlayType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    if (isTrending && (isRatioed || isSuspiciousProfile)) {
        return '';
    }

    const cardHTML = `
        <div class="video-card ${isBoosted ? `boosted boost-level-${boostLevel}` : ''}" id="${cardId}" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-is-trending="${isTrending}" data-validation-pending="${avatarUrl || nip05 ? 'true' : 'false'}"${lazy ? ' data-lazy="true"' : ''}>
            <div class="video-thumbnail ${showBlurred ? overlayType : ''}"
                 onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${event.id}')` : `showRatioedModal('${event.id}')`) : `navigateTo('/video/${event.id}')`}"
                 ${videoData.preview ? `data-preview="${videoData.preview}" data-thumbnail="${videoData.thumbnail || ''}"` : ''}>
                ${videoData.thumbnail ?
            `<img class="thumbnail-img" ${lazy ? `data-src="${videoData.thumbnail}"` : `src="${videoData.thumbnail}"`} alt="${videoData.title}" onerror="this.style.display='none'">` :
            `<video ${lazy ? `data-src="${videoData.url}"` : `src="${videoData.url}"`} preload="metadata"></video>`
        }
                ${showBlurred ? `
                    <div class="${overlayType}-overlay">
                        <div class="${overlayType}-badge">${overlayType === 'nsfw' ? t('badge.nsfw') : t('badge.communityWarning')}</div>
                        <div>Click to view</div>
                    </div>
                ` : ''}
                ${isBoosted ? `
                    <div class="boost-indicator">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                        </svg>
                        ${formatSats(boostAmount)}
                    </div>
                ` : ''}
                ${!showBlurred && videoData.duration ? `<span class="video-duration">${formatDuration(videoData.duration)}</span>` : ''}
                ${reactions && (reactions.likes > 0 || reactions.dislikes > 0) ? `
                    <div class="video-reactions">
                        ${reactions.likes > 0 ? `
                            <span class="reaction-count likes">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                                </svg>
                                ${formatNumber(reactions.likes)}
                            </span>
                        ` : ''}
                        ${reactions.dislikes > 0 ? `
                            <span class="reaction-count dislikes">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                                </svg>
                                ${formatNumber(reactions.dislikes)}
                            </span>
                        ` : ''}
                    </div>
                ` : ''}
                ${isTrending && trendingRank ? `<div class="trending-rank">#${trendingRank}</div>` : ''}
                ${showOwnerActions ? `
                    <div class="video-owner-actions">
                        ${(event.kind === NIP71_VIDEO_KIND || event.kind === NIP71_SHORT_KIND) ? `
                            <button class="owner-edit-btn" onclick="event.stopPropagation(); showEditVideoModal('${event.id}')" title="${t('button.editVideo')}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                                </svg>
                            </button>
                        ` : ''}
                        <button class="owner-delete-btn" onclick="event.stopPropagation(); handleDelete('${event.id}')" title="${t('button.deleteVideo')}">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                            </svg>
                        </button>
                    </div>
                ` : ''}
            </div>
            <div class="video-info">
                <a href="#/profile/${event.pubkey}" class="channel-info">
                    <div class="channel-avatar">
                        ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}" data-avatar-url="${avatarUrl}">` : ''}
                    </div>
                    <div class="channel-details">
                        <div class="channel-name">${displayName}</div>
                        ${nip05 ? `<div class="channel-nip05" data-nip05="${nip05}">${nip05}</div>` : ''}
                    </div>
                </a>
                <h3 class="video-title" onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${event.id}')` : `showRatioedModal('${event.id}')`) : `navigateTo('/video/${event.id}')`}">${videoData.title}</h3>
                <div class="video-meta">
                    ${formatTimestamp(event.created_at)}
                    <span class="video-views" data-event-id="${event.id}">${(() => { const c = getCachedViewCount(event.id); return c !== null ? ` • ${formatNumber(c)} ${t('stat.views')}` : ''; })()}</span>
                    ${isNSFW ? ' • <span style="color: #ff0000;">NSFW</span>' : ''}
                    <span class="community-warning-indicator" style="${showCommunityWarning && !showNSFWOverlay ? '' : 'display: none;'}"> • <span style="color: #ff9800;">Community Warning</span></span>
                </div>
            </div>
        </div>
    `;

    if (profile && (avatarUrl || nip05)) {
        setTimeout(() => validateVideoCard(event.id, event.pubkey, profile, reactions, isTrending), 0);
    }

    return cardHTML;
}

// Update video card in place without replacing the entire DOM element (prevents image flickering)
function updateVideoCardInPlace(eventId, profile, reactions) {
    const card = document.getElementById(`video-card-${eventId}`);
    if (!card) return false;

    const displayName = profile?.name || profile?.display_name || `User ${card.dataset.pubkey?.slice(0, 8) || ''}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';

    // Update channel avatar (only if different to prevent flicker)
    const avatarContainer = card.querySelector('.channel-avatar');
    if (avatarContainer) {
        const existingImg = avatarContainer.querySelector('img');
        const existingAvatarUrl = existingImg?.getAttribute('data-avatar-url') || existingImg?.src || '';

        if (avatarUrl && avatarUrl !== existingAvatarUrl) {
            if (existingImg) {
                existingImg.src = avatarUrl;
                existingImg.setAttribute('data-avatar-url', avatarUrl);
            } else {
                avatarContainer.innerHTML = `<img src="${avatarUrl}" alt="${displayName}" data-avatar-url="${avatarUrl}">`;
            }
        } else if (!avatarUrl && existingImg) {
            existingImg.remove();
        }
    }

    // Update channel name
    const channelName = card.querySelector('.channel-name');
    if (channelName && channelName.textContent !== displayName) {
        channelName.textContent = displayName;
    }

    // Update NIP-05
    const channelDetails = card.querySelector('.channel-details');
    if (channelDetails) {
        const existingNip05 = channelDetails.querySelector('.channel-nip05');
        if (nip05) {
            if (existingNip05) {
                if (existingNip05.textContent !== nip05) {
                    existingNip05.textContent = nip05;
                    existingNip05.setAttribute('data-nip05', nip05);
                }
            } else {
                const nip05El = document.createElement('div');
                nip05El.className = 'channel-nip05';
                nip05El.setAttribute('data-nip05', nip05);
                nip05El.textContent = nip05;
                channelDetails.appendChild(nip05El);
            }
        } else if (existingNip05) {
            existingNip05.remove();
        }
    }

    // Update reaction counts on thumbnail
    if (reactions) {
        const thumbnail = card.querySelector('.video-thumbnail');
        if (thumbnail) {
            let reactionsDiv = thumbnail.querySelector('.video-reactions');
            const hasReactions = reactions.likes > 0 || reactions.dislikes > 0;

            if (hasReactions) {
                const reactionsHTML = `
                    ${reactions.likes > 0 ? `
                        <span class="reaction-count likes">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                            </svg>
                            ${formatNumber(reactions.likes)}
                        </span>
                    ` : ''}
                    ${reactions.dislikes > 0 ? `
                        <span class="reaction-count dislikes">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                            </svg>
                            ${formatNumber(reactions.dislikes)}
                        </span>
                    ` : ''}
                `;

                if (reactionsDiv) {
                    reactionsDiv.innerHTML = reactionsHTML;
                } else {
                    reactionsDiv = document.createElement('div');
                    reactionsDiv.className = 'video-reactions';
                    reactionsDiv.innerHTML = reactionsHTML;
                    thumbnail.appendChild(reactionsDiv);
                }
            } else if (reactionsDiv) {
                reactionsDiv.remove();
            }
        }
    }

    // Trigger proper validation if not done yet
    // This validates nip05 (checks if it actually resolves to the pubkey)
    // and avatar (checks if image loads) - then updates warning accordingly
    const pubkey = card.dataset.pubkey;
    if (card.dataset.validationDone !== 'true' && pubkey) {
        const isTrending = card.dataset.isTrending === 'true';
        setTimeout(() => validateVideoCard(eventId, pubkey, profile, reactions, isTrending), 0);
    }

    return true;
}

// Get NIP-05 verified checkmark SVG
function getNip05CheckmarkSVG(size = 14) {
    return `<svg class="nip05-verified" width="${size}" height="${size}" viewBox="0 0 24 24" fill="currentColor" title="${t('badge.verifiedNip05')}">
        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/>
    </svg>`;
}

// Apply NIP-05 checkmark to any element with nip05
function applyNip05Checkmark(element, isValid, size = 14) {
    if (!element || !isValid) return;
    if (element.querySelector('.nip05-verified')) return; // Already has checkmark

    const nip05Text = element.textContent;
    element.innerHTML = `<span class="nip05-text">${nip05Text}</span>${getNip05CheckmarkSVG(size)}`;
}

// Apply validation result to a single card
function applyValidationToCard(card, isSuspiciousProfile) {
    if (!card) return;

    const eventId = card.dataset.eventId || card.id?.replace('video-card-', '');
    if (!eventId) return;

    const pubkey = card.dataset.pubkey;
    const isTrending = card.dataset.isTrending === 'true';
    const reactions = reactionsCache.get(eventId) || {};
    const isNSFW = isVideoNSFW(allEvents.get(eventId));
    const isRatioed = isVideoRatioed(reactions);

    card.dataset.validationDone = 'true';
    card.dataset.needsValidation = 'false';

    // Add NIP-05 verified checkmark if valid
    if (pubkey && profileValidationCache.has(pubkey)) {
        const cached = profileValidationCache.get(pubkey);
        const nip05El = card.querySelector('.channel-nip05');
        applyNip05Checkmark(nip05El, cached.nip05Valid);
    }

    // Remove trending cards with suspicious profiles
    if (isTrending && (isRatioed || isSuspiciousProfile)) {
        card.remove();
        const trendingGrid = document.getElementById('trendingGrid');
        if (trendingGrid && trendingGrid.querySelector('.video-card')) {
            setTimeout(() => initializeCarousel(), 100);
        }
        return;
    }

    const thumbnail = card.querySelector('.video-thumbnail');
    if (!thumbnail) return;

    const currentOverlay = thumbnail.querySelector('.ratioed-overlay, .nsfw-overlay');

    const shouldShowNSFWOverlay = isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own videos)
    const isReportedByFollowsCheck = pubkey && currentUser?.pubkey !== pubkey && isReportedByFollowsSync(eventId, pubkey);
    const shouldShowCommunityWarning = (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning();
    const needsOverlay = shouldShowNSFWOverlay || shouldShowCommunityWarning;
    const overlayType = shouldShowNSFWOverlay ? 'nsfw' : 'ratioed';

    if ((currentOverlay && !needsOverlay) || (!currentOverlay && needsOverlay)) {
        if (needsOverlay && !currentOverlay) {
            thumbnail.classList.add(overlayType);
            thumbnail.setAttribute('onclick',
                overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${eventId}')` : `showRatioedModal('${eventId}')`
            );
            const overlayHTML = `
                <div class="${overlayType}-overlay">
                    <div class="${overlayType}-badge">${overlayType === 'nsfw' ? t('badge.nsfw') : t('badge.communityWarning')}</div>
                    <div>Click to view</div>
                </div>
            `;
            thumbnail.insertAdjacentHTML('beforeend', overlayHTML);
        } else if (!needsOverlay) {
            thumbnail.classList.remove('ratioed', 'nsfw');
            thumbnail.setAttribute('onclick', `navigateTo('/video/${eventId}')`);
            if (currentOverlay) currentOverlay.remove();
        }

        const warningIndicator = card.querySelector('.community-warning-indicator');
        if (warningIndicator) {
            warningIndicator.style.display = shouldShowCommunityWarning && !shouldShowNSFWOverlay ? 'inline' : 'none';
        }

        const title = card.querySelector('.video-title');
        if (title) {
            title.setAttribute('onclick',
                needsOverlay ?
                    (overlayType === 'nsfw' ? `showNSFWModal('playVideo', '${eventId}')` : `showRatioedModal('${eventId}')`) :
                    `navigateTo('/video/${eventId}')`
            );
        }
    }
}

// Function to validate and update video cards - uses cached results when available
async function validateVideoCard(eventId, pubkey, profile, reactions, isTrending = false) {
    const card = document.getElementById(`video-card-${eventId}`);
    if (!card) return;

    if (card.dataset.validationDone === 'true') return;

    // Check if we already have validation result cached for this pubkey
    if (profileValidationCache.has(pubkey)) {
        const cached = profileValidationCache.get(pubkey);
        applyValidationToCard(card, cached.isSuspicious);

        // Also apply NIP-05 checkmark to video page and profile page elements
        if (cached.nip05Valid) {
            const videoPageNip05 = document.querySelector(`.video-channel-info .channel-nip05`);
            if (videoPageNip05) applyNip05Checkmark(videoPageNip05, true);

            const profileNip05 = document.querySelector(`.profile-nip05`);
            if (profileNip05) applyNip05Checkmark(profileNip05, true, 16);

            // Apply to comments from this user
            document.querySelectorAll(`.comment-author-nip05[data-pubkey="${pubkey}"]`).forEach(el => {
                applyNip05Checkmark(el, true, 12);
            });
        }
        return;
    }

    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';

    const [avatarValid, nip05Valid] = await Promise.all([
        avatarUrl ? createImageValidationPromise(avatarUrl) : Promise.resolve(false),
        nip05 ? validateNip05(nip05, pubkey) : Promise.resolve(false)
    ]);

    const isSuspiciousProfile = !avatarValid || !nip05Valid;

    // Cache the validation result for this pubkey
    profileValidationCache.set(pubkey, {
        isSuspicious: isSuspiciousProfile,
        avatarValid,
        nip05Valid
    });

    // Apply validation to ALL cards for this pubkey (not just the current one)
    const allCardsForPubkey = document.querySelectorAll(`[data-pubkey="${pubkey}"]`);
    allCardsForPubkey.forEach(c => {
        if (c.classList.contains('sidebar-video-card')) {
            applySidebarValidation(c, isSuspiciousProfile);
        } else {
            applyValidationToCard(c, isSuspiciousProfile);
        }
    });

    // Also apply NIP-05 checkmark to video page and profile page elements
    if (nip05Valid) {
        // Video page channel info
        const videoPageNip05 = document.querySelector(`.video-channel-info .channel-nip05`);
        if (videoPageNip05) {
            applyNip05Checkmark(videoPageNip05, true);
        }

        // Profile page
        const profileNip05 = document.querySelector(`.profile-nip05`);
        if (profileNip05) {
            applyNip05Checkmark(profileNip05, true, 16);
        }

        // Apply to comments from this user
        document.querySelectorAll(`.comment-author-nip05[data-pubkey="${pubkey}"]`).forEach(el => {
            applyNip05Checkmark(el, true, 12);
        });
    }
}

// Get video URL with fallback
async function getVideoUrl(hash, servers = BLOSSOM_SERVERS) {
    for (const server of servers) {
        const url = `${server}/${hash}`;
        try {
            const response = await fetch(url, { method: 'HEAD' });
            if (response.ok) {
                return url;
            }
        } catch (error) {
            console.error(`Failed to check ${server}:`, error);
        }
    }
    return null;
}

// Format duration
function formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

// Format timestamp
function formatTimestamp(timestamp) {
    const date = new Date(timestamp * 1000);
    const now = new Date();
    const diff = now - date;

    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    const months = Math.floor(days / 30);
    const years = Math.floor(days / 365);

    if (years > 0) return `${years} year${years > 1 ? 's' : ''} ago`;
    if (months > 0) return `${months} month${months > 1 ? 's' : ''} ago`;
    if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
    if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
    if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
    return `${seconds} second${seconds > 1 ? 's' : ''} ago`;
}

// ===== Create Modal Functions =====
function showCreateModal() {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }
    document.getElementById('createModal').classList.add('active');
}

function hideCreateModal() {
    document.getElementById('createModal').classList.remove('active');
}

// ===== Go Live Modal Functions =====
function showGoLiveModal() {
    hideCreateModal();
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    // Reset form
    document.getElementById('goLiveForm').reset();
    resetLiveStreamState();
    switchStreamType('now');

    // Set default date/time for scheduled streams
    const now = new Date();
    now.setMinutes(now.getMinutes() + 30);
    document.getElementById('streamDate').value = now.toISOString().split('T')[0];
    document.getElementById('streamTime').value = now.toTimeString().slice(0, 5);

    document.getElementById('goLiveModal').classList.add('active');

    // Setup thumbnail upload handler
    setupStreamThumbnailUpload();
}

function hideGoLiveModal() {
    document.getElementById('goLiveModal').classList.remove('active');
    resetLiveStreamState();
}

function resetLiveStreamState() {
    liveStreamState.thumbnailUrl = null;
    liveStreamState.thumbnailFile = null;
    liveStreamState.isScheduled = false;
    liveStreamState.scheduledTime = null;

    // Reset thumbnail preview
    const preview = document.getElementById('streamThumbnailPreview');
    if (preview) preview.style.display = 'none';
    const progress = document.getElementById('streamThumbnailProgress');
    if (progress) progress.style.display = 'none';
    const upload = document.getElementById('streamThumbnailUpload');
    if (upload) upload.style.display = 'flex';

    // Reset zap goal field
    const zapGoalField = document.getElementById('streamZapGoal');
    if (zapGoalField) zapGoalField.value = '';
}

function switchStreamType(type) {
    const tabs = document.querySelectorAll('.stream-type-tab');
    tabs.forEach(tab => {
        tab.classList.toggle('active', tab.dataset.type === type);
    });

    const scheduleOptions = document.getElementById('scheduleOptions');
    const goLiveBtn = document.getElementById('goLiveButtonText');

    if (type === 'schedule') {
        scheduleOptions.style.display = 'block';
        goLiveBtn.textContent = t('button.scheduleStream');
        liveStreamState.isScheduled = true;
    } else {
        scheduleOptions.style.display = 'none';
        goLiveBtn.textContent = t('button.goLive');
        liveStreamState.isScheduled = false;
    }
}

function setupStreamThumbnailUpload() {
    const fileInput = document.getElementById('streamThumbnailFile');
    if (fileInput) {
        fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Validate file type
            const allowedImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            if (!allowedImageTypes.includes(file.type)) {
                showToast('Invalid thumbnail file type. Please upload an image file (jpg, png, gif, webp)', 'error');
                fileInput.value = '';
                return;
            }

            liveStreamState.thumbnailFile = file;

            // Show progress
            document.getElementById('streamThumbnailUpload').style.display = 'none';
            document.getElementById('streamThumbnailProgress').style.display = 'block';
            document.getElementById('streamThumbnailName').textContent = file.name;
            document.getElementById('streamThumbnailStatus').textContent = t('status.uploading');
            document.getElementById('streamThumbnailProgressFill').style.width = '0%';

            try {
                // Upload directly to Blossom servers with progress callback
                const result = await uploadToBlossom(
                    file,
                    BLOSSOM_SERVERS,
                    'streamThumbnailServerStatus',
                    (progress, completed, total) => {
                        document.getElementById('streamThumbnailProgressFill').style.width = `${progress}%`;
                        document.getElementById('streamThumbnailStatus').textContent = `Uploading... (${completed}/${total} servers)`;
                    }
                );

                if (result.success && result.url) {
                    liveStreamState.thumbnailUrl = result.url;
                    document.getElementById('streamThumbnailProgressFill').style.width = '100%';

                    // Show preview
                    document.getElementById('streamThumbnailProgress').style.display = 'none';
                    document.getElementById('streamThumbnailPreview').style.display = 'block';
                    document.getElementById('streamThumbnailPreviewImage').src = result.url;
                    document.getElementById('streamThumbnailStatus').textContent = t('status.thumbnailReady');
                } else {
                    throw new Error(result.error || 'Upload failed');
                }
            } catch (error) {
                console.error('Failed to upload stream thumbnail:', error);
                showToast('Failed to upload thumbnail. Please try again.', 'error');
                document.getElementById('streamThumbnailStatus').textContent = t('status.thumbnailFailed');
                document.getElementById('streamThumbnailUpload').style.display = 'flex';
                document.getElementById('streamThumbnailProgress').style.display = 'none';
                liveStreamState.thumbnailFile = null;
                liveStreamState.thumbnailUrl = null;
            }
        };
    }
}

function deleteStreamThumbnail() {
    liveStreamState.thumbnailUrl = null;
    liveStreamState.thumbnailFile = null;
    document.getElementById('streamThumbnailPreview').style.display = 'none';
    document.getElementById('streamThumbnailUpload').style.display = 'flex';
    document.getElementById('streamThumbnailFile').value = '';
}

// Go Live Form Submit Handler
document.addEventListener('DOMContentLoaded', () => {
    const goLiveForm = document.getElementById('goLiveForm');
    if (goLiveForm) {
        goLiveForm.addEventListener('submit', handleGoLive);
    }
});

async function handleGoLive(e) {
    e.preventDefault();

    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const title = document.getElementById('streamTitle').value.trim();
    const description = document.getElementById('streamDescription').value.trim();
    const tags = document.getElementById('streamTags').value.split(',').map(t => t.trim()).filter(t => t);
    const streamUrl = document.getElementById('streamUrl').value.trim();
    const zapGoal = document.getElementById('streamZapGoal').value.trim();
    const isNSFW = document.getElementById('streamNsfwCheckbox').checked;

    // Validate required fields including thumbnail
    if (!title || !streamUrl) {
        alert(t('alert.fillRequiredFields'));
        return;
    }

    if (!liveStreamState.thumbnailUrl) {
        alert(t('alert.uploadThumbnail'));
        return;
    }

    // Get scheduled time if applicable
    let startTime = Math.floor(Date.now() / 1000);
    let status = 'live';

    if (liveStreamState.isScheduled) {
        const dateStr = document.getElementById('streamDate').value;
        const timeStr = document.getElementById('streamTime').value;
        if (dateStr && timeStr) {
            const scheduledDate = new Date(`${dateStr}T${timeStr}`);
            startTime = Math.floor(scheduledDate.getTime() / 1000);
            status = 'planned';
        }
    }

    // Disable button
    const goLiveBtn = document.getElementById('goLiveButton');
    goLiveBtn.disabled = true;
    document.getElementById('goLiveButtonText').textContent = t('button.creatingStream');

    try {
        // Create NIP-53 Live Event (kind 30311)
        const dTag = `plebs-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

        const eventTags = [
            ['d', dTag],
            ['title', title],
            ['summary', description],
            ['streaming', streamUrl],
            ['status', status],
            ['starts', String(startTime)],
            ['t', 'pv69420'], // Plebs app tag
        ];

        // Add thumbnail if uploaded
        if (liveStreamState.thumbnailUrl) {
            eventTags.push(['image', liveStreamState.thumbnailUrl]);
        }

        // Add content tags
        tags.forEach(tag => {
            eventTags.push(['t', tag.toLowerCase()]);
        });

        // Add NSFW tag if applicable
        if (isNSFW) {
            eventTags.push(['content-warning', 'nsfw']);
        }

        // Add zap goal if specified
        if (zapGoal && parseInt(zapGoal) > 0) {
            eventTags.push(['goal', zapGoal]);
        }

        // Add host participant
        eventTags.push(['p', currentUser.pubkey, '', 'Host']);

        const event = {
            kind: NIP53_LIVE_EVENT_KIND,
            created_at: Math.floor(Date.now() / 1000),
            tags: eventTags,
            content: ''
        };

        const signedEvent = await signEvent(event);
        if (!signedEvent) {
            throw new Error('Failed to sign event');
        }

        await publishEvent(signedEvent);

        // Store in allEvents
        allEvents.set(signedEvent.id, signedEvent);

        hideGoLiveModal();

        // Navigate to the live stream page
        navigateTo(`/live/${signedEvent.id}`);

    } catch (error) {
        console.error('Failed to create live stream:', error);
        alert(t('alert.failedCreateStream'));
    } finally {
        goLiveBtn.disabled = false;
        document.getElementById('goLiveButtonText').textContent = liveStreamState.isScheduled ? 'Schedule Stream' : 'Go Live';
    }
}

// ===== Edit Live Stream Modal Functions =====
let editStreamState = {
    eventId: null,
    event: null,
    liveData: null,
    newThumbnailUrl: null
};

async function showEditStreamModal(eventId) {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    // Fetch the event
    let event = allEvents.get(eventId);
    if (!event) {
        event = await fetchLiveEvent(eventId);
    }

    if (!event) {
        alert(t('alert.streamNotFound'));
        return;
    }

    // Verify ownership
    if (event.pubkey !== currentUser.pubkey) {
        alert(t('alert.canOnlyEditOwnStreams'));
        return;
    }

    const liveData = parseLiveEvent(event);
    if (!liveData) {
        alert(t('alert.invalidStreamData'));
        return;
    }

    // Store state
    editStreamState = {
        eventId: eventId,
        event: event,
        liveData: liveData,
        newThumbnailUrl: null
    };

    // Populate form fields
    document.getElementById('editStreamTitle').value = liveData.title || '';
    document.getElementById('editStreamDescription').value = liveData.summary || '';
    document.getElementById('editStreamTags').value = (liveData.tags || []).join(', ');
    document.getElementById('editStreamUrl').value = liveData.streamUrl || '';
    document.getElementById('editStreamZapGoal').value = liveData.zapGoal || '';
    document.getElementById('editStreamNsfwCheckbox').checked = liveData.isNSFW || false;

    // Hidden fields
    document.getElementById('editStreamEventId').value = eventId;
    document.getElementById('editStreamDTag').value = liveData.dTag;
    document.getElementById('editStreamStatus').value = liveData.status;
    document.getElementById('editStreamStarts').value = liveData.starts;
    document.getElementById('editStreamEnds').value = liveData.ends || '';

    // Show thumbnail preview
    const thumbnailPreview = document.getElementById('editStreamThumbnailPreview');
    if (liveData.thumbnail) {
        thumbnailPreview.src = liveData.thumbnail;
        thumbnailPreview.style.display = 'block';
    } else {
        thumbnailPreview.style.display = 'none';
    }

    // Show modal
    document.getElementById('editStreamModal').classList.add('active');

    // Setup thumbnail upload handler
    setupEditStreamThumbnailUpload();
}

function hideEditStreamModal() {
    document.getElementById('editStreamModal').classList.remove('active');
    editStreamState = {
        eventId: null,
        event: null,
        liveData: null,
        newThumbnailUrl: null
    };
}

function setupEditStreamThumbnailUpload() {
    const fileInput = document.getElementById('editStreamThumbnailFile');
    if (fileInput) {
        fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const progressDiv = document.getElementById('editStreamThumbnailProgress');
            const statusEl = document.getElementById('editStreamThumbnailStatus');
            const progressFill = document.getElementById('editStreamThumbnailProgressFill');

            progressDiv.style.display = 'block';
            statusEl.textContent = t('status.uploadingThumbnail');
            progressFill.style.width = '0%';

            try {
                const result = await uploadToNostrBuild(file, (progress) => {
                    progressFill.style.width = `${progress}%`;
                });

                if (result && result.url) {
                    editStreamState.newThumbnailUrl = result.url;
                    document.getElementById('editStreamThumbnailPreview').src = result.url;
                    document.getElementById('editStreamThumbnailPreview').style.display = 'block';
                    document.getElementById('editStreamNewThumbnailUrl').value = result.url;
                    statusEl.textContent = t('status.thumbnailUploaded');
                } else {
                    throw new Error('Upload failed');
                }
            } catch (error) {
                console.error('Thumbnail upload failed:', error);
                statusEl.textContent = t('status.uploadFailedRetry');
            }

            setTimeout(() => {
                progressDiv.style.display = 'none';
            }, 2000);
        };
    }
}

async function handleEditStream(e) {
    e.preventDefault();

    if (!currentUser || !editStreamState.event) {
        return;
    }

    const title = document.getElementById('editStreamTitle').value.trim();
    const description = document.getElementById('editStreamDescription').value.trim();
    const tags = document.getElementById('editStreamTags').value.split(',').map(t => t.trim()).filter(t => t);
    const streamUrl = document.getElementById('editStreamUrl').value.trim();
    const zapGoal = document.getElementById('editStreamZapGoal').value.trim();
    const isNSFW = document.getElementById('editStreamNsfwCheckbox').checked;

    const dTag = document.getElementById('editStreamDTag').value;
    const status = document.getElementById('editStreamStatus').value;
    const starts = document.getElementById('editStreamStarts').value;
    const ends = document.getElementById('editStreamEnds').value;

    if (!title || !streamUrl) {
        alert(t('alert.fillRequiredFields'));
        return;
    }

    const saveBtn = document.getElementById('saveStreamButton');
    saveBtn.disabled = true;
    saveBtn.textContent = t('status.saving');

    try {
        // Use new thumbnail if uploaded, otherwise keep old one
        const thumbnailUrl = editStreamState.newThumbnailUrl || editStreamState.liveData?.thumbnail || '';

        // Build event tags
        const eventTags = [
            ['d', dTag],
            ['title', title],
            ['summary', description],
            ['streaming', streamUrl],
            ['status', status],
            ['starts', String(starts)],
            ['t', 'pv69420'],
        ];

        // Add ends tag if stream has ended
        if (ends) {
            eventTags.push(['ends', String(ends)]);
        }

        // Add thumbnail
        if (thumbnailUrl) {
            eventTags.push(['image', thumbnailUrl]);
        }

        // Add content tags
        tags.forEach(tag => {
            eventTags.push(['t', tag.toLowerCase()]);
        });

        // Add NSFW tag if applicable
        if (isNSFW) {
            eventTags.push(['content-warning', 'nsfw']);
        }

        // Add zap goal if specified
        if (zapGoal && parseInt(zapGoal) > 0) {
            eventTags.push(['goal', zapGoal]);
        }

        // Add host participant
        eventTags.push(['p', currentUser.pubkey, '', 'Host']);

        const event = {
            kind: NIP53_LIVE_EVENT_KIND,
            created_at: Math.floor(Date.now() / 1000),
            tags: eventTags,
            content: ''
        };

        const signedEvent = await signEvent(event);
        if (!signedEvent) {
            throw new Error('Failed to sign event');
        }

        await publishEvent(signedEvent);

        // Update in allEvents (remove old, add new)
        allEvents.delete(editStreamState.eventId);
        allEvents.set(signedEvent.id, signedEvent);

        hideEditStreamModal();

        // Refresh the page to show updated data
        navigateTo(`/live/${signedEvent.id}`);

    } catch (error) {
        console.error('Failed to update stream:', error);
        alert(t('alert.failedUpdateStream'));
    } finally {
        saveBtn.disabled = false;
        saveBtn.textContent = t('common.saveChanges');
    }
}

// Initialize edit stream form handler
function initEditStreamForm() {
    const editForm = document.getElementById('editStreamForm');
    if (editForm) {
        editForm.addEventListener('submit', handleEditStream);
    }
}

// ===== NIP-53 Live Event Parsing =====
function parseLiveEvent(event) {
    if (event.kind !== NIP53_LIVE_EVENT_KIND) return null;

    const getTags = (name) => event.tags.filter(t => t[0] === name);
    const getTag = (name) => event.tags.find(t => t[0] === name)?.[1] || '';

    const status = getTag('status') || 'live';
    const startsTag = getTag('starts');
    const endsTag = getTag('ends');

    return {
        id: event.id,
        pubkey: event.pubkey,
        dTag: getTag('d'),
        title: getTag('title') || 'Untitled Stream',
        summary: getTag('summary') || '',
        thumbnail: getTag('image') || getTag('thumb') || '',
        streamUrl: getTag('streaming') || '',
        recordingUrl: getTag('recording') || '',
        status: status,
        starts: startsTag ? parseInt(startsTag) : event.created_at,
        ends: endsTag ? parseInt(endsTag) : null,
        currentParticipants: parseInt(getTag('current_participants')) || 0,
        totalParticipants: parseInt(getTag('total_participants')) || 0,
        participants: getTags('p').map(t => ({
            pubkey: t[1],
            relay: t[2] || '',
            role: t[3] || 'Participant',
            proof: t[4] || ''
        })),
        tags: getTags('t').map(t => t[1]).filter(t => t !== 'pv69420'),
        isNSFW: event.tags.some(t => t[0] === 'content-warning'),
        pinnedMessage: getTag('pinned'),
        zapGoal: parseInt(getTag('goal')) || 0,
        zapGoalSince: parseInt(getTag('goal_since')) || 0,
        createdAt: event.created_at
    };
}

function isLiveEvent(event) {
    return event.kind === NIP53_LIVE_EVENT_KIND;
}

function isLiveStreamActive(liveData) {
    return liveData.status === 'live';
}

function isLiveStreamScheduled(liveData) {
    return liveData.status === 'planned';
}

function isLiveStreamEnded(liveData) {
    return liveData.status === 'ended';
}

// ===== Live Stream Page =====
async function playLiveStream(eventId, skipNSFWCheck = false, skipRatioedCheck = false) {
    currentView = 'live';
    const mainContent = document.getElementById('mainContent');
    mainContent.innerHTML = '<div class="spinner"></div>';

    // Scroll to top of page
    window.scrollTo(0, 0);

    try {
        let event = allEvents.get(eventId);

        if (!event) {
            event = await fetchLiveEvent(eventId);
        }

        if (!event) {
            mainContent.innerHTML = `<div class="error-message">${t('error.liveStreamNotFound')}</div>`;
            return;
        }

        const liveData = parseLiveEvent(event);
        if (!liveData) {
            mainContent.innerHTML = `<div class="error-message">${t('error.invalidLiveStreamData')}</div>`;
            return;
        }

        const profile = await fetchUserProfile(event.pubkey);
        const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
        const avatarUrl = profile?.picture || profile?.avatar || '';
        const nip05 = profile?.nip05 || '';

        // Check if this is the user's own stream
        const isOwnStream = currentUser?.pubkey === event.pubkey;

        // Check NSFW (skip for own streams)
        const isNSFW = liveData.isNSFW || false;
        if (!isOwnStream && !skipNSFWCheck && isNSFW && !shouldShowNSFW()) {
            showNSFWModal('playLive', eventId);
            return;
        }

        // Check Community Warning (skip for own streams)
        const cachedReactions = reactionsCache.get(eventId) || {};
        const isRatioed = isVideoRatioed(cachedReactions);
        const isProfileSuspicious = profileCache.has(event.pubkey) && (!profile || !avatarUrl || !nip05);
        const isReportedByFollowsCheck = isReportedByFollowsSync(eventId, event.pubkey);

        if (!isOwnStream && !skipRatioedCheck && (isRatioed || isProfileSuspicious || isReportedByFollowsCheck)
            && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning()) {
            showRatioedModal(eventId, 'live');
            return;
        }

        // Update page title
        document.title = `${liveData.title} - Live on Plebs`;

        // Add to watch history
        addToWatchHistory(eventId, event.tags || [], event.pubkey);

        // Determine status badge
        let statusBadge = '';
        let statusClass = '';
        if (isLiveStreamActive(liveData)) {
            statusBadge = 'LIVE';
            statusClass = '';
        } else if (isLiveStreamScheduled(liveData)) {
            statusBadge = 'SCHEDULED';
            statusClass = 'scheduled';
        } else {
            statusBadge = 'ENDED';
            statusClass = 'ended';
        }

        // Get stream embed
        const streamEmbed = getStreamEmbed(liveData.streamUrl, liveData.status);

        // Scheduled stream overlay
        let scheduleOverlay = '';
        if (isLiveStreamScheduled(liveData)) {
            const scheduleDate = new Date(liveData.starts * 1000);
            scheduleOverlay = `
                <div class="stream-overlay">
                    ${liveData.thumbnail ? `<img src="${liveData.thumbnail}" class="thumbnail-preview" alt="Stream thumbnail">` : ''}
                    <h2>Stream Starting Soon</h2>
                    <p>Scheduled for ${scheduleDate.toLocaleDateString()} at ${scheduleDate.toLocaleTimeString()}</p>
                    <div class="stream-countdown" id="stream-countdown"></div>
                    <p>Chat is open - join the conversation!</p>
                </div>
            `;
        }

        // Ended stream overlay
        let endedOverlay = '';
        if (isLiveStreamEnded(liveData)) {
            endedOverlay = `
                <div class="stream-overlay">
                    ${liveData.thumbnail ? `<img src="${liveData.thumbnail}" class="thumbnail-preview" alt="Stream thumbnail">` : ''}
                    <h2>Stream Ended</h2>
                    <p>This live stream has ended.</p>
                    ${liveData.zapGoal > 0 ? `
                        <div class="ended-zap-goal" id="ended-zap-goal" data-goal="${liveData.zapGoal}" data-event-id="${event.id}">
                            <div class="ended-zap-goal-header">
                                <svg viewBox="0 0 24 24" fill="currentColor" class="zap-icon">
                                    <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                                </svg>
                                <span>Zap Goal</span>
                            </div>
                            <div class="ended-zap-goal-progress">
                                <span class="ended-zap-current" id="ended-zap-current">0</span>
                                <span class="ended-zap-separator">/</span>
                                <span class="ended-zap-target">${formatSatsExact(liveData.zapGoal)}</span>
                            </div>
                            <div class="ended-zap-goal-bar">
                                <div class="ended-zap-goal-fill" id="ended-zap-goal-fill" style="width: 0%"></div>
                            </div>
                            <div class="ended-zap-goal-status" id="ended-zap-goal-status"></div>
                        </div>
                    ` : ''}
                    ${liveData.recordingUrl ? `<a href="${liveData.recordingUrl}" class="upload-btn" style="margin-top: 1rem;">Watch Recording</a>` : ''}
                </div>
            `;
        }

        mainContent.innerHTML = `
            <div class="live-stream-container">
                <div class="live-stream-main">
                    <div class="live-stream-player">
                        ${streamEmbed}
                        <div class="live-status-overlay">
                            <div class="live-status-badge ${statusClass}">${statusBadge}</div>
                            <div class="live-viewer-count" id="live-viewer-count">
                                <svg viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                                </svg>
                                <span id="viewer-count-number">${liveData.currentParticipants}</span> watching
                            </div>
                        </div>
                        ${liveData.zapGoal > 0 ? `
                        <div class="live-zap-goal" id="live-zap-goal" data-goal="${liveData.zapGoal}" data-goalsince="${liveData.zapGoalSince || 0}" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-dtag="${liveData.dTag}">
                            <div class="zap-goal-header">
                                <svg viewBox="0 0 24 24" fill="currentColor" class="zap-icon">
                                    <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                                </svg>
                                <span class="zap-goal-text">
                                    <span class="zap-current" id="zap-current-amount">0</span>
                                    <span class="zap-separator">/</span>
                                    <span class="zap-target" id="zap-target-amount">${formatSatsExact(liveData.zapGoal)}</span>
                                </span>
                            </div>
                            <div class="zap-goal-bar">
                                <div class="zap-goal-fill" id="zap-goal-fill" style="width: 0%"></div>
                            </div>
                            ${isOwnStream ? `
                            <div class="zap-goal-reset-form" id="zap-goal-reset-form">
                                <div class="reset-form-inner">
                                    <label>Set new goal (sats)</label>
                                    <div class="reset-input-row">
                                        <input type="number" id="new-zap-goal-input" placeholder="e.g. 10000" min="1">
                                        <button onclick="resetZapGoal()">Reset</button>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                        ` : ''}
                        ${scheduleOverlay}
                        ${endedOverlay}
                    </div>

                    <div class="live-stream-details">
                        <h1>${escapeHtml(liveData.title)}</h1>
                        <div class="video-meta">
                            Started ${formatTimestamp(liveData.starts)}
                            ${isNSFW ? ' • <span style="color: #f44336;">NSFW</span>' : ''}
                            <span class="community-warning-indicator" style="${(isRatioed || isProfileSuspicious || isReportedByFollowsCheck) && !isNSFW ? '' : 'display: none;'}"> • <span style="color: #ff9800;">Community Warning</span></span>
                            • <span class="report-flag" onclick="showReportModal('${event.id}', '${event.pubkey}')" title="${t('action.reportStream')}">${t('action.report')}</span>
                        </div>
                        <div class="video-channel-info">
                            <a href="#/profile/${event.pubkey}" class="channel-info" style="text-decoration: none;">
                                <div class="channel-avatar">
                                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                                </div>
                                <div class="channel-details">
                                    <div class="channel-name">${displayName}</div>
                                    ${profile?.nip05 ? `<div class="channel-nip05">${profile.nip05}</div>` : ''}
                                    <div class="channel-stats" id="channel-stats-${event.pubkey}">
                                        <span class="channel-stat loading">
                                            <span class="stat-value">-</span> videos
                                        </span>
                                        <span class="channel-stat-separator">•</span>
                                        <span class="channel-stat loading">
                                            <span class="stat-value">-</span> followers
                                        </span>
                                    </div>
                                </div>
                            </a>
                            <div class="channel-actions" id="channel-actions-${event.pubkey}">
                                ${currentUser && currentUser.pubkey !== event.pubkey ? `
                                    <button class="channel-follow-btn loading" disabled>
                                        <span class="spinner-small"></span>
                                    </button>
                                    <button class="channel-mute-btn loading" disabled>
                                        <span class="spinner-small"></span>
                                    </button>
                                ` : ''}
                            </div>
                        </div>

                        <div class="video-actions" style="margin-top: 1rem;" id="live-stream-actions-${event.id}">
                            <button class="action-btn like" onclick="handleLiveLike('${event.id}')" data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                                </svg>
                                <span class="count live-like-count" data-event-id="${event.id}">0</span>
                            </button>
                            <button class="action-btn dislike" onclick="handleLiveDislike('${event.id}')" data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                                </svg>
                                <span class="count live-dislike-count" data-event-id="${event.id}">0</span>
                            </button>
                            <button class="action-btn zap ${currentUser && currentUser.pubkey === event.pubkey ? 'self-content' : ''}"
                                    onclick="${currentUser && currentUser.pubkey === event.pubkey ? '' : `handleZap('${window.NostrTools.nip19.npubEncode(event.pubkey)}', 1000, '${event.id}')`}"
                                    data-event-id="${event.id}"
                                    ${currentUser && currentUser.pubkey === event.pubkey ? `title="${t('zap.cannotZapOwnContent')}"` : ''}>
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                                </svg>
                                <span class="count">Zap</span>
                            </button>
                            <button class="action-btn boost" onclick="handleBoost('${event.id}')" data-event-id="${event.id}">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                                </svg>
                                <span class="count">Boost</span>
                            </button>
                            <button class="action-btn" onclick="shareLiveStream('${event.id}')">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
                                </svg>
                                Share
                            </button>
                            ${currentUser && currentUser.pubkey === event.pubkey ? `
                                <div class="video-owner-actions-row">
                                    <button class="action-btn edit" onclick="showEditStreamModal('${event.id}')">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                            <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                                        </svg>
                                        Edit
                                    </button>
                                    ${!isLiveStreamEnded(liveData) ? `
                                        <button class="action-btn delete" onclick="endLiveStream('${event.id}')">
                                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M6 6h12v12H6z"/>
                                            </svg>
                                            End Stream
                                        </button>
                                    ` : ''}
                                </div>
                            ` : ''}
                        </div>

                        ${liveData.summary ? `
                            <div style="margin-top: 1.5rem;">
                                <h3>Description</h3>
                                <div class="video-description-container">
                                    <div id="video-description" class="video-description ${liveData.summary.length > 300 ? 'collapsed' : ''}">
                                        <p style="white-space: pre-wrap; margin-top: 0.5rem;">${processTextWithLinks(liveData.summary)}</p>
                                    </div>
                                    ${liveData.summary.length > 300 ? `
                                        <button id="description-toggle" class="description-toggle-btn" onclick="toggleDescription()">
                                            Show More
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}
                        ${liveData.tags.length > 0 ? `
                            <div class="tags" style="margin-top: 0.5rem;">
                                ${liveData.tags.map(tag => `<span class="tag" onclick="navigateTo('/tag/${tag.toLowerCase()}')">#${tag}</span>`).join('')}
                            </div>
                        ` : ''}
                    </div>

                    <!-- Also Live Section - inside main content area -->
                    <div class="also-live-section" id="also-live-section" style="display: none;">
                        <div class="also-live-header">
                            <h3>
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                    <circle cx="12" cy="12" r="4" fill="#f44336"/>
                                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                                </svg>
                                Also Live
                            </h3>
                        </div>
                        <div class="also-live-grid" id="also-live-grid"></div>
                    </div>
                </div>

                <div class="live-chat-sidebar" id="live-chat-sidebar">
                    <div class="live-chat-header">
                        <h3>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"/>
                            </svg>
                            ${isLiveStreamEnded(liveData) ? 'Chat (Ended)' : 'Live Chat'}
                        </h3>
                        <div class="chat-header-actions">
                            <div class="chat-viewers">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                                </svg>
                                <span id="chat-viewer-count">${liveData.currentParticipants}</span>
                            </div>
                            <button class="chat-collapse-btn" onclick="toggleLiveChat()" title="${t('button.toggleChat')}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="collapse-icon">
                                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                                </svg>
                            </button>
                        </div>
                    </div>

                    <div class="live-chat-messages" id="live-chat-messages">
                        <div class="chat-message system-message">${isLiveStreamEnded(liveData) ? t('stream.ended') : t('stream.welcomeChat')}</div>
                    </div>

                    ${isLiveStreamEnded(liveData) ? `
                        <div class="live-chat-input-container">
                            <div class="live-chat-input-wrapper">
                                <input type="text" class="live-chat-input" id="live-chat-input" placeholder="${t('placeholder.chatEnded')}" disabled maxlength="500">
                                <button class="live-chat-send-btn" id="live-chat-send" disabled>
                                    <svg viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    ` : currentUser ? `
                        <div class="live-chat-input-container">
                            <div class="live-chat-input-wrapper">
                                <input type="text" class="live-chat-input" id="live-chat-input" placeholder="${t('placeholder.addComment')}" maxlength="500">
                                <button class="live-chat-send-btn" id="live-chat-send" onclick="sendLiveChatMessage('${event.id}')">
                                    <svg viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    ` : `
                        <div class="chat-login-prompt">
                            <p>Login to join the chat</p>
                            <button onclick="ensureLoggedIn()">Login</button>
                        </div>
                    `}
                </div>
            </div>
        `;

        // Restore live chat collapsed state
        restoreLiveChatState();

        // Setup chat input enter key handler
        const chatInput = document.getElementById('live-chat-input');
        if (chatInput) {
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendLiveChatMessage(event.id);
                }
            });
        }

        // Start loading live chat
        loadLiveChat(event.id, event.pubkey, liveData.dTag);

        // Start countdown if scheduled
        if (isLiveStreamScheduled(liveData)) {
            startStreamCountdown(liveData.starts);
        }

        // Note: trackLiveViewer is now called at the end of setupLiveChatSubscription
        // to avoid the interval being cleared by cleanupLiveChatSubscriptions

        // Load reactions (likes/dislikes) for the live stream
        loadLiveStreamReactions(event.id);

        // Load zap count for the zap button
        loadZapsForVideo(event.id).then(zapData => {
            updateZapButton(event.id, zapData.totalZaps);
        });

        // Load boost count for the boost button
        loadBoostsForVideo(event.id).then(boostData => {
            updateBoostButton(event.id, boostData.totalBoosts);
        });

        // Initialize zap goal tracking if there's a goal set
        if (liveData.zapGoal > 0) {
            if (isLiveStreamEnded(liveData)) {
                // For ended streams, just load the final zap total
                loadEndedStreamZapGoal(event.id, liveData.zapGoal);
            } else {
                // For active streams, track in real-time
                initLiveStreamZapGoal(event.id, liveData.zapGoal);
            }
        }

        // Load channel stats and actions (follow/mute buttons)
        setTimeout(() => loadChannelStats(event.pubkey), 100);

        // Load "Also Live" section with recommendation-based related live streams
        loadAlsoLive(event.pubkey, liveData.dTag, liveData.tags);

        // Validate NIP-05 and add checkmark if valid
        if (profile?.nip05) {
            // Check cache first
            if (profileValidationCache.has(event.pubkey)) {
                const cached = profileValidationCache.get(event.pubkey);
                if (cached.nip05Valid) {
                    const channelNip05 = document.querySelector('.live-stream-details .channel-nip05');
                    applyNip05Checkmark(channelNip05, true);
                }
            } else {
                // Validate asynchronously
                validateNip05(profile.nip05, event.pubkey).then(isValid => {
                    if (isValid) {
                        const channelNip05 = document.querySelector('.live-stream-details .channel-nip05');
                        applyNip05Checkmark(channelNip05, true);
                    }
                });
            }
        }

    } catch (error) {
        console.error('Failed to load live stream:', error);
        mainContent.innerHTML = `<div class="error-message">${t('error.failedLoadLiveStream')}</div>`;
    }
}

function getStreamEmbed(streamUrl, status) {
    if (!streamUrl || status === 'planned' || status === 'ended') {
        return '<div style="width: 100%; height: 100%; background: #000;"></div>';
    }

    // Check for common streaming services
    if (streamUrl.includes('youtube.com') || streamUrl.includes('youtu.be')) {
        const videoId = streamUrl.match(/(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([^&\s]+)/)?.[1];
        if (videoId) {
            return `<iframe src="https://www.youtube.com/embed/${videoId}?autoplay=1" allow="autoplay; encrypted-media" allowfullscreen></iframe>`;
        }
    }

    if (streamUrl.includes('twitch.tv')) {
        const channel = streamUrl.match(/twitch\.tv\/([^\/\?]+)/)?.[1];
        if (channel) {
            return `<iframe src="https://player.twitch.tv/?channel=${channel}&parent=${window.location.hostname}" allow="autoplay; encrypted-media" allowfullscreen></iframe>`;
        }
    }

    // HLS/m3u8 streams
    if (streamUrl.endsWith('.m3u8') || streamUrl.includes('m3u8')) {
        return `
            <video id="live-video-player" controls autoplay playsinline>
                <source src="${streamUrl}" type="application/x-mpegURL">
            </video>
            <script>
                if (Hls && Hls.isSupported()) {
                    var video = document.getElementById('live-video-player');
                    var hls = new Hls();
                    hls.loadSource('${streamUrl}');
                    hls.attachMedia(video);
                }
            </script>
        `;
    }

    // Default video player
    return `<video controls autoplay playsinline><source src="${streamUrl}"></video>`;
}

function startStreamCountdown(startTime) {
    const countdownEl = document.getElementById('stream-countdown');
    if (!countdownEl) return;

    const updateCountdown = () => {
        const now = Math.floor(Date.now() / 1000);
        const diff = startTime - now;

        if (diff <= 0) {
            countdownEl.textContent = t('status.startingNow');
            // Reload page to show live stream
            setTimeout(() => location.reload(), 2000);
            return;
        }

        const hours = Math.floor(diff / 3600);
        const minutes = Math.floor((diff % 3600) / 60);
        const seconds = diff % 60;

        if (hours > 0) {
            countdownEl.textContent = `${hours}h ${minutes}m ${seconds}s`;
        } else if (minutes > 0) {
            countdownEl.textContent = `${minutes}m ${seconds}s`;
        } else {
            countdownEl.textContent = `${seconds}s`;
        }
    };

    updateCountdown();
    setInterval(updateCountdown, 1000);
}

async function fetchLiveEvent(eventId) {
    return new Promise((resolve) => {
        let found = false;
        requestEventsStream({ kinds: [NIP53_LIVE_EVENT_KIND], ids: [eventId] }, (event) => {
            if (!found) {
                found = true;
                allEvents.set(event.id, event);
                resolve(event);
            }
        }, () => {
            if (!found) resolve(null);
        });
    });
}

// Toggle live chat sidebar visibility
function toggleLiveChat() {
    const sidebar = document.getElementById('live-chat-sidebar');
    if (!sidebar) return;

    sidebar.classList.toggle('collapsed');

    // Save preference
    const isCollapsed = sidebar.classList.contains('collapsed');
    localStorage.setItem('liveChatCollapsed', isCollapsed ? 'true' : 'false');
}

// Restore live chat collapsed state
function restoreLiveChatState() {
    const sidebar = document.getElementById('live-chat-sidebar');
    if (!sidebar) return;

    const isCollapsed = localStorage.getItem('liveChatCollapsed') === 'true';
    if (isCollapsed) {
        sidebar.classList.add('collapsed');
    }
}

// ===== Live Chat System =====
async function loadLiveChat(eventId, pubkey, dTag) {
    const chatContainer = document.getElementById('live-chat-messages');
    if (!chatContainer) return;

    // Clear the welcome message when loading actual chat
    chatContainer.innerHTML = '';

    // Store current stream info including the streamer's pubkey
    currentLiveChat.streamId = eventId;
    currentLiveChat.eventId = eventId;
    currentLiveChat.streamerPubkey = pubkey; // Store streamer pubkey for badge
    currentLiveChat.dTag = dTag;
    currentLiveChat.messages = [];
    currentLiveChat.zapEventIds = new Set(); // Track zap events to avoid duplicates
    currentLiveChat.chatParticipants = new Map(); // Reset chat participants

    // Subscribe to live chat messages (kind 1311)
    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${pubkey}:${dTag}`;

    const filter = {
        kinds: [NIP53_LIVE_CHAT_KIND],
        '#a': [aTagValue],
        limit: 100
    };

    // Also load zaps for this stream to show in chat
    const zapFilter = {
        kinds: [9735],
        '#e': [eventId],
        limit: 50
    };

    // Load existing messages
    requestEventsStream(filter, (event) => {
        // Track participant immediately (before async profile fetch in addChatMessage)
        currentLiveChat.chatParticipants.set(event.pubkey, event.created_at);
        addChatMessage(event, chatContainer);
    }, () => {
        // After loading existing messages, scroll to bottom (newest messages are at bottom)
        // Use multiple delayed scrolls to ensure messages are rendered after async profile fetches
        chatContainer.scrollTop = chatContainer.scrollHeight;
        setTimeout(() => {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }, 100);
        setTimeout(() => {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }, 500);

        // Calculate initial chat user count after loading all messages
        // Update immediately and again after a short delay to catch any async updates
        updateActiveChatUserCount();
        setTimeout(() => {
            updateActiveChatUserCount();
        }, 500);

        // Re-filter for muted users after initial load (handles race condition with mute list loading)
        // Call multiple times with increasing delays to catch slow mute list loads
        setTimeout(() => filterMutedChatMessages(), 500);
        setTimeout(() => filterMutedChatMessages(), 1500);
        setTimeout(() => filterMutedChatMessages(), 3000);
    });

    // Load zaps and display as notifications
    requestEventsStream(zapFilter, (event) => {
        addZapNotification(event, chatContainer, false);
    });

    // Set up real-time subscription for new messages and zaps
    setupLiveChatSubscription(aTagValue, chatContainer, eventId);
}

function setupLiveChatSubscription(aTagValue, chatContainer, eventId) {
    // Clean up any existing subscriptions first
    cleanupLiveChatSubscriptions();

    // Store subscription info for cleanup
    currentLiveChat.aTagValue = aTagValue;
    currentLiveChat.subscriptionStartTime = Math.floor(Date.now() / 1000);

    // Subscribe to new messages in real-time using persistent subscription
    const messageFilter = {
        kinds: [NIP53_LIVE_CHAT_KIND],
        '#a': [aTagValue],
        since: currentLiveChat.subscriptionStartTime
    };

    // Subscribe to new zaps in real-time (use #a for persistence across stream updates)
    const zapFilter = {
        kinds: [9735],
        '#a': [aTagValue],
        since: currentLiveChat.subscriptionStartTime
    };

    // Subscribe to new reactions (likes/dislikes) on the live stream (use #a for persistence)
    const reactionFilter = {
        kinds: [7],
        '#a': [aTagValue],
        since: currentLiveChat.subscriptionStartTime
    };

    // Subscribe to new viewer presence events
    // Parse aTagValue to get pubkey and dTag for building the d-tag pattern
    const aTagParts = aTagValue.split(':');
    const streamerPubkey = aTagParts[1];
    const streamDTag = aTagParts.slice(2).join(':'); // In case dTag contains colons
    const viewerDTagPattern = `${LIVE_VIEWER_TRACKING_APP_ID}/${streamerPubkey}:${streamDTag}`;

    const viewerFilter = {
        kinds: [VIEW_EVENT_KIND],
        '#d': [viewerDTagPattern],
        since: currentLiveChat.subscriptionStartTime
    };

    // Use persistent subscription for real-time chat messages (doesn't close after EOSE)
    currentLiveChat.messageSubscription = subscribePersistent(messageFilter, (event) => {
        // Check for duplicates
        if (!currentLiveChat.messages.some(m => m.id === event.id)) {
            addChatMessage(event, chatContainer, true);
        }
    });

    // Use persistent subscription for real-time zaps
    currentLiveChat.zapSubscription = subscribePersistent(zapFilter, (event) => {
        addZapNotification(event, chatContainer, true);
    });

    // Use persistent subscription for real-time reactions on the live stream
    currentLiveChat.reactionSubscription = subscribePersistent(reactionFilter, (event) => {
        // Update live stream like/dislike counts in real-time
        const likeCount = document.querySelector(`.live-like-count[data-event-id="${eventId}"]`);
        const dislikeCount = document.querySelector(`.live-dislike-count[data-event-id="${eventId}"]`);

        if (event.content === '+' || event.content === '👍') {
            if (likeCount) {
                const current = parseInt(likeCount.textContent) || 0;
                likeCount.textContent = formatNumber(current + 1);
            }
        } else if (event.content === '-' || event.content === '👎') {
            if (dislikeCount) {
                const current = parseInt(dislikeCount.textContent) || 0;
                dislikeCount.textContent = formatNumber(current + 1);
            }
        }
    });

    // Use persistent subscription for real-time viewer presence updates
    currentLiveChat.viewerSubscription = subscribePersistent(viewerFilter, (event) => {
        // When a new viewer presence event comes in, refresh the viewer count
        loadLiveViewers(eventId);
    });

    // Subscribe to live event updates (for zap goal changes, status changes, etc.)
    const liveEventFilter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        authors: [streamerPubkey],
        '#d': [streamDTag],
        since: currentLiveChat.subscriptionStartTime
    };

    currentLiveChat.liveEventSubscription = subscribePersistent(liveEventFilter, (event) => {
        handleLiveEventUpdate(event, eventId);
    });

    // Set up periodic refresh as backup to catch any missed messages (every 15 seconds)
    if (currentLiveChat.refreshInterval) {
        clearInterval(currentLiveChat.refreshInterval);
    }
    currentLiveChat.refreshInterval = setInterval(() => {
        refreshLiveChatMessages(aTagValue, chatContainer, eventId);
    }, 15000);

    // Set up interval to refresh viewer count and chat user counts (every 30 seconds)
    if (currentLiveChat.chatUserCountInterval) {
        clearInterval(currentLiveChat.chatUserCountInterval);
    }
    currentLiveChat.chatUserCountInterval = setInterval(() => {
        loadLiveViewers(eventId); // Refresh viewer count from relays
        updateActiveChatUserCount();
        refreshChatMessageReactionsAndZaps(); // Refresh reactions/zaps on chat messages
    }, 30000);

    // Start viewer presence tracking (must be after cleanup to avoid interval being cleared)
    trackLiveViewer(eventId);
}

// Clean up live chat subscriptions when leaving the page
function cleanupLiveChatSubscriptions() {
    if (currentLiveChat.messageSubscription) {
        currentLiveChat.messageSubscription.unsubscribe();
        currentLiveChat.messageSubscription = null;
    }
    if (currentLiveChat.zapSubscription) {
        currentLiveChat.zapSubscription.unsubscribe();
        currentLiveChat.zapSubscription = null;
    }
    if (currentLiveChat.reactionSubscription) {
        currentLiveChat.reactionSubscription.unsubscribe();
        currentLiveChat.reactionSubscription = null;
    }
    if (currentLiveChat.viewerSubscription) {
        currentLiveChat.viewerSubscription.unsubscribe();
        currentLiveChat.viewerSubscription = null;
    }
    if (currentLiveChat.liveEventSubscription) {
        currentLiveChat.liveEventSubscription.unsubscribe();
        currentLiveChat.liveEventSubscription = null;
    }
    if (currentLiveChat.refreshInterval) {
        clearInterval(currentLiveChat.refreshInterval);
        currentLiveChat.refreshInterval = null;
    }
    if (currentLiveChat.chatUserCountInterval) {
        clearInterval(currentLiveChat.chatUserCountInterval);
        currentLiveChat.chatUserCountInterval = null;
    }
    if (currentLiveChat.viewerTrackingInterval) {
        clearInterval(currentLiveChat.viewerTrackingInterval);
        currentLiveChat.viewerTrackingInterval = null;
    }
}

// Handle real-time updates to the live event (zap goal changes, etc.)
function handleLiveEventUpdate(event, currentEventId) {
    const liveData = parseLiveEvent(event);
    if (!liveData) return;

    // Update the zap goal if it changed
    const zapGoalEl = document.getElementById('live-zap-goal');
    if (zapGoalEl) {
        const currentGoal = parseInt(zapGoalEl.dataset.goal) || 0;
        const currentGoalSince = parseInt(zapGoalEl.dataset.goalsince) || 0;
        const newGoal = liveData.zapGoal || 0;
        const newGoalSince = liveData.zapGoalSince || 0;

        // Check if this is a goal reset (new goal_since timestamp)
        const isGoalReset = newGoalSince > 0 && newGoalSince !== currentGoalSince;

        if ((newGoal !== currentGoal && newGoal > 0) || isGoalReset) {
            // Update the goal display
            zapGoalEl.dataset.goal = newGoal;
            zapGoalEl.dataset.goalsince = newGoalSince;

            const targetEl = document.getElementById('zap-target-amount');
            if (targetEl) {
                targetEl.textContent = formatSatsExact(newGoal);
            }

            // If goal was reset, start fresh
            if (isGoalReset) {
                // Reset zap counter to 0 for new goal
                liveStreamZapTotal = 0;
                zapGoalReachedMessageShown = false;

                zapGoalEl.classList.remove('goal-reached');
                const resetFormEl = document.getElementById('zap-goal-reset-form');
                if (resetFormEl) {
                    resetFormEl.classList.remove('visible');
                }

                // Restart zap subscription with new goal_since filter
                const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${event.pubkey}:${liveData.dTag}`;
                subscribeLiveStreamZaps(aTagValue, newGoal, new Set(), newGoalSince);

                updateZapGoalDisplay(0, newGoal, false);

                // Announce new zap goal in chat
                addNewZapGoalMessage(newGoal);
            } else if (newGoal > currentGoal) {
                // Goal increased but not reset - keep current progress
                zapGoalEl.classList.remove('goal-reached');
                const resetFormEl = document.getElementById('zap-goal-reset-form');
                if (resetFormEl) {
                    resetFormEl.classList.remove('visible');
                }
                zapGoalReachedMessageShown = false;
                updateZapGoalDisplay(liveStreamZapTotal || 0, newGoal, false);

                // Announce new zap goal in chat
                addNewZapGoalMessage(newGoal);
            } else if (newGoal !== currentGoal) {
                // Goal decreased - recalculate with current zaps
                updateZapGoalDisplay(liveStreamZapTotal || 0, newGoal, false);

                // Announce new zap goal in chat
                addNewZapGoalMessage(newGoal);
            }

            // Update allEvents with the new event
            allEvents.delete(currentEventId);
            allEvents.set(event.id, event);
        }
    }

    // Update browser URL and data attributes if event ID changed (so refresh works)
    if (event.id !== currentEventId) {
        const newUrl = `#/live/${event.id}`;
        history.replaceState(null, '', newUrl);

        // Update data-event-id attributes on the page
        document.querySelectorAll(`[data-event-id="${currentEventId}"]`).forEach(el => {
            el.dataset.eventId = event.id;
        });

        // Update allEvents if not already done
        if (allEvents.has(currentEventId)) {
            allEvents.delete(currentEventId);
            allEvents.set(event.id, event);
        }
    }

    // Handle status changes (e.g., stream ended)
    const statusBadge = document.querySelector('.live-status-badge');
    if (statusBadge && liveData.status) {
        if (liveData.status === 'ended' && !statusBadge.classList.contains('ended')) {
            statusBadge.textContent = t('status.ended');
            statusBadge.classList.add('ended');
            statusBadge.classList.remove('scheduled');
        }
    }
}

// Calculate and update active chat user count (users who chatted in last 5 minutes)
function updateActiveChatUserCount() {
    const fiveMinutesAgo = Math.floor(Date.now() / 1000) - 300; // 5 minutes = 300 seconds

    // Count unique users who have sent a message in the last 5 minutes
    // Use the messages array directly for reliability
    const activeUserPubkeys = new Set();

    currentLiveChat.messages.forEach(msg => {
        if (msg.created_at >= fiveMinutesAgo) {
            activeUserPubkeys.add(msg.pubkey);
        }
    });

    // Also check chatParticipants map (for any participants tracked via subscriptions)
    currentLiveChat.chatParticipants.forEach((lastActivityTime, pubkey) => {
        if (lastActivityTime >= fiveMinutesAgo) {
            activeUserPubkeys.add(pubkey);
        }
    });

    const activeUsers = activeUserPubkeys.size;

    // Update the chat viewer count element
    const chatViewerCountEl = document.getElementById('chat-viewer-count');
    if (chatViewerCountEl) {
        chatViewerCountEl.textContent = formatNumber(activeUsers);
    }
}

// Refresh live chat to catch any missed messages
function refreshLiveChatMessages(aTagValue, chatContainer, eventId) {
    if (!chatContainer || currentView !== 'live') {
        if (currentLiveChat.refreshInterval) {
            clearInterval(currentLiveChat.refreshInterval);
            currentLiveChat.refreshInterval = null;
        }
        return;
    }

    const lastMessageTime = currentLiveChat.messages.length > 0
        ? Math.max(...currentLiveChat.messages.map(m => m.created_at))
        : currentLiveChat.subscriptionStartTime;

    const filter = {
        kinds: [NIP53_LIVE_CHAT_KIND],
        '#a': [aTagValue],
        since: lastMessageTime - 5 // 5 second buffer
    };

    requestEventsStream(filter, (event) => {
        if (!currentLiveChat.messages.some(m => m.id === event.id)) {
            addChatMessage(event, chatContainer, true);
        }
    });
}

// Refresh reactions and zaps for recent chat messages (for real-time updates)
function refreshChatMessageReactionsAndZaps() {
    if (currentView !== 'live' || !currentLiveChat.messages.length) return;

    // Get IDs of recent chat messages (last 50 or so)
    const recentMessages = currentLiveChat.messages.slice(-50);
    const messageIds = recentMessages.map(m => m.id);

    if (messageIds.length === 0) return;

    // Track what we've already counted for each message
    const reactionsPerMessage = new Map(); // eventId -> { likes: 0, dislikes: 0 }
    const zapsPerMessage = new Map(); // eventId -> totalSats

    // Initialize
    messageIds.forEach(id => {
        reactionsPerMessage.set(id, { likes: 0, dislikes: 0 });
        zapsPerMessage.set(id, 0);
    });

    // Load reactions for these messages
    const reactionFilter = {
        kinds: [7],
        '#e': messageIds,
        limit: 500
    };

    requestEventsStream(reactionFilter, (event) => {
        const eTag = event.tags.find(t => t[0] === 'e');
        if (eTag && reactionsPerMessage.has(eTag[1])) {
            const data = reactionsPerMessage.get(eTag[1]);
            if (event.content === '+' || event.content === '👍') {
                data.likes++;
            } else if (event.content === '-' || event.content === '👎') {
                data.dislikes++;
            }
        }
    }, () => {
        // Update UI for reactions
        reactionsPerMessage.forEach((data, eventId) => {
            const likeCount = document.querySelector(`.chat-like-count[data-event-id="${eventId}"]`);
            const dislikeCount = document.querySelector(`.chat-dislike-count[data-event-id="${eventId}"]`);
            if (likeCount) likeCount.textContent = data.likes > 0 ? data.likes : '0';
            if (dislikeCount) dislikeCount.textContent = data.dislikes > 0 ? data.dislikes : '0';
        });
    });

    // Load zaps for these messages
    const zapFilter = {
        kinds: [9735],
        '#e': messageIds,
        limit: 500
    };

    requestEventsStream(zapFilter, (event) => {
        const eTag = event.tags.find(t => t[0] === 'e');
        if (eTag && zapsPerMessage.has(eTag[1])) {
            const bolt11Tag = event.tags.find(t => t[0] === 'bolt11');
            if (bolt11Tag && bolt11Tag[1]) {
                const amount = extractAmountFromBolt11(bolt11Tag[1]);
                if (amount > 0) {
                    zapsPerMessage.set(eTag[1], zapsPerMessage.get(eTag[1]) + amount);
                }
            }
        }
    }, () => {
        // Update UI for zaps
        zapsPerMessage.forEach((totalSats, eventId) => {
            const zapCount = document.querySelector(`.chat-zap-count[data-event-id="${eventId}"]`);
            if (zapCount) zapCount.textContent = totalSats > 0 ? formatSats(totalSats) : '0';
        });
    });
}

async function addChatMessage(event, container, isNew = false) {
    // Prevent duplicates
    if (currentLiveChat.messages.some(m => m.id === event.id)) return;
    currentLiveChat.messages.push(event);

    // Track chat participant activity (update their last activity time)
    currentLiveChat.chatParticipants.set(event.pubkey, event.created_at);

    // Update active chat user count immediately for new messages
    if (isNew) {
        updateActiveChatUserCount();
    }

    // Sort messages by timestamp in ascending order (oldest first, newest at bottom)
    currentLiveChat.messages.sort((a, b) => a.created_at - b.created_at);

    const isOwnMessage = currentUser && currentUser.pubkey === event.pubkey;

    // Check if message is from a muted user (don't hide own messages)
    // Check both the function and direct cache in case mute list is still loading
    const isMutedUser = !isOwnMessage && (shouldHideMutedContent(event.pubkey) ||
        (currentUser && mutedUsersCache.has(event.pubkey) && !sessionUnhiddenMutedUsers.has(event.pubkey)));

    if (isMutedUser) {
        const placeholderHTML = `
            <div class="chat-message muted-chat-message" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-timestamp="${event.created_at}">
                <div class="chat-hidden-placeholder">
                    ${getMuteIconSVG(12)}
                    <span>Message from muted user</span>
                    <button class="chat-unhide-btn" onclick="unhideChatMessage('${event.id}', '${event.pubkey}')">Show</button>
                </div>
            </div>
        `;
        insertChatMessageHTML(container, placeholderHTML, event.created_at, isNew);
        return;
    }

    // Check if message matches content filters
    const filterResult = shouldFilterComment(event.content);
    if (!isOwnMessage && filterResult.filtered && !sessionFilteredAllowed.has(event.id)) {
        const packNames = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.name || p.packName).join(', ');
        const packIcons = filterResult.packs.map(p => FILTER_PACKS[p.packId]?.icon || '🚫').join(' ');
        const placeholderHTML = `
            <div class="chat-message filtered-chat-message" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-timestamp="${event.created_at}">
                <div class="chat-hidden-placeholder">
                    <span>${packIcons}</span>
                    <span>Message hidden (${escapeHtml(packNames)})</span>
                    <button class="chat-unhide-btn" onclick="unhideFilteredChatMessage('${event.id}')">Show</button>
                </div>
            </div>
        `;
        insertChatMessageHTML(container, placeholderHTML, event.created_at, isNew);
        return;
    }

    // Check if message is reported by follows
    if (!isOwnMessage && isReportedByFollowsSync(event.id, event.pubkey) &&
        !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning()) {
        const placeholderHTML = `
            <div class="chat-message reported-chat-message" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-timestamp="${event.created_at}">
                <div class="chat-hidden-placeholder">
                    <span>⚠️</span>
                    <span>Message reported by people you follow</span>
                    <button class="chat-unhide-btn" onclick="unhideReportedChatMessage('${event.id}')">Show</button>
                </div>
            </div>
        `;
        insertChatMessageHTML(container, placeholderHTML, event.created_at, isNew);
        return;
    }

    // Check for @mentions of current user (for notifications)
    if (isNew && currentUser && !isOwnMessage) {
        checkChatMentionNotification(event);
    }

    const profile = await fetchUserProfile(event.pubkey);
    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const authorNpub = window.NostrTools.nip19.npubEncode(event.pubkey);

    // Check if this is the streamer (creator of the live stream)
    const isStreamer = event.pubkey === currentLiveChat.streamerPubkey;

    // Process mentions in content
    const content = processChatMentions(event.content);

    // Streamer badge HTML
    const streamerBadge = isStreamer ? `
        <span class="streamer-badge" title="Streamer">
            <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                <circle cx="12" cy="12" r="4" fill="#f44336"/>
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
            </svg>
        </span>
    ` : '';

    const messageHTML = `
        <div class="chat-message ${isStreamer ? 'streamer-message' : ''}" data-event-id="${event.id}" data-pubkey="${event.pubkey}" data-timestamp="${event.created_at}">
            <div class="chat-message-header">
                <div class="chat-message-avatar">
                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                </div>
                <span class="chat-message-author ${isStreamer ? 'streamer-author' : ''}" onclick="navigateTo('/profile/${event.pubkey}')">${streamerBadge}${escapeHtml(displayName)}</span>
                <span class="chat-message-time">${formatChatTime(event.created_at)}</span>
            </div>
            <div class="chat-message-content">${content}</div>
            <div class="chat-message-stats">
                <span class="chat-stat chat-likes" data-event-id="${event.id}">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                    <span class="chat-like-count" data-event-id="${event.id}">0</span>
                </span>
                <span class="chat-stat chat-dislikes" data-event-id="${event.id}">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                    <span class="chat-dislike-count" data-event-id="${event.id}">0</span>
                </span>
                <span class="chat-stat chat-zaps" data-event-id="${event.id}">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12">
                        <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                    </svg>
                    <span class="chat-zap-count" data-event-id="${event.id}">0</span>
                </span>
            </div>
            <div class="chat-message-actions">
                <button class="chat-action-btn chat-like-btn" onclick="likeChatMessage('${event.id}')" title="Like" data-event-id="${event.id}">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"/>
                    </svg>
                </button>
                <button class="chat-action-btn chat-dislike-btn" onclick="dislikeChatMessage('${event.id}')" title="Dislike" data-event-id="${event.id}">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"/>
                    </svg>
                </button>
                <button class="chat-action-btn" onclick="replyToChatMessage('${event.id}', '${escapeHtml(displayName)}')" title="Reply">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/>
                    </svg>
                </button>
                ${!isOwnMessage ? `
                    <button class="chat-action-btn chat-zap-btn" onclick="handleZap('${authorNpub}', 100, '${event.id}')" title="Zap" data-event-id="${event.id}">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                        </svg>
                    </button>
                    <button class="chat-action-btn" onclick="handleChatMute('${event.pubkey}')" title="Mute">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69 16.9C4.63 15.55 4 13.85 4 12zm8 8c-1.85 0-3.55-.63-4.9-1.69L18.31 7.1C19.37 8.45 20 10.15 20 12c0 4.42-3.58 8-8 8z"/>
                        </svg>
                    </button>
                    <button class="chat-action-btn" onclick="showReportModal('${event.id}', '${event.pubkey}', 'comment')" title="Report">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"/>
                        </svg>
                    </button>
                ` : ''}
            </div>
        </div>
    `;

    // Insert message in ascending order (oldest first, newest at bottom)
    const existingMessages = container.querySelectorAll('.chat-message[data-timestamp]');
    let inserted = false;
    for (const msg of existingMessages) {
        const msgTimestamp = parseInt(msg.dataset.timestamp);
        // If new message is older than existing, insert before it
        if (event.created_at < msgTimestamp) {
            msg.insertAdjacentHTML('beforebegin', messageHTML);
            inserted = true;
            break;
        }
    }
    // If not inserted yet (newest message), add at the end (bottom)
    if (!inserted) {
        container.insertAdjacentHTML('beforeend', messageHTML);
    }

    // Load reactions and zaps for this message asynchronously
    loadChatMessageReactions(event.id);

    // Auto-scroll to bottom if user is near bottom (since newest messages are at bottom)
    if (isNew && container.scrollHeight - container.scrollTop - container.clientHeight < 100) {
        container.scrollTop = container.scrollHeight;
    }
}

// Helper function to insert chat message HTML in the correct position
function insertChatMessageHTML(container, html, timestamp, isNew) {
    const existingMessages = container.querySelectorAll('.chat-message[data-timestamp]');
    let inserted = false;
    for (const msg of existingMessages) {
        const msgTimestamp = parseInt(msg.dataset.timestamp);
        if (timestamp < msgTimestamp) {
            msg.insertAdjacentHTML('beforebegin', html);
            inserted = true;
            break;
        }
    }
    if (!inserted) {
        container.insertAdjacentHTML('beforeend', html);
    }
    // Auto-scroll for new messages
    if (isNew && container.scrollHeight - container.scrollTop - container.clientHeight < 100) {
        container.scrollTop = container.scrollHeight;
    }
}

// Unhide a muted chat message
function unhideChatMessage(eventId, pubkey) {
    // Temporarily show muted content for this user
    sessionUnhiddenMutedUsers.add(pubkey);
    // Remove the placeholder and reload the message
    const placeholder = document.querySelector(`.chat-message[data-event-id="${eventId}"]`);
    if (placeholder) {
        placeholder.remove();
        // Find the event and re-add it
        const event = currentLiveChat.messages.find(m => m.id === eventId);
        if (event) {
            // Remove from messages array so it can be re-added
            currentLiveChat.messages = currentLiveChat.messages.filter(m => m.id !== eventId);
            const container = document.getElementById('live-chat-messages');
            if (container) {
                addChatMessage(event, container, false);
            }
        }
    }
}

// Unhide a filtered chat message
function unhideFilteredChatMessage(eventId) {
    sessionFilteredAllowed.add(eventId);
    const placeholder = document.querySelector(`.chat-message[data-event-id="${eventId}"]`);
    if (placeholder) {
        placeholder.remove();
        const event = currentLiveChat.messages.find(m => m.id === eventId);
        if (event) {
            currentLiveChat.messages = currentLiveChat.messages.filter(m => m.id !== eventId);
            const container = document.getElementById('live-chat-messages');
            if (container) {
                addChatMessage(event, container, false);
            }
        }
    }
}

// Unhide a reported chat message
function unhideReportedChatMessage(eventId) {
    sessionRatioedAllowed.add(eventId);
    const placeholder = document.querySelector(`.chat-message[data-event-id="${eventId}"]`);
    if (placeholder) {
        placeholder.remove();
        const event = currentLiveChat.messages.find(m => m.id === eventId);
        if (event) {
            currentLiveChat.messages = currentLiveChat.messages.filter(m => m.id !== eventId);
            const container = document.getElementById('live-chat-messages');
            if (container) {
                addChatMessage(event, container, false);
            }
        }
    }
}

// Unhide a ratioed (heavily downvoted) chat message
function unhideRatioedChatMessage(eventId) {
    sessionRatioedAllowed.add(eventId);
    const placeholder = document.querySelector(`.chat-message[data-event-id="${eventId}"]`);
    if (placeholder) {
        placeholder.remove();
        const event = currentLiveChat.messages.find(m => m.id === eventId);
        if (event) {
            currentLiveChat.messages = currentLiveChat.messages.filter(m => m.id !== eventId);
            const container = document.getElementById('live-chat-messages');
            if (container) {
                addChatMessage(event, container, false);
            }
        }
    }
}

// Check if a chat message mentions the current user and show notification
async function checkChatMentionNotification(event) {
    if (!currentUser) return;

    // Don't show notifications from muted users
    if (isUserMuted(event.pubkey)) return;

    // Get current user's profile to check for username mentions
    const myProfile = profileCache.get(currentUser.pubkey);
    const myName = myProfile?.name || myProfile?.display_name || '';

    // Check for @mention of user's name (case insensitive)
    const mentionPattern = new RegExp(`@${myName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');

    if (myName && mentionPattern.test(event.content)) {
        // Show a notification toast
        const senderProfile = await fetchUserProfile(event.pubkey);
        const senderName = senderProfile?.name || senderProfile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
        showToast(`${senderName} mentioned you in live chat`, 'info');

        // Update notification badge
        incrementNotificationBadge();
    }
}

// Increment the notification badge count
function incrementNotificationBadge() {
    const badge = document.querySelector('.notification-badge');
    if (badge) {
        const current = parseInt(badge.textContent) || 0;
        badge.textContent = current + 1;
        badge.style.display = 'flex';
    }
}

// Reply to chat message by adding @mention
function replyToChatMessage(eventId, displayName) {
    const input = document.getElementById('live-chat-input');
    if (!input) return;

    // Add @mention at cursor position or end
    const mention = `@${displayName.replace(/\s+/g, '')} `;
    input.value = mention + input.value;
    input.focus();
    input.setSelectionRange(mention.length, mention.length);
}

// Load reactions (likes/dislikes) and zaps for a chat message
async function loadChatMessageReactions(eventId) {
    const filter = {
        kinds: [7], // Reactions
        '#e': [eventId],
        limit: 50
    };

    const zapFilter = {
        kinds: [9735],
        '#e': [eventId],
        limit: 20
    };

    let likes = 0;
    let dislikes = 0;
    let zapAmount = 0;

    // Load reactions
    requestEventsStream(filter, (event) => {
        if (event.content === '+' || event.content === '👍') {
            likes++;
        } else if (event.content === '-' || event.content === '👎') {
            dislikes++;
        }
    }, () => {
        // Update UI
        const likeCount = document.querySelector(`.chat-like-count[data-event-id="${eventId}"]`);
        const dislikeCount = document.querySelector(`.chat-dislike-count[data-event-id="${eventId}"]`);
        if (likeCount && likes > 0) likeCount.textContent = likes;
        if (dislikeCount && dislikes > 0) dislikeCount.textContent = dislikes;

        // Check if message is ratioed (more dislikes than likes, at least 3 dislikes)
        const isRatioed = dislikes > likes && dislikes >= 3;
        if (isRatioed && !sessionRatioedAllowed.has(eventId) && !shouldSkipCommunityWarning()) {
            // Find the message element and check if it's not own message
            const msgEl = document.querySelector(`.chat-message[data-event-id="${eventId}"]:not(.ratioed-chat-message)`);
            if (msgEl) {
                const msgPubkey = msgEl.dataset.pubkey;
                // Don't hide own messages
                if (!currentUser || currentUser.pubkey !== msgPubkey) {
                    const timestamp = msgEl.dataset.timestamp;
                    const placeholderHTML = `
                        <div class="chat-message ratioed-chat-message" data-event-id="${eventId}" data-pubkey="${msgPubkey}" data-timestamp="${timestamp}">
                            <div class="chat-hidden-placeholder" style="border-color: #ff9800;">
                                <span style="color: #ff9800;">👎</span>
                                <span>Message heavily downvoted</span>
                                <button class="chat-unhide-btn" onclick="unhideRatioedChatMessage('${eventId}')">Show</button>
                            </div>
                        </div>
                    `;
                    msgEl.outerHTML = placeholderHTML;
                }
            }
        }
    });

    // Load zaps
    requestEventsStream(zapFilter, (event) => {
        const bolt11Tag = event.tags.find(t => t[0] === 'bolt11');
        if (bolt11Tag && bolt11Tag[1]) {
            const amount = extractAmountFromBolt11(bolt11Tag[1]);
            if (amount > 0) zapAmount += amount;
        }
    }, () => {
        const zapCount = document.querySelector(`.chat-zap-count[data-event-id="${eventId}"]`);
        if (zapCount && zapAmount > 0) zapCount.textContent = formatSats(zapAmount);
    });
}

// Dislike a chat message
async function dislikeChatMessage(eventId) {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const event = {
        kind: 7,
        created_at: Math.floor(Date.now() / 1000),
        tags: [['e', eventId]],
        content: '-'
    };

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            // Update UI immediately
            const dislikeCount = document.querySelector(`.chat-dislike-count[data-event-id="${eventId}"]`);
            if (dislikeCount) {
                const current = parseInt(dislikeCount.textContent) || 0;
                dislikeCount.textContent = current + 1;
            }
        }
    } catch (error) {
        console.error('Failed to dislike chat message:', error);
    }
}

async function addZapNotification(event, container, isNew = false) {
    try {
        // Prevent duplicate zap notifications
        if (currentLiveChat.zapEventIds && currentLiveChat.zapEventIds.has(event.id)) return;
        if (currentLiveChat.zapEventIds) currentLiveChat.zapEventIds.add(event.id);

        const bolt11Tag = event.tags.find(t => t[0] === 'bolt11');
        if (!bolt11Tag || !bolt11Tag[1]) return;

        const amount = extractAmountFromBolt11(bolt11Tag[1]);
        if (amount <= 0) return;

        // Get sender from description
        const descTag = event.tags.find(t => t[0] === 'description');
        let senderPubkey = null;
        if (descTag && descTag[1]) {
            try {
                const desc = JSON.parse(descTag[1]);
                senderPubkey = desc.pubkey;
            } catch (e) {}
        }

        // Fetch sender profile if not cached
        let senderName = 'Someone';
        if (senderPubkey) {
            let profile = profileCache.get(senderPubkey);
            if (!profile) {
                // Fetch profile asynchronously
                profile = await fetchUserProfile(senderPubkey);
            }
            senderName = profile?.name || profile?.display_name || `User ${senderPubkey.slice(0, 8)}`;
        }

        const messageHTML = `
            <div class="chat-message zap-notification" data-zap-event-id="${event.id}" data-timestamp="${event.created_at}">
                <div class="chat-message-content">
                    <svg class="zap-icon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M7 2v11h3v9l7-12h-4l4-8z"/>
                    </svg>
                    ${escapeHtml(senderName)} zapped ${formatSats(amount)} sats!
                </div>
            </div>
        `;

        // Insert zap notification in ascending order (by timestamp)
        const existingMessages = container.querySelectorAll('.chat-message[data-timestamp]');
        let inserted = false;
        for (const msg of existingMessages) {
            const msgTimestamp = parseInt(msg.dataset.timestamp);
            // If zap is older than this message, insert before it
            if (event.created_at < msgTimestamp) {
                msg.insertAdjacentHTML('beforebegin', messageHTML);
                inserted = true;
                break;
            }
        }
        // If not inserted yet (newest), add at the end (bottom)
        if (!inserted) {
            container.insertAdjacentHTML('beforeend', messageHTML);
        }

        // Auto-scroll for new zaps if user is near bottom
        if (isNew && container.scrollHeight - container.scrollTop - container.clientHeight < 100) {
            container.scrollTop = container.scrollHeight;
        }
    } catch (e) {
        console.error('Failed to add zap notification:', e);
    }
}

function processChatMentions(content) {
    // Process @mentions
    return escapeHtml(content).replace(/@(\w+)/g, '<span class="mention">@$1</span>');
}

function formatChatTime(timestamp) {
    const date = new Date(timestamp * 1000);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

async function sendLiveChatMessage(eventId) {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const input = document.getElementById('live-chat-input');
    const message = input.value.trim();

    if (!message) return;

    // Get the stream event to construct the 'a' tag
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    const event = {
        kind: NIP53_LIVE_CHAT_KIND,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
            ['a', aTagValue, '', 'root']
        ],
        content: message
    };

    // Disable input while sending
    input.disabled = true;
    const sendBtn = document.getElementById('live-chat-send');
    sendBtn.disabled = true;

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            input.value = '';

            // Add message to chat immediately
            const chatContainer = document.getElementById('live-chat-messages');
            if (chatContainer) {
                addChatMessage(signedEvent, chatContainer, true);
            }
        }
    } catch (error) {
        console.error('Failed to send chat message:', error);
    } finally {
        input.disabled = false;
        sendBtn.disabled = false;
        input.focus();
    }
}

async function likeChatMessage(eventId) {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const event = {
        kind: 7,
        created_at: Math.floor(Date.now() / 1000),
        tags: [['e', eventId]],
        content: '+'
    };

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            // Update UI immediately
            const likeCount = document.querySelector(`.chat-like-count[data-event-id="${eventId}"]`);
            if (likeCount) {
                const current = parseInt(likeCount.textContent) || 0;
                likeCount.textContent = current + 1;
            }
            // Add visual feedback
            const likeBtn = document.querySelector(`.chat-like-btn[data-event-id="${eventId}"]`);
            if (likeBtn) {
                likeBtn.classList.add('liked');
            }
        }
    } catch (error) {
        console.error('Failed to like chat message:', error);
    }
}

// Track viewer presence - publishes a presence event and sets up periodic updates
async function trackLiveViewer(eventId) {
    // Clear any existing viewer tracking interval
    if (currentLiveChat.viewerTrackingInterval) {
        clearInterval(currentLiveChat.viewerTrackingInterval);
        currentLiveChat.viewerTrackingInterval = null;
    }

    // Record initial view
    console.log('Recording initial viewer presence for:', eventId);
    await recordLiveViewer(eventId);

    // Load current viewer count
    await loadLiveViewers(eventId);

    // Set up interval to send presence updates every 4 minutes (before 5min timeout)
    console.log(`Setting up viewer presence interval (${LIVE_VIEWER_UPDATE_INTERVAL}ms)`);
    currentLiveChat.viewerTrackingInterval = setInterval(async () => {
        console.log('Viewer presence interval fired, checking conditions...');
        console.log('currentView:', currentView, 'eventId match:', currentLiveChat.eventId === eventId);
        if (currentView !== 'live' || currentLiveChat.eventId !== eventId) {
            console.log('Stopping viewer presence interval - view changed or stream changed');
            clearInterval(currentLiveChat.viewerTrackingInterval);
            currentLiveChat.viewerTrackingInterval = null;
            return;
        }
        console.log('Sending viewer presence update...');
        await recordLiveViewer(eventId);
    }, LIVE_VIEWER_UPDATE_INTERVAL); // Every 4 minutes
}

// Publish a live viewer presence event (replaceable - one per user per stream)
async function recordLiveViewer(eventId) {
    const event = allEvents.get(eventId);
    if (!event) return;

    const liveData = parseLiveEvent(event);
    if (!liveData) return;

    const now = Math.floor(Date.now() / 1000);
    const dTagValue = `${LIVE_VIEWER_TRACKING_APP_ID}/${event.pubkey}:${liveData.dTag}`;

    // Build presence event
    const viewerEvent = {
        kind: VIEW_EVENT_KIND,
        created_at: now,
        tags: [
            ['d', dTagValue],
            ['t', 'live-viewer'],
            ['e', eventId],
            ['p', event.pubkey],
            ['client', 'Plebs']
        ],
        content: JSON.stringify({
            timestamp: now,
            streamId: eventId
        })
    };

    try {
        if (currentUser) {
            // Logged-in user: sign with their key
            const signedEvent = await signEvent(viewerEvent);
            if (signedEvent) {
                await publishEvent(signedEvent);
                console.log('Published viewer presence (logged in user)');
            }
        } else {
            // Anonymous user: generate ephemeral keypair
            const sk = window.NostrTools.generateSecretKey();
            const signedEvent = window.NostrTools.finalizeEvent(viewerEvent, sk);
            await publishEvent(signedEvent);
            console.log('Published viewer presence (anonymous user)');
        }
    } catch (e) {
        console.error('Failed to record live viewer:', e);
    }
}

// Load and count active live viewers (those who updated within timeout window)
async function loadLiveViewers(eventId) {
    const event = allEvents.get(eventId);
    if (!event) return 0;

    const liveData = parseLiveEvent(event);
    if (!liveData) return 0;

    const cutoffTime = Math.floor(Date.now() / 1000) - LIVE_VIEWER_TIMEOUT;
    const viewers = new Set();

    // Build the d-tag pattern for this stream's viewers
    const dTagPattern = `${LIVE_VIEWER_TRACKING_APP_ID}/${event.pubkey}:${liveData.dTag}`;

    return new Promise((resolve) => {
        // Use #d filter (canonical for NIP-78 replaceable events) plus #e for reliability
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#d': [dTagPattern],
            limit: 500
        };

        requestEventsStream(filter, (viewerEvent) => {
            // Only count viewers who updated within timeout window
            if (viewerEvent.created_at >= cutoffTime) {
                viewers.add(viewerEvent.pubkey);
            }
        }, () => {
            const count = viewers.size;
            updateLiveViewerCount(count);
            resolve(count);
        });
    });
}

// Update live viewer count on page and cards
function updateLiveViewerCount(count) {
    // Update main viewer count on live stream page
    const viewerCountEl = document.getElementById('viewer-count-number');
    if (viewerCountEl) {
        viewerCountEl.textContent = formatNumber(count);
    }

    // Update any visible live stream cards with this event ID
    if (currentLiveChat.eventId) {
        const cards = document.querySelectorAll(`[data-live-event-id="${currentLiveChat.eventId}"] .live-viewers-count`);
        cards.forEach(card => {
            card.textContent = formatNumber(count);
        });
    }
}

// Load viewer count for a live stream card (used in grids/homepage)
async function loadLiveStreamCardViewers(eventId) {
    const event = allEvents.get(eventId);
    if (!event) return 0;

    const liveData = parseLiveEvent(event);
    if (!liveData) return 0;

    const cutoffTime = Math.floor(Date.now() / 1000) - LIVE_VIEWER_TIMEOUT;
    const viewers = new Set();

    // Build the d-tag pattern for this stream's viewers
    const dTagPattern = `${LIVE_VIEWER_TRACKING_APP_ID}/${event.pubkey}:${liveData.dTag}`;

    return new Promise((resolve) => {
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#d': [dTagPattern],
            limit: 500
        };

        requestEventsStream(filter, (viewerEvent) => {
            // Only count viewers who updated within timeout window
            if (viewerEvent.created_at >= cutoffTime) {
                viewers.add(viewerEvent.pubkey);
            }
        }, () => {
            const count = viewers.size;
            // Update the card's viewer count
            const card = document.querySelector(`[data-live-event-id="${eventId}"] .live-viewers-count`);
            if (card) {
                card.textContent = formatNumber(count);
            }
            resolve(count);
        });
    });
}

// Load viewer counts for multiple live stream cards (batch operation)
async function loadLiveStreamCardsViewers(eventIds) {
    if (!eventIds || eventIds.length === 0) return;

    const cutoffTime = Math.floor(Date.now() / 1000) - LIVE_VIEWER_TIMEOUT;
    const viewersByStream = new Map(); // eventId -> Set of viewer pubkeys
    const dTagToEventId = new Map(); // dTagPattern -> eventId

    // Build d-tag patterns for each event and initialize viewer sets
    const dTagPatterns = [];
    eventIds.forEach(eventId => {
        viewersByStream.set(eventId, new Set());
        const event = allEvents.get(eventId);
        if (event) {
            const liveData = parseLiveEvent(event);
            if (liveData) {
                const dTagPattern = `${LIVE_VIEWER_TRACKING_APP_ID}/${event.pubkey}:${liveData.dTag}`;
                dTagPatterns.push(dTagPattern);
                dTagToEventId.set(dTagPattern, eventId);
            }
        }
    });

    if (dTagPatterns.length === 0) return viewersByStream;

    return new Promise((resolve) => {
        const filter = {
            kinds: [VIEW_EVENT_KIND],
            '#d': dTagPatterns,
            limit: 1000
        };

        requestEventsStream(filter, (viewerEvent) => {
            // Only count viewers who updated within timeout window
            if (viewerEvent.created_at < cutoffTime) return;

            // Find which stream this viewer event is for using d-tag
            const dTag = viewerEvent.tags.find(t => t[0] === 'd')?.[1];
            if (dTag && dTagToEventId.has(dTag)) {
                const streamId = dTagToEventId.get(dTag);
                if (viewersByStream.has(streamId)) {
                    viewersByStream.get(streamId).add(viewerEvent.pubkey);
                }
            }
        }, () => {
            // Update all cards with their viewer counts
            viewersByStream.forEach((viewers, eventId) => {
                const count = viewers.size;
                const card = document.querySelector(`[data-live-event-id="${eventId}"] .live-viewers-count`);
                if (card) {
                    card.textContent = formatNumber(count);
                }
            });
            resolve(viewersByStream);
        });
    });
}

// End live stream (for host)
async function endLiveStream(eventId) {
    if (!currentUser) return;

    const streamEvent = allEvents.get(eventId);
    if (!streamEvent || streamEvent.pubkey !== currentUser.pubkey) {
        showToast('You can only end your own streams', 'error');
        return;
    }

    showConfirmModal(
        'End Live Stream',
        'Are you sure you want to end this live stream? This action cannot be undone.',
        async () => {
            await performEndLiveStream(eventId, streamEvent);
        },
        { confirmText: 'End Stream', danger: true }
    );
}

// Actually perform the stream ending after confirmation
async function performEndLiveStream(eventId, streamEvent) {
    const liveData = parseLiveEvent(streamEvent);

    // Create updated event with 'ended' status
    const updatedTags = streamEvent.tags.map(tag => {
        if (tag[0] === 'status') return ['status', 'ended'];
        return tag;
    });

    // Add ends timestamp if not present
    if (!updatedTags.some(t => t[0] === 'ends')) {
        updatedTags.push(['ends', String(Math.floor(Date.now() / 1000))]);
    }

    const event = {
        kind: NIP53_LIVE_EVENT_KIND,
        created_at: Math.floor(Date.now() / 1000),
        tags: updatedTags,
        content: ''
    };

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            allEvents.set(signedEvent.id, signedEvent);

            // Update UI in place instead of reloading
            updateStreamEndedUI(eventId, liveData);
            showToast('Stream ended successfully', 'success');
        }
    } catch (error) {
        console.error('Failed to end stream:', error);
        showToast('Failed to end stream', 'error');
    }
}

// Update the UI when a stream is ended
function updateStreamEndedUI(eventId, liveData) {
    // Update status badge from LIVE to ENDED
    const statusBadge = document.querySelector('.live-status-badge');
    if (statusBadge) {
        statusBadge.textContent = t('status.ended');
        statusBadge.classList.add('ended');
    }

    // Hide viewer count
    const viewerCount = document.getElementById('live-viewer-count');
    if (viewerCount) {
        viewerCount.style.display = 'none';
    }

    // Show ended overlay on the player
    const player = document.querySelector('.live-stream-player');
    if (player) {
        // Remove any existing stream embed
        const existingEmbed = player.querySelector('iframe, video');
        if (existingEmbed) {
            existingEmbed.remove();
        }

        // Add ended overlay if not already present
        if (!player.querySelector('.stream-overlay')) {
            const endedOverlay = document.createElement('div');
            endedOverlay.className = 'stream-overlay';
            endedOverlay.innerHTML = `
                ${liveData.thumbnail ? `<img src="${liveData.thumbnail}" class="thumbnail-preview" alt="Stream thumbnail">` : ''}
                <h2>Stream Ended</h2>
                <p>This live stream has ended.</p>
            `;
            player.appendChild(endedOverlay);
        }
    }

    // Remove the End Stream button
    const actionsContainer = document.getElementById(`live-stream-actions-${eventId}`);
    if (actionsContainer) {
        const endStreamBtn = actionsContainer.querySelector('button[onclick*="endLiveStream"]');
        if (endStreamBtn) {
            endStreamBtn.remove();
        }
    }

    // Disable live chat input
    const chatInput = document.getElementById('live-chat-input');
    if (chatInput) {
        chatInput.disabled = true;
        chatInput.placeholder = 'Chat is closed - stream has ended';
    }

    const sendBtn = document.getElementById('live-chat-send');
    if (sendBtn) {
        sendBtn.disabled = true;
    }

    // Update the chat header to show ended status
    const chatHeader = document.querySelector('.live-chat-header h3');
    if (chatHeader) {
        chatHeader.innerHTML = `
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                <path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"/>
            </svg>
            Chat (Ended)
        `;
    }

    // Clean up live chat subscriptions
    cleanupLiveChatSubscriptions();
}

// ===== Live Feed Page =====
async function loadLiveFeed() {
    currentView = 'live';
    const mainContent = document.getElementById('mainContent');

    mainContent.innerHTML = `
        <div class="live-feed-header">
            <h2>
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                    <circle cx="12" cy="12" r="4" fill="#f44336"/>
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                </svg>
                Live Streams
            </h2>
            <span class="live-count" id="live-count">Loading...</span>
        </div>

        <div class="live-feed-section" id="live-now-section">
            <div class="video-grid" id="live-now-grid"></div>
        </div>

        <div class="live-feed-section" id="scheduled-section" style="display: none;">
            <h3>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM9 10H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm-8 4H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2z"/>
                </svg>
                Upcoming Streams
            </h3>
            <div class="scheduled-streams-list" id="scheduled-streams-list"></div>
        </div>

        <div class="live-feed-section" id="past-streams-section" style="display: none;">
            <h3>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"/>
                </svg>
                Past Streams
            </h3>
            <div class="video-grid" id="past-streams-grid"></div>
        </div>
    `;

    // Show skeleton loading cards while fetching
    showLiveStreamSkeletonGrid(document.getElementById('live-now-grid'), 4);

    // Load live streams
    const liveStreams = [];
    const scheduledStreams = [];
    const pastStreams = [];

    const filter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        '#t': ['pv69420'],
        limit: 100
    };

    requestEventsStream(filter, (event) => {
        const liveData = parseLiveEvent(event);
        if (!liveData) return;

        if (isLiveStreamActive(liveData)) {
            liveStreams.push({ event, liveData });
        } else if (isLiveStreamScheduled(liveData)) {
            scheduledStreams.push({ event, liveData });
        } else if (isLiveStreamEnded(liveData)) {
            pastStreams.push({ event, liveData });
        }
    }, async () => {
        // Update live count
        document.getElementById('live-count').textContent = `${liveStreams.length} live`;

        // Render live streams
        const liveNowGrid = document.getElementById('live-now-grid');
        if (liveStreams.length === 0) {
            liveNowGrid.innerHTML = `<p style="color: var(--text-secondary); text-align: center; grid-column: 1/-1;">${t('empty.noLiveNow')}</p>`;
        } else {
            liveNowGrid.innerHTML = '';
            const liveEventIds = [];
            for (const { event, liveData } of liveStreams) {
                const profile = await fetchUserProfile(event.pubkey);
                const card = createLiveStreamCard(event, liveData, profile);
                liveNowGrid.insertAdjacentHTML('beforeend', card);
                liveEventIds.push(event.id);
            }
            // Load actual viewer counts for all live streams
            loadLiveStreamCardsViewers(liveEventIds);
        }

        // Render scheduled streams
        if (scheduledStreams.length > 0) {
            document.getElementById('scheduled-section').style.display = 'block';
            const scheduledList = document.getElementById('scheduled-streams-list');
            scheduledList.innerHTML = '';

            // Sort by start time
            scheduledStreams.sort((a, b) => a.liveData.starts - b.liveData.starts);

            for (const { event, liveData } of scheduledStreams) {
                const profile = await fetchUserProfile(event.pubkey);
                const card = createScheduledStreamCard(event, liveData, profile);
                scheduledList.insertAdjacentHTML('beforeend', card);
            }
        }

        // Render past streams
        if (pastStreams.length > 0) {
            document.getElementById('past-streams-section').style.display = 'block';
            const pastGrid = document.getElementById('past-streams-grid');
            pastGrid.innerHTML = '';

            // Sort by end time (most recent first)
            pastStreams.sort((a, b) => (b.liveData.ends || b.event.created_at) - (a.liveData.ends || a.event.created_at));

            for (const { event, liveData } of pastStreams.slice(0, 12)) {
                const profile = await fetchUserProfile(event.pubkey);
                const card = createLiveStreamCard(event, liveData, profile, true);
                pastGrid.insertAdjacentHTML('beforeend', card);
            }
        }
    });
}

function createLiveStreamCard(event, liveData, profile, isEnded = false, reactions = null) {
    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';

    // Check boost level
    const boostAmount = boostsCache.get(event.id) || 0;
    const boostLevel = getBoostLevel(boostAmount);
    const isBoosted = boostLevel > 0;
    const boostClasses = isBoosted ? `boosted boost-level-${boostLevel}` : '';

    // Check if nip05 validation is cached
    const validationCached = profileValidationCache.get(event.pubkey);
    const nip05Valid = validationCached?.nip05Valid || false;

    // Validate nip05 async if not cached
    if (nip05 && !validationCached) {
        setTimeout(() => {
            validateNip05(nip05, event.pubkey).then(isValid => {
                if (isValid) {
                    const card = document.querySelector(`.video-card[data-pubkey="${event.pubkey}"][data-live-event-id="${event.id}"] .channel-nip05`);
                    if (card) applyNip05Checkmark(card, true);
                }
            });
        }, 0);
    }

    // Check NSFW and community warning states
    const isNSFW = liveData.isNSFW || false;
    const cachedReactions = reactions || reactionsCache.get(event.id) || {};
    const isRatioed = isVideoRatioed(cachedReactions);

    // Check suspicious profile
    const profileChecked = profileCache.has(event.pubkey);
    const isSuspiciousProfile = profileChecked && (!profile || !avatarUrl || !nip05);

    // Determine what type of overlay to show (skip for own streams)
    const isOwnStream = currentUser?.pubkey === event.pubkey;
    const showNSFWOverlay = !isOwnStream && isNSFW && !shouldShowNSFW();
    // Check if reported by follows (skip for own streams)
    const isReportedByFollowsCheck = !isOwnStream && isReportedByFollowsSync(event.id, event.pubkey);
    const showCommunityWarning = !isOwnStream && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning();
    const showBlurred = showNSFWOverlay || showCommunityWarning;
    const overlayType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    return `
        <div class="video-card is-live ${boostClasses}" data-live-event-id="${event.id}" data-pubkey="${event.pubkey}" onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playLive', '${event.id}')` : `showRatioedModal('${event.id}', 'live')`) : `navigateTo('/live/${event.id}')`}">
            <div class="video-thumbnail ${showBlurred ? overlayType : ''}">
                ${liveData.thumbnail ?
                    `<img src="${liveData.thumbnail}" alt="${liveData.title}"${showBlurred ? ' style="filter: blur(20px);"' : ''}>` :
                    '<div style="width:100%; height:100%; background: var(--bg-secondary);"></div>'
                }
                ${showBlurred ? `
                    <div class="${overlayType}-overlay">
                        <div class="${overlayType}-badge">${overlayType === 'nsfw' ? t('badge.nsfw') : t('badge.communityWarning')}</div>
                        <div>Click to view</div>
                    </div>
                ` : ''}
                ${!isEnded && !showBlurred ? '<div class="live-badge">Live</div>' : ''}
                ${!isEnded && !showBlurred ? `
                    <div class="live-viewers">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <span class="live-viewers-count">${liveData.currentParticipants || 0}</span>
                    </div>
                ` : ''}
                ${isBoosted && !showBlurred ? `
                    <div class="boost-indicator">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z" stroke-width="2"/>
                        </svg>
                        ${formatSats(boostAmount)}
                    </div>
                ` : ''}
            </div>
            <div class="video-info">
                <a href="#/profile/${event.pubkey}" class="channel-info" onclick="event.stopPropagation();">
                    <div class="channel-avatar">
                        ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                    </div>
                    <div class="channel-details">
                        <div class="channel-name">${escapeHtml(displayName)}</div>
                        ${nip05 ? `<div class="channel-nip05">${nip05}${nip05Valid ? getNip05CheckmarkSVG(12) : ''}</div>` : ''}
                    </div>
                </a>
                <h3 class="video-title">${escapeHtml(liveData.title)}</h3>
                <div class="video-meta">
                    ${isEnded ? 'Ended ' : 'Started '}${formatTimestamp(isEnded ? (liveData.ends || event.created_at) : liveData.starts)}
                    ${liveData.isNSFW ? ' • <span style="color: #f44336;">NSFW</span>' : ''}
                </div>
            </div>
        </div>
    `;
}

function createScheduledStreamCard(event, liveData, profile) {
    const displayName = profile?.name || profile?.display_name || `User ${event.pubkey.slice(0, 8)}`;
    const avatarUrl = profile?.picture || profile?.avatar || '';
    const nip05 = profile?.nip05 || '';
    const scheduleDate = new Date(liveData.starts * 1000);

    // Check if nip05 validation is cached
    const validationCached = profileValidationCache.get(event.pubkey);
    const nip05Valid = validationCached?.nip05Valid || false;

    // Validate nip05 async if not cached
    if (nip05 && !validationCached) {
        setTimeout(() => {
            validateNip05(nip05, event.pubkey).then(isValid => {
                if (isValid) {
                    const card = document.querySelector(`.scheduled-stream-card[data-pubkey="${event.pubkey}"][data-event-id="${event.id}"] .channel-nip05`);
                    if (card) applyNip05Checkmark(card, true);
                }
            });
        }, 0);
    }

    // Check NSFW and community warning states
    const isNSFW = liveData.isNSFW || false;
    const cachedReactions = reactionsCache.get(event.id) || {};
    const isRatioed = isVideoRatioed(cachedReactions);

    // Check suspicious profile
    const profileChecked = profileCache.has(event.pubkey);
    const isSuspiciousProfile = profileChecked && (!profile || !avatarUrl || !nip05);

    // Determine what type of overlay to show (skip for own streams)
    const isOwnStream = currentUser?.pubkey === event.pubkey;
    const showNSFWOverlay = !isOwnStream && isNSFW && !shouldShowNSFW();
    const isReportedByFollowsCheck = !isOwnStream && isReportedByFollowsSync(event.id, event.pubkey);
    const showCommunityWarning = !isOwnStream && (isRatioed || isSuspiciousProfile || isReportedByFollowsCheck) && !sessionRatioedAllowed.has(event.id) && !shouldSkipCommunityWarning();
    const showBlurred = showNSFWOverlay || showCommunityWarning;
    const overlayType = showNSFWOverlay ? 'nsfw' : 'ratioed';

    return `
        <div class="scheduled-stream-card" data-event-id="${event.id}" data-pubkey="${event.pubkey}" onclick="${showBlurred ? (overlayType === 'nsfw' ? `showNSFWModal('playLive', '${event.id}')` : `showRatioedModal('${event.id}', 'live')`) : `navigateTo('/live/${event.id}')`}">
            <div class="scheduled-stream-thumbnail ${showBlurred ? overlayType : ''}">
                ${liveData.thumbnail ?
                    `<img src="${liveData.thumbnail}" alt="${liveData.title}"${showBlurred ? ' style="filter: blur(20px);"' : ''}>` :
                    '<div style="width:100%; height:100%; background: var(--bg-secondary);"></div>'
                }
                ${showBlurred ? `
                    <div class="${overlayType}-overlay">
                        <div class="${overlayType}-badge">${overlayType === 'nsfw' ? t('badge.nsfw') : t('badge.communityWarning')}</div>
                        <div>Click to view</div>
                    </div>
                ` : `<div class="scheduled-badge">SCHEDULED</div>`}
            </div>
            <div class="scheduled-stream-info">
                <h4>${escapeHtml(liveData.title)}</h4>
                <div class="scheduled-stream-time">
                    ${scheduleDate.toLocaleDateString()} at ${scheduleDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                </div>
                ${liveData.summary ? `<p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.25rem;">${escapeHtml(liveData.summary.slice(0, 100))}${liveData.summary.length > 100 ? '...' : ''}</p>` : ''}
                <div class="scheduled-stream-creator">
                    ${avatarUrl ? `<img src="${avatarUrl}" alt="${displayName}">` : ''}
                    <span>${escapeHtml(displayName)}</span>
                    ${nip05 ? `<span class="channel-nip05" style="margin-left: 0.5rem; font-size: 0.75rem; color: var(--text-secondary);">${nip05}${nip05Valid ? getNip05CheckmarkSVG(12) : ''}</span>` : ''}
                </div>
            </div>
        </div>
    `;
}

// Format sats for display
function formatSats(sats) {
    if (sats >= 1000000) {
        return `${(sats / 1000000).toFixed(1)}M`;
    } else if (sats >= 1000) {
        return `${(sats / 1000).toFixed(1)}K`;
    }
    return sats.toString();
}

// ===== Live Stream Action Functions =====

// Like a live stream (uses #a tag for persistence across stream updates)
async function handleLiveLike(eventId) {
    if (!await ensureLoggedIn()) return;

    // Get stream event to construct the 'a' tag
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    const event = {
        kind: 7,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
            ['a', aTagValue],
            ['e', eventId],
            ['p', streamEvent.pubkey],
            ['t', 'pv69420']
        ],
        content: '+'
    };

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            // Update UI immediately
            const likeCount = document.querySelector(`.live-like-count[data-event-id="${eventId}"]`);
            const likeBtn = document.querySelector(`.action-btn.like[data-event-id="${eventId}"]`);
            if (likeCount) {
                const current = parseInt(likeCount.textContent) || 0;
                likeCount.textContent = current + 1;
            }
            if (likeBtn) likeBtn.classList.add('active');
            showToast('Liked!', 'success');
        }
    } catch (error) {
        console.error('Failed to like live stream:', error);
    }
}

// Dislike a live stream (uses #a tag for persistence across stream updates)
async function handleLiveDislike(eventId) {
    if (!await ensureLoggedIn()) return;

    // Get stream event to construct the 'a' tag
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    const event = {
        kind: 7,
        created_at: Math.floor(Date.now() / 1000),
        tags: [
            ['a', aTagValue],
            ['e', eventId],
            ['p', streamEvent.pubkey],
            ['t', 'pv69420']
        ],
        content: '-'
    };

    try {
        const signedEvent = await signEvent(event);
        if (signedEvent) {
            await publishEvent(signedEvent);
            // Update UI immediately
            const dislikeCount = document.querySelector(`.live-dislike-count[data-event-id="${eventId}"]`);
            const dislikeBtn = document.querySelector(`.action-btn.dislike[data-event-id="${eventId}"]`);
            if (dislikeCount) {
                const current = parseInt(dislikeCount.textContent) || 0;
                dislikeCount.textContent = current + 1;
            }
            if (dislikeBtn) dislikeBtn.classList.add('active');
            showToast('Disliked!', 'success');
        }
    } catch (error) {
        console.error('Failed to dislike live stream:', error);
    }
}

// Load reactions for a live stream (queries by #a tag for persistence)
async function loadLiveStreamReactions(eventId) {
    // Get stream event to construct the 'a' tag
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    // Query by both #a and #e tags to catch all reactions
    const filter = {
        kinds: [7],
        '#a': [aTagValue],
        limit: 200
    };

    let likes = 0;
    let dislikes = 0;
    let userReaction = null;
    const seenReactions = new Set();

    requestEventsStream(filter, (event) => {
        // Deduplicate by event id
        if (seenReactions.has(event.id)) return;
        seenReactions.add(event.id);

        if (event.content === '+' || event.content === '👍') {
            likes++;
            if (currentUser && event.pubkey === currentUser.pubkey) {
                userReaction = 'like';
            }
        } else if (event.content === '-' || event.content === '👎') {
            dislikes++;
            if (currentUser && event.pubkey === currentUser.pubkey) {
                userReaction = 'dislike';
            }
        }
    }, () => {
        // Update UI
        const likeCount = document.querySelector(`.live-like-count[data-event-id="${eventId}"]`);
        const dislikeCount = document.querySelector(`.live-dislike-count[data-event-id="${eventId}"]`);
        const likeBtn = document.querySelector(`.action-btn.like[data-event-id="${eventId}"]`);
        const dislikeBtn = document.querySelector(`.action-btn.dislike[data-event-id="${eventId}"]`);

        if (likeCount) likeCount.textContent = formatNumber(likes);
        if (dislikeCount) dislikeCount.textContent = formatNumber(dislikes);

        if (userReaction === 'like' && likeBtn) likeBtn.classList.add('active');
        if (userReaction === 'dislike' && dislikeBtn) dislikeBtn.classList.add('active');
    });
}

// Live stream zap goal tracking
let liveStreamZapSubscription = null;
let liveStreamZapTotal = 0;

async function initLiveStreamZapGoal(eventId, zapGoal) {
    liveStreamZapTotal = 0;

    // Get stream event to construct the 'a' tag for persistence
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    // Get the goal_since timestamp (if goal was reset, only count zaps after that)
    const goalSince = liveData.zapGoalSince || 0;

    // Query by #a tag for persistence across stream updates
    const filter = {
        kinds: [9735],
        '#a': [aTagValue],
        limit: 500
    };

    // If there's a goal_since, add it to the filter
    if (goalSince > 0) {
        filter.since = goalSince;
    }

    const processedZaps = new Set();

    requestEventsStream(filter, (event) => {
        if (processedZaps.has(event.id)) return;
        processedZaps.add(event.id);

        // Double-check timestamp if goal_since is set (some relays may not respect 'since')
        if (goalSince > 0 && event.created_at < goalSince) return;

        const amount = getZapAmount(event);
        if (amount > 0) {
            liveStreamZapTotal += amount;
        }
    }, () => {
        // Update the display with initial total
        updateZapGoalDisplay(liveStreamZapTotal, zapGoal, false);

        // Subscribe to new zaps in real-time
        subscribeLiveStreamZaps(aTagValue, zapGoal, processedZaps, goalSince);
    });
}

function subscribeLiveStreamZaps(aTagValue, zapGoal, processedZaps, goalSince = 0) {
    // Clean up any existing subscription
    if (liveStreamZapSubscription) {
        try {
            liveStreamZapSubscription.close();
        } catch (e) {}
    }

    // Subscribe using #a tag for persistence across stream updates
    // Use goalSince if set (for reset goals), otherwise use current time
    const sinceTime = goalSince > 0 ? goalSince : Math.floor(Date.now() / 1000);
    const filter = {
        kinds: [9735],
        '#a': [aTagValue],
        since: sinceTime
    };

    // Create a subscription for new zaps
    liveStreamZapSubscription = {
        active: true,
        close: () => { liveStreamZapSubscription.active = false; }
    };

    // Poll for new zaps every 5 seconds
    const pollInterval = setInterval(() => {
        if (!liveStreamZapSubscription || !liveStreamZapSubscription.active) {
            clearInterval(pollInterval);
            return;
        }

        // Check if we're still on the live stream page
        if (!document.getElementById('live-zap-goal')) {
            clearInterval(pollInterval);
            return;
        }

        requestEventsStream(filter, (event) => {
            if (processedZaps.has(event.id)) return;
            processedZaps.add(event.id);

            // Double-check timestamp if goalSince is set
            if (goalSince > 0 && event.created_at < goalSince) return;

            const amount = getZapAmount(event);
            if (amount > 0) {
                liveStreamZapTotal += amount;
                updateZapGoalDisplay(liveStreamZapTotal, zapGoal, true);
            }
        }, () => {});
    }, 5000);
}

function getZapAmount(zapEvent) {
    try {
        const bolt11Tag = zapEvent.tags.find(tag => tag[0] === 'bolt11');
        if (bolt11Tag && bolt11Tag[1]) {
            return extractAmountFromBolt11(bolt11Tag[1]);
        }
    } catch (e) {
        console.error('Error extracting zap amount:', e);
    }
    return 0;
}

// Track if goal reached message has been shown
let zapGoalReachedMessageShown = false;

function updateZapGoalDisplay(currentAmount, goalAmount, animate) {
    const zapGoalEl = document.getElementById('live-zap-goal');
    const currentAmountEl = document.getElementById('zap-current-amount');
    const fillEl = document.getElementById('zap-goal-fill');
    const resetFormEl = document.getElementById('zap-goal-reset-form');

    if (!zapGoalEl || !currentAmountEl || !fillEl) return;

    const percentage = Math.min((currentAmount / goalAmount) * 100, 100);
    const wasGoalReached = zapGoalEl.classList.contains('goal-reached');

    currentAmountEl.textContent = formatSats(currentAmount);
    fillEl.style.width = `${percentage}%`;

    if (animate) {
        // Add pulse animation class
        zapGoalEl.classList.add('zap-received');

        // Remove animation class after it completes
        setTimeout(() => {
            zapGoalEl.classList.remove('zap-received');
        }, 600);
    }

    // Add goal reached state and show reset form for stream owner
    if (percentage >= 100) {
        zapGoalEl.classList.add('goal-reached');
        // Show reset form for stream owner
        if (resetFormEl) {
            resetFormEl.classList.add('visible');
        }
        // Add chat message when goal is first reached
        if (!wasGoalReached && !zapGoalReachedMessageShown) {
            zapGoalReachedMessageShown = true;
            addZapGoalReachedMessage(goalAmount);
        }
    } else {
        zapGoalEl.classList.remove('goal-reached');
        if (resetFormEl) {
            resetFormEl.classList.remove('visible');
        }
    }
}

// Add goal reached message to live chat
function addZapGoalReachedMessage(goalAmount) {
    const container = document.getElementById('live-chat-messages');
    if (!container) return;

    const messageHTML = `
        <div class="chat-message goal-reached-notification" data-timestamp="${Math.floor(Date.now() / 1000)}">
            <div class="chat-message-content">
                <svg class="celebration-icon" width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                    <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/>
                    <circle cx="8" cy="10" r="1.5"/>
                    <circle cx="16" cy="10" r="1.5"/>
                    <path d="M8 15c0 0 2 3 4 3s4-3 4-3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
                Zap goal reached! ${formatSatsExact(goalAmount)} sats!
            </div>
        </div>
    `;

    container.insertAdjacentHTML('beforeend', messageHTML);

    // Auto-scroll to show the message
    if (container.scrollHeight - container.scrollTop - container.clientHeight < 150) {
        container.scrollTop = container.scrollHeight;
    }
}

// Add new zap goal announcement message to live chat
function addNewZapGoalMessage(goalAmount) {
    const container = document.getElementById('live-chat-messages');
    if (!container) return;

    const messageHTML = `
        <div class="chat-message new-goal-notification" data-timestamp="${Math.floor(Date.now() / 1000)}">
            <div class="chat-message-content">
                <svg class="zap-icon" width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                </svg>
                New zap goal: ${formatSatsExact(goalAmount)} sats!
            </div>
        </div>
    `;

    container.insertAdjacentHTML('beforeend', messageHTML);

    // Auto-scroll to show the message
    if (container.scrollHeight - container.scrollTop - container.clientHeight < 150) {
        container.scrollTop = container.scrollHeight;
    }
}

// Reset zap goal to a new amount (stream owner only)
async function resetZapGoal() {
    if (!currentUser) {
        ensureLoggedIn();
        return;
    }

    const zapGoalEl = document.getElementById('live-zap-goal');
    const newGoalInput = document.getElementById('new-zap-goal-input');

    if (!zapGoalEl || !newGoalInput) return;

    const newGoal = parseInt(newGoalInput.value);
    if (!newGoal || newGoal < 1) {
        alert(t('alert.enterValidGoalAmount'));
        return;
    }

    const eventId = zapGoalEl.dataset.eventId;
    const pubkey = zapGoalEl.dataset.pubkey;
    const dTag = zapGoalEl.dataset.dtag;

    // Verify ownership
    if (pubkey !== currentUser.pubkey) {
        alert(t('alert.canOnlyResetOwnGoals'));
        return;
    }

    // Fetch the current event
    let event = allEvents.get(eventId);
    if (!event) {
        event = await fetchLiveEvent(eventId);
    }

    if (!event) {
        alert(t('alert.streamEventNotFound'));
        return;
    }

    const liveData = parseLiveEvent(event);
    if (!liveData) {
        alert(t('alert.invalidStreamData'));
        return;
    }

    try {
        // Build updated event tags (copy existing, update goal)
        const eventTags = [
            ['d', dTag],
            ['title', liveData.title],
            ['summary', liveData.summary || ''],
            ['streaming', liveData.streamUrl || ''],
            ['status', liveData.status],
            ['starts', String(liveData.starts)],
            ['t', 'pv69420'],
        ];

        // Add ends tag if stream has ended
        if (liveData.ends) {
            eventTags.push(['ends', String(liveData.ends)]);
        }

        // Add thumbnail
        if (liveData.thumbnail) {
            eventTags.push(['image', liveData.thumbnail]);
        }

        // Add content tags
        (liveData.tags || []).forEach(tag => {
            eventTags.push(['t', tag.toLowerCase()]);
        });

        // Add NSFW tag if applicable
        if (liveData.isNSFW) {
            eventTags.push(['content-warning', 'NSFW']);
        }

        // Add new zap goal with timestamp for when this goal started
        const goalSinceTimestamp = Math.floor(Date.now() / 1000);
        eventTags.push(['goal', String(newGoal)]);
        eventTags.push(['goal_since', String(goalSinceTimestamp)]);

        // Add host participant
        eventTags.push(['p', currentUser.pubkey, '', 'Host']);

        const newEvent = {
            kind: NIP53_LIVE_EVENT_KIND,
            created_at: Math.floor(Date.now() / 1000),
            tags: eventTags,
            content: ''
        };

        const signedEvent = await signEvent(newEvent);
        if (!signedEvent) {
            throw new Error('Failed to sign event');
        }

        await publishEvent(signedEvent);

        // Update UI immediately
        const targetEl = document.getElementById('zap-target-amount');
        if (targetEl) {
            targetEl.textContent = formatSatsExact(newGoal);
        }

        // Update data attributes
        zapGoalEl.dataset.goal = newGoal;

        // Reset visual state
        zapGoalEl.classList.remove('goal-reached');
        const resetFormEl = document.getElementById('zap-goal-reset-form');
        if (resetFormEl) {
            resetFormEl.classList.remove('visible');
        }

        // Reset the goal reached message flag so it can trigger again
        zapGoalReachedMessageShown = false;

        // Reset zap counter to 0 for new goal (previous zaps don't count)
        liveStreamZapTotal = 0;
        updateZapGoalDisplay(0, newGoal, false);

        // Clear input
        newGoalInput.value = '';

        // Update in allEvents
        allEvents.delete(eventId);
        allEvents.set(signedEvent.id, signedEvent);

        // Restart zap tracking with the new goal_since timestamp
        const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${pubkey}:${dTag}`;
        subscribeLiveStreamZaps(aTagValue, newGoal, new Set(), goalSinceTimestamp);

    } catch (error) {
        console.error('Failed to reset zap goal:', error);
        alert(t('alert.failedResetZapGoal'));
    }
}

// Load zap goal results for ended streams (uses #a tag for persistence)
async function loadEndedStreamZapGoal(eventId, zapGoal) {
    // Get stream event to construct the 'a' tag
    const streamEvent = allEvents.get(eventId);
    if (!streamEvent) return;

    const liveData = parseLiveEvent(streamEvent);
    if (!liveData) return;

    const aTagValue = `${NIP53_LIVE_EVENT_KIND}:${streamEvent.pubkey}:${liveData.dTag}`;

    let totalZaps = 0;

    const filter = {
        kinds: [9735],
        '#a': [aTagValue],
        limit: 500
    };

    requestEventsStream(filter, (event) => {
        const amount = getZapAmount(event);
        if (amount > 0) {
            totalZaps += amount;
        }
    }, () => {
        // Update the ended stream overlay display
        const currentEl = document.getElementById('ended-zap-current');
        const fillEl = document.getElementById('ended-zap-goal-fill');
        const statusEl = document.getElementById('ended-zap-goal-status');
        const containerEl = document.getElementById('ended-zap-goal');

        if (!currentEl || !fillEl) return;

        const percentage = Math.min((totalZaps / zapGoal) * 100, 100);

        currentEl.textContent = formatSats(totalZaps);
        fillEl.style.width = `${percentage}%`;

        // Show status message
        if (statusEl) {
            if (percentage >= 100) {
                statusEl.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="vertical-align: middle; margin-right: 4px;"><circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="8" cy="10" r="1.5"/><circle cx="16" cy="10" r="1.5"/><path d="M8 15c0 0 2 3 4 3s4-3 4-3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>Goal Reached!';
                statusEl.style.color = '#ffd700';
                if (containerEl) containerEl.classList.add('goal-reached');
            } else {
                statusEl.textContent = `${Math.round(percentage)}% of goal`;
                statusEl.style.color = 'rgba(255, 255, 255, 0.7)';
            }
        }
    });
}

// Share live stream with embed support
function shareLiveStream(eventId) {
    currentShareEventId = eventId;
    const isLocal = window.location.protocol === 'file:';
    const baseUrl = isLocal ? window.location.href.split('#')[0] : window.location.origin;
    const shareUrl = `${baseUrl}/#/live/${eventId}`;
    document.getElementById('shareUrlInput').value = shareUrl;

    // Reset to link tab
    switchShareTab('link');

    // Generate embed code for live stream
    updateLiveStreamEmbedCode(eventId);

    // Hide the fallback note since live streams don't use blossom hosts
    const fallbackNote = document.getElementById('embedFallbackNote');
    if (fallbackNote) fallbackNote.style.display = 'none';

    // Record share event for analytics
    recordVideoShare(eventId);

    document.getElementById('shareModal').classList.add('active');
}

// Update embed code for live stream
function updateLiveStreamEmbedCode(eventId) {
    const sizeSelect = document.getElementById('embedSizeSelect');
    const selectedSize = sizeSelect?.value || 'responsive';

    const isLocal = window.location.protocol === 'file:';
    const baseUrl = isLocal ? window.location.href.split('#')[0] : window.location.origin;
    const embedUrl = `${baseUrl}/embed-live.html?id=${eventId}`;

    let embedCode;
    if (selectedSize === 'responsive') {
        embedCode = `<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="${embedUrl}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;" allowfullscreen></iframe>
</div>`;
    } else {
        const [width, height] = selectedSize.split('x');
        embedCode = `<iframe width="${width}" height="${height}" src="${embedUrl}" frameborder="0" allowfullscreen></iframe>`;
    }

    const embedCodeInput = document.getElementById('embedCodeInput');
    if (embedCodeInput) {
        embedCodeInput.value = embedCode;
    }
}

// Load "Also Live" section with recommendation-based related live streams
async function loadAlsoLive(currentStreamerPubkey, currentDTag, tags) {
    const alsoLiveSection = document.getElementById('also-live-section');
    const alsoLiveGrid = document.getElementById('also-live-grid');

    if (!alsoLiveSection || !alsoLiveGrid) return;

    const filter = {
        kinds: [NIP53_LIVE_EVENT_KIND],
        '#t': ['pv69420'],
        limit: 50
    };

    const otherLiveStreams = [];

    // Use the existing userFollowsCache for current user's follows (already loaded on login)
    const userFollowingSet = userFollowsCache || new Set();

    requestEventsStream(filter, (event) => {
        const liveData = parseLiveEvent(event);

        if (!liveData || !isLiveStreamActive(liveData)) return;

        // Exclude current stream by pubkey + d-tag (unique identifier for replaceable events)
        if (event.pubkey === currentStreamerPubkey && liveData.dTag === currentDTag) return;

        // Exclude current user's own streams when logged in
        if (currentUser && event.pubkey === currentUser.pubkey) return;

        // Skip muted users and content filtered by keywords
        const filterResult = shouldFilterLiveContent(event, liveData);
        if (filterResult && filterResult.filtered) return;

        // Calculate recommendation score
        let score = 0;

        // Check for tag overlap (related streams by topic)
        const streamTags = liveData.tags || [];
        const matchingTags = tags.filter(tag => streamTags.includes(tag));
        score += matchingTags.length * 10; // +10 per matching tag

        // Boost if user follows this streamer
        if (userFollowingSet.has(event.pubkey)) {
            score += 25;
        }

        // Add viewer count as a tiebreaker (normalized)
        const viewers = liveData.currentParticipants || 0;
        score += Math.min(viewers / 10, 5); // Cap at +5 for popular streams

        otherLiveStreams.push({ event, liveData, score, matchingTags: matchingTags.length });
    }, async () => {
        if (otherLiveStreams.length === 0) {
            alsoLiveSection.style.display = 'none';
            return;
        }

        // Sort by recommendation score (highest first)
        otherLiveStreams.sort((a, b) => b.score - a.score);

        // Save scroll position before showing section to prevent page jump
        const scrollY = window.scrollY;

        // Show section
        alsoLiveSection.style.display = 'block';
        alsoLiveGrid.innerHTML = '';

        // Show up to 6 streams - use the standard createLiveStreamCard for consistent UI and filtering
        const streamsToShow = otherLiveStreams.slice(0, 6);
        const liveEventIds = [];

        for (const { event, liveData } of streamsToShow) {
            const profile = await fetchUserProfile(event.pubkey);
            // Use standard live stream card which handles NSFW, community warnings, etc.
            const card = createLiveStreamCard(event, liveData, profile);
            alsoLiveGrid.insertAdjacentHTML('beforeend', card);
            liveEventIds.push(event.id);
        }

        // Restore scroll position after all cards are added
        window.scrollTo(0, scrollY);

        // Load actual viewer counts for Also Live streams
        if (liveEventIds.length > 0) {
            loadLiveStreamCardsViewers(liveEventIds);
            // Load boosts for live streams
            liveEventIds.forEach(id => {
                if (!boostsCache.has(id)) {
                    loadBoostsForVideo(id);
                }
            });
        }
    });
}

// Helper function to filter live content (similar to video filtering)
function shouldFilterLiveContent(event, liveData) {
    if (!liveData) return { filtered: false };

    // Check muted users
    if (shouldHideMutedContent(event.pubkey)) {
        return { filtered: true, reason: 'muted' };
    }

    // Check content filter keywords in title and summary using existing matchesFilterPacks
    const textToCheck = `${liveData.title || ''} ${liveData.summary || ''}`;
    const filterResult = matchesFilterPacks(textToCheck);
    if (filterResult.matches) {
        return { filtered: true, reason: 'keyword' };
    }

    return { filtered: false };
}
