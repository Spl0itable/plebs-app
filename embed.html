<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plebs Embedded Video</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .embed-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        /* Plebs Logo Watermark */
        .watermark {
            position: absolute;
            bottom: 70px;
            right: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            text-decoration: none;
            color: white;
            font-size: 12px;
            font-weight: 600;
            opacity: 0.8;
            transition: opacity 0.2s;
            z-index: 10;
        }

        .watermark:hover {
            opacity: 1;
        }

        .watermark svg {
            width: 20px;
            height: 20px;
        }

        /* Loading state */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #ff5500;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Error state */
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            padding: 20px;
        }

        .error h3 {
            margin-bottom: 10px;
            color: #ff5500;
        }

        .error p {
            color: #aaa;
            font-size: 14px;
        }

        .error a {
            color: #ff5500;
            text-decoration: none;
        }

        .error a:hover {
            text-decoration: underline;
        }

        /* Hide watermark when controls are hidden */
        video::-webkit-media-controls {
            display: flex !important;
        }
    </style>
</head>
<body>
    <div class="embed-container" id="embedContainer">
        <div class="loading" id="loadingState">
            <div class="spinner"></div>
            <span>Loading video...</span>
        </div>
    </div>

    <script>
        // Relay configuration (same as main app)
        const RELAYS = [
            'wss://relay.primal.net',
            'wss://relay.damus.io',
            'wss://nos.lol',
            'wss://relay.nostr.band'
        ];

        // NIP-71 Video Event Kinds
        const NIP71_VIDEO_KIND = 34235;
        const NIP71_SHORT_KIND = 34236;
        const NIP71_VIDEO_KIND_LEGACY = 21;
        const NIP71_SHORT_KIND_LEGACY = 22;
        const ALL_VIDEO_KINDS = [1, NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY];

        // Get event ID from URL
        const urlParams = new URLSearchParams(window.location.search);
        const eventId = urlParams.get('id');

        if (!eventId) {
            showError('No video ID provided');
        } else {
            loadVideo(eventId);
        }

        async function loadVideo(eventId) {
            try {
                // Connect to relays and fetch event
                const event = await fetchEvent(eventId);

                if (!event) {
                    showError('Video not found', 'The video may have been deleted or is unavailable.');
                    return;
                }

                // Parse video data
                const videoData = parseVideoEvent(event);
                if (!videoData || !videoData.url) {
                    showError('Invalid video data', 'Could not parse video information.');
                    return;
                }

                // Create video player with fallback support
                createPlayer(videoData, eventId);

            } catch (error) {
                console.error('Error loading video:', error);
                showError('Failed to load video', error.message);
            }
        }

        async function fetchEvent(eventId) {
            return new Promise((resolve, reject) => {
                let resolved = false;
                let event = null;
                const sockets = [];
                const timeout = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        sockets.forEach(ws => ws.close());
                        resolve(event);
                    }
                }, 10000);

                RELAYS.forEach(relayUrl => {
                    try {
                        const ws = new WebSocket(relayUrl);
                        sockets.push(ws);

                        ws.onopen = () => {
                            const subId = 'embed_' + Math.random().toString(36).substr(2, 9);
                            const filter = {
                                ids: [eventId]
                            };
                            ws.send(JSON.stringify(['REQ', subId, filter]));
                        };

                        ws.onmessage = (msg) => {
                            try {
                                const data = JSON.parse(msg.data);
                                if (data[0] === 'EVENT' && data[2]) {
                                    event = data[2];
                                    if (!resolved) {
                                        resolved = true;
                                        clearTimeout(timeout);
                                        sockets.forEach(s => s.close());
                                        resolve(event);
                                    }
                                }
                            } catch (e) {}
                        };

                        ws.onerror = () => {};
                    } catch (e) {}
                });
            });
        }

        function parseVideoEvent(event) {
            const tags = event.tags || [];

            // Check if NIP-71 event
            if ([NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY].includes(event.kind)) {
                return parseNip71Event(event);
            }

            // Parse kind 1 event
            const urlTag = tags.find(t => t[0] === 'url' || t[0] === 'video_url');
            const url = urlTag ? urlTag[1] : null;

            if (!url) {
                // Try to find URL in content
                const urlMatch = event.content?.match(/https?:\/\/[^\s]+\.(mp4|webm|mov|m3u8)/i);
                if (urlMatch) {
                    return { url: urlMatch[0], fallbackUrls: [] };
                }
                return null;
            }

            // Get fallback URLs
            const fallbackUrls = tags
                .filter(t => t[0] === 'fallback')
                .map(t => t[1])
                .filter(Boolean);

            return {
                url,
                fallbackUrls,
                title: tags.find(t => t[0] === 'title')?.[1] || ''
            };
        }

        function parseNip71Event(event) {
            const tags = event.tags || [];

            // Get primary video URL from imeta tag
            let primaryUrl = null;
            let fallbackUrls = [];

            // Parse imeta tags for video URLs
            const imetaTags = tags.filter(t => t[0] === 'imeta');
            for (const imeta of imetaTags) {
                const tagData = {};
                for (let i = 1; i < imeta.length; i++) {
                    const [key, ...valueParts] = imeta[i].split(' ');
                    tagData[key] = valueParts.join(' ');
                }

                // Check if this is a video
                if (tagData.m && tagData.m.startsWith('video/') && tagData.url) {
                    if (!primaryUrl) {
                        primaryUrl = tagData.url;
                    } else {
                        fallbackUrls.push(tagData.url);
                    }
                }
            }

            // Also check for direct URL tag
            const urlTag = tags.find(t => t[0] === 'url');
            if (urlTag && urlTag[1]) {
                if (!primaryUrl) {
                    primaryUrl = urlTag[1];
                } else if (!fallbackUrls.includes(urlTag[1])) {
                    fallbackUrls.push(urlTag[1]);
                }
            }

            // Check fallback tags
            const fallbackTags = tags.filter(t => t[0] === 'fallback');
            fallbackTags.forEach(t => {
                if (t[1] && !fallbackUrls.includes(t[1]) && t[1] !== primaryUrl) {
                    fallbackUrls.push(t[1]);
                }
            });

            // Get thumbnail
            const thumbTag = tags.find(t => t[0] === 'thumb' || t[0] === 'image');
            const thumbnail = thumbTag ? thumbTag[1] : null;

            // Get title
            const titleTag = tags.find(t => t[0] === 'title');
            const title = titleTag ? titleTag[1] : '';

            return {
                url: primaryUrl,
                fallbackUrls,
                thumbnail,
                title
            };
        }

        function createPlayer(videoData, eventId) {
            const container = document.getElementById('embedContainer');
            const allUrls = [videoData.url, ...videoData.fallbackUrls].filter(Boolean);
            let currentUrlIndex = 0;

            // Create video element
            const video = document.createElement('video');
            video.controls = true;
            video.autoplay = false;
            video.playsInline = true;
            video.preload = 'metadata';

            // Set poster if available
            if (videoData.thumbnail) {
                video.poster = videoData.thumbnail;
            }

            // Error handler with fallback
            video.onerror = () => {
                currentUrlIndex++;
                if (currentUrlIndex < allUrls.length) {
                    console.log('Trying fallback URL:', allUrls[currentUrlIndex]);
                    video.src = allUrls[currentUrlIndex];
                    video.load();
                } else {
                    showError('Video unavailable', 'All video sources failed to load.');
                }
            };

            // Set initial source
            video.src = allUrls[0];

            // Create watermark
            const watermark = document.createElement('a');
            watermark.className = 'watermark';
            watermark.href = window.location.origin + '/#/video/' + eventId;
            watermark.target = '_blank';
            watermark.rel = 'noopener noreferrer';
            watermark.innerHTML = `
                <svg viewBox="0 0 24 24">
                    <path d="M4 7 Q4 4, 6 5.5 L11 10.5 Q14 12, 11 13.5 L6 18.5 Q4 20, 4 17 Z" fill="#1da1f2" opacity="0.4"/>
                    <path d="M10 7 Q10 4, 12 5.5 L17 10.5 Q20 12, 17 13.5 L12 18.5 Q10 20, 10 17 Z" fill="#1da1f2"/>
                </svg>
                <span>Watch on Plebs</span>
            `;

            // Clear loading state and add player
            container.innerHTML = '';
            container.appendChild(video);
            container.appendChild(watermark);

            // Show/hide watermark based on video state
            let hideTimeout;
            const showWatermark = () => {
                watermark.style.opacity = '0.8';
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    if (!video.paused) {
                        watermark.style.opacity = '0.3';
                    }
                }, 3000);
            };

            video.addEventListener('play', showWatermark);
            video.addEventListener('pause', () => {
                watermark.style.opacity = '0.8';
                clearTimeout(hideTimeout);
            });
            video.addEventListener('mousemove', showWatermark);
            container.addEventListener('mousemove', showWatermark);
        }

        function showError(title, message = '') {
            const container = document.getElementById('embedContainer');
            const origin = window.location.origin || window.location.href.split('/embed.html')[0];

            container.innerHTML = `
                <div class="error">
                    <h3>${title}</h3>
                    ${message ? `<p>${message}</p>` : ''}
                    <p style="margin-top: 15px;">
                        <a href="${origin}" target="_blank">Visit Plebs</a>
                    </p>
                </div>
            `;
        }
    </script>
</body>
</html>
