<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plebs Embedded Video</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .embed-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        /* Plebs Logo Watermark */
        .watermark {
            position: absolute;
            bottom: 70px;
            right: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            text-decoration: none;
            color: white;
            font-size: 12px;
            font-weight: 600;
            opacity: 0.8;
            transition: opacity 0.2s;
            z-index: 10;
        }

        .watermark:hover {
            opacity: 1;
        }

        .watermark svg {
            width: 20px;
            height: 20px;
        }

        /* Loading state */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #ff5500;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Error state */
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            padding: 20px;
        }

        .error h3 {
            margin-bottom: 10px;
            color: #ff5500;
        }

        .error p {
            color: #aaa;
            font-size: 14px;
        }

        .error a {
            color: #ff5500;
            text-decoration: none;
        }

        .error a:hover {
            text-decoration: underline;
        }

        .peertube-info {
            margin-top: 1rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
            align-items: center;
        }

        .peertube-info a {
            color: #1da1f2;
            text-decoration: underline;
        }

        .webtorrent-consent.embed {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.72);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            color: #fff;
        }

        .webtorrent-consent.embed p {
            margin: 0;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.85);
        }

        .webtorrent-consent.embed button {
            background: #00b894;
            border: none;
            color: white;
            padding: 0.5rem 0.95rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        .webtorrent-consent.embed button:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
        }

        .webtorrent-consent.embed.webtorrent-active {
            border: 1px solid #00ffb3;
        }

        /* Hide watermark when controls are hidden */
        video::-webkit-media-controls {
            display: flex !important;
        }
    </style>
</head>
<body>
    <div class="embed-container" id="embedContainer">
        <div class="loading" id="loadingState">
            <div class="spinner"></div>
            <span>Loading video...</span>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/webtorrent@latest/webtorrent.min.js"></script>

    <script>
        // Relay configuration (same as main app)
        const RELAYS = [
            'wss://relay.primal.net',
            'wss://relay.damus.io',
            'wss://nos.lol',
            'wss://relay.nostr.band'
        ];

        // NIP-71 Video Event Kinds
        const NIP71_VIDEO_KIND = 34235;
        const NIP71_SHORT_KIND = 34236;
        const NIP71_VIDEO_KIND_LEGACY = 21;
        const NIP71_SHORT_KIND_LEGACY = 22;
        const ALL_VIDEO_KINDS = [1, NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY];

        function extractPeertubeMetadata(tags) {
            if (!tags || !tags.length) {
                return null;
            }

            const info = {
                source: null,
                instance: '',
                videoId: '',
                watchUrl: '',
                author: '',
                allowWebTorrent: false,
                magnet: '',
                nostrPubkey: ''
            };

            for (const tag of tags) {
                const key = tag[0];
                const value = tag[1] || '';

                switch (key) {
                    case 'source':
                        info.source = value;
                        break;
                    case 'peertube-instance':
                        info.instance = value;
                        break;
                    case 'peertube-video-id':
                        info.videoId = value;
                        break;
                    case 'peertube-watch':
                        info.watchUrl = value;
                        break;
                    case 'peertube-author':
                        info.author = value;
                        break;
                    case 'peertube-allow-webtorrent':
                        info.allowWebTorrent = value?.toLowerCase() === 'true';
                        break;
                    case 'peertube-magnet':
                        info.magnet = value;
                        break;
                    case 'p':
                        if (!info.nostrPubkey && value) {
                            info.nostrPubkey = value;
                        }
                        break;
                }
            }

            if (info.source !== 'peertube') {
                return null;
            }

            return {
                instance: info.instance,
                videoId: info.videoId,
                watchUrl: info.watchUrl,
                author: info.author,
                allowWebTorrent: info.allowWebTorrent,
                magnet: info.magnet,
                nostrPubkey: info.nostrPubkey || null
            };
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;'
            };
            return (text || '').replace(/[&<>]/g, char => map[char] || char);
        }

        // Get event ID from URL
        const urlParams = new URLSearchParams(window.location.search);
        const eventId = urlParams.get('id');

        if (!eventId) {
            showError('No video ID provided');
        } else {
            loadVideo(eventId);
        }

        async function loadVideo(eventId) {
            try {
                // Connect to relays and fetch event
                const event = await fetchEvent(eventId);

                if (!event) {
                    showError('Video not found', 'The video may have been deleted or is unavailable.');
                    return;
                }

                // Parse video data
                const videoData = parseVideoEvent(event);
                if (!videoData || !videoData.url) {
                    showError('Invalid video data', 'Could not parse video information.');
                    return;
                }

                // Create video player with fallback support
                createPlayer(videoData, eventId);

            } catch (error) {
                console.error('Error loading video:', error);
                showError('Failed to load video', error.message);
            }
        }

        async function fetchEvent(eventId) {
            return new Promise((resolve, reject) => {
                let resolved = false;
                let event = null;
                const sockets = [];
                const timeout = setTimeout(() => {
                    if (!resolved) {
                        resolved = true;
                        sockets.forEach(ws => ws.close());
                        resolve(event);
                    }
                }, 10000);

                RELAYS.forEach(relayUrl => {
                    try {
                        const ws = new WebSocket(relayUrl);
                        sockets.push(ws);

                        ws.onopen = () => {
                            const subId = 'embed_' + Math.random().toString(36).substr(2, 9);
                            const filter = {
                                ids: [eventId]
                            };
                            ws.send(JSON.stringify(['REQ', subId, filter]));
                        };

                        ws.onmessage = (msg) => {
                            try {
                                const data = JSON.parse(msg.data);
                                if (data[0] === 'EVENT' && data[2]) {
                                    event = data[2];
                                    if (!resolved) {
                                        resolved = true;
                                        clearTimeout(timeout);
                                        sockets.forEach(s => s.close());
                                        resolve(event);
                                    }
                                }
                            } catch (e) {}
                        };

                        ws.onerror = () => {};
                    } catch (e) {}
                });
            });
        }

        function parseVideoEvent(event) {
            const tags = event.tags || [];

            // Check if NIP-71 event
            if ([NIP71_VIDEO_KIND, NIP71_SHORT_KIND, NIP71_VIDEO_KIND_LEGACY, NIP71_SHORT_KIND_LEGACY].includes(event.kind)) {
                return parseNip71Event(event);
            }

            // Parse kind 1 event
            const urlTag = tags.find(t => t[0] === 'url' || t[0] === 'video_url');
            const url = urlTag ? urlTag[1] : null;

            if (!url) {
                // Try to find URL in content
                const urlMatch = event.content?.match(/https?:\/\/[^\s]+\.(mp4|webm|mov|m3u8)/i);
                if (urlMatch) {
                    return { url: urlMatch[0], fallbackUrls: [] };
                }
                return null;
            }

            // Get fallback URLs
            const fallbackUrls = tags
                .filter(t => t[0] === 'fallback')
                .map(t => t[1])
                .filter(Boolean);

            return {
                url,
                fallbackUrls,
                title: tags.find(t => t[0] === 'title')?.[1] || '',
                peertube: extractPeertubeMetadata(tags)
            };
        }

        function parseNip71Event(event) {
            const tags = event.tags || [];

            // Get primary video URL from imeta tag
            let primaryUrl = null;
            let fallbackUrls = [];

            // Parse imeta tags for video URLs
            const imetaTags = tags.filter(t => t[0] === 'imeta');
            for (const imeta of imetaTags) {
                const tagData = {};
                for (let i = 1; i < imeta.length; i++) {
                    const [key, ...valueParts] = imeta[i].split(' ');
                    tagData[key] = valueParts.join(' ');
                }

                // Check if this is a video
                if (tagData.m && tagData.m.startsWith('video/') && tagData.url) {
                    if (!primaryUrl) {
                        primaryUrl = tagData.url;
                    } else {
                        fallbackUrls.push(tagData.url);
                    }
                }
            }

            // Also check for direct URL tag
            const urlTag = tags.find(t => t[0] === 'url');
            if (urlTag && urlTag[1]) {
                if (!primaryUrl) {
                    primaryUrl = urlTag[1];
                } else if (!fallbackUrls.includes(urlTag[1])) {
                    fallbackUrls.push(urlTag[1]);
                }
            }

            // Check fallback tags
            const fallbackTags = tags.filter(t => t[0] === 'fallback');
            fallbackTags.forEach(t => {
                if (t[1] && !fallbackUrls.includes(t[1]) && t[1] !== primaryUrl) {
                    fallbackUrls.push(t[1]);
                }
            });

            // Get thumbnail
            const thumbTag = tags.find(t => t[0] === 'thumb' || t[0] === 'image');
            const thumbnail = thumbTag ? thumbTag[1] : null;

            // Get title
            const titleTag = tags.find(t => t[0] === 'title');
            const title = titleTag ? titleTag[1] : '';
            const peertubeInfo = extractPeertubeMetadata(tags);

            return {
                url: primaryUrl,
                fallbackUrls,
                thumbnail,
                title,
                peertube: peertubeInfo
            };
        }

        function createPlayer(videoData, eventId) {
            const container = document.getElementById('embedContainer');
            const peertubeInfo = videoData.peertube;
            const canStartWebTorrent = !!(peertubeInfo?.allowWebTorrent && peertubeInfo.magnet);
            cleanupEmbedWebTorrentSession();
            const allUrls = [videoData.url, ...videoData.fallbackUrls].filter(Boolean);
            let currentUrlIndex = 0;

            // Create video element
            const video = document.createElement('video');
            video.controls = true;
            video.autoplay = false;
            video.playsInline = true;
            video.preload = 'metadata';

            // Set poster if available
            if (videoData.thumbnail) {
                video.poster = videoData.thumbnail;
            }

            // Error handler with fallback
            video.onerror = () => {
                currentUrlIndex++;
                if (currentUrlIndex < allUrls.length) {
                    console.log('Trying fallback URL:', allUrls[currentUrlIndex]);
                    video.src = allUrls[currentUrlIndex];
                    video.load();
                } else {
                    showError('Video unavailable', 'All video sources failed to load.');
                }
            };

            // Set initial source
            video.src = allUrls[0];

            // Create watermark
            const watermark = document.createElement('a');
            watermark.className = 'watermark';
            watermark.href = window.location.origin + '/#/video/' + eventId;
            watermark.target = '_blank';
            watermark.rel = 'noopener noreferrer';
            watermark.innerHTML = `
                <svg viewBox="0 0 24 24">
                    <path d="M4 7 Q4 4, 6 5.5 L11 10.5 Q14 12, 11 13.5 L6 18.5 Q4 20, 4 17 Z" fill="#1da1f2" opacity="0.4"/>
                    <path d="M10 7 Q10 4, 12 5.5 L17 10.5 Q20 12, 17 13.5 L12 18.5 Q10 20, 10 17 Z" fill="#1da1f2"/>
                </svg>
                <span>Watch on Plebs</span>
            `;

            // Clear loading state and add player
            container.innerHTML = '';
            container.appendChild(video);
            container.appendChild(watermark);

            if (peertubeInfo) {
                const infoEl = document.createElement('div');
                infoEl.className = 'peertube-info';
                const details = [];
                if (peertubeInfo.author) {
                    details.push(`by ${escapeHtml(peertubeInfo.author)}`);
                }
                if (peertubeInfo.instance) {
                    details.push(`(${escapeHtml(peertubeInfo.instance)})`);
                }
                const watchLink = peertubeInfo.watchUrl ? `<a href="${escapeHtml(peertubeInfo.watchUrl)}" target="_blank" rel="noopener noreferrer">View on Peertube</a>` : '';
                infoEl.innerHTML = `<span>Original on Peertube ${details.join(' • ')}</span> ${watchLink}`;
                container.appendChild(infoEl);
            }

            if (canStartWebTorrent) {
                const consentEl = document.createElement('div');
                consentEl.className = 'webtorrent-consent embed';
                consentEl.innerHTML = `
                    <div>
                        <strong>WebTorrent stream available</strong>
                        <p>Peer-to-peer playback via WebTorrent.</p>
                    </div>
                    <button type="button">Stream via WebTorrent</button>
                `;
                const button = consentEl.querySelector('button');
                if (button) {
                    button.addEventListener('click', () => handleEmbedWebTorrent(video, peertubeInfo.magnet, consentEl, button));
                    if (!window.WebTorrent) {
                        button.disabled = true;
                        button.textContent = 'WebTorrent unavailable';
                    }
                }
                container.appendChild(consentEl);
            }

            // Show/hide watermark based on video state
            let hideTimeout;
            const showWatermark = () => {
                watermark.style.opacity = '0.8';
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    if (!video.paused) {
                        watermark.style.opacity = '0.3';
                    }
                }, 3000);
            };

            video.addEventListener('play', showWatermark);
            video.addEventListener('pause', () => {
                watermark.style.opacity = '0.8';
                clearTimeout(hideTimeout);
            });
            video.addEventListener('mousemove', showWatermark);
            container.addEventListener('mousemove', showWatermark);
        }

        function showError(title, message = '') {
            const container = document.getElementById('embedContainer');
            const origin = window.location.origin || window.location.href.split('/embed.html')[0];

            container.innerHTML = `
                <div class="error">
                    <h3>${title}</h3>
                    ${message ? `<p>${message}</p>` : ''}
                    <p style="margin-top: 15px;">
                        <a href="${origin}" target="_blank">Visit Plebs</a>
                    </p>
                </div>
            `;
        }

        let embedWebTorrentClient = null;
        let embedWebTorrentSession = null;

        function ensureEmbedWebTorrentClient() {
            if (!window.WebTorrent) {
                return null;
            }
            if (!embedWebTorrentClient) {
                embedWebTorrentClient = new WebTorrent();
            }
            return embedWebTorrentClient;
        }

        function cleanupEmbedWebTorrentSession() {
            if (embedWebTorrentSession) {
                try {
                    embedWebTorrentSession.destroy();
                } catch (error) {
                    console.error('Failed to destroy embed WebTorrent session:', error);
                }
            }
            embedWebTorrentSession = null;
        }

        async function startEmbedWebTorrent(videoElement, magnet) {
            if (!magnet) {
                throw new Error('Magnet link missing');
            }
            const client = ensureEmbedWebTorrentClient();
            if (!client) {
                throw new Error('WebTorrent is not available in this browser');
            }
            cleanupEmbedWebTorrentSession();
            return new Promise((resolve, reject) => {
                try {
                    const torrent = client.add(magnet, (torrent) => {
                        const file = torrent.files.find(f => /\.(mp4|webm|mkv|mov)$/i.test(f.name)) || torrent.files[0];
                        if (!file) {
                            reject(new Error('No playable file in torrent'));
                            return;
                        }
                        embedWebTorrentSession = torrent;
                        file.renderTo(videoElement, { autoplay: true }, (error) => {
                            if (error) {
                                reject(error);
                            } else {
                                resolve(file);
                            }
                        });
                    });
                    torrent.on('error', (err) => reject(err));
                } catch (error) {
                    reject(error);
                }
            });
        }

        async function handleEmbedWebTorrent(videoElement, magnet, consentEl, button) {
            if (!videoElement || !magnet) {
                return;
            }
            if (button) {
                button.disabled = true;
                button.textContent = 'Starting WebTorrent…';
            }
            if (consentEl) {
                consentEl.classList.add('webtorrent-pending');
            }
            videoElement.pause();
            videoElement.removeAttribute('src');
            videoElement.load();
            try {
                await startEmbedWebTorrent(videoElement, magnet);
                if (button) {
                    button.textContent = 'Streaming via WebTorrent';
                }
                if (consentEl) {
                    consentEl.classList.add('webtorrent-active');
                    consentEl.classList.remove('webtorrent-pending');
                }
            } catch (error) {
                console.error('Embed WebTorrent failed:', error);
                if (button) {
                    button.disabled = false;
                    button.textContent = 'Stream via WebTorrent';
                }
                if (consentEl) {
                    consentEl.classList.remove('webtorrent-pending');
                }
                showError('WebTorrent failed', error.message || 'Unable to start WebTorrent stream.');
            }
        }

        window.addEventListener('beforeunload', cleanupEmbedWebTorrentSession);
    </script>
</body>
</html>
